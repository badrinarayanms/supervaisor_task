"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@xyflow";
exports.ids = ["vendor-chunks/@xyflow"];
exports.modules = {

/***/ "(ssr)/./node_modules/@xyflow/react/dist/esm/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@xyflow/react/dist/esm/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Background: () => (/* binding */ Background),\n/* harmony export */   BackgroundVariant: () => (/* binding */ BackgroundVariant),\n/* harmony export */   BaseEdge: () => (/* binding */ BaseEdge),\n/* harmony export */   BezierEdge: () => (/* binding */ BezierEdge),\n/* harmony export */   ConnectionLineType: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionLineType),\n/* harmony export */   ConnectionMode: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionMode),\n/* harmony export */   ControlButton: () => (/* binding */ ControlButton),\n/* harmony export */   Controls: () => (/* binding */ Controls),\n/* harmony export */   EdgeLabelRenderer: () => (/* binding */ EdgeLabelRenderer),\n/* harmony export */   EdgeText: () => (/* binding */ EdgeText),\n/* harmony export */   Handle: () => (/* binding */ Handle),\n/* harmony export */   MarkerType: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.MarkerType),\n/* harmony export */   MiniMap: () => (/* binding */ MiniMap),\n/* harmony export */   NodeResizeControl: () => (/* binding */ NodeResizeControl),\n/* harmony export */   NodeResizer: () => (/* binding */ NodeResizer),\n/* harmony export */   NodeToolbar: () => (/* binding */ NodeToolbar),\n/* harmony export */   PanOnScrollMode: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.PanOnScrollMode),\n/* harmony export */   Panel: () => (/* binding */ Panel),\n/* harmony export */   Position: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position),\n/* harmony export */   ReactFlow: () => (/* binding */ index),\n/* harmony export */   ReactFlowProvider: () => (/* binding */ ReactFlowProvider),\n/* harmony export */   ResizeControlVariant: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ResizeControlVariant),\n/* harmony export */   SelectionMode: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.SelectionMode),\n/* harmony export */   SimpleBezierEdge: () => (/* binding */ SimpleBezierEdge),\n/* harmony export */   SmoothStepEdge: () => (/* binding */ SmoothStepEdge),\n/* harmony export */   StepEdge: () => (/* binding */ StepEdge),\n/* harmony export */   StraightEdge: () => (/* binding */ StraightEdge),\n/* harmony export */   ViewportPortal: () => (/* binding */ ViewportPortal),\n/* harmony export */   addEdge: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.addEdge),\n/* harmony export */   applyEdgeChanges: () => (/* binding */ applyEdgeChanges),\n/* harmony export */   applyNodeChanges: () => (/* binding */ applyNodeChanges),\n/* harmony export */   getBezierEdgeCenter: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getBezierEdgeCenter),\n/* harmony export */   getBezierPath: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getBezierPath),\n/* harmony export */   getConnectedEdges: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getConnectedEdges),\n/* harmony export */   getEdgeCenter: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getEdgeCenter),\n/* harmony export */   getIncomers: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getIncomers),\n/* harmony export */   getNodesBounds: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getNodesBounds),\n/* harmony export */   getOutgoers: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getOutgoers),\n/* harmony export */   getSimpleBezierPath: () => (/* binding */ getSimpleBezierPath),\n/* harmony export */   getSmoothStepPath: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getSmoothStepPath),\n/* harmony export */   getStraightPath: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getStraightPath),\n/* harmony export */   getViewportForBounds: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getViewportForBounds),\n/* harmony export */   isEdge: () => (/* binding */ isEdge),\n/* harmony export */   isNode: () => (/* binding */ isNode),\n/* harmony export */   reconnectEdge: () => (/* reexport safe */ _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.reconnectEdge),\n/* harmony export */   useConnection: () => (/* binding */ useConnection),\n/* harmony export */   useEdges: () => (/* binding */ useEdges),\n/* harmony export */   useEdgesState: () => (/* binding */ useEdgesState),\n/* harmony export */   useHandleConnections: () => (/* binding */ useHandleConnections),\n/* harmony export */   useInternalNode: () => (/* binding */ useInternalNode),\n/* harmony export */   useKeyPress: () => (/* binding */ useKeyPress),\n/* harmony export */   useNodeConnections: () => (/* binding */ useNodeConnections),\n/* harmony export */   useNodeId: () => (/* binding */ useNodeId),\n/* harmony export */   useNodes: () => (/* binding */ useNodes),\n/* harmony export */   useNodesData: () => (/* binding */ useNodesData),\n/* harmony export */   useNodesInitialized: () => (/* binding */ useNodesInitialized),\n/* harmony export */   useNodesState: () => (/* binding */ useNodesState),\n/* harmony export */   useOnSelectionChange: () => (/* binding */ useOnSelectionChange),\n/* harmony export */   useOnViewportChange: () => (/* binding */ useOnViewportChange),\n/* harmony export */   useReactFlow: () => (/* binding */ useReactFlow),\n/* harmony export */   useStore: () => (/* binding */ useStore),\n/* harmony export */   useStoreApi: () => (/* binding */ useStoreApi),\n/* harmony export */   useUpdateNodeInternals: () => (/* binding */ useUpdateNodeInternals),\n/* harmony export */   useViewport: () => (/* binding */ useViewport)\n/* harmony export */ });\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-runtime */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-jsx-runtime.js\");\n/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var classcat__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! classcat */ \"(ssr)/./node_modules/classcat/index.js\");\n/* harmony import */ var _xyflow_system__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @xyflow/system */ \"(ssr)/./node_modules/@xyflow/system/dist/esm/index.js\");\n/* harmony import */ var zustand_traditional__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! zustand/traditional */ \"(ssr)/./node_modules/zustand/esm/traditional.mjs\");\n/* harmony import */ var zustand_shallow__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! zustand/shallow */ \"(ssr)/./node_modules/zustand/esm/shallow.mjs\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react-dom */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react-dom.js\");\n/* harmony import */ var react_dom__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react_dom__WEBPACK_IMPORTED_MODULE_4__);\n/* __next_internal_client_entry_do_not_use__ ConnectionLineType,ConnectionMode,MarkerType,PanOnScrollMode,Position,ResizeControlVariant,SelectionMode,addEdge,getBezierEdgeCenter,getBezierPath,getConnectedEdges,getEdgeCenter,getIncomers,getNodesBounds,getOutgoers,getSmoothStepPath,getStraightPath,getViewportForBounds,reconnectEdge,Background,BackgroundVariant,BaseEdge,BezierEdge,ControlButton,Controls,EdgeLabelRenderer,EdgeText,Handle,MiniMap,NodeResizeControl,NodeResizer,NodeToolbar,Panel,ReactFlow,ReactFlowProvider,SimpleBezierEdge,SmoothStepEdge,StepEdge,StraightEdge,ViewportPortal,applyEdgeChanges,applyNodeChanges,getSimpleBezierPath,isEdge,isNode,useConnection,useEdges,useEdgesState,useHandleConnections,useInternalNode,useKeyPress,useNodeConnections,useNodeId,useNodes,useNodesData,useNodesInitialized,useNodesState,useOnSelectionChange,useOnViewportChange,useReactFlow,useStore,useStoreApi,useUpdateNodeInternals,useViewport auto */ \n\n\n\n\n\n\n\nconst StoreContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(null);\nconst Provider$1 = StoreContext.Provider;\nconst zustandErrorMessage = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages['error001']();\n/**\n * This hook can be used to subscribe to internal state changes of the React Flow\n * component. The `useStore` hook is re-exported from the [Zustand](https://github.com/pmndrs/zustand)\n * state management library, so you should check out their docs for more details.\n *\n * @public\n * @param selector\n * @param equalityFn\n * @returns The selected state slice\n *\n * @example\n * ```ts\n * const nodes = useStore((state) => state.nodes);\n * ```\n *\n * @remarks This hook should only be used if there is no other way to access the internal\n * state. For many of the common use cases, there are dedicated hooks available\n * such as {@link useReactFlow}, {@link useViewport}, etc.\n */ function useStore(selector, equalityFn) {\n    const store = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(StoreContext);\n    if (store === null) {\n        throw new Error(zustandErrorMessage);\n    }\n    return (0,zustand_traditional__WEBPACK_IMPORTED_MODULE_5__.useStoreWithEqualityFn)(store, selector, equalityFn);\n}\n/**\n * In some cases, you might need to access the store directly. This hook returns the store object which can be used on demand to access the state or dispatch actions.\n *\n * @returns The store object\n *\n * @example\n * ```ts\n * const store = useStoreApi();\n * ```\n *\n * @remarks This hook should only be used if there is no other way to access the internal\n * state. For many of the common use cases, there are dedicated hooks available\n * such as {@link useReactFlow}, {@link useViewport}, etc.\n */ function useStoreApi() {\n    const store = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(StoreContext);\n    if (store === null) {\n        throw new Error(zustandErrorMessage);\n    }\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"useStoreApi.useMemo\": ()=>({\n                getState: store.getState,\n                setState: store.setState,\n                subscribe: store.subscribe\n            })\n    }[\"useStoreApi.useMemo\"], [\n        store\n    ]);\n}\nconst style = {\n    display: 'none'\n};\nconst ariaLiveStyle = {\n    position: 'absolute',\n    width: 1,\n    height: 1,\n    margin: -1,\n    border: 0,\n    padding: 0,\n    overflow: 'hidden',\n    clip: 'rect(0px, 0px, 0px, 0px)',\n    clipPath: 'inset(100%)'\n};\nconst ARIA_NODE_DESC_KEY = 'react-flow__node-desc';\nconst ARIA_EDGE_DESC_KEY = 'react-flow__edge-desc';\nconst ARIA_LIVE_MESSAGE = 'react-flow__aria-live';\nconst selector$o = (s)=>s.ariaLiveMessage;\nfunction AriaLiveMessage({ rfId }) {\n    const ariaLiveMessage = useStore(selector$o);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        id: `${ARIA_LIVE_MESSAGE}-${rfId}`,\n        \"aria-live\": \"assertive\",\n        \"aria-atomic\": \"true\",\n        style: ariaLiveStyle,\n        children: ariaLiveMessage\n    });\n}\nfunction A11yDescriptions({ rfId, disableKeyboardA11y }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", {\n                id: `${ARIA_NODE_DESC_KEY}-${rfId}`,\n                style: style,\n                children: [\n                    \"Press enter or space to select a node.\",\n                    !disableKeyboardA11y && 'You can then use the arrow keys to move the node around.',\n                    \" Press delete to remove it and escape to cancel.\",\n                    ' '\n                ]\n            }),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n                id: `${ARIA_EDGE_DESC_KEY}-${rfId}`,\n                style: style,\n                children: \"Press enter or space to select an edge. You can then press delete to remove it or escape to cancel.\"\n            }),\n            !disableKeyboardA11y && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(AriaLiveMessage, {\n                rfId: rfId\n            })\n        ]\n    });\n}\nconst selector$n = (s)=>s.userSelectionActive ? 'none' : 'all';\n/**\n * The `<Panel />` component helps you position content above the viewport.\n * It is used internally by the [`<MiniMap />`](/api-reference/components/minimap)\n * and [`<Controls />`](/api-reference/components/controls) components.\n *\n * @public\n *\n * @example\n * ```jsx\n *import { ReactFlow, Background, Panel } from '@xyflow/react';\n *\n *export default function Flow() {\n *  return (\n *    <ReactFlow nodes={[]} fitView>\n *      <Panel position=\"top-left\">top-left</Panel>\n *      <Panel position=\"top-center\">top-center</Panel>\n *      <Panel position=\"top-right\">top-right</Panel>\n *      <Panel position=\"bottom-left\">bottom-left</Panel>\n *      <Panel position=\"bottom-center\">bottom-center</Panel>\n *      <Panel position=\"bottom-right\">bottom-right</Panel>\n *    </ReactFlow>\n *  );\n *}\n *```\n */ const Panel = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(({ position = 'top-left', children, className, style, ...rest }, ref)=>{\n    const pointerEvents = useStore(selector$n);\n    const positionClasses = `${position}`.split('-');\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            'react-flow__panel',\n            className,\n            ...positionClasses\n        ]),\n        style: {\n            ...style,\n            pointerEvents\n        },\n        ref: ref,\n        ...rest,\n        children: children\n    });\n});\nPanel.displayName = 'Panel';\nfunction Attribution({ proOptions, position = 'bottom-right' }) {\n    if (proOptions?.hideAttribution) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Panel, {\n        position: position,\n        className: \"react-flow__attribution\",\n        \"data-message\": \"Please only hide this attribution when you are subscribed to React Flow Pro: https://pro.reactflow.dev\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"a\", {\n            href: \"https://reactflow.dev\",\n            target: \"_blank\",\n            rel: \"noopener noreferrer\",\n            \"aria-label\": \"React Flow attribution\",\n            children: \"React Flow\"\n        })\n    });\n}\nconst selector$m = (s)=>{\n    const selectedNodes = [];\n    const selectedEdges = [];\n    for (const [, node] of s.nodeLookup){\n        if (node.selected) {\n            selectedNodes.push(node.internals.userNode);\n        }\n    }\n    for (const [, edge] of s.edgeLookup){\n        if (edge.selected) {\n            selectedEdges.push(edge);\n        }\n    }\n    return {\n        selectedNodes,\n        selectedEdges\n    };\n};\nconst selectId = (obj)=>obj.id;\nfunction areEqual(a, b) {\n    return (0,zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow)(a.selectedNodes.map(selectId), b.selectedNodes.map(selectId)) && (0,zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow)(a.selectedEdges.map(selectId), b.selectedEdges.map(selectId));\n}\nfunction SelectionListenerInner({ onSelectionChange }) {\n    const store = useStoreApi();\n    const { selectedNodes, selectedEdges } = useStore(selector$m, areEqual);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"SelectionListenerInner.useEffect\": ()=>{\n            const params = {\n                nodes: selectedNodes,\n                edges: selectedEdges\n            };\n            onSelectionChange?.(params);\n            store.getState().onSelectionChangeHandlers.forEach({\n                \"SelectionListenerInner.useEffect\": (fn)=>fn(params)\n            }[\"SelectionListenerInner.useEffect\"]);\n        }\n    }[\"SelectionListenerInner.useEffect\"], [\n        selectedNodes,\n        selectedEdges,\n        onSelectionChange\n    ]);\n    return null;\n}\nconst changeSelector = (s)=>!!s.onSelectionChangeHandlers;\nfunction SelectionListener({ onSelectionChange }) {\n    const storeHasSelectionChangeHandlers = useStore(changeSelector);\n    if (onSelectionChange || storeHasSelectionChangeHandlers) {\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(SelectionListenerInner, {\n            onSelectionChange: onSelectionChange\n        });\n    }\n    return null;\n}\nconst defaultNodeOrigin = [\n    0,\n    0\n];\nconst defaultViewport = {\n    x: 0,\n    y: 0,\n    zoom: 1\n};\n/*\n * This component helps us to update the store with the values coming from the user.\n * We distinguish between values we can update directly with `useDirectStoreUpdater` (like `snapGrid`)\n * and values that have a dedicated setter function in the store (like `setNodes`).\n */ // these fields exist in the global store and we need to keep them up to date\nconst reactFlowFieldsToTrack = [\n    'nodes',\n    'edges',\n    'defaultNodes',\n    'defaultEdges',\n    'onConnect',\n    'onConnectStart',\n    'onConnectEnd',\n    'onClickConnectStart',\n    'onClickConnectEnd',\n    'nodesDraggable',\n    'nodesConnectable',\n    'nodesFocusable',\n    'edgesFocusable',\n    'edgesReconnectable',\n    'elevateNodesOnSelect',\n    'elevateEdgesOnSelect',\n    'minZoom',\n    'maxZoom',\n    'nodeExtent',\n    'onNodesChange',\n    'onEdgesChange',\n    'elementsSelectable',\n    'connectionMode',\n    'snapGrid',\n    'snapToGrid',\n    'translateExtent',\n    'connectOnClick',\n    'defaultEdgeOptions',\n    'fitView',\n    'fitViewOptions',\n    'onNodesDelete',\n    'onEdgesDelete',\n    'onDelete',\n    'onNodeDrag',\n    'onNodeDragStart',\n    'onNodeDragStop',\n    'onSelectionDrag',\n    'onSelectionDragStart',\n    'onSelectionDragStop',\n    'onMoveStart',\n    'onMove',\n    'onMoveEnd',\n    'noPanClassName',\n    'nodeOrigin',\n    'autoPanOnConnect',\n    'autoPanOnNodeDrag',\n    'onError',\n    'connectionRadius',\n    'isValidConnection',\n    'selectNodesOnDrag',\n    'nodeDragThreshold',\n    'onBeforeDelete',\n    'debug',\n    'autoPanSpeed',\n    'paneClickDistance'\n];\n// rfId doesn't exist in ReactFlowProps, but it's one of the fields we want to update\nconst fieldsToTrack = [\n    ...reactFlowFieldsToTrack,\n    'rfId'\n];\nconst selector$l = (s)=>({\n        setNodes: s.setNodes,\n        setEdges: s.setEdges,\n        setMinZoom: s.setMinZoom,\n        setMaxZoom: s.setMaxZoom,\n        setTranslateExtent: s.setTranslateExtent,\n        setNodeExtent: s.setNodeExtent,\n        reset: s.reset,\n        setDefaultNodesAndEdges: s.setDefaultNodesAndEdges,\n        setPaneClickDistance: s.setPaneClickDistance\n    });\nconst initPrevValues = {\n    /*\n     * these are values that are also passed directly to other components\n     * than the StoreUpdater. We can reduce the number of setStore calls\n     * by setting the same values here as prev fields.\n     */ translateExtent: _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.infiniteExtent,\n    nodeOrigin: defaultNodeOrigin,\n    minZoom: 0.5,\n    maxZoom: 2,\n    elementsSelectable: true,\n    noPanClassName: 'nopan',\n    rfId: '1',\n    paneClickDistance: 0\n};\nfunction StoreUpdater(props) {\n    const { setNodes, setEdges, setMinZoom, setMaxZoom, setTranslateExtent, setNodeExtent, reset, setDefaultNodesAndEdges, setPaneClickDistance } = useStore(selector$l, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const store = useStoreApi();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"StoreUpdater.useEffect\": ()=>{\n            setDefaultNodesAndEdges(props.defaultNodes, props.defaultEdges);\n            return ({\n                \"StoreUpdater.useEffect\": ()=>{\n                    // when we reset the store we also need to reset the previous fields\n                    previousFields.current = initPrevValues;\n                    reset();\n                }\n            })[\"StoreUpdater.useEffect\"];\n        }\n    }[\"StoreUpdater.useEffect\"], []);\n    const previousFields = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(initPrevValues);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"StoreUpdater.useEffect\": ()=>{\n            for (const fieldName of fieldsToTrack){\n                const fieldValue = props[fieldName];\n                const previousFieldValue = previousFields.current[fieldName];\n                if (fieldValue === previousFieldValue) continue;\n                if (typeof props[fieldName] === 'undefined') continue;\n                // Custom handling with dedicated setters for some fields\n                if (fieldName === 'nodes') setNodes(fieldValue);\n                else if (fieldName === 'edges') setEdges(fieldValue);\n                else if (fieldName === 'minZoom') setMinZoom(fieldValue);\n                else if (fieldName === 'maxZoom') setMaxZoom(fieldValue);\n                else if (fieldName === 'translateExtent') setTranslateExtent(fieldValue);\n                else if (fieldName === 'nodeExtent') setNodeExtent(fieldValue);\n                else if (fieldName === 'paneClickDistance') setPaneClickDistance(fieldValue);\n                else if (fieldName === 'fitView') store.setState({\n                    fitViewOnInit: fieldValue\n                });\n                else if (fieldName === 'fitViewOptions') store.setState({\n                    fitViewOnInitOptions: fieldValue\n                });\n                else store.setState({\n                    [fieldName]: fieldValue\n                });\n            }\n            previousFields.current = props;\n        }\n    }[\"StoreUpdater.useEffect\"], // Only re-run the effect if one of the fields we track changes\n    fieldsToTrack.map({\n        \"StoreUpdater.useEffect\": (fieldName)=>props[fieldName]\n    }[\"StoreUpdater.useEffect\"]));\n    return null;\n}\nfunction getMediaQuery() {\n    if (true) {\n        return null;\n    }\n    return window.matchMedia('(prefers-color-scheme: dark)');\n}\n/**\n * Hook for receiving the current color mode class 'dark' or 'light'.\n *\n * @internal\n * @param colorMode - The color mode to use ('dark', 'light' or 'system')\n */ function useColorModeClass(colorMode) {\n    const [colorModeClass, setColorModeClass] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(colorMode === 'system' ? null : colorMode);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useColorModeClass.useEffect\": ()=>{\n            if (colorMode !== 'system') {\n                setColorModeClass(colorMode);\n                return;\n            }\n            const mediaQuery = getMediaQuery();\n            const updateColorModeClass = {\n                \"useColorModeClass.useEffect.updateColorModeClass\": ()=>setColorModeClass(mediaQuery?.matches ? 'dark' : 'light')\n            }[\"useColorModeClass.useEffect.updateColorModeClass\"];\n            updateColorModeClass();\n            mediaQuery?.addEventListener('change', updateColorModeClass);\n            return ({\n                \"useColorModeClass.useEffect\": ()=>{\n                    mediaQuery?.removeEventListener('change', updateColorModeClass);\n                }\n            })[\"useColorModeClass.useEffect\"];\n        }\n    }[\"useColorModeClass.useEffect\"], [\n        colorMode\n    ]);\n    return colorModeClass !== null ? colorModeClass : getMediaQuery()?.matches ? 'dark' : 'light';\n}\nconst defaultDoc = typeof document !== 'undefined' ? document : null;\n/**\n * This hook lets you listen for specific key codes and tells you whether they are\n * currently pressed or not.\n *\n * @public\n * @param param.keyCode - The key code (string or array of strings) to use\n * @param param.options - Options\n * @returns boolean\n *\n * @example\n * ```tsx\n *import { useKeyPress } from '@xyflow/react';\n *\n *export default function () {\n *  const spacePressed = useKeyPress('Space');\n *  const cmdAndSPressed = useKeyPress(['Meta+s', 'Strg+s']);\n *\n *  return (\n *    <div>\n *     {spacePressed && <p>Space pressed!</p>}\n *     {cmdAndSPressed && <p>Cmd + S pressed!</p>}\n *    </div>\n *  );\n *}\n *```\n */ function useKeyPress(/*\n * the keycode can be a string 'a' or an array of strings ['a', 'a+d']\n * a string means a single key 'a' or a combination when '+' is used 'a+d'\n * an array means different possibilites. Explainer: ['a', 'd+s'] here the\n * user can use the single key 'a' or the combination 'd' + 's'\n */ keyCode = null, options = {\n    target: defaultDoc,\n    actInsideInputWithModifier: true\n}) {\n    const [keyPressed, setKeyPressed] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    // we need to remember if a modifier key is pressed in order to track it\n    const modifierPressed = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    // we need to remember the pressed keys in order to support combinations\n    const pressedKeys = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(new Set([]));\n    /*\n     * keyCodes = array with single keys [['a']] or key combinations [['a', 's']]\n     * keysToWatch = array with all keys flattened ['a', 'd', 'ShiftLeft']\n     * used to check if we store event.code or event.key. When the code is in the list of keysToWatch\n     * we use the code otherwise the key. Explainer: When you press the left \"command\" key, the code is \"MetaLeft\"\n     * and the key is \"Meta\". We want users to be able to pass keys and codes so we assume that the key is meant when\n     * we can't find it in the list of keysToWatch.\n     */ const [keyCodes, keysToWatch] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"useKeyPress.useMemo\": ()=>{\n            if (keyCode !== null) {\n                const keyCodeArr = Array.isArray(keyCode) ? keyCode : [\n                    keyCode\n                ];\n                const keys = keyCodeArr.filter({\n                    \"useKeyPress.useMemo.keys\": (kc)=>typeof kc === 'string'\n                }[\"useKeyPress.useMemo.keys\"])/*\n                 * we first replace all '+' with '\\n'  which we will use to split the keys on\n                 * then we replace '\\n\\n' with '\\n+', this way we can also support the combination 'key++'\n                 * in the end we simply split on '\\n' to get the key array\n                 */ .map({\n                    \"useKeyPress.useMemo.keys\": (kc)=>kc.replace('+', '\\n').replace('\\n\\n', '\\n+').split('\\n')\n                }[\"useKeyPress.useMemo.keys\"]);\n                const keysFlat = keys.reduce({\n                    \"useKeyPress.useMemo.keysFlat\": (res, item)=>res.concat(...item)\n                }[\"useKeyPress.useMemo.keysFlat\"], []);\n                return [\n                    keys,\n                    keysFlat\n                ];\n            }\n            return [\n                [],\n                []\n            ];\n        }\n    }[\"useKeyPress.useMemo\"], [\n        keyCode\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useKeyPress.useEffect\": ()=>{\n            const target = options?.target || defaultDoc;\n            if (keyCode !== null) {\n                const downHandler = {\n                    \"useKeyPress.useEffect.downHandler\": (event)=>{\n                        modifierPressed.current = event.ctrlKey || event.metaKey || event.shiftKey;\n                        const preventAction = (!modifierPressed.current || modifierPressed.current && !options.actInsideInputWithModifier) && (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isInputDOMNode)(event);\n                        if (preventAction) {\n                            return false;\n                        }\n                        const keyOrCode = useKeyOrCode(event.code, keysToWatch);\n                        pressedKeys.current.add(event[keyOrCode]);\n                        if (isMatchingKey(keyCodes, pressedKeys.current, false)) {\n                            event.preventDefault();\n                            setKeyPressed(true);\n                        }\n                    }\n                }[\"useKeyPress.useEffect.downHandler\"];\n                const upHandler = {\n                    \"useKeyPress.useEffect.upHandler\": (event)=>{\n                        const preventAction = (!modifierPressed.current || modifierPressed.current && !options.actInsideInputWithModifier) && (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isInputDOMNode)(event);\n                        if (preventAction) {\n                            return false;\n                        }\n                        const keyOrCode = useKeyOrCode(event.code, keysToWatch);\n                        if (isMatchingKey(keyCodes, pressedKeys.current, true)) {\n                            setKeyPressed(false);\n                            pressedKeys.current.clear();\n                        } else {\n                            pressedKeys.current.delete(event[keyOrCode]);\n                        }\n                        // fix for Mac: when cmd key is pressed, keyup is not triggered for any other key, see: https://stackoverflow.com/questions/27380018/when-cmd-key-is-kept-pressed-keyup-is-not-triggered-for-any-other-key\n                        if (event.key === 'Meta') {\n                            pressedKeys.current.clear();\n                        }\n                        modifierPressed.current = false;\n                    }\n                }[\"useKeyPress.useEffect.upHandler\"];\n                const resetHandler = {\n                    \"useKeyPress.useEffect.resetHandler\": ()=>{\n                        pressedKeys.current.clear();\n                        setKeyPressed(false);\n                    }\n                }[\"useKeyPress.useEffect.resetHandler\"];\n                target?.addEventListener('keydown', downHandler);\n                target?.addEventListener('keyup', upHandler);\n                window.addEventListener('blur', resetHandler);\n                window.addEventListener('contextmenu', resetHandler);\n                return ({\n                    \"useKeyPress.useEffect\": ()=>{\n                        target?.removeEventListener('keydown', downHandler);\n                        target?.removeEventListener('keyup', upHandler);\n                        window.removeEventListener('blur', resetHandler);\n                        window.removeEventListener('contextmenu', resetHandler);\n                    }\n                })[\"useKeyPress.useEffect\"];\n            }\n        }\n    }[\"useKeyPress.useEffect\"], [\n        keyCode,\n        setKeyPressed\n    ]);\n    return keyPressed;\n}\n// utils\nfunction isMatchingKey(keyCodes, pressedKeys, isUp) {\n    return keyCodes/*\n         * we only want to compare same sizes of keyCode definitions\n         * and pressed keys. When the user specified 'Meta' as a key somewhere\n         * this would also be truthy without this filter when user presses 'Meta' + 'r'\n         */ .filter((keys)=>isUp || keys.length === pressedKeys.size)/*\n         * since we want to support multiple possibilities only one of the\n         * combinations need to be part of the pressed keys\n         */ .some((keys)=>keys.every((k)=>pressedKeys.has(k)));\n}\nfunction useKeyOrCode(eventCode, keysToWatch) {\n    return keysToWatch.includes(eventCode) ? 'code' : 'key';\n}\n/**\n * Hook for getting viewport helper functions.\n *\n * @internal\n * @returns viewport helper functions\n */ const useViewportHelper = ()=>{\n    const store = useStoreApi();\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"useViewportHelper.useMemo\": ()=>{\n            return {\n                zoomIn: ({\n                    \"useViewportHelper.useMemo\": (options)=>{\n                        const { panZoom } = store.getState();\n                        return panZoom ? panZoom.scaleBy(1.2, {\n                            duration: options?.duration\n                        }) : Promise.resolve(false);\n                    }\n                })[\"useViewportHelper.useMemo\"],\n                zoomOut: ({\n                    \"useViewportHelper.useMemo\": (options)=>{\n                        const { panZoom } = store.getState();\n                        return panZoom ? panZoom.scaleBy(1 / 1.2, {\n                            duration: options?.duration\n                        }) : Promise.resolve(false);\n                    }\n                })[\"useViewportHelper.useMemo\"],\n                zoomTo: ({\n                    \"useViewportHelper.useMemo\": (zoomLevel, options)=>{\n                        const { panZoom } = store.getState();\n                        return panZoom ? panZoom.scaleTo(zoomLevel, {\n                            duration: options?.duration\n                        }) : Promise.resolve(false);\n                    }\n                })[\"useViewportHelper.useMemo\"],\n                getZoom: ({\n                    \"useViewportHelper.useMemo\": ()=>store.getState().transform[2]\n                })[\"useViewportHelper.useMemo\"],\n                setViewport: ({\n                    \"useViewportHelper.useMemo\": async (viewport, options)=>{\n                        const { transform: [tX, tY, tZoom], panZoom } = store.getState();\n                        if (!panZoom) {\n                            return Promise.resolve(false);\n                        }\n                        await panZoom.setViewport({\n                            x: viewport.x ?? tX,\n                            y: viewport.y ?? tY,\n                            zoom: viewport.zoom ?? tZoom\n                        }, {\n                            duration: options?.duration\n                        });\n                        return Promise.resolve(true);\n                    }\n                })[\"useViewportHelper.useMemo\"],\n                getViewport: ({\n                    \"useViewportHelper.useMemo\": ()=>{\n                        const [x, y, zoom] = store.getState().transform;\n                        return {\n                            x,\n                            y,\n                            zoom\n                        };\n                    }\n                })[\"useViewportHelper.useMemo\"],\n                fitView: ({\n                    \"useViewportHelper.useMemo\": (options)=>{\n                        const { nodeLookup, minZoom, maxZoom, panZoom, domNode } = store.getState();\n                        if (!panZoom || !domNode) {\n                            return Promise.resolve(false);\n                        }\n                        const fitViewNodes = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getFitViewNodes)(nodeLookup, options);\n                        const { width, height } = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getDimensions)(domNode);\n                        return (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.fitView)({\n                            nodes: fitViewNodes,\n                            width,\n                            height,\n                            minZoom,\n                            maxZoom,\n                            panZoom\n                        }, options);\n                    }\n                })[\"useViewportHelper.useMemo\"],\n                setCenter: ({\n                    \"useViewportHelper.useMemo\": async (x, y, options)=>{\n                        const { width, height, maxZoom, panZoom } = store.getState();\n                        const nextZoom = typeof options?.zoom !== 'undefined' ? options.zoom : maxZoom;\n                        const centerX = width / 2 - x * nextZoom;\n                        const centerY = height / 2 - y * nextZoom;\n                        if (!panZoom) {\n                            return Promise.resolve(false);\n                        }\n                        await panZoom.setViewport({\n                            x: centerX,\n                            y: centerY,\n                            zoom: nextZoom\n                        }, {\n                            duration: options?.duration\n                        });\n                        return Promise.resolve(true);\n                    }\n                })[\"useViewportHelper.useMemo\"],\n                fitBounds: ({\n                    \"useViewportHelper.useMemo\": async (bounds, options)=>{\n                        const { width, height, minZoom, maxZoom, panZoom } = store.getState();\n                        const viewport = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getViewportForBounds)(bounds, width, height, minZoom, maxZoom, options?.padding ?? 0.1);\n                        if (!panZoom) {\n                            return Promise.resolve(false);\n                        }\n                        await panZoom.setViewport(viewport, {\n                            duration: options?.duration\n                        });\n                        return Promise.resolve(true);\n                    }\n                })[\"useViewportHelper.useMemo\"],\n                screenToFlowPosition: ({\n                    \"useViewportHelper.useMemo\": (clientPosition, options = {})=>{\n                        const { transform, snapGrid, snapToGrid, domNode } = store.getState();\n                        if (!domNode) {\n                            return clientPosition;\n                        }\n                        const { x: domX, y: domY } = domNode.getBoundingClientRect();\n                        const correctedPosition = {\n                            x: clientPosition.x - domX,\n                            y: clientPosition.y - domY\n                        };\n                        const _snapGrid = options.snapGrid ?? snapGrid;\n                        const _snapToGrid = options.snapToGrid ?? snapToGrid;\n                        return (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.pointToRendererPoint)(correctedPosition, transform, _snapToGrid, _snapGrid);\n                    }\n                })[\"useViewportHelper.useMemo\"],\n                flowToScreenPosition: ({\n                    \"useViewportHelper.useMemo\": (flowPosition)=>{\n                        const { transform, domNode } = store.getState();\n                        if (!domNode) {\n                            return flowPosition;\n                        }\n                        const { x: domX, y: domY } = domNode.getBoundingClientRect();\n                        const rendererPosition = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.rendererPointToPoint)(flowPosition, transform);\n                        return {\n                            x: rendererPosition.x + domX,\n                            y: rendererPosition.y + domY\n                        };\n                    }\n                })[\"useViewportHelper.useMemo\"]\n            };\n        }\n    }[\"useViewportHelper.useMemo\"], []);\n};\n/*\n * This function applies changes to nodes or edges that are triggered by React Flow internally.\n * When you drag a node for example, React Flow will send a position change update.\n * This function then applies the changes and returns the updated elements.\n */ function applyChanges(changes, elements) {\n    const updatedElements = [];\n    /*\n     * By storing a map of changes for each element, we can a quick lookup as we\n     * iterate over the elements array!\n     */ const changesMap = new Map();\n    const addItemChanges = [];\n    for (const change of changes){\n        if (change.type === 'add') {\n            addItemChanges.push(change);\n            continue;\n        } else if (change.type === 'remove' || change.type === 'replace') {\n            /*\n             * For a 'remove' change we can safely ignore any other changes queued for\n             * the same element, it's going to be removed anyway!\n             */ changesMap.set(change.id, [\n                change\n            ]);\n        } else {\n            const elementChanges = changesMap.get(change.id);\n            if (elementChanges) {\n                /*\n                 * If we have some changes queued already, we can do a mutable update of\n                 * that array and save ourselves some copying.\n                 */ elementChanges.push(change);\n            } else {\n                changesMap.set(change.id, [\n                    change\n                ]);\n            }\n        }\n    }\n    for (const element of elements){\n        const changes = changesMap.get(element.id);\n        /*\n         * When there are no changes for an element we can just push it unmodified,\n         * no need to copy it.\n         */ if (!changes) {\n            updatedElements.push(element);\n            continue;\n        }\n        // If we have a 'remove' change queued, it'll be the only change in the array\n        if (changes[0].type === 'remove') {\n            continue;\n        }\n        if (changes[0].type === 'replace') {\n            updatedElements.push({\n                ...changes[0].item\n            });\n            continue;\n        }\n        /**\n         * For other types of changes, we want to start with a shallow copy of the\n         * object so React knows this element has changed. Sequential changes will\n         * each _mutate_ this object, so there's only ever one copy.\n         */ const updatedElement = {\n            ...element\n        };\n        for (const change of changes){\n            applyChange(change, updatedElement);\n        }\n        updatedElements.push(updatedElement);\n    }\n    /*\n     * we need to wait for all changes to be applied before adding new items\n     * to be able to add them at the correct index\n     */ if (addItemChanges.length) {\n        addItemChanges.forEach((change)=>{\n            if (change.index !== undefined) {\n                updatedElements.splice(change.index, 0, {\n                    ...change.item\n                });\n            } else {\n                updatedElements.push({\n                    ...change.item\n                });\n            }\n        });\n    }\n    return updatedElements;\n}\n// Applies a single change to an element. This is a *mutable* update.\nfunction applyChange(change, element) {\n    switch(change.type){\n        case 'select':\n            {\n                element.selected = change.selected;\n                break;\n            }\n        case 'position':\n            {\n                if (typeof change.position !== 'undefined') {\n                    element.position = change.position;\n                }\n                if (typeof change.dragging !== 'undefined') {\n                    element.dragging = change.dragging;\n                }\n                break;\n            }\n        case 'dimensions':\n            {\n                if (typeof change.dimensions !== 'undefined') {\n                    element.measured ??= {};\n                    element.measured.width = change.dimensions.width;\n                    element.measured.height = change.dimensions.height;\n                    if (change.setAttributes) {\n                        element.width = change.dimensions.width;\n                        element.height = change.dimensions.height;\n                    }\n                }\n                if (typeof change.resizing === 'boolean') {\n                    element.resizing = change.resizing;\n                }\n                break;\n            }\n    }\n}\n/**\n * Drop in function that applies node changes to an array of nodes.\n * @public\n * @param changes - Array of changes to apply\n * @param nodes - Array of nodes to apply the changes to\n * @returns Array of updated nodes\n * @example\n *```tsx\n *import { useState, useCallback } from 'react';\n *import { ReactFlow, applyNodeChanges, type Node, type Edge, type OnNodesChange } from '@xyflow/react';\n *\n *export default function Flow() {\n *  const [nodes, setNodes] = useState<Node[]>([]);\n *  const [edges, setEdges] = useState<Edge[]>([]);\n *  const onNodesChange: OnNodesChange = useCallback(\n *    (changes) => {\n *      setNodes((oldNodes) => applyNodeChanges(changes, oldNodes));\n *    },\n *    [setNodes],\n *  );\n *\n *  return (\n *    <ReactFlow nodes={nodes} edges={edges} onNodesChange={onNodesChange} />\n *  );\n *}\n *```\n * @remarks Various events on the <ReactFlow /> component can produce an {@link NodeChange}\n * that describes how to update the edges of your flow in some way.\n * If you don't need any custom behaviour, this util can be used to take an array\n * of these changes and apply them to your edges.\n */ function applyNodeChanges(changes, nodes) {\n    return applyChanges(changes, nodes);\n}\n/**\n * Drop in function that applies edge changes to an array of edges.\n * @public\n * @param changes - Array of changes to apply\n * @param edges - Array of edge to apply the changes to\n * @returns Array of updated edges\n * @example\n * ```tsx\n *import { useState, useCallback } from 'react';\n *import { ReactFlow, applyEdgeChanges } from '@xyflow/react';\n *\n *export default function Flow() {\n *  const [nodes, setNodes] = useState([]);\n *  const [edges, setEdges] = useState([]);\n *  const onEdgesChange = useCallback(\n *    (changes) => {\n *      setEdges((oldEdges) => applyEdgeChanges(changes, oldEdges));\n *    },\n *    [setEdges],\n *  );\n *\n *  return (\n *    <ReactFlow nodes={nodes} edges={edges} onEdgesChange={onEdgesChange} />\n *  );\n *}\n *```\n * @remarks Various events on the <ReactFlow /> component can produce an {@link EdgeChange}\n * that describes how to update the edges of your flow in some way.\n * If you don't need any custom behaviour, this util can be used to take an array\n * of these changes and apply them to your edges.\n */ function applyEdgeChanges(changes, edges) {\n    return applyChanges(changes, edges);\n}\nfunction createSelectionChange(id, selected) {\n    return {\n        id,\n        type: 'select',\n        selected\n    };\n}\nfunction getSelectionChanges(items, selectedIds = new Set(), mutateItem = false) {\n    const changes = [];\n    for (const [id, item] of items){\n        const willBeSelected = selectedIds.has(id);\n        // we don't want to set all items to selected=false on the first selection\n        if (!(item.selected === undefined && !willBeSelected) && item.selected !== willBeSelected) {\n            if (mutateItem) {\n                /*\n                 * this hack is needed for nodes. When the user dragged a node, it's selected.\n                 * When another node gets dragged, we need to deselect the previous one,\n                 * in order to have only one selected node at a time - the onNodesChange callback comes too late here :/\n                 */ item.selected = willBeSelected;\n            }\n            changes.push(createSelectionChange(item.id, willBeSelected));\n        }\n    }\n    return changes;\n}\nfunction getElementsDiffChanges({ items = [], lookup }) {\n    const changes = [];\n    const itemsLookup = new Map(items.map((item)=>[\n            item.id,\n            item\n        ]));\n    for (const [index, item] of items.entries()){\n        const lookupItem = lookup.get(item.id);\n        const storeItem = lookupItem?.internals?.userNode ?? lookupItem;\n        if (storeItem !== undefined && storeItem !== item) {\n            changes.push({\n                id: item.id,\n                item: item,\n                type: 'replace'\n            });\n        }\n        if (storeItem === undefined) {\n            changes.push({\n                item: item,\n                type: 'add',\n                index\n            });\n        }\n    }\n    for (const [id] of lookup){\n        const nextNode = itemsLookup.get(id);\n        if (nextNode === undefined) {\n            changes.push({\n                id,\n                type: 'remove'\n            });\n        }\n    }\n    return changes;\n}\nfunction elementToRemoveChange(item) {\n    return {\n        id: item.id,\n        type: 'remove'\n    };\n}\n/**\n * Test whether an object is useable as an [`Node`](/api-reference/types/node).\n * In TypeScript this is a type guard that will narrow the type of whatever you pass in to\n * [`Node`](/api-reference/types/node) if it returns `true`.\n *\n * @public\n * @remarks In TypeScript this is a type guard that will narrow the type of whatever you pass in to Node if it returns true\n * @param element - The element to test\n * @returns A boolean indicating whether the element is an Node\n *\n * @example\n * ```js\n *import { isNode } from '@xyflow/react';\n *\n *if (isNode(node)) {\n * // ..\n *}\n *```\n */ const isNode = (element)=>(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isNodeBase)(element);\n/**\n * Test whether an object is useable as an [`Edge`](/api-reference/types/edge).\n * In TypeScript this is a type guard that will narrow the type of whatever you pass in to\n * [`Edge`](/api-reference/types/edge) if it returns `true`.\n *\n * @public\n * @remarks In TypeScript this is a type guard that will narrow the type of whatever you pass in to Edge if it returns true\n * @param element - The element to test\n * @returns A boolean indicating whether the element is an Edge\n *\n * @example\n * ```js\n *import { isEdge } from '@xyflow/react';\n *\n *if (isEdge(edge)) {\n * // ..\n *}\n *```\n */ const isEdge = (element)=>(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isEdgeBase)(element);\n// eslint-disable-next-line @typescript-eslint/no-empty-object-type\nfunction fixedForwardRef(render) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.forwardRef)(render);\n}\n// we need this hook to prevent a warning when using react-flow in SSR\nconst useIsomorphicLayoutEffect =  false ? 0 : react__WEBPACK_IMPORTED_MODULE_1__.useEffect;\n/**\n * This hook returns a queue that can be used to batch updates.\n *\n * @param runQueue - a function that gets called when the queue is flushed\n * @internal\n *\n * @returns a Queue object\n */ function useQueue(runQueue) {\n    /*\n     * Because we're using a ref above, we need some way to let React know when to\n     * actually process the queue. We increment this number any time we mutate the\n     * queue, creating a new state to trigger the layout effect below.\n     * Using a boolean dirty flag here instead would lead to issues related to\n     * automatic batching. (https://github.com/xyflow/xyflow/issues/4779)\n     */ const [serial, setSerial] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(BigInt(0));\n    /*\n     * A reference of all the batched updates to process before the next render. We\n     * want a reference here so multiple synchronous calls to `setNodes` etc can be\n     * batched together.\n     */ const [queue] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        \"useQueue.useState\": ()=>createQueue({\n                \"useQueue.useState\": ()=>setSerial({\n                        \"useQueue.useState\": (n)=>n + BigInt(1)\n                    }[\"useQueue.useState\"])\n            }[\"useQueue.useState\"])\n    }[\"useQueue.useState\"]);\n    /*\n     * Layout effects are guaranteed to run before the next render which means we\n     * shouldn't run into any issues with stale state or weird issues that come from\n     * rendering things one frame later than expected (we used to use `setTimeout`).\n     */ useIsomorphicLayoutEffect({\n        \"useQueue.useIsomorphicLayoutEffect\": ()=>{\n            const queueItems = queue.get();\n            if (queueItems.length) {\n                runQueue(queueItems);\n                queue.reset();\n            }\n        }\n    }[\"useQueue.useIsomorphicLayoutEffect\"], [\n        serial\n    ]);\n    return queue;\n}\nfunction createQueue(cb) {\n    let queue = [];\n    return {\n        get: ()=>queue,\n        reset: ()=>{\n            queue = [];\n        },\n        push: (item)=>{\n            queue.push(item);\n            cb();\n        }\n    };\n}\nconst BatchContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(null);\n/**\n * This is a context provider that holds and processes the node and edge update queues\n * that are needed to handle setNodes, addNodes, setEdges and addEdges.\n *\n * @internal\n */ function BatchProvider({ children }) {\n    const store = useStoreApi();\n    const nodeQueueHandler = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"BatchProvider.useCallback[nodeQueueHandler]\": (queueItems)=>{\n            const { nodes = [], setNodes, hasDefaultNodes, onNodesChange, nodeLookup } = store.getState();\n            /*\n         * This is essentially an `Array.reduce` in imperative clothing. Processing\n         * this queue is a relatively hot path so we'd like to avoid the overhead of\n         * array methods where we can.\n         */ let next = nodes;\n            for (const payload of queueItems){\n                next = typeof payload === 'function' ? payload(next) : payload;\n            }\n            if (hasDefaultNodes) {\n                setNodes(next);\n            } else if (onNodesChange) {\n                onNodesChange(getElementsDiffChanges({\n                    items: next,\n                    lookup: nodeLookup\n                }));\n            }\n        }\n    }[\"BatchProvider.useCallback[nodeQueueHandler]\"], []);\n    const nodeQueue = useQueue(nodeQueueHandler);\n    const edgeQueueHandler = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"BatchProvider.useCallback[edgeQueueHandler]\": (queueItems)=>{\n            const { edges = [], setEdges, hasDefaultEdges, onEdgesChange, edgeLookup } = store.getState();\n            let next = edges;\n            for (const payload of queueItems){\n                next = typeof payload === 'function' ? payload(next) : payload;\n            }\n            if (hasDefaultEdges) {\n                setEdges(next);\n            } else if (onEdgesChange) {\n                onEdgesChange(getElementsDiffChanges({\n                    items: next,\n                    lookup: edgeLookup\n                }));\n            }\n        }\n    }[\"BatchProvider.useCallback[edgeQueueHandler]\"], []);\n    const edgeQueue = useQueue(edgeQueueHandler);\n    const value = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"BatchProvider.useMemo[value]\": ()=>({\n                nodeQueue,\n                edgeQueue\n            })\n    }[\"BatchProvider.useMemo[value]\"], []);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BatchContext.Provider, {\n        value: value,\n        children: children\n    });\n}\nfunction useBatchContext() {\n    const batchContext = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(BatchContext);\n    if (!batchContext) {\n        throw new Error('useBatchContext must be used within a BatchProvider');\n    }\n    return batchContext;\n}\nconst selector$k = (s)=>!!s.panZoom;\n/**\n * This hook returns a ReactFlowInstance that can be used to update nodes and edges, manipulate the viewport, or query the current state of the flow.\n *\n * @public\n * @returns ReactFlowInstance\n *\n * @example\n * ```jsx\n *import { useCallback, useState } from 'react';\n *import { useReactFlow } from '@xyflow/react';\n *\n *export function NodeCounter() {\n *  const reactFlow = useReactFlow();\n *  const [count, setCount] = useState(0);\n *  const countNodes = useCallback(() => {\n *    setCount(reactFlow.getNodes().length);\n *    // you need to pass it as a dependency if you are using it with useEffect or useCallback\n *    // because at the first render, it's not initialized yet and some functions might not work.\n *  }, [reactFlow]);\n *\n *  return (\n *    <div>\n *      <button onClick={countNodes}>Update count</button>\n *      <p>There are {count} nodes in the flow.</p>\n *    </div>\n *  );\n *}\n *```\n */ function useReactFlow() {\n    const viewportHelper = useViewportHelper();\n    const store = useStoreApi();\n    const batchContext = useBatchContext();\n    const viewportInitialized = useStore(selector$k);\n    const generalHelper = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"useReactFlow.useMemo[generalHelper]\": ()=>{\n            const getInternalNode = {\n                \"useReactFlow.useMemo[generalHelper].getInternalNode\": (id)=>store.getState().nodeLookup.get(id)\n            }[\"useReactFlow.useMemo[generalHelper].getInternalNode\"];\n            const setNodes = {\n                \"useReactFlow.useMemo[generalHelper].setNodes\": (payload)=>{\n                    batchContext.nodeQueue.push(payload);\n                }\n            }[\"useReactFlow.useMemo[generalHelper].setNodes\"];\n            const setEdges = {\n                \"useReactFlow.useMemo[generalHelper].setEdges\": (payload)=>{\n                    batchContext.edgeQueue.push(payload);\n                }\n            }[\"useReactFlow.useMemo[generalHelper].setEdges\"];\n            const getNodeRect = {\n                \"useReactFlow.useMemo[generalHelper].getNodeRect\": (node)=>{\n                    const { nodeLookup, nodeOrigin } = store.getState();\n                    const nodeToUse = isNode(node) ? node : nodeLookup.get(node.id);\n                    const position = nodeToUse.parentId ? (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.evaluateAbsolutePosition)(nodeToUse.position, nodeToUse.measured, nodeToUse.parentId, nodeLookup, nodeOrigin) : nodeToUse.position;\n                    const nodeWithPosition = {\n                        ...nodeToUse,\n                        position,\n                        width: nodeToUse.measured?.width ?? nodeToUse.width,\n                        height: nodeToUse.measured?.height ?? nodeToUse.height\n                    };\n                    return (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.nodeToRect)(nodeWithPosition);\n                }\n            }[\"useReactFlow.useMemo[generalHelper].getNodeRect\"];\n            const updateNode = {\n                \"useReactFlow.useMemo[generalHelper].updateNode\": (id, nodeUpdate, options = {\n                    replace: false\n                })=>{\n                    setNodes({\n                        \"useReactFlow.useMemo[generalHelper].updateNode\": (prevNodes)=>prevNodes.map({\n                                \"useReactFlow.useMemo[generalHelper].updateNode\": (node)=>{\n                                    if (node.id === id) {\n                                        const nextNode = typeof nodeUpdate === 'function' ? nodeUpdate(node) : nodeUpdate;\n                                        return options.replace && isNode(nextNode) ? nextNode : {\n                                            ...node,\n                                            ...nextNode\n                                        };\n                                    }\n                                    return node;\n                                }\n                            }[\"useReactFlow.useMemo[generalHelper].updateNode\"])\n                    }[\"useReactFlow.useMemo[generalHelper].updateNode\"]);\n                }\n            }[\"useReactFlow.useMemo[generalHelper].updateNode\"];\n            const updateEdge = {\n                \"useReactFlow.useMemo[generalHelper].updateEdge\": (id, edgeUpdate, options = {\n                    replace: false\n                })=>{\n                    setEdges({\n                        \"useReactFlow.useMemo[generalHelper].updateEdge\": (prevEdges)=>prevEdges.map({\n                                \"useReactFlow.useMemo[generalHelper].updateEdge\": (edge)=>{\n                                    if (edge.id === id) {\n                                        const nextEdge = typeof edgeUpdate === 'function' ? edgeUpdate(edge) : edgeUpdate;\n                                        return options.replace && isEdge(nextEdge) ? nextEdge : {\n                                            ...edge,\n                                            ...nextEdge\n                                        };\n                                    }\n                                    return edge;\n                                }\n                            }[\"useReactFlow.useMemo[generalHelper].updateEdge\"])\n                    }[\"useReactFlow.useMemo[generalHelper].updateEdge\"]);\n                }\n            }[\"useReactFlow.useMemo[generalHelper].updateEdge\"];\n            return {\n                getNodes: ({\n                    \"useReactFlow.useMemo[generalHelper]\": ()=>store.getState().nodes.map({\n                            \"useReactFlow.useMemo[generalHelper]\": (n)=>({\n                                    ...n\n                                })\n                        }[\"useReactFlow.useMemo[generalHelper]\"])\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                getNode: ({\n                    \"useReactFlow.useMemo[generalHelper]\": (id)=>getInternalNode(id)?.internals.userNode\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                getInternalNode,\n                getEdges: ({\n                    \"useReactFlow.useMemo[generalHelper]\": ()=>{\n                        const { edges = [] } = store.getState();\n                        return edges.map({\n                            \"useReactFlow.useMemo[generalHelper]\": (e)=>({\n                                    ...e\n                                })\n                        }[\"useReactFlow.useMemo[generalHelper]\"]);\n                    }\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                getEdge: ({\n                    \"useReactFlow.useMemo[generalHelper]\": (id)=>store.getState().edgeLookup.get(id)\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                setNodes,\n                setEdges,\n                addNodes: ({\n                    \"useReactFlow.useMemo[generalHelper]\": (payload)=>{\n                        const newNodes = Array.isArray(payload) ? payload : [\n                            payload\n                        ];\n                        batchContext.nodeQueue.push({\n                            \"useReactFlow.useMemo[generalHelper]\": (nodes)=>[\n                                    ...nodes,\n                                    ...newNodes\n                                ]\n                        }[\"useReactFlow.useMemo[generalHelper]\"]);\n                    }\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                addEdges: ({\n                    \"useReactFlow.useMemo[generalHelper]\": (payload)=>{\n                        const newEdges = Array.isArray(payload) ? payload : [\n                            payload\n                        ];\n                        batchContext.edgeQueue.push({\n                            \"useReactFlow.useMemo[generalHelper]\": (edges)=>[\n                                    ...edges,\n                                    ...newEdges\n                                ]\n                        }[\"useReactFlow.useMemo[generalHelper]\"]);\n                    }\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                toObject: ({\n                    \"useReactFlow.useMemo[generalHelper]\": ()=>{\n                        const { nodes = [], edges = [], transform } = store.getState();\n                        const [x, y, zoom] = transform;\n                        return {\n                            nodes: nodes.map({\n                                \"useReactFlow.useMemo[generalHelper]\": (n)=>({\n                                        ...n\n                                    })\n                            }[\"useReactFlow.useMemo[generalHelper]\"]),\n                            edges: edges.map({\n                                \"useReactFlow.useMemo[generalHelper]\": (e)=>({\n                                        ...e\n                                    })\n                            }[\"useReactFlow.useMemo[generalHelper]\"]),\n                            viewport: {\n                                x,\n                                y,\n                                zoom\n                            }\n                        };\n                    }\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                deleteElements: ({\n                    \"useReactFlow.useMemo[generalHelper]\": async ({ nodes: nodesToRemove = [], edges: edgesToRemove = [] })=>{\n                        const { nodes, edges, onNodesDelete, onEdgesDelete, triggerNodeChanges, triggerEdgeChanges, onDelete, onBeforeDelete } = store.getState();\n                        const { nodes: matchingNodes, edges: matchingEdges } = await (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getElementsToRemove)({\n                            nodesToRemove,\n                            edgesToRemove,\n                            nodes,\n                            edges,\n                            onBeforeDelete\n                        });\n                        const hasMatchingEdges = matchingEdges.length > 0;\n                        const hasMatchingNodes = matchingNodes.length > 0;\n                        if (hasMatchingEdges) {\n                            const edgeChanges = matchingEdges.map(elementToRemoveChange);\n                            onEdgesDelete?.(matchingEdges);\n                            triggerEdgeChanges(edgeChanges);\n                        }\n                        if (hasMatchingNodes) {\n                            const nodeChanges = matchingNodes.map(elementToRemoveChange);\n                            onNodesDelete?.(matchingNodes);\n                            triggerNodeChanges(nodeChanges);\n                        }\n                        if (hasMatchingNodes || hasMatchingEdges) {\n                            onDelete?.({\n                                nodes: matchingNodes,\n                                edges: matchingEdges\n                            });\n                        }\n                        return {\n                            deletedNodes: matchingNodes,\n                            deletedEdges: matchingEdges\n                        };\n                    }\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                getIntersectingNodes: ({\n                    \"useReactFlow.useMemo[generalHelper]\": (nodeOrRect, partially = true, nodes)=>{\n                        const isRect = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isRectObject)(nodeOrRect);\n                        const nodeRect = isRect ? nodeOrRect : getNodeRect(nodeOrRect);\n                        const hasNodesOption = nodes !== undefined;\n                        if (!nodeRect) {\n                            return [];\n                        }\n                        return (nodes || store.getState().nodes).filter({\n                            \"useReactFlow.useMemo[generalHelper]\": (n)=>{\n                                const internalNode = store.getState().nodeLookup.get(n.id);\n                                if (internalNode && !isRect && (n.id === nodeOrRect.id || !internalNode.internals.positionAbsolute)) {\n                                    return false;\n                                }\n                                const currNodeRect = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.nodeToRect)(hasNodesOption ? n : internalNode);\n                                const overlappingArea = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getOverlappingArea)(currNodeRect, nodeRect);\n                                const partiallyVisible = partially && overlappingArea > 0;\n                                return partiallyVisible || overlappingArea >= nodeRect.width * nodeRect.height;\n                            }\n                        }[\"useReactFlow.useMemo[generalHelper]\"]);\n                    }\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                isNodeIntersecting: ({\n                    \"useReactFlow.useMemo[generalHelper]\": (nodeOrRect, area, partially = true)=>{\n                        const isRect = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isRectObject)(nodeOrRect);\n                        const nodeRect = isRect ? nodeOrRect : getNodeRect(nodeOrRect);\n                        if (!nodeRect) {\n                            return false;\n                        }\n                        const overlappingArea = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getOverlappingArea)(nodeRect, area);\n                        const partiallyVisible = partially && overlappingArea > 0;\n                        return partiallyVisible || overlappingArea >= nodeRect.width * nodeRect.height;\n                    }\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                updateNode,\n                updateNodeData: ({\n                    \"useReactFlow.useMemo[generalHelper]\": (id, dataUpdate, options = {\n                        replace: false\n                    })=>{\n                        updateNode(id, {\n                            \"useReactFlow.useMemo[generalHelper]\": (node)=>{\n                                const nextData = typeof dataUpdate === 'function' ? dataUpdate(node) : dataUpdate;\n                                return options.replace ? {\n                                    ...node,\n                                    data: nextData\n                                } : {\n                                    ...node,\n                                    data: {\n                                        ...node.data,\n                                        ...nextData\n                                    }\n                                };\n                            }\n                        }[\"useReactFlow.useMemo[generalHelper]\"], options);\n                    }\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                updateEdge,\n                updateEdgeData: ({\n                    \"useReactFlow.useMemo[generalHelper]\": (id, dataUpdate, options = {\n                        replace: false\n                    })=>{\n                        updateEdge(id, {\n                            \"useReactFlow.useMemo[generalHelper]\": (edge)=>{\n                                const nextData = typeof dataUpdate === 'function' ? dataUpdate(edge) : dataUpdate;\n                                return options.replace ? {\n                                    ...edge,\n                                    data: nextData\n                                } : {\n                                    ...edge,\n                                    data: {\n                                        ...edge.data,\n                                        ...nextData\n                                    }\n                                };\n                            }\n                        }[\"useReactFlow.useMemo[generalHelper]\"], options);\n                    }\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                getNodesBounds: ({\n                    \"useReactFlow.useMemo[generalHelper]\": (nodes)=>{\n                        const { nodeLookup, nodeOrigin } = store.getState();\n                        return (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getNodesBounds)(nodes, {\n                            nodeLookup,\n                            nodeOrigin\n                        });\n                    }\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                getHandleConnections: ({\n                    \"useReactFlow.useMemo[generalHelper]\": ({ type, id, nodeId })=>Array.from(store.getState().connectionLookup.get(`${nodeId}-${type}${id ? `-${id}` : ''}`)?.values() ?? [])\n                })[\"useReactFlow.useMemo[generalHelper]\"],\n                getNodeConnections: ({\n                    \"useReactFlow.useMemo[generalHelper]\": ({ type, handleId, nodeId })=>Array.from(store.getState().connectionLookup.get(`${nodeId}${type ? handleId ? `-${type}-${handleId}` : `-${type}` : ''}`)?.values() ?? [])\n                })[\"useReactFlow.useMemo[generalHelper]\"]\n            };\n        }\n    }[\"useReactFlow.useMemo[generalHelper]\"], []);\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"useReactFlow.useMemo\": ()=>{\n            return {\n                ...generalHelper,\n                ...viewportHelper,\n                viewportInitialized\n            };\n        }\n    }[\"useReactFlow.useMemo\"], [\n        viewportInitialized\n    ]);\n}\nconst selected = (item)=>item.selected;\nconst deleteKeyOptions = {\n    actInsideInputWithModifier: false\n};\nconst win$1 =  false ? 0 : undefined;\n/**\n * Hook for handling global key events.\n *\n * @internal\n */ function useGlobalKeyHandler({ deleteKeyCode, multiSelectionKeyCode }) {\n    const store = useStoreApi();\n    const { deleteElements } = useReactFlow();\n    const deleteKeyPressed = useKeyPress(deleteKeyCode, deleteKeyOptions);\n    const multiSelectionKeyPressed = useKeyPress(multiSelectionKeyCode, {\n        target: win$1\n    });\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useGlobalKeyHandler.useEffect\": ()=>{\n            if (deleteKeyPressed) {\n                const { edges, nodes } = store.getState();\n                deleteElements({\n                    nodes: nodes.filter(selected),\n                    edges: edges.filter(selected)\n                });\n                store.setState({\n                    nodesSelectionActive: false\n                });\n            }\n        }\n    }[\"useGlobalKeyHandler.useEffect\"], [\n        deleteKeyPressed\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useGlobalKeyHandler.useEffect\": ()=>{\n            store.setState({\n                multiSelectionActive: multiSelectionKeyPressed\n            });\n        }\n    }[\"useGlobalKeyHandler.useEffect\"], [\n        multiSelectionKeyPressed\n    ]);\n}\n/**\n * Hook for handling resize events.\n *\n * @internal\n */ function useResizeHandler(domNode) {\n    const store = useStoreApi();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useResizeHandler.useEffect\": ()=>{\n            const updateDimensions = {\n                \"useResizeHandler.useEffect.updateDimensions\": ()=>{\n                    if (!domNode.current) {\n                        return false;\n                    }\n                    const size = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getDimensions)(domNode.current);\n                    if (size.height === 0 || size.width === 0) {\n                        store.getState().onError?.('004', _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages['error004']());\n                    }\n                    store.setState({\n                        width: size.width || 500,\n                        height: size.height || 500\n                    });\n                }\n            }[\"useResizeHandler.useEffect.updateDimensions\"];\n            if (domNode.current) {\n                updateDimensions();\n                window.addEventListener('resize', updateDimensions);\n                const resizeObserver = new ResizeObserver({\n                    \"useResizeHandler.useEffect\": ()=>updateDimensions()\n                }[\"useResizeHandler.useEffect\"]);\n                resizeObserver.observe(domNode.current);\n                return ({\n                    \"useResizeHandler.useEffect\": ()=>{\n                        window.removeEventListener('resize', updateDimensions);\n                        if (resizeObserver && domNode.current) {\n                            resizeObserver.unobserve(domNode.current);\n                        }\n                    }\n                })[\"useResizeHandler.useEffect\"];\n            }\n        }\n    }[\"useResizeHandler.useEffect\"], []);\n}\nconst containerStyle = {\n    position: 'absolute',\n    width: '100%',\n    height: '100%',\n    top: 0,\n    left: 0\n};\nconst selector$j = (s)=>({\n        userSelectionActive: s.userSelectionActive,\n        lib: s.lib\n    });\nfunction ZoomPane({ onPaneContextMenu, zoomOnScroll = true, zoomOnPinch = true, panOnScroll = false, panOnScrollSpeed = 0.5, panOnScrollMode = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.PanOnScrollMode.Free, zoomOnDoubleClick = true, panOnDrag = true, defaultViewport, translateExtent, minZoom, maxZoom, zoomActivationKeyCode, preventScrolling = true, children, noWheelClassName, noPanClassName, onViewportChange, isControlledViewport, paneClickDistance }) {\n    const store = useStoreApi();\n    const zoomPane = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const { userSelectionActive, lib } = useStore(selector$j, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const zoomActivationKeyPressed = useKeyPress(zoomActivationKeyCode);\n    const panZoom = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    useResizeHandler(zoomPane);\n    const onTransformChange = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"ZoomPane.useCallback[onTransformChange]\": (transform)=>{\n            onViewportChange?.({\n                x: transform[0],\n                y: transform[1],\n                zoom: transform[2]\n            });\n            if (!isControlledViewport) {\n                store.setState({\n                    transform\n                });\n            }\n        }\n    }[\"ZoomPane.useCallback[onTransformChange]\"], [\n        onViewportChange,\n        isControlledViewport\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ZoomPane.useEffect\": ()=>{\n            if (zoomPane.current) {\n                panZoom.current = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.XYPanZoom)({\n                    domNode: zoomPane.current,\n                    minZoom,\n                    maxZoom,\n                    translateExtent,\n                    viewport: defaultViewport,\n                    paneClickDistance,\n                    onDraggingChange: {\n                        \"ZoomPane.useEffect\": (paneDragging)=>store.setState({\n                                paneDragging\n                            })\n                    }[\"ZoomPane.useEffect\"],\n                    onPanZoomStart: {\n                        \"ZoomPane.useEffect\": (event, vp)=>{\n                            const { onViewportChangeStart, onMoveStart } = store.getState();\n                            onMoveStart?.(event, vp);\n                            onViewportChangeStart?.(vp);\n                        }\n                    }[\"ZoomPane.useEffect\"],\n                    onPanZoom: {\n                        \"ZoomPane.useEffect\": (event, vp)=>{\n                            const { onViewportChange, onMove } = store.getState();\n                            onMove?.(event, vp);\n                            onViewportChange?.(vp);\n                        }\n                    }[\"ZoomPane.useEffect\"],\n                    onPanZoomEnd: {\n                        \"ZoomPane.useEffect\": (event, vp)=>{\n                            const { onViewportChangeEnd, onMoveEnd } = store.getState();\n                            onMoveEnd?.(event, vp);\n                            onViewportChangeEnd?.(vp);\n                        }\n                    }[\"ZoomPane.useEffect\"]\n                });\n                const { x, y, zoom } = panZoom.current.getViewport();\n                store.setState({\n                    panZoom: panZoom.current,\n                    transform: [\n                        x,\n                        y,\n                        zoom\n                    ],\n                    domNode: zoomPane.current.closest('.react-flow')\n                });\n                return ({\n                    \"ZoomPane.useEffect\": ()=>{\n                        panZoom.current?.destroy();\n                    }\n                })[\"ZoomPane.useEffect\"];\n            }\n        }\n    }[\"ZoomPane.useEffect\"], []);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ZoomPane.useEffect\": ()=>{\n            panZoom.current?.update({\n                onPaneContextMenu,\n                zoomOnScroll,\n                zoomOnPinch,\n                panOnScroll,\n                panOnScrollSpeed,\n                panOnScrollMode,\n                zoomOnDoubleClick,\n                panOnDrag,\n                zoomActivationKeyPressed,\n                preventScrolling,\n                noPanClassName,\n                userSelectionActive,\n                noWheelClassName,\n                lib,\n                onTransformChange\n            });\n        }\n    }[\"ZoomPane.useEffect\"], [\n        onPaneContextMenu,\n        zoomOnScroll,\n        zoomOnPinch,\n        panOnScroll,\n        panOnScrollSpeed,\n        panOnScrollMode,\n        zoomOnDoubleClick,\n        panOnDrag,\n        zoomActivationKeyPressed,\n        preventScrolling,\n        noPanClassName,\n        userSelectionActive,\n        noWheelClassName,\n        lib,\n        onTransformChange\n    ]);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: \"react-flow__renderer\",\n        ref: zoomPane,\n        style: containerStyle,\n        children: children\n    });\n}\nconst selector$i = (s)=>({\n        userSelectionActive: s.userSelectionActive,\n        userSelectionRect: s.userSelectionRect\n    });\nfunction UserSelection() {\n    const { userSelectionActive, userSelectionRect } = useStore(selector$i, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const isActive = userSelectionActive && userSelectionRect;\n    if (!isActive) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: \"react-flow__selection react-flow__container\",\n        style: {\n            width: userSelectionRect.width,\n            height: userSelectionRect.height,\n            transform: `translate(${userSelectionRect.x}px, ${userSelectionRect.y}px)`\n        }\n    });\n}\nconst wrapHandler = (handler, containerRef)=>{\n    return (event)=>{\n        if (event.target !== containerRef.current) {\n            return;\n        }\n        handler?.(event);\n    };\n};\nconst selector$h = (s)=>({\n        userSelectionActive: s.userSelectionActive,\n        elementsSelectable: s.elementsSelectable,\n        dragging: s.paneDragging\n    });\nfunction Pane({ isSelecting, selectionKeyPressed, selectionMode = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.SelectionMode.Full, panOnDrag, selectionOnDrag, onSelectionStart, onSelectionEnd, onPaneClick, onPaneContextMenu, onPaneScroll, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, children }) {\n    const store = useStoreApi();\n    const { userSelectionActive, elementsSelectable, dragging } = useStore(selector$h, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const hasActiveSelection = elementsSelectable && (isSelecting || userSelectionActive);\n    const container = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const containerBounds = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    const selectedNodeIds = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(new Set());\n    const selectedEdgeIds = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(new Set());\n    // Used to prevent click events when the user lets go of the selectionKey during a selection\n    const selectionInProgress = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    const selectionStarted = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    const onClick = (event)=>{\n        // We prevent click events when the user let go of the selectionKey during a selection\n        if (selectionInProgress.current) {\n            selectionInProgress.current = false;\n            return;\n        }\n        onPaneClick?.(event);\n        store.getState().resetSelectedElements();\n        store.setState({\n            nodesSelectionActive: false\n        });\n    };\n    const onContextMenu = (event)=>{\n        if (Array.isArray(panOnDrag) && panOnDrag?.includes(2)) {\n            event.preventDefault();\n            return;\n        }\n        onPaneContextMenu?.(event);\n    };\n    const onWheel = onPaneScroll ? (event)=>onPaneScroll(event) : undefined;\n    const onPointerDown = (event)=>{\n        const { resetSelectedElements, domNode } = store.getState();\n        containerBounds.current = domNode?.getBoundingClientRect();\n        if (!elementsSelectable || !isSelecting || event.button !== 0 || event.target !== container.current || !containerBounds.current) {\n            return;\n        }\n        event.target?.setPointerCapture?.(event.pointerId);\n        selectionStarted.current = true;\n        selectionInProgress.current = false;\n        const { x, y } = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getEventPosition)(event.nativeEvent, containerBounds.current);\n        resetSelectedElements();\n        store.setState({\n            userSelectionRect: {\n                width: 0,\n                height: 0,\n                startX: x,\n                startY: y,\n                x,\n                y\n            }\n        });\n        onSelectionStart?.(event);\n    };\n    const onPointerMove = (event)=>{\n        const { userSelectionRect, transform, nodeLookup, edgeLookup, connectionLookup, triggerNodeChanges, triggerEdgeChanges, defaultEdgeOptions } = store.getState();\n        if (!containerBounds.current || !userSelectionRect) {\n            return;\n        }\n        selectionInProgress.current = true;\n        const { x: mouseX, y: mouseY } = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getEventPosition)(event.nativeEvent, containerBounds.current);\n        const { startX, startY } = userSelectionRect;\n        const nextUserSelectRect = {\n            startX,\n            startY,\n            x: mouseX < startX ? mouseX : startX,\n            y: mouseY < startY ? mouseY : startY,\n            width: Math.abs(mouseX - startX),\n            height: Math.abs(mouseY - startY)\n        };\n        const prevSelectedNodeIds = selectedNodeIds.current;\n        const prevSelectedEdgeIds = selectedEdgeIds.current;\n        selectedNodeIds.current = new Set((0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getNodesInside)(nodeLookup, nextUserSelectRect, transform, selectionMode === _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.SelectionMode.Partial, true).map((node)=>node.id));\n        selectedEdgeIds.current = new Set();\n        const edgesSelectable = defaultEdgeOptions?.selectable ?? true;\n        // We look for all edges connected to the selected nodes\n        for (const nodeId of selectedNodeIds.current){\n            const connections = connectionLookup.get(nodeId);\n            if (!connections) continue;\n            for (const { edgeId } of connections.values()){\n                const edge = edgeLookup.get(edgeId);\n                if (edge && (edge.selectable ?? edgesSelectable)) {\n                    selectedEdgeIds.current.add(edgeId);\n                }\n            }\n        }\n        if (!(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.areSetsEqual)(prevSelectedNodeIds, selectedNodeIds.current)) {\n            const changes = getSelectionChanges(nodeLookup, selectedNodeIds.current, true);\n            triggerNodeChanges(changes);\n        }\n        if (!(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.areSetsEqual)(prevSelectedEdgeIds, selectedEdgeIds.current)) {\n            const changes = getSelectionChanges(edgeLookup, selectedEdgeIds.current);\n            triggerEdgeChanges(changes);\n        }\n        store.setState({\n            userSelectionRect: nextUserSelectRect,\n            userSelectionActive: true,\n            nodesSelectionActive: false\n        });\n    };\n    const onPointerUp = (event)=>{\n        if (event.button !== 0 || !selectionStarted.current) {\n            return;\n        }\n        event.target?.releasePointerCapture?.(event.pointerId);\n        const { userSelectionRect } = store.getState();\n        /*\n         * We only want to trigger click functions when in selection mode if\n         * the user did not move the mouse.\n         */ if (!userSelectionActive && userSelectionRect && event.target === container.current) {\n            onClick?.(event);\n        }\n        store.setState({\n            userSelectionActive: false,\n            userSelectionRect: null,\n            nodesSelectionActive: selectedNodeIds.current.size > 0\n        });\n        onSelectionEnd?.(event);\n        /*\n         * If the user kept holding the selectionKey during the selection,\n         * we need to reset the selectionInProgress, so the next click event is not prevented\n         */ if (selectionKeyPressed || selectionOnDrag) {\n            selectionInProgress.current = false;\n        }\n        selectionStarted.current = false;\n    };\n    const draggable = panOnDrag === true || Array.isArray(panOnDrag) && panOnDrag.includes(0);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            'react-flow__pane',\n            {\n                draggable,\n                dragging,\n                selection: isSelecting\n            }\n        ]),\n        onClick: hasActiveSelection ? undefined : wrapHandler(onClick, container),\n        onContextMenu: wrapHandler(onContextMenu, container),\n        onWheel: wrapHandler(onWheel, container),\n        onPointerEnter: hasActiveSelection ? undefined : onPaneMouseEnter,\n        onPointerDown: hasActiveSelection ? onPointerDown : onPaneMouseMove,\n        onPointerMove: hasActiveSelection ? onPointerMove : onPaneMouseMove,\n        onPointerUp: hasActiveSelection ? onPointerUp : undefined,\n        onPointerLeave: onPaneMouseLeave,\n        ref: container,\n        style: containerStyle,\n        children: [\n            children,\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(UserSelection, {})\n        ]\n    });\n}\n/*\n * this handler is called by\n * 1. the click handler when node is not draggable or selectNodesOnDrag = false\n * or\n * 2. the on drag start handler when node is draggable and selectNodesOnDrag = true\n */ function handleNodeClick({ id, store, unselect = false, nodeRef }) {\n    const { addSelectedNodes, unselectNodesAndEdges, multiSelectionActive, nodeLookup, onError } = store.getState();\n    const node = nodeLookup.get(id);\n    if (!node) {\n        onError?.('012', _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages['error012'](id));\n        return;\n    }\n    store.setState({\n        nodesSelectionActive: false\n    });\n    if (!node.selected) {\n        addSelectedNodes([\n            id\n        ]);\n    } else if (unselect || node.selected && multiSelectionActive) {\n        unselectNodesAndEdges({\n            nodes: [\n                node\n            ],\n            edges: []\n        });\n        requestAnimationFrame(()=>nodeRef?.current?.blur());\n    }\n}\n/**\n * Hook for calling XYDrag helper from @xyflow/system.\n *\n * @internal\n */ function useDrag({ nodeRef, disabled = false, noDragClassName, handleSelector, nodeId, isSelectable, nodeClickDistance }) {\n    const store = useStoreApi();\n    const [dragging, setDragging] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const xyDrag = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useDrag.useEffect\": ()=>{\n            xyDrag.current = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.XYDrag)({\n                getStoreItems: {\n                    \"useDrag.useEffect\": ()=>store.getState()\n                }[\"useDrag.useEffect\"],\n                onNodeMouseDown: {\n                    \"useDrag.useEffect\": (id)=>{\n                        handleNodeClick({\n                            id,\n                            store,\n                            nodeRef\n                        });\n                    }\n                }[\"useDrag.useEffect\"],\n                onDragStart: {\n                    \"useDrag.useEffect\": ()=>{\n                        setDragging(true);\n                    }\n                }[\"useDrag.useEffect\"],\n                onDragStop: {\n                    \"useDrag.useEffect\": ()=>{\n                        setDragging(false);\n                    }\n                }[\"useDrag.useEffect\"]\n            });\n        }\n    }[\"useDrag.useEffect\"], []);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useDrag.useEffect\": ()=>{\n            if (disabled) {\n                xyDrag.current?.destroy();\n            } else if (nodeRef.current) {\n                xyDrag.current?.update({\n                    noDragClassName,\n                    handleSelector,\n                    domNode: nodeRef.current,\n                    isSelectable,\n                    nodeId,\n                    nodeClickDistance\n                });\n                return ({\n                    \"useDrag.useEffect\": ()=>{\n                        xyDrag.current?.destroy();\n                    }\n                })[\"useDrag.useEffect\"];\n            }\n        }\n    }[\"useDrag.useEffect\"], [\n        noDragClassName,\n        handleSelector,\n        disabled,\n        isSelectable,\n        nodeRef,\n        nodeId\n    ]);\n    return dragging;\n}\nconst selectedAndDraggable = (nodesDraggable)=>(n)=>n.selected && (n.draggable || nodesDraggable && typeof n.draggable === 'undefined');\n/**\n * Hook for updating node positions by passing a direction and factor\n *\n * @internal\n * @returns function for updating node positions\n */ function useMoveSelectedNodes() {\n    const store = useStoreApi();\n    const moveSelectedNodes = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"useMoveSelectedNodes.useCallback[moveSelectedNodes]\": (params)=>{\n            const { nodeExtent, snapToGrid, snapGrid, nodesDraggable, onError, updateNodePositions, nodeLookup, nodeOrigin } = store.getState();\n            const nodeUpdates = new Map();\n            const isSelected = selectedAndDraggable(nodesDraggable);\n            /*\n         * by default a node moves 5px on each key press\n         * if snap grid is enabled, we use that for the velocity\n         */ const xVelo = snapToGrid ? snapGrid[0] : 5;\n            const yVelo = snapToGrid ? snapGrid[1] : 5;\n            const xDiff = params.direction.x * xVelo * params.factor;\n            const yDiff = params.direction.y * yVelo * params.factor;\n            for (const [, node] of nodeLookup){\n                if (!isSelected(node)) {\n                    continue;\n                }\n                let nextPosition = {\n                    x: node.internals.positionAbsolute.x + xDiff,\n                    y: node.internals.positionAbsolute.y + yDiff\n                };\n                if (snapToGrid) {\n                    nextPosition = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.snapPosition)(nextPosition, snapGrid);\n                }\n                const { position, positionAbsolute } = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.calculateNodePosition)({\n                    nodeId: node.id,\n                    nextPosition,\n                    nodeLookup,\n                    nodeExtent,\n                    nodeOrigin,\n                    onError\n                });\n                node.position = position;\n                node.internals.positionAbsolute = positionAbsolute;\n                nodeUpdates.set(node.id, node);\n            }\n            updateNodePositions(nodeUpdates);\n        }\n    }[\"useMoveSelectedNodes.useCallback[moveSelectedNodes]\"], []);\n    return moveSelectedNodes;\n}\nconst NodeIdContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.createContext)(null);\nconst Provider = NodeIdContext.Provider;\nNodeIdContext.Consumer;\n/**\n * You can use this hook to get the id of the node it is used inside. It is useful\n * if you need the node's id deeper in the render tree but don't want to manually\n * drill down the id as a prop.\n *\n * @public\n * @returns id of the node\n *\n * @example\n *```jsx\n *import { useNodeId } from '@xyflow/react';\n *\n *export default function CustomNode() {\n *  return (\n *    <div>\n *      <span>This node has an id of </span>\n *      <NodeIdDisplay />\n *    </div>\n *  );\n *}\n *\n *function NodeIdDisplay() {\n *  const nodeId = useNodeId();\n *\n *  return <span>{nodeId}</span>;\n *}\n *```\n */ const useNodeId = ()=>{\n    const nodeId = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(NodeIdContext);\n    return nodeId;\n};\nconst selector$g = (s)=>({\n        connectOnClick: s.connectOnClick,\n        noPanClassName: s.noPanClassName,\n        rfId: s.rfId\n    });\nconst connectingSelector = (nodeId, handleId, type)=>(state)=>{\n        const { connectionClickStartHandle: clickHandle, connectionMode, connection } = state;\n        const { fromHandle, toHandle, isValid } = connection;\n        const connectingTo = toHandle?.nodeId === nodeId && toHandle?.id === handleId && toHandle?.type === type;\n        return {\n            connectingFrom: fromHandle?.nodeId === nodeId && fromHandle?.id === handleId && fromHandle?.type === type,\n            connectingTo,\n            clickConnecting: clickHandle?.nodeId === nodeId && clickHandle?.id === handleId && clickHandle?.type === type,\n            isPossibleEndHandle: connectionMode === _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionMode.Strict ? fromHandle?.type !== type : nodeId !== fromHandle?.nodeId || handleId !== fromHandle?.id,\n            connectionInProcess: !!fromHandle,\n            clickConnectionInProcess: !!clickHandle,\n            valid: connectingTo && isValid\n        };\n    };\nfunction HandleComponent({ type = 'source', position = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Top, isValidConnection, isConnectable = true, isConnectableStart = true, isConnectableEnd = true, id, onConnect, children, className, onMouseDown, onTouchStart, ...rest }, ref) {\n    const handleId = id || null;\n    const isTarget = type === 'target';\n    const store = useStoreApi();\n    const nodeId = useNodeId();\n    const { connectOnClick, noPanClassName, rfId } = useStore(selector$g, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const { connectingFrom, connectingTo, clickConnecting, isPossibleEndHandle, connectionInProcess, clickConnectionInProcess, valid } = useStore(connectingSelector(nodeId, handleId, type), zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    if (!nodeId) {\n        store.getState().onError?.('010', _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages['error010']());\n    }\n    const onConnectExtended = (params)=>{\n        const { defaultEdgeOptions, onConnect: onConnectAction, hasDefaultEdges } = store.getState();\n        const edgeParams = {\n            ...defaultEdgeOptions,\n            ...params\n        };\n        if (hasDefaultEdges) {\n            const { edges, setEdges } = store.getState();\n            setEdges((0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.addEdge)(edgeParams, edges));\n        }\n        onConnectAction?.(edgeParams);\n        onConnect?.(edgeParams);\n    };\n    const onPointerDown = (event)=>{\n        if (!nodeId) {\n            return;\n        }\n        const isMouseTriggered = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isMouseEvent)(event.nativeEvent);\n        if (isConnectableStart && (isMouseTriggered && event.button === 0 || !isMouseTriggered)) {\n            const currentStore = store.getState();\n            _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.XYHandle.onPointerDown(event.nativeEvent, {\n                autoPanOnConnect: currentStore.autoPanOnConnect,\n                connectionMode: currentStore.connectionMode,\n                connectionRadius: currentStore.connectionRadius,\n                domNode: currentStore.domNode,\n                nodeLookup: currentStore.nodeLookup,\n                lib: currentStore.lib,\n                isTarget,\n                handleId,\n                nodeId,\n                flowId: currentStore.rfId,\n                panBy: currentStore.panBy,\n                cancelConnection: currentStore.cancelConnection,\n                onConnectStart: currentStore.onConnectStart,\n                onConnectEnd: currentStore.onConnectEnd,\n                updateConnection: currentStore.updateConnection,\n                onConnect: onConnectExtended,\n                isValidConnection: isValidConnection || currentStore.isValidConnection,\n                getTransform: ()=>store.getState().transform,\n                getFromHandle: ()=>store.getState().connection.fromHandle,\n                autoPanSpeed: currentStore.autoPanSpeed\n            });\n        }\n        if (isMouseTriggered) {\n            onMouseDown?.(event);\n        } else {\n            onTouchStart?.(event);\n        }\n    };\n    const onClick = (event)=>{\n        const { onClickConnectStart, onClickConnectEnd, connectionClickStartHandle, connectionMode, isValidConnection: isValidConnectionStore, lib, rfId: flowId, nodeLookup, connection: connectionState } = store.getState();\n        if (!nodeId || !connectionClickStartHandle && !isConnectableStart) {\n            return;\n        }\n        if (!connectionClickStartHandle) {\n            onClickConnectStart?.(event.nativeEvent, {\n                nodeId,\n                handleId,\n                handleType: type\n            });\n            store.setState({\n                connectionClickStartHandle: {\n                    nodeId,\n                    type,\n                    id: handleId\n                }\n            });\n            return;\n        }\n        const doc = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getHostForElement)(event.target);\n        const isValidConnectionHandler = isValidConnection || isValidConnectionStore;\n        const { connection, isValid } = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.XYHandle.isValid(event.nativeEvent, {\n            handle: {\n                nodeId,\n                id: handleId,\n                type\n            },\n            connectionMode,\n            fromNodeId: connectionClickStartHandle.nodeId,\n            fromHandleId: connectionClickStartHandle.id || null,\n            fromType: connectionClickStartHandle.type,\n            isValidConnection: isValidConnectionHandler,\n            flowId,\n            doc,\n            lib,\n            nodeLookup\n        });\n        if (isValid && connection) {\n            onConnectExtended(connection);\n        }\n        const connectionClone = structuredClone(connectionState);\n        delete connectionClone.inProgress;\n        connectionClone.toPosition = connectionClone.toHandle ? connectionClone.toHandle.position : null;\n        onClickConnectEnd?.(event, connectionClone);\n        store.setState({\n            connectionClickStartHandle: null\n        });\n    };\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        \"data-handleid\": handleId,\n        \"data-nodeid\": nodeId,\n        \"data-handlepos\": position,\n        \"data-id\": `${rfId}-${nodeId}-${handleId}-${type}`,\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            'react-flow__handle',\n            `react-flow__handle-${position}`,\n            'nodrag',\n            noPanClassName,\n            className,\n            {\n                source: !isTarget,\n                target: isTarget,\n                connectable: isConnectable,\n                connectablestart: isConnectableStart,\n                connectableend: isConnectableEnd,\n                clickconnecting: clickConnecting,\n                connectingfrom: connectingFrom,\n                connectingto: connectingTo,\n                valid,\n                /*\n                 * shows where you can start a connection from\n                 * and where you can end it while connecting\n                 */ connectionindicator: isConnectable && (!connectionInProcess || isPossibleEndHandle) && (connectionInProcess || clickConnectionInProcess ? isConnectableEnd : isConnectableStart)\n            }\n        ]),\n        onMouseDown: onPointerDown,\n        onTouchStart: onPointerDown,\n        onClick: connectOnClick ? onClick : undefined,\n        ref: ref,\n        ...rest,\n        children: children\n    });\n}\n/**\n * The `<Handle />` component is used in your [custom nodes](/learn/customization/custom-nodes)\n * to define connection points.\n *\n *@public\n *\n *@example\n *\n *```jsx\n *import { Handle, Position } from '@xyflow/react';\n *\n *export function CustomNode({ data }) {\n *  return (\n *    <>\n *      <div style={{ padding: '10px 20px' }}>\n *        {data.label}\n *      </div>\n *\n *      <Handle type=\"target\" position={Position.Left} />\n *      <Handle type=\"source\" position={Position.Right} />\n *    </>\n *  );\n *};\n *```\n */ const Handle = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(fixedForwardRef(HandleComponent));\nfunction InputNode({ data, isConnectable, sourcePosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Bottom }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            data?.label,\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Handle, {\n                type: \"source\",\n                position: sourcePosition,\n                isConnectable: isConnectable\n            })\n        ]\n    });\n}\nfunction DefaultNode({ data, isConnectable, targetPosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Top, sourcePosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Bottom }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Handle, {\n                type: \"target\",\n                position: targetPosition,\n                isConnectable: isConnectable\n            }),\n            data?.label,\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Handle, {\n                type: \"source\",\n                position: sourcePosition,\n                isConnectable: isConnectable\n            })\n        ]\n    });\n}\nfunction GroupNode() {\n    return null;\n}\nfunction OutputNode({ data, isConnectable, targetPosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Top }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Handle, {\n                type: \"target\",\n                position: targetPosition,\n                isConnectable: isConnectable\n            }),\n            data?.label\n        ]\n    });\n}\nconst arrowKeyDiffs = {\n    ArrowUp: {\n        x: 0,\n        y: -1\n    },\n    ArrowDown: {\n        x: 0,\n        y: 1\n    },\n    ArrowLeft: {\n        x: -1,\n        y: 0\n    },\n    ArrowRight: {\n        x: 1,\n        y: 0\n    }\n};\nconst builtinNodeTypes = {\n    input: InputNode,\n    default: DefaultNode,\n    output: OutputNode,\n    group: GroupNode\n};\nfunction getNodeInlineStyleDimensions(node) {\n    if (node.internals.handleBounds === undefined) {\n        return {\n            width: node.width ?? node.initialWidth ?? node.style?.width,\n            height: node.height ?? node.initialHeight ?? node.style?.height\n        };\n    }\n    return {\n        width: node.width ?? node.style?.width,\n        height: node.height ?? node.style?.height\n    };\n}\nconst selector$f = (s)=>{\n    const { width, height, x, y } = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getInternalNodesBounds)(s.nodeLookup, {\n        filter: (node)=>!!node.selected\n    });\n    return {\n        width: (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isNumeric)(width) ? width : null,\n        height: (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isNumeric)(height) ? height : null,\n        userSelectionActive: s.userSelectionActive,\n        transformString: `translate(${s.transform[0]}px,${s.transform[1]}px) scale(${s.transform[2]}) translate(${x}px,${y}px)`\n    };\n};\nfunction NodesSelection({ onSelectionContextMenu, noPanClassName, disableKeyboardA11y }) {\n    const store = useStoreApi();\n    const { width, height, transformString, userSelectionActive } = useStore(selector$f, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const moveSelectedNodes = useMoveSelectedNodes();\n    const nodeRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"NodesSelection.useEffect\": ()=>{\n            if (!disableKeyboardA11y) {\n                nodeRef.current?.focus({\n                    preventScroll: true\n                });\n            }\n        }\n    }[\"NodesSelection.useEffect\"], [\n        disableKeyboardA11y\n    ]);\n    useDrag({\n        nodeRef\n    });\n    if (userSelectionActive || !width || !height) {\n        return null;\n    }\n    const onContextMenu = onSelectionContextMenu ? (event)=>{\n        const selectedNodes = store.getState().nodes.filter((n)=>n.selected);\n        onSelectionContextMenu(event, selectedNodes);\n    } : undefined;\n    const onKeyDown = (event)=>{\n        if (Object.prototype.hasOwnProperty.call(arrowKeyDiffs, event.key)) {\n            event.preventDefault();\n            moveSelectedNodes({\n                direction: arrowKeyDiffs[event.key],\n                factor: event.shiftKey ? 4 : 1\n            });\n        }\n    };\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            'react-flow__nodesselection',\n            'react-flow__container',\n            noPanClassName\n        ]),\n        style: {\n            transform: transformString\n        },\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n            ref: nodeRef,\n            className: \"react-flow__nodesselection-rect\",\n            onContextMenu: onContextMenu,\n            tabIndex: disableKeyboardA11y ? undefined : -1,\n            onKeyDown: disableKeyboardA11y ? undefined : onKeyDown,\n            style: {\n                width,\n                height\n            }\n        })\n    });\n}\nconst win =  false ? 0 : undefined;\nconst selector$e = (s)=>{\n    return {\n        nodesSelectionActive: s.nodesSelectionActive,\n        userSelectionActive: s.userSelectionActive\n    };\n};\nfunction FlowRendererComponent({ children, onPaneClick, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, onPaneContextMenu, onPaneScroll, paneClickDistance, deleteKeyCode, selectionKeyCode, selectionOnDrag, selectionMode, onSelectionStart, onSelectionEnd, multiSelectionKeyCode, panActivationKeyCode, zoomActivationKeyCode, elementsSelectable, zoomOnScroll, zoomOnPinch, panOnScroll: _panOnScroll, panOnScrollSpeed, panOnScrollMode, zoomOnDoubleClick, panOnDrag: _panOnDrag, defaultViewport, translateExtent, minZoom, maxZoom, preventScrolling, onSelectionContextMenu, noWheelClassName, noPanClassName, disableKeyboardA11y, onViewportChange, isControlledViewport }) {\n    const { nodesSelectionActive, userSelectionActive } = useStore(selector$e);\n    const selectionKeyPressed = useKeyPress(selectionKeyCode, {\n        target: win\n    });\n    const panActivationKeyPressed = useKeyPress(panActivationKeyCode, {\n        target: win\n    });\n    const panOnDrag = panActivationKeyPressed || _panOnDrag;\n    const panOnScroll = panActivationKeyPressed || _panOnScroll;\n    const _selectionOnDrag = selectionOnDrag && panOnDrag !== true;\n    const isSelecting = selectionKeyPressed || userSelectionActive || _selectionOnDrag;\n    useGlobalKeyHandler({\n        deleteKeyCode,\n        multiSelectionKeyCode\n    });\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ZoomPane, {\n        onPaneContextMenu: onPaneContextMenu,\n        elementsSelectable: elementsSelectable,\n        zoomOnScroll: zoomOnScroll,\n        zoomOnPinch: zoomOnPinch,\n        panOnScroll: panOnScroll,\n        panOnScrollSpeed: panOnScrollSpeed,\n        panOnScrollMode: panOnScrollMode,\n        zoomOnDoubleClick: zoomOnDoubleClick,\n        panOnDrag: !selectionKeyPressed && panOnDrag,\n        defaultViewport: defaultViewport,\n        translateExtent: translateExtent,\n        minZoom: minZoom,\n        maxZoom: maxZoom,\n        zoomActivationKeyCode: zoomActivationKeyCode,\n        preventScrolling: preventScrolling,\n        noWheelClassName: noWheelClassName,\n        noPanClassName: noPanClassName,\n        onViewportChange: onViewportChange,\n        isControlledViewport: isControlledViewport,\n        paneClickDistance: paneClickDistance,\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(Pane, {\n            onSelectionStart: onSelectionStart,\n            onSelectionEnd: onSelectionEnd,\n            onPaneClick: onPaneClick,\n            onPaneMouseEnter: onPaneMouseEnter,\n            onPaneMouseMove: onPaneMouseMove,\n            onPaneMouseLeave: onPaneMouseLeave,\n            onPaneContextMenu: onPaneContextMenu,\n            onPaneScroll: onPaneScroll,\n            panOnDrag: panOnDrag,\n            isSelecting: !!isSelecting,\n            selectionMode: selectionMode,\n            selectionKeyPressed: selectionKeyPressed,\n            selectionOnDrag: _selectionOnDrag,\n            children: [\n                children,\n                nodesSelectionActive && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodesSelection, {\n                    onSelectionContextMenu: onSelectionContextMenu,\n                    noPanClassName: noPanClassName,\n                    disableKeyboardA11y: disableKeyboardA11y\n                })\n            ]\n        })\n    });\n}\nFlowRendererComponent.displayName = 'FlowRenderer';\nconst FlowRenderer = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(FlowRendererComponent);\nconst selector$d = (onlyRenderVisible)=>(s)=>{\n        return onlyRenderVisible ? (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getNodesInside)(s.nodeLookup, {\n            x: 0,\n            y: 0,\n            width: s.width,\n            height: s.height\n        }, s.transform, true).map((node)=>node.id) : Array.from(s.nodeLookup.keys());\n    };\n/**\n * Hook for getting the visible node ids from the store.\n *\n * @internal\n * @param onlyRenderVisible\n * @returns array with visible node ids\n */ function useVisibleNodeIds(onlyRenderVisible) {\n    const nodeIds = useStore((0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)(selector$d(onlyRenderVisible), [\n        onlyRenderVisible\n    ]), zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    return nodeIds;\n}\nconst selector$c = (s)=>s.updateNodeInternals;\nfunction useResizeObserver() {\n    const updateNodeInternals = useStore(selector$c);\n    const [resizeObserver] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        \"useResizeObserver.useState\": ()=>{\n            if (typeof ResizeObserver === 'undefined') {\n                return null;\n            }\n            return new ResizeObserver({\n                \"useResizeObserver.useState\": (entries)=>{\n                    const updates = new Map();\n                    entries.forEach({\n                        \"useResizeObserver.useState\": (entry)=>{\n                            const id = entry.target.getAttribute('data-id');\n                            updates.set(id, {\n                                id,\n                                nodeElement: entry.target,\n                                force: true\n                            });\n                        }\n                    }[\"useResizeObserver.useState\"]);\n                    updateNodeInternals(updates);\n                }\n            }[\"useResizeObserver.useState\"]);\n        }\n    }[\"useResizeObserver.useState\"]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useResizeObserver.useEffect\": ()=>{\n            return ({\n                \"useResizeObserver.useEffect\": ()=>{\n                    resizeObserver?.disconnect();\n                }\n            })[\"useResizeObserver.useEffect\"];\n        }\n    }[\"useResizeObserver.useEffect\"], [\n        resizeObserver\n    ]);\n    return resizeObserver;\n}\n/**\n * Hook to handle the resize observation + internal updates for the passed node.\n *\n * @internal\n * @returns nodeRef - reference to the node element\n */ function useNodeObserver({ node, nodeType, hasDimensions, resizeObserver }) {\n    const store = useStoreApi();\n    const nodeRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const observedNode = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const prevSourcePosition = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(node.sourcePosition);\n    const prevTargetPosition = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(node.targetPosition);\n    const prevType = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(nodeType);\n    const isInitialized = hasDimensions && !!node.internals.handleBounds;\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useNodeObserver.useEffect\": ()=>{\n            if (nodeRef.current && !node.hidden && (!isInitialized || observedNode.current !== nodeRef.current)) {\n                if (observedNode.current) {\n                    resizeObserver?.unobserve(observedNode.current);\n                }\n                resizeObserver?.observe(nodeRef.current);\n                observedNode.current = nodeRef.current;\n            }\n        }\n    }[\"useNodeObserver.useEffect\"], [\n        isInitialized,\n        node.hidden\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useNodeObserver.useEffect\": ()=>{\n            return ({\n                \"useNodeObserver.useEffect\": ()=>{\n                    if (observedNode.current) {\n                        resizeObserver?.unobserve(observedNode.current);\n                        observedNode.current = null;\n                    }\n                }\n            })[\"useNodeObserver.useEffect\"];\n        }\n    }[\"useNodeObserver.useEffect\"], []);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useNodeObserver.useEffect\": ()=>{\n            if (nodeRef.current) {\n                /*\n             * when the user programmatically changes the source or handle position, we need to update the internals\n             * to make sure the edges are updated correctly\n             */ const typeChanged = prevType.current !== nodeType;\n                const sourcePosChanged = prevSourcePosition.current !== node.sourcePosition;\n                const targetPosChanged = prevTargetPosition.current !== node.targetPosition;\n                if (typeChanged || sourcePosChanged || targetPosChanged) {\n                    prevType.current = nodeType;\n                    prevSourcePosition.current = node.sourcePosition;\n                    prevTargetPosition.current = node.targetPosition;\n                    store.getState().updateNodeInternals(new Map([\n                        [\n                            node.id,\n                            {\n                                id: node.id,\n                                nodeElement: nodeRef.current,\n                                force: true\n                            }\n                        ]\n                    ]));\n                }\n            }\n        }\n    }[\"useNodeObserver.useEffect\"], [\n        node.id,\n        nodeType,\n        node.sourcePosition,\n        node.targetPosition\n    ]);\n    return nodeRef;\n}\nfunction NodeWrapper({ id, onClick, onMouseEnter, onMouseMove, onMouseLeave, onContextMenu, onDoubleClick, nodesDraggable, elementsSelectable, nodesConnectable, nodesFocusable, resizeObserver, noDragClassName, noPanClassName, disableKeyboardA11y, rfId, nodeTypes, nodeClickDistance, onError }) {\n    const { node, internals, isParent } = useStore({\n        \"NodeWrapper.useStore\": (s)=>{\n            const node = s.nodeLookup.get(id);\n            const isParent = s.parentLookup.has(id);\n            return {\n                node,\n                internals: node.internals,\n                isParent\n            };\n        }\n    }[\"NodeWrapper.useStore\"], zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    let nodeType = node.type || 'default';\n    let NodeComponent = nodeTypes?.[nodeType] || builtinNodeTypes[nodeType];\n    if (NodeComponent === undefined) {\n        onError?.('003', _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages['error003'](nodeType));\n        nodeType = 'default';\n        NodeComponent = builtinNodeTypes.default;\n    }\n    const isDraggable = !!(node.draggable || nodesDraggable && typeof node.draggable === 'undefined');\n    const isSelectable = !!(node.selectable || elementsSelectable && typeof node.selectable === 'undefined');\n    const isConnectable = !!(node.connectable || nodesConnectable && typeof node.connectable === 'undefined');\n    const isFocusable = !!(node.focusable || nodesFocusable && typeof node.focusable === 'undefined');\n    const store = useStoreApi();\n    const hasDimensions = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.nodeHasDimensions)(node);\n    const nodeRef = useNodeObserver({\n        node,\n        nodeType,\n        hasDimensions,\n        resizeObserver\n    });\n    const dragging = useDrag({\n        nodeRef,\n        disabled: node.hidden || !isDraggable,\n        noDragClassName,\n        handleSelector: node.dragHandle,\n        nodeId: id,\n        isSelectable,\n        nodeClickDistance\n    });\n    const moveSelectedNodes = useMoveSelectedNodes();\n    if (node.hidden) {\n        return null;\n    }\n    const nodeDimensions = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getNodeDimensions)(node);\n    const inlineDimensions = getNodeInlineStyleDimensions(node);\n    const hasPointerEvents = isSelectable || isDraggable || onClick || onMouseEnter || onMouseMove || onMouseLeave;\n    const onMouseEnterHandler = onMouseEnter ? (event)=>onMouseEnter(event, {\n            ...internals.userNode\n        }) : undefined;\n    const onMouseMoveHandler = onMouseMove ? (event)=>onMouseMove(event, {\n            ...internals.userNode\n        }) : undefined;\n    const onMouseLeaveHandler = onMouseLeave ? (event)=>onMouseLeave(event, {\n            ...internals.userNode\n        }) : undefined;\n    const onContextMenuHandler = onContextMenu ? (event)=>onContextMenu(event, {\n            ...internals.userNode\n        }) : undefined;\n    const onDoubleClickHandler = onDoubleClick ? (event)=>onDoubleClick(event, {\n            ...internals.userNode\n        }) : undefined;\n    const onSelectNodeHandler = (event)=>{\n        const { selectNodesOnDrag, nodeDragThreshold } = store.getState();\n        if (isSelectable && (!selectNodesOnDrag || !isDraggable || nodeDragThreshold > 0)) {\n            /*\n             * this handler gets called by XYDrag on drag start when selectNodesOnDrag=true\n             * here we only need to call it when selectNodesOnDrag=false\n             */ handleNodeClick({\n                id,\n                store,\n                nodeRef\n            });\n        }\n        if (onClick) {\n            onClick(event, {\n                ...internals.userNode\n            });\n        }\n    };\n    const onKeyDown = (event)=>{\n        if ((0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isInputDOMNode)(event.nativeEvent) || disableKeyboardA11y) {\n            return;\n        }\n        if (_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.elementSelectionKeys.includes(event.key) && isSelectable) {\n            const unselect = event.key === 'Escape';\n            handleNodeClick({\n                id,\n                store,\n                unselect,\n                nodeRef\n            });\n        } else if (isDraggable && node.selected && Object.prototype.hasOwnProperty.call(arrowKeyDiffs, event.key)) {\n            // prevent default scrolling behavior on arrow key press when node is moved\n            event.preventDefault();\n            store.setState({\n                ariaLiveMessage: `Moved selected node ${event.key.replace('Arrow', '').toLowerCase()}. New position, x: ${~~internals.positionAbsolute.x}, y: ${~~internals.positionAbsolute.y}`\n            });\n            moveSelectedNodes({\n                direction: arrowKeyDiffs[event.key],\n                factor: event.shiftKey ? 4 : 1\n            });\n        }\n    };\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            'react-flow__node',\n            `react-flow__node-${nodeType}`,\n            {\n                // this is overwritable by passing `nopan` as a class name\n                [noPanClassName]: isDraggable\n            },\n            node.className,\n            {\n                selected: node.selected,\n                selectable: isSelectable,\n                parent: isParent,\n                draggable: isDraggable,\n                dragging\n            }\n        ]),\n        ref: nodeRef,\n        style: {\n            zIndex: internals.z,\n            transform: `translate(${internals.positionAbsolute.x}px,${internals.positionAbsolute.y}px)`,\n            pointerEvents: hasPointerEvents ? 'all' : 'none',\n            visibility: hasDimensions ? 'visible' : 'hidden',\n            ...node.style,\n            ...inlineDimensions\n        },\n        \"data-id\": id,\n        \"data-testid\": `rf__node-${id}`,\n        onMouseEnter: onMouseEnterHandler,\n        onMouseMove: onMouseMoveHandler,\n        onMouseLeave: onMouseLeaveHandler,\n        onContextMenu: onContextMenuHandler,\n        onClick: onSelectNodeHandler,\n        onDoubleClick: onDoubleClickHandler,\n        onKeyDown: isFocusable ? onKeyDown : undefined,\n        tabIndex: isFocusable ? 0 : undefined,\n        role: isFocusable ? 'button' : undefined,\n        \"aria-describedby\": disableKeyboardA11y ? undefined : `${ARIA_NODE_DESC_KEY}-${rfId}`,\n        \"aria-label\": node.ariaLabel,\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Provider, {\n            value: id,\n            children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeComponent, {\n                id: id,\n                data: node.data,\n                type: nodeType,\n                positionAbsoluteX: internals.positionAbsolute.x,\n                positionAbsoluteY: internals.positionAbsolute.y,\n                selected: node.selected ?? false,\n                selectable: isSelectable,\n                draggable: isDraggable,\n                deletable: node.deletable ?? true,\n                isConnectable: isConnectable,\n                sourcePosition: node.sourcePosition,\n                targetPosition: node.targetPosition,\n                dragging: dragging,\n                dragHandle: node.dragHandle,\n                zIndex: internals.z,\n                parentId: node.parentId,\n                ...nodeDimensions\n            })\n        })\n    });\n}\nconst selector$b = (s)=>({\n        nodesDraggable: s.nodesDraggable,\n        nodesConnectable: s.nodesConnectable,\n        nodesFocusable: s.nodesFocusable,\n        elementsSelectable: s.elementsSelectable,\n        onError: s.onError\n    });\nfunction NodeRendererComponent(props) {\n    const { nodesDraggable, nodesConnectable, nodesFocusable, elementsSelectable, onError } = useStore(selector$b, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const nodeIds = useVisibleNodeIds(props.onlyRenderVisibleElements);\n    const resizeObserver = useResizeObserver();\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: \"react-flow__nodes\",\n        style: containerStyle,\n        children: nodeIds.map((nodeId)=>{\n            return(/*\n             * The split of responsibilities between NodeRenderer and\n             * NodeComponentWrapper may appear weird. However, its designed to\n             * minimize the cost of updates when individual nodes change.\n             *\n             * For example, when youre dragging a single node, that node gets\n             * updated multiple times per second. If `NodeRenderer` were to update\n             * every time, it would have to re-run the `nodes.map()` loop every\n             * time. This gets pricey with hundreds of nodes, especially if every\n             * loop cycle does more than just rendering a JSX element!\n             *\n             * As a result of this choice, we took the following implementation\n             * decisions:\n             * - NodeRenderer subscribes *only* to node IDs  and therefore\n             *   rerender *only* when visible nodes are added or removed.\n             * - NodeRenderer performs all operations the result of which can be\n             *   shared between nodes (such as creating the `ResizeObserver`\n             *   instance, or subscribing to `selector`). This means extra prop\n             *   drilling into `NodeComponentWrapper`, but it means we need to run\n             *   these operations only once  instead of once per node.\n             * - Any operations that youd normally write inside `nodes.map` are\n             *   moved into `NodeComponentWrapper`. This ensures they are\n             *   memorized  so if `NodeRenderer` *has* to rerender, it only\n             *   needs to regenerate the list of nodes, nothing else.\n             */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeWrapper, {\n                id: nodeId,\n                nodeTypes: props.nodeTypes,\n                nodeExtent: props.nodeExtent,\n                onClick: props.onNodeClick,\n                onMouseEnter: props.onNodeMouseEnter,\n                onMouseMove: props.onNodeMouseMove,\n                onMouseLeave: props.onNodeMouseLeave,\n                onContextMenu: props.onNodeContextMenu,\n                onDoubleClick: props.onNodeDoubleClick,\n                noDragClassName: props.noDragClassName,\n                noPanClassName: props.noPanClassName,\n                rfId: props.rfId,\n                disableKeyboardA11y: props.disableKeyboardA11y,\n                resizeObserver: resizeObserver,\n                nodesDraggable: nodesDraggable,\n                nodesConnectable: nodesConnectable,\n                nodesFocusable: nodesFocusable,\n                elementsSelectable: elementsSelectable,\n                nodeClickDistance: props.nodeClickDistance,\n                onError: onError\n            }, nodeId));\n        })\n    });\n}\nNodeRendererComponent.displayName = 'NodeRenderer';\nconst NodeRenderer = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(NodeRendererComponent);\n/**\n * Hook for getting the visible edge ids from the store.\n *\n * @internal\n * @param onlyRenderVisible\n * @returns array with visible edge ids\n */ function useVisibleEdgeIds(onlyRenderVisible) {\n    const edgeIds = useStore((0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"useVisibleEdgeIds.useStore[edgeIds]\": (s)=>{\n            if (!onlyRenderVisible) {\n                return s.edges.map({\n                    \"useVisibleEdgeIds.useStore[edgeIds]\": (edge)=>edge.id\n                }[\"useVisibleEdgeIds.useStore[edgeIds]\"]);\n            }\n            const visibleEdgeIds = [];\n            if (s.width && s.height) {\n                for (const edge of s.edges){\n                    const sourceNode = s.nodeLookup.get(edge.source);\n                    const targetNode = s.nodeLookup.get(edge.target);\n                    if (sourceNode && targetNode && (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isEdgeVisible)({\n                        sourceNode,\n                        targetNode,\n                        width: s.width,\n                        height: s.height,\n                        transform: s.transform\n                    })) {\n                        visibleEdgeIds.push(edge.id);\n                    }\n                }\n            }\n            return visibleEdgeIds;\n        }\n    }[\"useVisibleEdgeIds.useStore[edgeIds]\"], [\n        onlyRenderVisible\n    ]), zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    return edgeIds;\n}\nconst ArrowSymbol = ({ color = 'none', strokeWidth = 1 })=>{\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"polyline\", {\n        style: {\n            stroke: color,\n            strokeWidth\n        },\n        strokeLinecap: \"round\",\n        strokeLinejoin: \"round\",\n        fill: \"none\",\n        points: \"-5,-4 0,0 -5,4\"\n    });\n};\nconst ArrowClosedSymbol = ({ color = 'none', strokeWidth = 1 })=>{\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"polyline\", {\n        style: {\n            stroke: color,\n            fill: color,\n            strokeWidth\n        },\n        strokeLinecap: \"round\",\n        strokeLinejoin: \"round\",\n        points: \"-5,-4 0,0 -5,4 -5,-4\"\n    });\n};\nconst MarkerSymbols = {\n    [_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.MarkerType.Arrow]: ArrowSymbol,\n    [_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.MarkerType.ArrowClosed]: ArrowClosedSymbol\n};\nfunction useMarkerSymbol(type) {\n    const store = useStoreApi();\n    const symbol = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"useMarkerSymbol.useMemo[symbol]\": ()=>{\n            const symbolExists = Object.prototype.hasOwnProperty.call(MarkerSymbols, type);\n            if (!symbolExists) {\n                store.getState().onError?.('009', _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages['error009'](type));\n                return null;\n            }\n            return MarkerSymbols[type];\n        }\n    }[\"useMarkerSymbol.useMemo[symbol]\"], [\n        type\n    ]);\n    return symbol;\n}\nconst Marker = ({ id, type, color, width = 12.5, height = 12.5, markerUnits = 'strokeWidth', strokeWidth, orient = 'auto-start-reverse' })=>{\n    const Symbol = useMarkerSymbol(type);\n    if (!Symbol) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"marker\", {\n        className: \"react-flow__arrowhead\",\n        id: id,\n        markerWidth: `${width}`,\n        markerHeight: `${height}`,\n        viewBox: \"-10 -10 20 20\",\n        markerUnits: markerUnits,\n        orient: orient,\n        refX: \"0\",\n        refY: \"0\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Symbol, {\n            color: color,\n            strokeWidth: strokeWidth\n        })\n    });\n};\n/*\n * when you have multiple flows on a page and you hide the first one, the other ones have no markers anymore\n * when they do have markers with the same ids. To prevent this the user can pass a unique id to the react flow wrapper\n * that we can then use for creating our unique marker ids\n */ const MarkerDefinitions = ({ defaultColor, rfId })=>{\n    const edges = useStore({\n        \"MarkerDefinitions.useStore[edges]\": (s)=>s.edges\n    }[\"MarkerDefinitions.useStore[edges]\"]);\n    const defaultEdgeOptions = useStore({\n        \"MarkerDefinitions.useStore[defaultEdgeOptions]\": (s)=>s.defaultEdgeOptions\n    }[\"MarkerDefinitions.useStore[defaultEdgeOptions]\"]);\n    const markers = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"MarkerDefinitions.useMemo[markers]\": ()=>{\n            const markers = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.createMarkerIds)(edges, {\n                id: rfId,\n                defaultColor,\n                defaultMarkerStart: defaultEdgeOptions?.markerStart,\n                defaultMarkerEnd: defaultEdgeOptions?.markerEnd\n            });\n            return markers;\n        }\n    }[\"MarkerDefinitions.useMemo[markers]\"], [\n        edges,\n        defaultEdgeOptions,\n        rfId,\n        defaultColor\n    ]);\n    if (!markers.length) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n        className: \"react-flow__marker\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"defs\", {\n            children: markers.map((marker)=>(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Marker, {\n                    id: marker.id,\n                    type: marker.type,\n                    color: marker.color,\n                    width: marker.width,\n                    height: marker.height,\n                    markerUnits: marker.markerUnits,\n                    strokeWidth: marker.strokeWidth,\n                    orient: marker.orient\n                }, marker.id))\n        })\n    });\n};\nMarkerDefinitions.displayName = 'MarkerDefinitions';\nvar MarkerDefinitions$1 = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(MarkerDefinitions);\nfunction EdgeTextComponent({ x, y, label, labelStyle = {}, labelShowBg = true, labelBgStyle = {}, labelBgPadding = [\n    2,\n    4\n], labelBgBorderRadius = 2, children, className, ...rest }) {\n    const [edgeTextBbox, setEdgeTextBbox] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        x: 1,\n        y: 0,\n        width: 0,\n        height: 0\n    });\n    const edgeTextClasses = (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n        'react-flow__edge-textwrapper',\n        className\n    ]);\n    const edgeTextRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"EdgeTextComponent.useEffect\": ()=>{\n            if (edgeTextRef.current) {\n                const textBbox = edgeTextRef.current.getBBox();\n                setEdgeTextBbox({\n                    x: textBbox.x,\n                    y: textBbox.y,\n                    width: textBbox.width,\n                    height: textBbox.height\n                });\n            }\n        }\n    }[\"EdgeTextComponent.useEffect\"], [\n        label\n    ]);\n    if (typeof label === 'undefined' || !label) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"g\", {\n        transform: `translate(${x - edgeTextBbox.width / 2} ${y - edgeTextBbox.height / 2})`,\n        className: edgeTextClasses,\n        visibility: edgeTextBbox.width ? 'visible' : 'hidden',\n        ...rest,\n        children: [\n            labelShowBg && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"rect\", {\n                width: edgeTextBbox.width + 2 * labelBgPadding[0],\n                x: -labelBgPadding[0],\n                y: -labelBgPadding[1],\n                height: edgeTextBbox.height + 2 * labelBgPadding[1],\n                className: \"react-flow__edge-textbg\",\n                style: labelBgStyle,\n                rx: labelBgBorderRadius,\n                ry: labelBgBorderRadius\n            }),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"text\", {\n                className: \"react-flow__edge-text\",\n                y: edgeTextBbox.height / 2,\n                dy: \"0.3em\",\n                ref: edgeTextRef,\n                style: labelStyle,\n                children: label\n            }),\n            children\n        ]\n    });\n}\nEdgeTextComponent.displayName = 'EdgeText';\n/**\n * You can use the `<EdgeText />` component as a helper component to display text\n * within your custom edges.\n *\n *@public\n *\n *@example\n *```jsx\n *import { EdgeText } from '@xyflow/react';\n *\n *export function CustomEdgeLabel({ label }) {\n *  return (\n *    <EdgeText\n *      x={100}\n *      y={100}\n *      label={label}\n *      labelStyle={{ fill: 'white' }}\n *      labelShowBg\n *      labelBgStyle={{ fill: 'red' }}\n *      labelBgPadding={[2, 4]}\n *      labelBgBorderRadius={2}\n *    />\n *  );\n *}\n *```\n */ const EdgeText = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(EdgeTextComponent);\n/**\n * The `<BaseEdge />` component gets used internally for all the edges. It can be\n * used inside a custom edge and handles the invisible helper edge and the edge label\n * for you.\n *\n * @public\n * @example\n * ```jsx\n *import { BaseEdge } from '@xyflow/react';\n *\n *export function CustomEdge({ sourceX, sourceY, targetX, targetY, ...props }) {\n *  const [edgePath] = getStraightPath({\n *    sourceX,\n *    sourceY,\n *    targetX,\n *    targetY,\n *  });\n *\n *  return <BaseEdge path={edgePath} {...props} />;\n *}\n *```\n *\n * @remarks If you want to use an edge marker with the [`<BaseEdge />`](/api-reference/components/base-edge) component,\n * you can pass the `markerStart` or `markerEnd` props passed to your custom edge\n * through to the [`<BaseEdge />`](/api-reference/components/base-edge) component.\n * You can see all the props passed to a custom edge by looking at the [`EdgeProps`](/api-reference/types/edge-props) type.\n */ function BaseEdge({ path, labelX, labelY, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, interactionWidth = 20, ...props }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                ...props,\n                d: path,\n                fill: \"none\",\n                className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n                    'react-flow__edge-path',\n                    props.className\n                ])\n            }),\n            interactionWidth && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                d: path,\n                fill: \"none\",\n                strokeOpacity: 0,\n                strokeWidth: interactionWidth,\n                className: \"react-flow__edge-interaction\"\n            }),\n            label && (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isNumeric)(labelX) && (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isNumeric)(labelY) ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EdgeText, {\n                x: labelX,\n                y: labelY,\n                label: label,\n                labelStyle: labelStyle,\n                labelShowBg: labelShowBg,\n                labelBgStyle: labelBgStyle,\n                labelBgPadding: labelBgPadding,\n                labelBgBorderRadius: labelBgBorderRadius\n            }) : null\n        ]\n    });\n}\nfunction getControl({ pos, x1, y1, x2, y2 }) {\n    if (pos === _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Left || pos === _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Right) {\n        return [\n            0.5 * (x1 + x2),\n            y1\n        ];\n    }\n    return [\n        x1,\n        0.5 * (y1 + y2)\n    ];\n}\n/**\n * The `getSimpleBezierPath` util returns everything you need to render a simple\n * bezier edge between two nodes.\n * @public\n */ function getSimpleBezierPath({ sourceX, sourceY, sourcePosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Bottom, targetX, targetY, targetPosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Top }) {\n    const [sourceControlX, sourceControlY] = getControl({\n        pos: sourcePosition,\n        x1: sourceX,\n        y1: sourceY,\n        x2: targetX,\n        y2: targetY\n    });\n    const [targetControlX, targetControlY] = getControl({\n        pos: targetPosition,\n        x1: targetX,\n        y1: targetY,\n        x2: sourceX,\n        y2: sourceY\n    });\n    const [labelX, labelY, offsetX, offsetY] = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getBezierEdgeCenter)({\n        sourceX,\n        sourceY,\n        targetX,\n        targetY,\n        sourceControlX,\n        sourceControlY,\n        targetControlX,\n        targetControlY\n    });\n    return [\n        `M${sourceX},${sourceY} C${sourceControlX},${sourceControlY} ${targetControlX},${targetControlY} ${targetX},${targetY}`,\n        labelX,\n        labelY,\n        offsetX,\n        offsetY\n    ];\n}\nfunction createSimpleBezierEdge(params) {\n    // eslint-disable-next-line react/display-name\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(({ id, sourceX, sourceY, targetX, targetY, sourcePosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Bottom, targetPosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Top, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style, markerEnd, markerStart, interactionWidth })=>{\n        const [path, labelX, labelY] = getSimpleBezierPath({\n            sourceX,\n            sourceY,\n            sourcePosition,\n            targetX,\n            targetY,\n            targetPosition\n        });\n        const _id = params.isInternal ? undefined : id;\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BaseEdge, {\n            id: _id,\n            path: path,\n            labelX: labelX,\n            labelY: labelY,\n            label: label,\n            labelStyle: labelStyle,\n            labelShowBg: labelShowBg,\n            labelBgStyle: labelBgStyle,\n            labelBgPadding: labelBgPadding,\n            labelBgBorderRadius: labelBgBorderRadius,\n            style: style,\n            markerEnd: markerEnd,\n            markerStart: markerStart,\n            interactionWidth: interactionWidth\n        });\n    });\n}\nconst SimpleBezierEdge = createSimpleBezierEdge({\n    isInternal: false\n});\nconst SimpleBezierEdgeInternal = createSimpleBezierEdge({\n    isInternal: true\n});\nSimpleBezierEdge.displayName = 'SimpleBezierEdge';\nSimpleBezierEdgeInternal.displayName = 'SimpleBezierEdgeInternal';\nfunction createSmoothStepEdge(params) {\n    // eslint-disable-next-line react/display-name\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(({ id, sourceX, sourceY, targetX, targetY, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style, sourcePosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Bottom, targetPosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Top, markerEnd, markerStart, pathOptions, interactionWidth })=>{\n        const [path, labelX, labelY] = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getSmoothStepPath)({\n            sourceX,\n            sourceY,\n            sourcePosition,\n            targetX,\n            targetY,\n            targetPosition,\n            borderRadius: pathOptions?.borderRadius,\n            offset: pathOptions?.offset\n        });\n        const _id = params.isInternal ? undefined : id;\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BaseEdge, {\n            id: _id,\n            path: path,\n            labelX: labelX,\n            labelY: labelY,\n            label: label,\n            labelStyle: labelStyle,\n            labelShowBg: labelShowBg,\n            labelBgStyle: labelBgStyle,\n            labelBgPadding: labelBgPadding,\n            labelBgBorderRadius: labelBgBorderRadius,\n            style: style,\n            markerEnd: markerEnd,\n            markerStart: markerStart,\n            interactionWidth: interactionWidth\n        });\n    });\n}\nconst SmoothStepEdge = createSmoothStepEdge({\n    isInternal: false\n});\nconst SmoothStepEdgeInternal = createSmoothStepEdge({\n    isInternal: true\n});\nSmoothStepEdge.displayName = 'SmoothStepEdge';\nSmoothStepEdgeInternal.displayName = 'SmoothStepEdgeInternal';\nfunction createStepEdge(params) {\n    // eslint-disable-next-line react/display-name\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(({ id, ...props })=>{\n        const _id = params.isInternal ? undefined : id;\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(SmoothStepEdge, {\n            ...props,\n            id: _id,\n            pathOptions: (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n                \"createStepEdge.useMemo\": ()=>({\n                        borderRadius: 0,\n                        offset: props.pathOptions?.offset\n                    })\n            }[\"createStepEdge.useMemo\"], [\n                props.pathOptions?.offset\n            ])\n        });\n    });\n}\nconst StepEdge = createStepEdge({\n    isInternal: false\n});\nconst StepEdgeInternal = createStepEdge({\n    isInternal: true\n});\nStepEdge.displayName = 'StepEdge';\nStepEdgeInternal.displayName = 'StepEdgeInternal';\nfunction createStraightEdge(params) {\n    // eslint-disable-next-line react/display-name\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(({ id, sourceX, sourceY, targetX, targetY, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style, markerEnd, markerStart, interactionWidth })=>{\n        const [path, labelX, labelY] = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getStraightPath)({\n            sourceX,\n            sourceY,\n            targetX,\n            targetY\n        });\n        const _id = params.isInternal ? undefined : id;\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BaseEdge, {\n            id: _id,\n            path: path,\n            labelX: labelX,\n            labelY: labelY,\n            label: label,\n            labelStyle: labelStyle,\n            labelShowBg: labelShowBg,\n            labelBgStyle: labelBgStyle,\n            labelBgPadding: labelBgPadding,\n            labelBgBorderRadius: labelBgBorderRadius,\n            style: style,\n            markerEnd: markerEnd,\n            markerStart: markerStart,\n            interactionWidth: interactionWidth\n        });\n    });\n}\nconst StraightEdge = createStraightEdge({\n    isInternal: false\n});\nconst StraightEdgeInternal = createStraightEdge({\n    isInternal: true\n});\nStraightEdge.displayName = 'StraightEdge';\nStraightEdgeInternal.displayName = 'StraightEdgeInternal';\nfunction createBezierEdge(params) {\n    // eslint-disable-next-line react/display-name\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(({ id, sourceX, sourceY, targetX, targetY, sourcePosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Bottom, targetPosition = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Top, label, labelStyle, labelShowBg, labelBgStyle, labelBgPadding, labelBgBorderRadius, style, markerEnd, markerStart, pathOptions, interactionWidth })=>{\n        const [path, labelX, labelY] = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getBezierPath)({\n            sourceX,\n            sourceY,\n            sourcePosition,\n            targetX,\n            targetY,\n            targetPosition,\n            curvature: pathOptions?.curvature\n        });\n        const _id = params.isInternal ? undefined : id;\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BaseEdge, {\n            id: _id,\n            path: path,\n            labelX: labelX,\n            labelY: labelY,\n            label: label,\n            labelStyle: labelStyle,\n            labelShowBg: labelShowBg,\n            labelBgStyle: labelBgStyle,\n            labelBgPadding: labelBgPadding,\n            labelBgBorderRadius: labelBgBorderRadius,\n            style: style,\n            markerEnd: markerEnd,\n            markerStart: markerStart,\n            interactionWidth: interactionWidth\n        });\n    });\n}\nconst BezierEdge = createBezierEdge({\n    isInternal: false\n});\nconst BezierEdgeInternal = createBezierEdge({\n    isInternal: true\n});\nBezierEdge.displayName = 'BezierEdge';\nBezierEdgeInternal.displayName = 'BezierEdgeInternal';\nconst builtinEdgeTypes = {\n    default: BezierEdgeInternal,\n    straight: StraightEdgeInternal,\n    step: StepEdgeInternal,\n    smoothstep: SmoothStepEdgeInternal,\n    simplebezier: SimpleBezierEdgeInternal\n};\nconst nullPosition = {\n    sourceX: null,\n    sourceY: null,\n    targetX: null,\n    targetY: null,\n    sourcePosition: null,\n    targetPosition: null\n};\nconst shiftX = (x, shift, position)=>{\n    if (position === _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Left) return x - shift;\n    if (position === _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Right) return x + shift;\n    return x;\n};\nconst shiftY = (y, shift, position)=>{\n    if (position === _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Top) return y - shift;\n    if (position === _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Bottom) return y + shift;\n    return y;\n};\nconst EdgeUpdaterClassName = 'react-flow__edgeupdater';\nfunction EdgeAnchor({ position, centerX, centerY, radius = 10, onMouseDown, onMouseEnter, onMouseOut, type }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"circle\", {\n        onMouseDown: onMouseDown,\n        onMouseEnter: onMouseEnter,\n        onMouseOut: onMouseOut,\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            EdgeUpdaterClassName,\n            `${EdgeUpdaterClassName}-${type}`\n        ]),\n        cx: shiftX(centerX, radius, position),\n        cy: shiftY(centerY, radius, position),\n        r: radius,\n        stroke: \"transparent\",\n        fill: \"transparent\"\n    });\n}\nfunction EdgeUpdateAnchors({ isReconnectable, reconnectRadius, edge, sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition, onReconnect, onReconnectStart, onReconnectEnd, setReconnecting, setUpdateHover }) {\n    const store = useStoreApi();\n    const handleEdgeUpdater = (event, oppositeHandle)=>{\n        // avoid triggering edge updater if mouse btn is not left\n        if (event.button !== 0) {\n            return;\n        }\n        const { autoPanOnConnect, domNode, isValidConnection, connectionMode, connectionRadius, lib, onConnectStart, onConnectEnd, cancelConnection, nodeLookup, rfId: flowId, panBy, updateConnection } = store.getState();\n        const isTarget = oppositeHandle.type === 'target';\n        setReconnecting(true);\n        onReconnectStart?.(event, edge, oppositeHandle.type);\n        const _onReconnectEnd = (evt, connectionState)=>{\n            setReconnecting(false);\n            onReconnectEnd?.(evt, edge, oppositeHandle.type, connectionState);\n        };\n        const onConnectEdge = (connection)=>onReconnect?.(edge, connection);\n        _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.XYHandle.onPointerDown(event.nativeEvent, {\n            autoPanOnConnect,\n            connectionMode,\n            connectionRadius,\n            domNode,\n            handleId: oppositeHandle.id,\n            nodeId: oppositeHandle.nodeId,\n            nodeLookup,\n            isTarget,\n            edgeUpdaterType: oppositeHandle.type,\n            lib,\n            flowId,\n            cancelConnection,\n            panBy,\n            isValidConnection,\n            onConnect: onConnectEdge,\n            onConnectStart,\n            onConnectEnd,\n            onReconnectEnd: _onReconnectEnd,\n            updateConnection,\n            getTransform: ()=>store.getState().transform,\n            getFromHandle: ()=>store.getState().connection.fromHandle\n        });\n    };\n    const onReconnectSourceMouseDown = (event)=>handleEdgeUpdater(event, {\n            nodeId: edge.target,\n            id: edge.targetHandle ?? null,\n            type: 'target'\n        });\n    const onReconnectTargetMouseDown = (event)=>handleEdgeUpdater(event, {\n            nodeId: edge.source,\n            id: edge.sourceHandle ?? null,\n            type: 'source'\n        });\n    const onReconnectMouseEnter = ()=>setUpdateHover(true);\n    const onReconnectMouseOut = ()=>setUpdateHover(false);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            (isReconnectable === true || isReconnectable === 'source') && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EdgeAnchor, {\n                position: sourcePosition,\n                centerX: sourceX,\n                centerY: sourceY,\n                radius: reconnectRadius,\n                onMouseDown: onReconnectSourceMouseDown,\n                onMouseEnter: onReconnectMouseEnter,\n                onMouseOut: onReconnectMouseOut,\n                type: \"source\"\n            }),\n            (isReconnectable === true || isReconnectable === 'target') && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EdgeAnchor, {\n                position: targetPosition,\n                centerX: targetX,\n                centerY: targetY,\n                radius: reconnectRadius,\n                onMouseDown: onReconnectTargetMouseDown,\n                onMouseEnter: onReconnectMouseEnter,\n                onMouseOut: onReconnectMouseOut,\n                type: \"target\"\n            })\n        ]\n    });\n}\nfunction EdgeWrapper({ id, edgesFocusable, edgesReconnectable, elementsSelectable, onClick, onDoubleClick, onContextMenu, onMouseEnter, onMouseMove, onMouseLeave, reconnectRadius, onReconnect, onReconnectStart, onReconnectEnd, rfId, edgeTypes, noPanClassName, onError, disableKeyboardA11y }) {\n    let edge = useStore({\n        \"EdgeWrapper.useStore[edge]\": (s)=>s.edgeLookup.get(id)\n    }[\"EdgeWrapper.useStore[edge]\"]);\n    const defaultEdgeOptions = useStore({\n        \"EdgeWrapper.useStore[defaultEdgeOptions]\": (s)=>s.defaultEdgeOptions\n    }[\"EdgeWrapper.useStore[defaultEdgeOptions]\"]);\n    edge = defaultEdgeOptions ? {\n        ...defaultEdgeOptions,\n        ...edge\n    } : edge;\n    let edgeType = edge.type || 'default';\n    let EdgeComponent = edgeTypes?.[edgeType] || builtinEdgeTypes[edgeType];\n    if (EdgeComponent === undefined) {\n        onError?.('011', _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages['error011'](edgeType));\n        edgeType = 'default';\n        EdgeComponent = builtinEdgeTypes.default;\n    }\n    const isFocusable = !!(edge.focusable || edgesFocusable && typeof edge.focusable === 'undefined');\n    const isReconnectable = typeof onReconnect !== 'undefined' && (edge.reconnectable || edgesReconnectable && typeof edge.reconnectable === 'undefined');\n    const isSelectable = !!(edge.selectable || elementsSelectable && typeof edge.selectable === 'undefined');\n    const edgeRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [updateHover, setUpdateHover] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [reconnecting, setReconnecting] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const store = useStoreApi();\n    const { zIndex, sourceX, sourceY, targetX, targetY, sourcePosition, targetPosition } = useStore((0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"EdgeWrapper.useStore.useCallback\": (store)=>{\n            const sourceNode = store.nodeLookup.get(edge.source);\n            const targetNode = store.nodeLookup.get(edge.target);\n            if (!sourceNode || !targetNode) {\n                return {\n                    zIndex: edge.zIndex,\n                    ...nullPosition\n                };\n            }\n            const edgePosition = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getEdgePosition)({\n                id,\n                sourceNode,\n                targetNode,\n                sourceHandle: edge.sourceHandle || null,\n                targetHandle: edge.targetHandle || null,\n                connectionMode: store.connectionMode,\n                onError\n            });\n            const zIndex = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getElevatedEdgeZIndex)({\n                selected: edge.selected,\n                zIndex: edge.zIndex,\n                sourceNode,\n                targetNode,\n                elevateOnSelect: store.elevateEdgesOnSelect\n            });\n            return {\n                zIndex,\n                ...edgePosition || nullPosition\n            };\n        }\n    }[\"EdgeWrapper.useStore.useCallback\"], [\n        edge.source,\n        edge.target,\n        edge.sourceHandle,\n        edge.targetHandle,\n        edge.selected,\n        edge.zIndex\n    ]), zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const markerStartUrl = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"EdgeWrapper.useMemo[markerStartUrl]\": ()=>edge.markerStart ? `url('#${(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getMarkerId)(edge.markerStart, rfId)}')` : undefined\n    }[\"EdgeWrapper.useMemo[markerStartUrl]\"], [\n        edge.markerStart,\n        rfId\n    ]);\n    const markerEndUrl = (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"EdgeWrapper.useMemo[markerEndUrl]\": ()=>edge.markerEnd ? `url('#${(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getMarkerId)(edge.markerEnd, rfId)}')` : undefined\n    }[\"EdgeWrapper.useMemo[markerEndUrl]\"], [\n        edge.markerEnd,\n        rfId\n    ]);\n    if (edge.hidden || sourceX === null || sourceY === null || targetX === null || targetY === null) {\n        return null;\n    }\n    const onEdgeClick = (event)=>{\n        const { addSelectedEdges, unselectNodesAndEdges, multiSelectionActive } = store.getState();\n        if (isSelectable) {\n            store.setState({\n                nodesSelectionActive: false\n            });\n            if (edge.selected && multiSelectionActive) {\n                unselectNodesAndEdges({\n                    nodes: [],\n                    edges: [\n                        edge\n                    ]\n                });\n                edgeRef.current?.blur();\n            } else {\n                addSelectedEdges([\n                    id\n                ]);\n            }\n        }\n        if (onClick) {\n            onClick(event, edge);\n        }\n    };\n    const onEdgeDoubleClick = onDoubleClick ? (event)=>{\n        onDoubleClick(event, {\n            ...edge\n        });\n    } : undefined;\n    const onEdgeContextMenu = onContextMenu ? (event)=>{\n        onContextMenu(event, {\n            ...edge\n        });\n    } : undefined;\n    const onEdgeMouseEnter = onMouseEnter ? (event)=>{\n        onMouseEnter(event, {\n            ...edge\n        });\n    } : undefined;\n    const onEdgeMouseMove = onMouseMove ? (event)=>{\n        onMouseMove(event, {\n            ...edge\n        });\n    } : undefined;\n    const onEdgeMouseLeave = onMouseLeave ? (event)=>{\n        onMouseLeave(event, {\n            ...edge\n        });\n    } : undefined;\n    const onKeyDown = (event)=>{\n        if (!disableKeyboardA11y && _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.elementSelectionKeys.includes(event.key) && isSelectable) {\n            const { unselectNodesAndEdges, addSelectedEdges } = store.getState();\n            const unselect = event.key === 'Escape';\n            if (unselect) {\n                edgeRef.current?.blur();\n                unselectNodesAndEdges({\n                    edges: [\n                        edge\n                    ]\n                });\n            } else {\n                addSelectedEdges([\n                    id\n                ]);\n            }\n        }\n    };\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n        style: {\n            zIndex\n        },\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"g\", {\n            className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n                'react-flow__edge',\n                `react-flow__edge-${edgeType}`,\n                edge.className,\n                noPanClassName,\n                {\n                    selected: edge.selected,\n                    animated: edge.animated,\n                    inactive: !isSelectable && !onClick,\n                    updating: updateHover,\n                    selectable: isSelectable\n                }\n            ]),\n            onClick: onEdgeClick,\n            onDoubleClick: onEdgeDoubleClick,\n            onContextMenu: onEdgeContextMenu,\n            onMouseEnter: onEdgeMouseEnter,\n            onMouseMove: onEdgeMouseMove,\n            onMouseLeave: onEdgeMouseLeave,\n            onKeyDown: isFocusable ? onKeyDown : undefined,\n            tabIndex: isFocusable ? 0 : undefined,\n            role: isFocusable ? 'button' : 'img',\n            \"data-id\": id,\n            \"data-testid\": `rf__edge-${id}`,\n            \"aria-label\": edge.ariaLabel === null ? undefined : edge.ariaLabel || `Edge from ${edge.source} to ${edge.target}`,\n            \"aria-describedby\": isFocusable ? `${ARIA_EDGE_DESC_KEY}-${rfId}` : undefined,\n            ref: edgeRef,\n            children: [\n                !reconnecting && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EdgeComponent, {\n                    id: id,\n                    source: edge.source,\n                    target: edge.target,\n                    type: edge.type,\n                    selected: edge.selected,\n                    animated: edge.animated,\n                    selectable: isSelectable,\n                    deletable: edge.deletable ?? true,\n                    label: edge.label,\n                    labelStyle: edge.labelStyle,\n                    labelShowBg: edge.labelShowBg,\n                    labelBgStyle: edge.labelBgStyle,\n                    labelBgPadding: edge.labelBgPadding,\n                    labelBgBorderRadius: edge.labelBgBorderRadius,\n                    sourceX: sourceX,\n                    sourceY: sourceY,\n                    targetX: targetX,\n                    targetY: targetY,\n                    sourcePosition: sourcePosition,\n                    targetPosition: targetPosition,\n                    data: edge.data,\n                    style: edge.style,\n                    sourceHandleId: edge.sourceHandle,\n                    targetHandleId: edge.targetHandle,\n                    markerStart: markerStartUrl,\n                    markerEnd: markerEndUrl,\n                    pathOptions: 'pathOptions' in edge ? edge.pathOptions : undefined,\n                    interactionWidth: edge.interactionWidth\n                }),\n                isReconnectable && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EdgeUpdateAnchors, {\n                    edge: edge,\n                    isReconnectable: isReconnectable,\n                    reconnectRadius: reconnectRadius,\n                    onReconnect: onReconnect,\n                    onReconnectStart: onReconnectStart,\n                    onReconnectEnd: onReconnectEnd,\n                    sourceX: sourceX,\n                    sourceY: sourceY,\n                    targetX: targetX,\n                    targetY: targetY,\n                    sourcePosition: sourcePosition,\n                    targetPosition: targetPosition,\n                    setUpdateHover: setUpdateHover,\n                    setReconnecting: setReconnecting\n                })\n            ]\n        })\n    });\n}\nconst selector$a = (s)=>({\n        edgesFocusable: s.edgesFocusable,\n        edgesReconnectable: s.edgesReconnectable,\n        elementsSelectable: s.elementsSelectable,\n        connectionMode: s.connectionMode,\n        onError: s.onError\n    });\nfunction EdgeRendererComponent({ defaultMarkerColor, onlyRenderVisibleElements, rfId, edgeTypes, noPanClassName, onReconnect, onEdgeContextMenu, onEdgeMouseEnter, onEdgeMouseMove, onEdgeMouseLeave, onEdgeClick, reconnectRadius, onEdgeDoubleClick, onReconnectStart, onReconnectEnd, disableKeyboardA11y }) {\n    const { edgesFocusable, edgesReconnectable, elementsSelectable, onError } = useStore(selector$a, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const edgeIds = useVisibleEdgeIds(onlyRenderVisibleElements);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"div\", {\n        className: \"react-flow__edges\",\n        children: [\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(MarkerDefinitions$1, {\n                defaultColor: defaultMarkerColor,\n                rfId: rfId\n            }),\n            edgeIds.map((id)=>{\n                return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EdgeWrapper, {\n                    id: id,\n                    edgesFocusable: edgesFocusable,\n                    edgesReconnectable: edgesReconnectable,\n                    elementsSelectable: elementsSelectable,\n                    noPanClassName: noPanClassName,\n                    onReconnect: onReconnect,\n                    onContextMenu: onEdgeContextMenu,\n                    onMouseEnter: onEdgeMouseEnter,\n                    onMouseMove: onEdgeMouseMove,\n                    onMouseLeave: onEdgeMouseLeave,\n                    onClick: onEdgeClick,\n                    reconnectRadius: reconnectRadius,\n                    onDoubleClick: onEdgeDoubleClick,\n                    onReconnectStart: onReconnectStart,\n                    onReconnectEnd: onReconnectEnd,\n                    rfId: rfId,\n                    onError: onError,\n                    edgeTypes: edgeTypes,\n                    disableKeyboardA11y: disableKeyboardA11y\n                }, id);\n            })\n        ]\n    });\n}\nEdgeRendererComponent.displayName = 'EdgeRenderer';\nconst EdgeRenderer = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(EdgeRendererComponent);\nconst selector$9 = (s)=>`translate(${s.transform[0]}px,${s.transform[1]}px) scale(${s.transform[2]})`;\nfunction Viewport({ children }) {\n    const transform = useStore(selector$9);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: \"react-flow__viewport xyflow__viewport react-flow__container\",\n        style: {\n            transform\n        },\n        children: children\n    });\n}\n/**\n * Hook for calling onInit handler.\n *\n * @internal\n */ function useOnInitHandler(onInit) {\n    const rfInstance = useReactFlow();\n    const isInitialized = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useOnInitHandler.useEffect\": ()=>{\n            if (!isInitialized.current && rfInstance.viewportInitialized && onInit) {\n                setTimeout({\n                    \"useOnInitHandler.useEffect\": ()=>onInit(rfInstance)\n                }[\"useOnInitHandler.useEffect\"], 1);\n                isInitialized.current = true;\n            }\n        }\n    }[\"useOnInitHandler.useEffect\"], [\n        onInit,\n        rfInstance.viewportInitialized\n    ]);\n}\nconst selector$8 = (state)=>state.panZoom?.syncViewport;\n/**\n * Hook for syncing the viewport with the panzoom instance.\n *\n * @internal\n * @param viewport\n */ function useViewportSync(viewport) {\n    const syncViewport = useStore(selector$8);\n    const store = useStoreApi();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useViewportSync.useEffect\": ()=>{\n            if (viewport) {\n                syncViewport?.(viewport);\n                store.setState({\n                    transform: [\n                        viewport.x,\n                        viewport.y,\n                        viewport.zoom\n                    ]\n                });\n            }\n        }\n    }[\"useViewportSync.useEffect\"], [\n        viewport,\n        syncViewport\n    ]);\n    return null;\n}\nfunction storeSelector$1(s) {\n    return s.connection.inProgress ? {\n        ...s.connection,\n        to: (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.pointToRendererPoint)(s.connection.to, s.transform)\n    } : {\n        ...s.connection\n    };\n}\nfunction getSelector(connectionSelector) {\n    if (connectionSelector) {\n        const combinedSelector = (s)=>{\n            const connection = storeSelector$1(s);\n            return connectionSelector(connection);\n        };\n        return combinedSelector;\n    }\n    return storeSelector$1;\n}\n/**\n * The `useConnection` hook returns the current connection when there is an active\n * connection interaction. If no connection interaction is active, it returns null\n * for every property. A typical use case for this hook is to colorize handles\n * based on a certain condition (e.g. if the connection is valid or not).\n *\n * @public\n * @example\n *\n * ```tsx\n *import { useConnection } from '@xyflow/react';\n *\n *function App() {\n *  const connection = useConnection();\n *\n *  return (\n *    <div> {connection ? `Someone is trying to make a connection from ${connection.fromNode} to this one.` : 'There are currently no incoming connections!'}\n *\n *   </div>\n *   );\n * }\n * ```\n *\n * @returns ConnectionState\n */ function useConnection(connectionSelector) {\n    const combinedSelector = getSelector(connectionSelector);\n    return useStore(combinedSelector, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n}\nconst selector$7 = (s)=>({\n        nodesConnectable: s.nodesConnectable,\n        isValid: s.connection.isValid,\n        inProgress: s.connection.inProgress,\n        width: s.width,\n        height: s.height\n    });\nfunction ConnectionLineWrapper({ containerStyle, style, type, component }) {\n    const { nodesConnectable, width, height, isValid, inProgress } = useStore(selector$7, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const renderConnection = !!(width && nodesConnectable && inProgress);\n    if (!renderConnection) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n        style: containerStyle,\n        width: width,\n        height: height,\n        className: \"react-flow__connectionline react-flow__container\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"g\", {\n            className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n                'react-flow__connection',\n                (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getConnectionStatus)(isValid)\n            ]),\n            children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ConnectionLine, {\n                style: style,\n                type: type,\n                CustomComponent: component,\n                isValid: isValid\n            })\n        })\n    });\n}\nconst ConnectionLine = ({ style, type = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionLineType.Bezier, CustomComponent, isValid })=>{\n    const { inProgress, from, fromNode, fromHandle, fromPosition, to, toNode, toHandle, toPosition } = useConnection();\n    if (!inProgress) {\n        return;\n    }\n    if (CustomComponent) {\n        return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(CustomComponent, {\n            connectionLineType: type,\n            connectionLineStyle: style,\n            fromNode: fromNode,\n            fromHandle: fromHandle,\n            fromX: from.x,\n            fromY: from.y,\n            toX: to.x,\n            toY: to.y,\n            fromPosition: fromPosition,\n            toPosition: toPosition,\n            connectionStatus: (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getConnectionStatus)(isValid),\n            toNode: toNode,\n            toHandle: toHandle\n        });\n    }\n    let path = '';\n    const pathParams = {\n        sourceX: from.x,\n        sourceY: from.y,\n        sourcePosition: fromPosition,\n        targetX: to.x,\n        targetY: to.y,\n        targetPosition: toPosition\n    };\n    switch(type){\n        case _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionLineType.Bezier:\n            [path] = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getBezierPath)(pathParams);\n            break;\n        case _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionLineType.SimpleBezier:\n            [path] = getSimpleBezierPath(pathParams);\n            break;\n        case _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionLineType.Step:\n            [path] = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getSmoothStepPath)({\n                ...pathParams,\n                borderRadius: 0\n            });\n            break;\n        case _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionLineType.SmoothStep:\n            [path] = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getSmoothStepPath)(pathParams);\n            break;\n        default:\n            [path] = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getStraightPath)(pathParams);\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n        d: path,\n        fill: \"none\",\n        className: \"react-flow__connection-path\",\n        style: style\n    });\n};\nConnectionLine.displayName = 'ConnectionLine';\nconst emptyTypes = {};\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction useNodeOrEdgeTypesWarning(nodeOrEdgeTypes = emptyTypes) {\n    const typesRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(nodeOrEdgeTypes);\n    const store = useStoreApi();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useNodeOrEdgeTypesWarning.useEffect\": ()=>{\n            if (true) {\n                const usedKeys = new Set([\n                    ...Object.keys(typesRef.current),\n                    ...Object.keys(nodeOrEdgeTypes)\n                ]);\n                for (const key of usedKeys){\n                    if (typesRef.current[key] !== nodeOrEdgeTypes[key]) {\n                        store.getState().onError?.('002', _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages['error002']());\n                        break;\n                    }\n                }\n                typesRef.current = nodeOrEdgeTypes;\n            }\n        }\n    }[\"useNodeOrEdgeTypesWarning.useEffect\"], [\n        nodeOrEdgeTypes\n    ]);\n}\nfunction useStylesLoadedWarning() {\n    const store = useStoreApi();\n    const checked = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(false);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useStylesLoadedWarning.useEffect\": ()=>{\n            if (true) {\n                if (!checked.current) {\n                    const pane = document.querySelector('.react-flow__pane');\n                    if (pane && !(window.getComputedStyle(pane).zIndex === '1')) {\n                        store.getState().onError?.('013', _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages['error013']('react'));\n                    }\n                    checked.current = true;\n                }\n            }\n        }\n    }[\"useStylesLoadedWarning.useEffect\"], []);\n}\nfunction GraphViewComponent({ nodeTypes, edgeTypes, onInit, onNodeClick, onEdgeClick, onNodeDoubleClick, onEdgeDoubleClick, onNodeMouseEnter, onNodeMouseMove, onNodeMouseLeave, onNodeContextMenu, onSelectionContextMenu, onSelectionStart, onSelectionEnd, connectionLineType, connectionLineStyle, connectionLineComponent, connectionLineContainerStyle, selectionKeyCode, selectionOnDrag, selectionMode, multiSelectionKeyCode, panActivationKeyCode, zoomActivationKeyCode, deleteKeyCode, onlyRenderVisibleElements, elementsSelectable, defaultViewport, translateExtent, minZoom, maxZoom, preventScrolling, defaultMarkerColor, zoomOnScroll, zoomOnPinch, panOnScroll, panOnScrollSpeed, panOnScrollMode, zoomOnDoubleClick, panOnDrag, onPaneClick, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, onPaneScroll, onPaneContextMenu, paneClickDistance, nodeClickDistance, onEdgeContextMenu, onEdgeMouseEnter, onEdgeMouseMove, onEdgeMouseLeave, reconnectRadius, onReconnect, onReconnectStart, onReconnectEnd, noDragClassName, noWheelClassName, noPanClassName, disableKeyboardA11y, nodeExtent, rfId, viewport, onViewportChange }) {\n    useNodeOrEdgeTypesWarning(nodeTypes);\n    useNodeOrEdgeTypesWarning(edgeTypes);\n    useStylesLoadedWarning();\n    useOnInitHandler(onInit);\n    useViewportSync(viewport);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(FlowRenderer, {\n        onPaneClick: onPaneClick,\n        onPaneMouseEnter: onPaneMouseEnter,\n        onPaneMouseMove: onPaneMouseMove,\n        onPaneMouseLeave: onPaneMouseLeave,\n        onPaneContextMenu: onPaneContextMenu,\n        onPaneScroll: onPaneScroll,\n        paneClickDistance: paneClickDistance,\n        deleteKeyCode: deleteKeyCode,\n        selectionKeyCode: selectionKeyCode,\n        selectionOnDrag: selectionOnDrag,\n        selectionMode: selectionMode,\n        onSelectionStart: onSelectionStart,\n        onSelectionEnd: onSelectionEnd,\n        multiSelectionKeyCode: multiSelectionKeyCode,\n        panActivationKeyCode: panActivationKeyCode,\n        zoomActivationKeyCode: zoomActivationKeyCode,\n        elementsSelectable: elementsSelectable,\n        zoomOnScroll: zoomOnScroll,\n        zoomOnPinch: zoomOnPinch,\n        zoomOnDoubleClick: zoomOnDoubleClick,\n        panOnScroll: panOnScroll,\n        panOnScrollSpeed: panOnScrollSpeed,\n        panOnScrollMode: panOnScrollMode,\n        panOnDrag: panOnDrag,\n        defaultViewport: defaultViewport,\n        translateExtent: translateExtent,\n        minZoom: minZoom,\n        maxZoom: maxZoom,\n        onSelectionContextMenu: onSelectionContextMenu,\n        preventScrolling: preventScrolling,\n        noDragClassName: noDragClassName,\n        noWheelClassName: noWheelClassName,\n        noPanClassName: noPanClassName,\n        disableKeyboardA11y: disableKeyboardA11y,\n        onViewportChange: onViewportChange,\n        isControlledViewport: !!viewport,\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(Viewport, {\n            children: [\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(EdgeRenderer, {\n                    edgeTypes: edgeTypes,\n                    onEdgeClick: onEdgeClick,\n                    onEdgeDoubleClick: onEdgeDoubleClick,\n                    onReconnect: onReconnect,\n                    onReconnectStart: onReconnectStart,\n                    onReconnectEnd: onReconnectEnd,\n                    onlyRenderVisibleElements: onlyRenderVisibleElements,\n                    onEdgeContextMenu: onEdgeContextMenu,\n                    onEdgeMouseEnter: onEdgeMouseEnter,\n                    onEdgeMouseMove: onEdgeMouseMove,\n                    onEdgeMouseLeave: onEdgeMouseLeave,\n                    reconnectRadius: reconnectRadius,\n                    defaultMarkerColor: defaultMarkerColor,\n                    noPanClassName: noPanClassName,\n                    disableKeyboardA11y: disableKeyboardA11y,\n                    rfId: rfId\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ConnectionLineWrapper, {\n                    style: connectionLineStyle,\n                    type: connectionLineType,\n                    component: connectionLineComponent,\n                    containerStyle: connectionLineContainerStyle\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n                    className: \"react-flow__edgelabel-renderer\"\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeRenderer, {\n                    nodeTypes: nodeTypes,\n                    onNodeClick: onNodeClick,\n                    onNodeDoubleClick: onNodeDoubleClick,\n                    onNodeMouseEnter: onNodeMouseEnter,\n                    onNodeMouseMove: onNodeMouseMove,\n                    onNodeMouseLeave: onNodeMouseLeave,\n                    onNodeContextMenu: onNodeContextMenu,\n                    nodeClickDistance: nodeClickDistance,\n                    onlyRenderVisibleElements: onlyRenderVisibleElements,\n                    noPanClassName: noPanClassName,\n                    noDragClassName: noDragClassName,\n                    disableKeyboardA11y: disableKeyboardA11y,\n                    nodeExtent: nodeExtent,\n                    rfId: rfId\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n                    className: \"react-flow__viewport-portal\"\n                })\n            ]\n        })\n    });\n}\nGraphViewComponent.displayName = 'GraphView';\nconst GraphView = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(GraphViewComponent);\nconst getInitialState = ({ nodes, edges, defaultNodes, defaultEdges, width, height, fitView, nodeOrigin, nodeExtent } = {})=>{\n    const nodeLookup = new Map();\n    const parentLookup = new Map();\n    const connectionLookup = new Map();\n    const edgeLookup = new Map();\n    const storeEdges = defaultEdges ?? edges ?? [];\n    const storeNodes = defaultNodes ?? nodes ?? [];\n    const storeNodeOrigin = nodeOrigin ?? [\n        0,\n        0\n    ];\n    const storeNodeExtent = nodeExtent ?? _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.infiniteExtent;\n    (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.updateConnectionLookup)(connectionLookup, edgeLookup, storeEdges);\n    (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.adoptUserNodes)(storeNodes, nodeLookup, parentLookup, {\n        nodeOrigin: storeNodeOrigin,\n        nodeExtent: storeNodeExtent,\n        elevateNodesOnSelect: false\n    });\n    let transform = [\n        0,\n        0,\n        1\n    ];\n    if (fitView && width && height) {\n        const bounds = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getInternalNodesBounds)(nodeLookup, {\n            filter: (node)=>!!((node.width || node.initialWidth) && (node.height || node.initialHeight))\n        });\n        const { x, y, zoom } = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getViewportForBounds)(bounds, width, height, 0.5, 2, 0.1);\n        transform = [\n            x,\n            y,\n            zoom\n        ];\n    }\n    return {\n        rfId: '1',\n        width: 0,\n        height: 0,\n        transform,\n        nodes: storeNodes,\n        nodeLookup,\n        parentLookup,\n        edges: storeEdges,\n        edgeLookup,\n        connectionLookup,\n        onNodesChange: null,\n        onEdgesChange: null,\n        hasDefaultNodes: defaultNodes !== undefined,\n        hasDefaultEdges: defaultEdges !== undefined,\n        panZoom: null,\n        minZoom: 0.5,\n        maxZoom: 2,\n        translateExtent: _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.infiniteExtent,\n        nodeExtent: storeNodeExtent,\n        nodesSelectionActive: false,\n        userSelectionActive: false,\n        userSelectionRect: null,\n        connectionMode: _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionMode.Strict,\n        domNode: null,\n        paneDragging: false,\n        noPanClassName: 'nopan',\n        nodeOrigin: storeNodeOrigin,\n        nodeDragThreshold: 1,\n        snapGrid: [\n            15,\n            15\n        ],\n        snapToGrid: false,\n        nodesDraggable: true,\n        nodesConnectable: true,\n        nodesFocusable: true,\n        edgesFocusable: true,\n        edgesReconnectable: true,\n        elementsSelectable: true,\n        elevateNodesOnSelect: true,\n        elevateEdgesOnSelect: false,\n        fitViewOnInit: false,\n        fitViewDone: false,\n        fitViewOnInitOptions: undefined,\n        selectNodesOnDrag: true,\n        multiSelectionActive: false,\n        connection: {\n            ..._xyflow_system__WEBPACK_IMPORTED_MODULE_3__.initialConnection\n        },\n        connectionClickStartHandle: null,\n        connectOnClick: true,\n        ariaLiveMessage: '',\n        autoPanOnConnect: true,\n        autoPanOnNodeDrag: true,\n        autoPanSpeed: 15,\n        connectionRadius: 20,\n        onError: _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.devWarn,\n        isValidConnection: undefined,\n        onSelectionChangeHandlers: [],\n        lib: 'react',\n        debug: false\n    };\n};\nconst createStore = ({ nodes, edges, defaultNodes, defaultEdges, width, height, fitView: fitView$1, nodeOrigin, nodeExtent })=>(0,zustand_traditional__WEBPACK_IMPORTED_MODULE_5__.createWithEqualityFn)((set, get)=>({\n            ...getInitialState({\n                nodes,\n                edges,\n                width,\n                height,\n                fitView: fitView$1,\n                nodeOrigin,\n                nodeExtent,\n                defaultNodes,\n                defaultEdges\n            }),\n            setNodes: (nodes)=>{\n                const { nodeLookup, parentLookup, nodeOrigin, elevateNodesOnSelect } = get();\n                /*\n         * setNodes() is called exclusively in response to user actions:\n         * - either when the `<ReactFlow nodes>` prop is updated in the controlled ReactFlow setup,\n         * - or when the user calls something like `reactFlowInstance.setNodes()` in an uncontrolled ReactFlow setup.\n         *\n         * When this happens, we take the note objects passed by the user and extend them with fields\n         * relevant for internal React Flow operations.\n         */ (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.adoptUserNodes)(nodes, nodeLookup, parentLookup, {\n                    nodeOrigin,\n                    nodeExtent,\n                    elevateNodesOnSelect,\n                    checkEquality: true\n                });\n                set({\n                    nodes\n                });\n            },\n            setEdges: (edges)=>{\n                const { connectionLookup, edgeLookup } = get();\n                (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.updateConnectionLookup)(connectionLookup, edgeLookup, edges);\n                set({\n                    edges\n                });\n            },\n            setDefaultNodesAndEdges: (nodes, edges)=>{\n                if (nodes) {\n                    const { setNodes } = get();\n                    setNodes(nodes);\n                    set({\n                        hasDefaultNodes: true\n                    });\n                }\n                if (edges) {\n                    const { setEdges } = get();\n                    setEdges(edges);\n                    set({\n                        hasDefaultEdges: true\n                    });\n                }\n            },\n            /*\n     * Every node gets registerd at a ResizeObserver. Whenever a node\n     * changes its dimensions, this function is called to measure the\n     * new dimensions and update the nodes.\n     */ updateNodeInternals: (updates, params = {\n                triggerFitView: true\n            })=>{\n                const { triggerNodeChanges, nodeLookup, parentLookup, fitViewOnInit, fitViewDone, fitViewOnInitOptions, domNode, nodeOrigin, nodeExtent, debug, fitViewSync } = get();\n                const { changes, updatedInternals } = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.updateNodeInternals)(updates, nodeLookup, parentLookup, domNode, nodeOrigin, nodeExtent);\n                if (!updatedInternals) {\n                    return;\n                }\n                (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.updateAbsolutePositions)(nodeLookup, parentLookup, {\n                    nodeOrigin,\n                    nodeExtent\n                });\n                if (params.triggerFitView) {\n                    // we call fitView once initially after all dimensions are set\n                    let nextFitViewDone = fitViewDone;\n                    if (!fitViewDone && fitViewOnInit) {\n                        nextFitViewDone = fitViewSync({\n                            ...fitViewOnInitOptions,\n                            nodes: fitViewOnInitOptions?.nodes\n                        });\n                    }\n                    /*\n             * here we are cirmumventing the onNodesChange handler\n             * in order to be able to display nodes even if the user\n             * has not provided an onNodesChange handler.\n             * Nodes are only rendered if they have a width and height\n             * attribute which they get from this handler.\n             */ set({\n                        fitViewDone: nextFitViewDone\n                    });\n                } else {\n                    // we always want to trigger useStore calls whenever updateNodeInternals is called\n                    set({});\n                }\n                if (changes?.length > 0) {\n                    if (debug) {\n                        console.log('React Flow: trigger node changes', changes);\n                    }\n                    triggerNodeChanges?.(changes);\n                }\n            },\n            updateNodePositions: (nodeDragItems, dragging = false)=>{\n                const parentExpandChildren = [];\n                const changes = [];\n                const { nodeLookup, triggerNodeChanges } = get();\n                for (const [id, dragItem] of nodeDragItems){\n                    // we are using the nodelookup to be sure to use the current expandParent and parentId value\n                    const node = nodeLookup.get(id);\n                    const expandParent = !!(node?.expandParent && node?.parentId && dragItem?.position);\n                    const change = {\n                        id,\n                        type: 'position',\n                        position: expandParent ? {\n                            x: Math.max(0, dragItem.position.x),\n                            y: Math.max(0, dragItem.position.y)\n                        } : dragItem.position,\n                        dragging\n                    };\n                    if (expandParent && node.parentId) {\n                        parentExpandChildren.push({\n                            id,\n                            parentId: node.parentId,\n                            rect: {\n                                ...dragItem.internals.positionAbsolute,\n                                width: dragItem.measured.width ?? 0,\n                                height: dragItem.measured.height ?? 0\n                            }\n                        });\n                    }\n                    changes.push(change);\n                }\n                if (parentExpandChildren.length > 0) {\n                    const { parentLookup, nodeOrigin } = get();\n                    const parentExpandChanges = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.handleExpandParent)(parentExpandChildren, nodeLookup, parentLookup, nodeOrigin);\n                    changes.push(...parentExpandChanges);\n                }\n                triggerNodeChanges(changes);\n            },\n            triggerNodeChanges: (changes)=>{\n                const { onNodesChange, setNodes, nodes, hasDefaultNodes, debug } = get();\n                if (changes?.length) {\n                    if (hasDefaultNodes) {\n                        const updatedNodes = applyNodeChanges(changes, nodes);\n                        setNodes(updatedNodes);\n                    }\n                    if (debug) {\n                        console.log('React Flow: trigger node changes', changes);\n                    }\n                    onNodesChange?.(changes);\n                }\n            },\n            triggerEdgeChanges: (changes)=>{\n                const { onEdgesChange, setEdges, edges, hasDefaultEdges, debug } = get();\n                if (changes?.length) {\n                    if (hasDefaultEdges) {\n                        const updatedEdges = applyEdgeChanges(changes, edges);\n                        setEdges(updatedEdges);\n                    }\n                    if (debug) {\n                        console.log('React Flow: trigger edge changes', changes);\n                    }\n                    onEdgesChange?.(changes);\n                }\n            },\n            addSelectedNodes: (selectedNodeIds)=>{\n                const { multiSelectionActive, edgeLookup, nodeLookup, triggerNodeChanges, triggerEdgeChanges } = get();\n                if (multiSelectionActive) {\n                    const nodeChanges = selectedNodeIds.map((nodeId)=>createSelectionChange(nodeId, true));\n                    triggerNodeChanges(nodeChanges);\n                    return;\n                }\n                triggerNodeChanges(getSelectionChanges(nodeLookup, new Set([\n                    ...selectedNodeIds\n                ]), true));\n                triggerEdgeChanges(getSelectionChanges(edgeLookup));\n            },\n            addSelectedEdges: (selectedEdgeIds)=>{\n                const { multiSelectionActive, edgeLookup, nodeLookup, triggerNodeChanges, triggerEdgeChanges } = get();\n                if (multiSelectionActive) {\n                    const changedEdges = selectedEdgeIds.map((edgeId)=>createSelectionChange(edgeId, true));\n                    triggerEdgeChanges(changedEdges);\n                    return;\n                }\n                triggerEdgeChanges(getSelectionChanges(edgeLookup, new Set([\n                    ...selectedEdgeIds\n                ])));\n                triggerNodeChanges(getSelectionChanges(nodeLookup, new Set(), true));\n            },\n            unselectNodesAndEdges: ({ nodes, edges } = {})=>{\n                const { edges: storeEdges, nodes: storeNodes, nodeLookup, triggerNodeChanges, triggerEdgeChanges } = get();\n                const nodesToUnselect = nodes ? nodes : storeNodes;\n                const edgesToUnselect = edges ? edges : storeEdges;\n                const nodeChanges = nodesToUnselect.map((n)=>{\n                    const internalNode = nodeLookup.get(n.id);\n                    if (internalNode) {\n                        /*\n                 * we need to unselect the internal node that was selected previously before we\n                 * send the change to the user to prevent it to be selected while dragging the new node\n                 */ internalNode.selected = false;\n                    }\n                    return createSelectionChange(n.id, false);\n                });\n                const edgeChanges = edgesToUnselect.map((edge)=>createSelectionChange(edge.id, false));\n                triggerNodeChanges(nodeChanges);\n                triggerEdgeChanges(edgeChanges);\n            },\n            setMinZoom: (minZoom)=>{\n                const { panZoom, maxZoom } = get();\n                panZoom?.setScaleExtent([\n                    minZoom,\n                    maxZoom\n                ]);\n                set({\n                    minZoom\n                });\n            },\n            setMaxZoom: (maxZoom)=>{\n                const { panZoom, minZoom } = get();\n                panZoom?.setScaleExtent([\n                    minZoom,\n                    maxZoom\n                ]);\n                set({\n                    maxZoom\n                });\n            },\n            setTranslateExtent: (translateExtent)=>{\n                get().panZoom?.setTranslateExtent(translateExtent);\n                set({\n                    translateExtent\n                });\n            },\n            setPaneClickDistance: (clickDistance)=>{\n                get().panZoom?.setClickDistance(clickDistance);\n            },\n            resetSelectedElements: ()=>{\n                const { edges, nodes, triggerNodeChanges, triggerEdgeChanges } = get();\n                const nodeChanges = nodes.reduce((res, node)=>node.selected ? [\n                        ...res,\n                        createSelectionChange(node.id, false)\n                    ] : res, []);\n                const edgeChanges = edges.reduce((res, edge)=>edge.selected ? [\n                        ...res,\n                        createSelectionChange(edge.id, false)\n                    ] : res, []);\n                triggerNodeChanges(nodeChanges);\n                triggerEdgeChanges(edgeChanges);\n            },\n            setNodeExtent: (nextNodeExtent)=>{\n                const { nodes, nodeLookup, parentLookup, nodeOrigin, elevateNodesOnSelect, nodeExtent } = get();\n                if (nextNodeExtent[0][0] === nodeExtent[0][0] && nextNodeExtent[0][1] === nodeExtent[0][1] && nextNodeExtent[1][0] === nodeExtent[1][0] && nextNodeExtent[1][1] === nodeExtent[1][1]) {\n                    return;\n                }\n                (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.adoptUserNodes)(nodes, nodeLookup, parentLookup, {\n                    nodeOrigin,\n                    nodeExtent: nextNodeExtent,\n                    elevateNodesOnSelect,\n                    checkEquality: false\n                });\n                set({\n                    nodeExtent: nextNodeExtent\n                });\n            },\n            panBy: (delta)=>{\n                const { transform, width, height, panZoom, translateExtent } = get();\n                return (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.panBy)({\n                    delta,\n                    panZoom,\n                    transform,\n                    translateExtent,\n                    width,\n                    height\n                });\n            },\n            fitView: (options)=>{\n                const { panZoom, width, height, minZoom, maxZoom, nodeLookup } = get();\n                if (!panZoom) {\n                    return Promise.resolve(false);\n                }\n                const fitViewNodes = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getFitViewNodes)(nodeLookup, options);\n                return (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.fitView)({\n                    nodes: fitViewNodes,\n                    width,\n                    height,\n                    panZoom,\n                    minZoom,\n                    maxZoom\n                }, options);\n            },\n            /*\n     * we can't call an asnychronous function in updateNodeInternals\n     * for that we created this sync version of fitView\n     */ fitViewSync: (options)=>{\n                const { panZoom, width, height, minZoom, maxZoom, nodeLookup } = get();\n                if (!panZoom) {\n                    return false;\n                }\n                const fitViewNodes = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getFitViewNodes)(nodeLookup, options);\n                (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.fitView)({\n                    nodes: fitViewNodes,\n                    width,\n                    height,\n                    panZoom,\n                    minZoom,\n                    maxZoom\n                }, options);\n                return fitViewNodes.size > 0;\n            },\n            cancelConnection: ()=>{\n                set({\n                    connection: {\n                        ..._xyflow_system__WEBPACK_IMPORTED_MODULE_3__.initialConnection\n                    }\n                });\n            },\n            updateConnection: (connection)=>{\n                set({\n                    connection\n                });\n            },\n            reset: ()=>set({\n                    ...getInitialState()\n                })\n        }), Object.is);\n/**\n * The `<ReactFlowProvider />` component is a [context provider](https://react.dev/learn/passing-data-deeply-with-context#)\n * that makes it possible to access a flow's internal state outside of the\n * [`<ReactFlow />`](/api-reference/react-flow) component. Many of the hooks we\n * provide rely on this component to work.\n * @public\n *\n * @example\n * ```tsx\n *import { ReactFlow, ReactFlowProvider, useNodes } from '@xyflow/react'\n *\n *export default function Flow() {\n *  return (\n *    <ReactFlowProvider>\n *      <ReactFlow nodes={...} edges={...} />\n *      <Sidebar />\n *    </ReactFlowProvider>\n *  );\n *}\n *\n *function Sidebar() {\n *  // This hook will only work if the component it's used in is a child of a\n *  // <ReactFlowProvider />.\n *  const nodes = useNodes()\n *\n *  return <aside>do something with nodes</aside>;\n *}\n *```\n *\n * @remarks If you're using a router and want your flow's state to persist across routes,\n * it's vital that you place the `<ReactFlowProvider />` component _outside_ of\n * your router. If you have multiple flows on the same page you will need to use a separate\n * `<ReactFlowProvider />` for each flow.\n */ function ReactFlowProvider({ initialNodes: nodes, initialEdges: edges, defaultNodes, defaultEdges, initialWidth: width, initialHeight: height, fitView, nodeOrigin, nodeExtent, children }) {\n    const [store] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)({\n        \"ReactFlowProvider.useState\": ()=>createStore({\n                nodes,\n                edges,\n                defaultNodes,\n                defaultEdges,\n                width,\n                height,\n                fitView,\n                nodeOrigin,\n                nodeExtent\n            })\n    }[\"ReactFlowProvider.useState\"]);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Provider$1, {\n        value: store,\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(BatchProvider, {\n            children: children\n        })\n    });\n}\nfunction Wrapper({ children, nodes, edges, defaultNodes, defaultEdges, width, height, fitView, nodeOrigin, nodeExtent }) {\n    const isWrapped = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(StoreContext);\n    if (isWrapped) {\n        /*\n         * we need to wrap it with a fragment because it's not allowed for children to be a ReactNode\n         * https://github.com/DefinitelyTyped/DefinitelyTyped/issues/18051\n         */ return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n            children: children\n        });\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ReactFlowProvider, {\n        initialNodes: nodes,\n        initialEdges: edges,\n        defaultNodes: defaultNodes,\n        defaultEdges: defaultEdges,\n        initialWidth: width,\n        initialHeight: height,\n        fitView: fitView,\n        nodeOrigin: nodeOrigin,\n        nodeExtent: nodeExtent,\n        children: children\n    });\n}\nconst wrapperStyle = {\n    width: '100%',\n    height: '100%',\n    overflow: 'hidden',\n    position: 'relative',\n    zIndex: 0\n};\nfunction ReactFlow({ nodes, edges, defaultNodes, defaultEdges, className, nodeTypes, edgeTypes, onNodeClick, onEdgeClick, onInit, onMove, onMoveStart, onMoveEnd, onConnect, onConnectStart, onConnectEnd, onClickConnectStart, onClickConnectEnd, onNodeMouseEnter, onNodeMouseMove, onNodeMouseLeave, onNodeContextMenu, onNodeDoubleClick, onNodeDragStart, onNodeDrag, onNodeDragStop, onNodesDelete, onEdgesDelete, onDelete, onSelectionChange, onSelectionDragStart, onSelectionDrag, onSelectionDragStop, onSelectionContextMenu, onSelectionStart, onSelectionEnd, onBeforeDelete, connectionMode, connectionLineType = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ConnectionLineType.Bezier, connectionLineStyle, connectionLineComponent, connectionLineContainerStyle, deleteKeyCode = 'Backspace', selectionKeyCode = 'Shift', selectionOnDrag = false, selectionMode = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.SelectionMode.Full, panActivationKeyCode = 'Space', multiSelectionKeyCode = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isMacOs)() ? 'Meta' : 'Control', zoomActivationKeyCode = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.isMacOs)() ? 'Meta' : 'Control', snapToGrid, snapGrid, onlyRenderVisibleElements = false, selectNodesOnDrag, nodesDraggable, nodesConnectable, nodesFocusable, nodeOrigin = defaultNodeOrigin, edgesFocusable, edgesReconnectable, elementsSelectable = true, defaultViewport: defaultViewport$1 = defaultViewport, minZoom = 0.5, maxZoom = 2, translateExtent = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.infiniteExtent, preventScrolling = true, nodeExtent, defaultMarkerColor = '#b1b1b7', zoomOnScroll = true, zoomOnPinch = true, panOnScroll = false, panOnScrollSpeed = 0.5, panOnScrollMode = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.PanOnScrollMode.Free, zoomOnDoubleClick = true, panOnDrag = true, onPaneClick, onPaneMouseEnter, onPaneMouseMove, onPaneMouseLeave, onPaneScroll, onPaneContextMenu, paneClickDistance = 0, nodeClickDistance = 0, children, onReconnect, onReconnectStart, onReconnectEnd, onEdgeContextMenu, onEdgeDoubleClick, onEdgeMouseEnter, onEdgeMouseMove, onEdgeMouseLeave, reconnectRadius = 10, onNodesChange, onEdgesChange, noDragClassName = 'nodrag', noWheelClassName = 'nowheel', noPanClassName = 'nopan', fitView, fitViewOptions, connectOnClick, attributionPosition, proOptions, defaultEdgeOptions, elevateNodesOnSelect, elevateEdgesOnSelect, disableKeyboardA11y = false, autoPanOnConnect, autoPanOnNodeDrag, autoPanSpeed, connectionRadius, isValidConnection, onError, style, id, nodeDragThreshold, viewport, onViewportChange, width, height, colorMode = 'light', debug, onScroll, ...rest }, ref) {\n    const rfId = id || '1';\n    const colorModeClassName = useColorModeClass(colorMode);\n    // Undo scroll events, preventing viewport from shifting when nodes outside of it are focused\n    const wrapperOnScroll = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"ReactFlow.useCallback[wrapperOnScroll]\": (e)=>{\n            e.currentTarget.scrollTo({\n                top: 0,\n                left: 0,\n                behavior: 'instant'\n            });\n            onScroll?.(e);\n        }\n    }[\"ReactFlow.useCallback[wrapperOnScroll]\"], [\n        onScroll\n    ]);\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        \"data-testid\": \"rf__wrapper\",\n        ...rest,\n        onScroll: wrapperOnScroll,\n        style: {\n            ...style,\n            ...wrapperStyle\n        },\n        ref: ref,\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            'react-flow',\n            className,\n            colorModeClassName\n        ]),\n        id: id,\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(Wrapper, {\n            nodes: nodes,\n            edges: edges,\n            width: width,\n            height: height,\n            fitView: fitView,\n            nodeOrigin: nodeOrigin,\n            nodeExtent: nodeExtent,\n            children: [\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(GraphView, {\n                    onInit: onInit,\n                    onNodeClick: onNodeClick,\n                    onEdgeClick: onEdgeClick,\n                    onNodeMouseEnter: onNodeMouseEnter,\n                    onNodeMouseMove: onNodeMouseMove,\n                    onNodeMouseLeave: onNodeMouseLeave,\n                    onNodeContextMenu: onNodeContextMenu,\n                    onNodeDoubleClick: onNodeDoubleClick,\n                    nodeTypes: nodeTypes,\n                    edgeTypes: edgeTypes,\n                    connectionLineType: connectionLineType,\n                    connectionLineStyle: connectionLineStyle,\n                    connectionLineComponent: connectionLineComponent,\n                    connectionLineContainerStyle: connectionLineContainerStyle,\n                    selectionKeyCode: selectionKeyCode,\n                    selectionOnDrag: selectionOnDrag,\n                    selectionMode: selectionMode,\n                    deleteKeyCode: deleteKeyCode,\n                    multiSelectionKeyCode: multiSelectionKeyCode,\n                    panActivationKeyCode: panActivationKeyCode,\n                    zoomActivationKeyCode: zoomActivationKeyCode,\n                    onlyRenderVisibleElements: onlyRenderVisibleElements,\n                    defaultViewport: defaultViewport$1,\n                    translateExtent: translateExtent,\n                    minZoom: minZoom,\n                    maxZoom: maxZoom,\n                    preventScrolling: preventScrolling,\n                    zoomOnScroll: zoomOnScroll,\n                    zoomOnPinch: zoomOnPinch,\n                    zoomOnDoubleClick: zoomOnDoubleClick,\n                    panOnScroll: panOnScroll,\n                    panOnScrollSpeed: panOnScrollSpeed,\n                    panOnScrollMode: panOnScrollMode,\n                    panOnDrag: panOnDrag,\n                    onPaneClick: onPaneClick,\n                    onPaneMouseEnter: onPaneMouseEnter,\n                    onPaneMouseMove: onPaneMouseMove,\n                    onPaneMouseLeave: onPaneMouseLeave,\n                    onPaneScroll: onPaneScroll,\n                    onPaneContextMenu: onPaneContextMenu,\n                    paneClickDistance: paneClickDistance,\n                    nodeClickDistance: nodeClickDistance,\n                    onSelectionContextMenu: onSelectionContextMenu,\n                    onSelectionStart: onSelectionStart,\n                    onSelectionEnd: onSelectionEnd,\n                    onReconnect: onReconnect,\n                    onReconnectStart: onReconnectStart,\n                    onReconnectEnd: onReconnectEnd,\n                    onEdgeContextMenu: onEdgeContextMenu,\n                    onEdgeDoubleClick: onEdgeDoubleClick,\n                    onEdgeMouseEnter: onEdgeMouseEnter,\n                    onEdgeMouseMove: onEdgeMouseMove,\n                    onEdgeMouseLeave: onEdgeMouseLeave,\n                    reconnectRadius: reconnectRadius,\n                    defaultMarkerColor: defaultMarkerColor,\n                    noDragClassName: noDragClassName,\n                    noWheelClassName: noWheelClassName,\n                    noPanClassName: noPanClassName,\n                    rfId: rfId,\n                    disableKeyboardA11y: disableKeyboardA11y,\n                    nodeExtent: nodeExtent,\n                    viewport: viewport,\n                    onViewportChange: onViewportChange\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(StoreUpdater, {\n                    nodes: nodes,\n                    edges: edges,\n                    defaultNodes: defaultNodes,\n                    defaultEdges: defaultEdges,\n                    onConnect: onConnect,\n                    onConnectStart: onConnectStart,\n                    onConnectEnd: onConnectEnd,\n                    onClickConnectStart: onClickConnectStart,\n                    onClickConnectEnd: onClickConnectEnd,\n                    nodesDraggable: nodesDraggable,\n                    nodesConnectable: nodesConnectable,\n                    nodesFocusable: nodesFocusable,\n                    edgesFocusable: edgesFocusable,\n                    edgesReconnectable: edgesReconnectable,\n                    elementsSelectable: elementsSelectable,\n                    elevateNodesOnSelect: elevateNodesOnSelect,\n                    elevateEdgesOnSelect: elevateEdgesOnSelect,\n                    minZoom: minZoom,\n                    maxZoom: maxZoom,\n                    nodeExtent: nodeExtent,\n                    onNodesChange: onNodesChange,\n                    onEdgesChange: onEdgesChange,\n                    snapToGrid: snapToGrid,\n                    snapGrid: snapGrid,\n                    connectionMode: connectionMode,\n                    translateExtent: translateExtent,\n                    connectOnClick: connectOnClick,\n                    defaultEdgeOptions: defaultEdgeOptions,\n                    fitView: fitView,\n                    fitViewOptions: fitViewOptions,\n                    onNodesDelete: onNodesDelete,\n                    onEdgesDelete: onEdgesDelete,\n                    onDelete: onDelete,\n                    onNodeDragStart: onNodeDragStart,\n                    onNodeDrag: onNodeDrag,\n                    onNodeDragStop: onNodeDragStop,\n                    onSelectionDrag: onSelectionDrag,\n                    onSelectionDragStart: onSelectionDragStart,\n                    onSelectionDragStop: onSelectionDragStop,\n                    onMove: onMove,\n                    onMoveStart: onMoveStart,\n                    onMoveEnd: onMoveEnd,\n                    noPanClassName: noPanClassName,\n                    nodeOrigin: nodeOrigin,\n                    rfId: rfId,\n                    autoPanOnConnect: autoPanOnConnect,\n                    autoPanOnNodeDrag: autoPanOnNodeDrag,\n                    autoPanSpeed: autoPanSpeed,\n                    onError: onError,\n                    connectionRadius: connectionRadius,\n                    isValidConnection: isValidConnection,\n                    selectNodesOnDrag: selectNodesOnDrag,\n                    nodeDragThreshold: nodeDragThreshold,\n                    onBeforeDelete: onBeforeDelete,\n                    paneClickDistance: paneClickDistance,\n                    debug: debug\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(SelectionListener, {\n                    onSelectionChange: onSelectionChange\n                }),\n                children,\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Attribution, {\n                    proOptions: proOptions,\n                    position: attributionPosition\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(A11yDescriptions, {\n                    rfId: rfId,\n                    disableKeyboardA11y: disableKeyboardA11y\n                })\n            ]\n        })\n    });\n}\n/**\n * The `<ReactFlow />` component is the heart of your React Flow application.\n * It renders your nodes and edges and handles user interaction\n *\n * @public\n *\n * @example\n * ```tsx\n *import { ReactFlow } from '@xyflow/react'\n *\n *export default function Flow() {\n *  return (<ReactFlow\n *    nodes={...}\n *    edges={...}\n *    onNodesChange={...}\n *    ...\n *  />);\n *}\n *```\n */ var index = fixedForwardRef(ReactFlow);\nconst selector$6 = (s)=>s.domNode?.querySelector('.react-flow__edgelabel-renderer');\n/**\n * Edges are SVG-based. If you want to render more complex labels you can use the\n * `<EdgeLabelRenderer />` component to access a div based renderer. This component\n * is a portal that renders the label in a `<div />` that is positioned on top of\n * the edges. You can see an example usage of the component in the [edge label renderer](/examples/edges/edge-label-renderer) example.\n * @public\n *\n * @example\n *```jsx\n *import React from 'react';\n *import { getBezierPath, EdgeLabelRenderer, BaseEdge } from '@xyflow/react';\n *\n *export function CustomEdge({ id, data, ...props }) {\n *  const [edgePath, labelX, labelY] = getBezierPath(props);\n *\n *  return (\n *    <>\n *      <BaseEdge id={id} path={edgePath} />\n *      <EdgeLabelRenderer>\n *        <div\n *          style={{\n *            position: 'absolute',\n *            transform: `translate(-50%, -50%) translate(${labelX}px,${labelY}px)`,\n *            background: '#ffcc00',\n *            padding: 10,\n *        }}\n *          className=\"nodrag nopan\"\n *        >\n *         {data.label}\n *        </div>\n *      </EdgeLabelRenderer>\n *    </>\n *  );\n *};\n *```\n *\n * @remarks The `<EdgeLabelRenderer />` has no pointer events by default. If you want to\n * add mouse interactions you need to set the style `pointerEvents: all` and add\n * the `nopan` class on the label or the element you want to interact with.\n */ function EdgeLabelRenderer({ children }) {\n    const edgeLabelRenderer = useStore(selector$6);\n    if (!edgeLabelRenderer) {\n        return null;\n    }\n    return /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_4__.createPortal)(children, edgeLabelRenderer);\n}\nconst selector$5 = (s)=>s.domNode?.querySelector('.react-flow__viewport-portal');\n/**\n * The `<ViewportPortal />` component can be used to add components to the same viewport\n * of the flow where nodes and edges are rendered. This is useful when you want to render\n * your own components that are adhere to the same coordinate system as the nodes & edges\n * and are also affected by zooming and panning\n * @public\n * @example\n *\n * ```jsx\n *import React from 'react';\n *import { ViewportPortal } from '@xyflow/react';\n *\n *export default function () {\n *  return (\n *    <ViewportPortal>\n *      <div\n *        style={{ transform: 'translate(100px, 100px)', position: 'absolute' }}\n *      >\n *        This div is positioned at [100, 100] on the flow.\n *      </div>\n *    </ViewportPortal>\n *  );\n *}\n *```\n */ function ViewportPortal({ children }) {\n    const viewPortalDiv = useStore(selector$5);\n    if (!viewPortalDiv) {\n        return null;\n    }\n    return /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_4__.createPortal)(children, viewPortalDiv);\n}\n/**\n * When you programmatically add or remove handles to a node or update a node's\n *handle position, you need to let React Flow know about it using this hook. This\n *will update the internal dimensions of the node and properly reposition handles\n *on the canvas if necessary.\n *\n * @public\n * @returns function for updating node internals\n *\n * @example\n * ```jsx\n *import { useCallback, useState } from 'react';\n *import { Handle, useUpdateNodeInternals } from '@xyflow/react';\n *\n *export default function RandomHandleNode({ id }) {\n *  const updateNodeInternals = useUpdateNodeInternals();\n *  const [handleCount, setHandleCount] = useState(0);\n *  const randomizeHandleCount = useCallback(() => {\n *   setHandleCount(Math.floor(Math.random() * 10));\n *    updateNodeInternals(id);\n *  }, [id, updateNodeInternals]);\n *\n *  return (\n *    <>\n *      {Array.from({ length: handleCount }).map((_, index) => (\n *        <Handle\n *          key={index}\n *          type=\"target\"\n *          position=\"left\"\n *          id={`handle-${index}`}\n *        />\n *      ))}\n *\n *      <div>\n *        <button onClick={randomizeHandleCount}>Randomize handle count</button>\n *        <p>There are {handleCount} handles on this node.</p>\n *      </div>\n *    </>\n *  );\n *}\n *```\n * @remarks This hook can only be used in a component that is a child of a\n *{@link ReactFlowProvider} or a {@link ReactFlow} component.\n */ function useUpdateNodeInternals() {\n    const store = useStoreApi();\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"useUpdateNodeInternals.useCallback\": (id)=>{\n            const { domNode, updateNodeInternals } = store.getState();\n            const updateIds = Array.isArray(id) ? id : [\n                id\n            ];\n            const updates = new Map();\n            updateIds.forEach({\n                \"useUpdateNodeInternals.useCallback\": (updateId)=>{\n                    const nodeElement = domNode?.querySelector(`.react-flow__node[data-id=\"${updateId}\"]`);\n                    if (nodeElement) {\n                        updates.set(updateId, {\n                            id: updateId,\n                            nodeElement,\n                            force: true\n                        });\n                    }\n                }\n            }[\"useUpdateNodeInternals.useCallback\"]);\n            requestAnimationFrame({\n                \"useUpdateNodeInternals.useCallback\": ()=>updateNodeInternals(updates, {\n                        triggerFitView: false\n                    })\n            }[\"useUpdateNodeInternals.useCallback\"]);\n        }\n    }[\"useUpdateNodeInternals.useCallback\"], []);\n}\nconst nodesSelector = (state)=>state.nodes;\n/**\n * This hook returns an array of the current nodes. Components that use this hook\n * will re-render **whenever any node changes**, including when a node is selected\n * or moved.\n *\n * @public\n * @returns An array of nodes\n *\n * @example\n * ```jsx\n *import { useNodes } from '@xyflow/react';\n *\n *export default function() {\n *  const nodes = useNodes();\n *\n *  return <div>There are currently {nodes.length} nodes!</div>;\n *}\n *```\n */ function useNodes() {\n    const nodes = useStore(nodesSelector, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    return nodes;\n}\nconst edgesSelector = (state)=>state.edges;\n/**\n * This hook returns an array of the current edges. Components that use this hook\n * will re-render **whenever any edge changes**.\n *\n * @public\n * @returns An array of edges\n *\n * @example\n * ```tsx\n *import { useEdges } from '@xyflow/react';\n *\n *export default function () {\n *  const edges = useEdges();\n *\n *  return <div>There are currently {edges.length} edges!</div>;\n *}\n *```\n */ function useEdges() {\n    const edges = useStore(edgesSelector, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    return edges;\n}\nconst viewportSelector = (state)=>({\n        x: state.transform[0],\n        y: state.transform[1],\n        zoom: state.transform[2]\n    });\n/**\n * The `useViewport` hook is a convenient way to read the current state of the\n *{@link Viewport} in a component. Components that use this hook\n *will re-render **whenever the viewport changes**.\n *\n * @public\n * @returns The current viewport\n *\n * @example\n *\n *```jsx\n *import { useViewport } from '@xyflow/react';\n *\n *export default function ViewportDisplay() {\n *  const { x, y, zoom } = useViewport();\n *\n *  return (\n *    <div>\n *      <p>\n *        The viewport is currently at ({x}, {y}) and zoomed to {zoom}.\n *      </p>\n *    </div>\n *  );\n *}\n *```\n *\n * @remarks This hook can only be used in a component that is a child of a\n *{@link ReactFlowProvider} or a {@link ReactFlow} component.\n */ function useViewport() {\n    const viewport = useStore(viewportSelector, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    return viewport;\n}\n/**\n * This hook makes it easy to prototype a controlled flow where you manage the\n * state of nodes and edges outside the `ReactFlowInstance`. You can think of it\n * like React's `useState` hook with an additional helper callback.\n *\n * @public\n * @param initialNodes\n * @returns an array [nodes, setNodes, onNodesChange]\n * @example\n *\n *```tsx\n *import { ReactFlow, useNodesState, useEdgesState } from '@xyflow/react';\n *\n *const initialNodes = [];\n *const initialEdges = [];\n *\n *export default function () {\n *  const [nodes, setNodes, onNodesChange] = useNodesState(initialNodes);\n *  const [edges, setEdges, onEdgesChange] = useEdgesState(initialEdges);\n *\n *  return (\n *    <ReactFlow\n *      nodes={nodes}\n *      edges={edges}\n *      onNodesChange={onNodesChange}\n *      onEdgesChange={onEdgesChange}\n *    />\n *  );\n *}\n *```\n *\n * @remarks This hook was created to make prototyping easier and our documentation\n * examples clearer. Although it is OK to use this hook in production, in\n * practice you may want to use a more sophisticated state management solution\n * like Zustand {@link https://reactflow.dev/docs/guides/state-management/} instead.\n *\n */ function useNodesState(initialNodes) {\n    const [nodes, setNodes] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(initialNodes);\n    const onNodesChange = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"useNodesState.useCallback[onNodesChange]\": (changes)=>setNodes({\n                \"useNodesState.useCallback[onNodesChange]\": (nds)=>applyNodeChanges(changes, nds)\n            }[\"useNodesState.useCallback[onNodesChange]\"])\n    }[\"useNodesState.useCallback[onNodesChange]\"], []);\n    return [\n        nodes,\n        setNodes,\n        onNodesChange\n    ];\n}\n/**\n * This hook makes it easy to prototype a controlled flow where you manage the\n * state of nodes and edges outside the `ReactFlowInstance`. You can think of it\n * like React's `useState` hook with an additional helper callback.\n *\n * @public\n * @param initialEdges\n * @returns an array [edges, setEdges, onEdgesChange]\n * @example\n *\n *```tsx\n *import { ReactFlow, useNodesState, useEdgesState } from '@xyflow/react';\n *\n *const initialNodes = [];\n *const initialEdges = [];\n *\n *export default function () {\n *  const [nodes, setNodes, onNodesChange] = useNodesState(initialNodes);\n *  const [edges, setEdges, onEdgesChange] = useEdgesState(initialEdges);\n *\n *  return (\n *    <ReactFlow\n *      nodes={nodes}\n *      edges={edges}\n *      onNodesChange={onNodesChange}\n *      onEdgesChange={onEdgesChange}\n *    />\n *  );\n *}\n *```\n *\n * @remarks This hook was created to make prototyping easier and our documentation\n * examples clearer. Although it is OK to use this hook in production, in\n * practice you may want to use a more sophisticated state management solution\n * like Zustand {@link https://reactflow.dev/docs/guides/state-management/} instead.\n *\n */ function useEdgesState(initialEdges) {\n    const [edges, setEdges] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(initialEdges);\n    const onEdgesChange = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"useEdgesState.useCallback[onEdgesChange]\": (changes)=>setEdges({\n                \"useEdgesState.useCallback[onEdgesChange]\": (eds)=>applyEdgeChanges(changes, eds)\n            }[\"useEdgesState.useCallback[onEdgesChange]\"])\n    }[\"useEdgesState.useCallback[onEdgesChange]\"], []);\n    return [\n        edges,\n        setEdges,\n        onEdgesChange\n    ];\n}\n/**\n * The `useOnViewportChange` hook lets you listen for changes to the viewport such\n *as panning and zooming. You can provide a callback for each phase of a viewport\n *change: `onStart`, `onChange`, and `onEnd`.\n *\n * @public\n * @param params.onStart - gets called when the viewport starts changing\n * @param params.onChange - gets called when the viewport changes\n * @param params.onEnd - gets called when the viewport stops changing\n *\n * @example\n * ```jsx\n *import { useCallback } from 'react';\n *import { useOnViewportChange } from '@xyflow/react';\n *\n *function ViewportChangeLogger() {\n *  useOnViewportChange({\n *    onStart: (viewport: Viewport) => console.log('start', viewport),\n *    onChange: (viewport: Viewport) => console.log('change', viewport),\n *    onEnd: (viewport: Viewport) => console.log('end', viewport),\n *  });\n *\n *  return null;\n *}\n *```\n */ function useOnViewportChange({ onStart, onChange, onEnd }) {\n    const store = useStoreApi();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useOnViewportChange.useEffect\": ()=>{\n            store.setState({\n                onViewportChangeStart: onStart\n            });\n        }\n    }[\"useOnViewportChange.useEffect\"], [\n        onStart\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useOnViewportChange.useEffect\": ()=>{\n            store.setState({\n                onViewportChange: onChange\n            });\n        }\n    }[\"useOnViewportChange.useEffect\"], [\n        onChange\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useOnViewportChange.useEffect\": ()=>{\n            store.setState({\n                onViewportChangeEnd: onEnd\n            });\n        }\n    }[\"useOnViewportChange.useEffect\"], [\n        onEnd\n    ]);\n}\n/**\n * This hook lets you listen for changes to both node and edge selection. As the\n *name implies, the callback you provide will be called whenever the selection of\n *_either_ nodes or edges changes.\n *\n * @public\n * @param params.onChange - The handler to register\n *\n * @example\n * ```jsx\n *import { useState } from 'react';\n *import { ReactFlow, useOnSelectionChange } from '@xyflow/react';\n *\n *function SelectionDisplay() {\n *  const [selectedNodes, setSelectedNodes] = useState([]);\n *  const [selectedEdges, setSelectedEdges] = useState([]);\n *\n *  // the passed handler has to be memoized, otherwise the hook will not work correctly\n *  const onChange = useCallback(({ nodes, edges }) => {\n *    setSelectedNodes(nodes.map((node) => node.id));\n *    setSelectedEdges(edges.map((edge) => edge.id));\n *  }, []);\n *\n *  useOnSelectionChange({\n *    onChange,\n *  });\n *\n *  return (\n *    <div>\n *      <p>Selected nodes: {selectedNodes.join(', ')}</p>\n *      <p>Selected edges: {selectedEdges.join(', ')}</p>\n *    </div>\n *  );\n *}\n *```\n *\n * @remarks You need to memoize the passed `onChange` handler, otherwise the hook will not work correctly.\n */ function useOnSelectionChange({ onChange }) {\n    const store = useStoreApi();\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useOnSelectionChange.useEffect\": ()=>{\n            const nextOnSelectionChangeHandlers = [\n                ...store.getState().onSelectionChangeHandlers,\n                onChange\n            ];\n            store.setState({\n                onSelectionChangeHandlers: nextOnSelectionChangeHandlers\n            });\n            return ({\n                \"useOnSelectionChange.useEffect\": ()=>{\n                    const nextHandlers = store.getState().onSelectionChangeHandlers.filter({\n                        \"useOnSelectionChange.useEffect.nextHandlers\": (fn)=>fn !== onChange\n                    }[\"useOnSelectionChange.useEffect.nextHandlers\"]);\n                    store.setState({\n                        onSelectionChangeHandlers: nextHandlers\n                    });\n                }\n            })[\"useOnSelectionChange.useEffect\"];\n        }\n    }[\"useOnSelectionChange.useEffect\"], [\n        onChange\n    ]);\n}\nconst selector$4 = (options)=>(s)=>{\n        if (s.nodeLookup.size === 0) {\n            return false;\n        }\n        for (const [, { hidden, internals }] of s.nodeLookup){\n            if (options.includeHiddenNodes || !hidden) {\n                if (internals.handleBounds === undefined || !(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.nodeHasDimensions)(internals.userNode)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    };\n/**\n * This hook tells you whether all the nodes in a flow have been measured and given\n *a width and height. When you add a node to the flow, this hook will return\n *`false` and then `true` again once the node has been measured.\n *\n * @public\n * @param options.includeHiddenNodes - defaults to false\n * @returns boolean indicating whether all nodes are initialized\n *\n * @example\n * ```jsx\n *import { useReactFlow, useNodesInitialized } from '@xyflow/react';\n *import { useEffect, useState } from 'react';\n *\n *const options = {\n *  includeHiddenNodes: false,\n *};\n *\n *export default function useLayout() {\n *  const { getNodes } = useReactFlow();\n *  const nodesInitialized = useNodesInitialized(options);\n *  const [layoutedNodes, setLayoutedNodes] = useState(getNodes());\n *\n *  useEffect(() => {\n *    if (nodesInitialized) {\n *      setLayoutedNodes(yourLayoutingFunction(getNodes()));\n *    }\n *  }, [nodesInitialized]);\n *\n *  return layoutedNodes;\n *}\n *```\n */ function useNodesInitialized(options = {\n    includeHiddenNodes: false\n}) {\n    const initialized = useStore(selector$4(options));\n    return initialized;\n}\n/**\n * Hook to check if a <Handle /> is connected to another <Handle /> and get the connections.\n *\n * @public\n * @deprecated Use `useNodeConnections` instead.\n * @param param.type - handle type 'source' or 'target'\n * @param param.nodeId - node id - if not provided, the node id from the NodeIdContext is used\n * @param param.id - the handle id (this is only needed if the node has multiple handles of the same type)\n * @param param.onConnect - gets called when a connection is established\n * @param param.onDisconnect - gets called when a connection is removed\n * @returns an array with handle connections\n */ function useHandleConnections({ type, id, nodeId, onConnect, onDisconnect }) {\n    console.warn('[DEPRECATED] `useHandleConnections` is deprecated. Instead use `useNodeConnections` https://reactflow.dev/api-reference/hooks/useNodeConnections');\n    const _nodeId = useNodeId();\n    const currentNodeId = nodeId ?? _nodeId;\n    const prevConnections = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const connections = useStore({\n        \"useHandleConnections.useStore[connections]\": (state)=>state.connectionLookup.get(`${currentNodeId}-${type}${id ? `-${id}` : ''}`)\n    }[\"useHandleConnections.useStore[connections]\"], _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.areConnectionMapsEqual);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useHandleConnections.useEffect\": ()=>{\n            // @todo dicuss if onConnect/onDisconnect should be called when the component mounts/unmounts\n            if (prevConnections.current && prevConnections.current !== connections) {\n                const _connections = connections ?? new Map();\n                (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.handleConnectionChange)(prevConnections.current, _connections, onDisconnect);\n                (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.handleConnectionChange)(_connections, prevConnections.current, onConnect);\n            }\n            prevConnections.current = connections ?? new Map();\n        }\n    }[\"useHandleConnections.useEffect\"], [\n        connections,\n        onConnect,\n        onDisconnect\n    ]);\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"useHandleConnections.useMemo\": ()=>Array.from(connections?.values() ?? [])\n    }[\"useHandleConnections.useMemo\"], [\n        connections\n    ]);\n}\nconst error014 = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.errorMessages['error014']();\n/**\n * This hook returns an array of connections on a specific node, handle type ('source', 'target') or handle ID.\n *\n * @public\n * @param param.id - node id - optional if called inside a custom node\n * @param param.handleType - filter by handle type 'source' or 'target'\n * @param param.handleId - filter by handle id (this is only needed if the node has multiple handles of the same type)\n * @param param.onConnect - gets called when a connection is established\n * @param param.onDisconnect - gets called when a connection is removed\n * @returns an array with connections\n *\n * @example\n * ```jsx\n *import { useNodeConnections } from '@xyflow/react';\n *\n *export default function () {\n *  const connections = useNodeConnections({\n *    handleType: 'target',\n *    handleId: 'my-handle',\n *  });\n *\n *  return (\n *    <div>There are currently {connections.length} incoming connections!</div>\n *  );\n *}\n *```\n */ function useNodeConnections({ id, handleType, handleId, onConnect, onDisconnect } = {}) {\n    const nodeId = useNodeId();\n    const currentNodeId = id ?? nodeId;\n    if (!currentNodeId) {\n        throw new Error(error014);\n    }\n    const prevConnections = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const connections = useStore({\n        \"useNodeConnections.useStore[connections]\": (state)=>state.connectionLookup.get(`${currentNodeId}${handleType ? handleId ? `-${handleType}-${handleId}` : `-${handleType}` : ''}`)\n    }[\"useNodeConnections.useStore[connections]\"], _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.areConnectionMapsEqual);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"useNodeConnections.useEffect\": ()=>{\n            // @todo dicuss if onConnect/onDisconnect should be called when the component mounts/unmounts\n            if (prevConnections.current && prevConnections.current !== connections) {\n                const _connections = connections ?? new Map();\n                (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.handleConnectionChange)(prevConnections.current, _connections, onDisconnect);\n                (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.handleConnectionChange)(_connections, prevConnections.current, onConnect);\n            }\n            prevConnections.current = connections ?? new Map();\n        }\n    }[\"useNodeConnections.useEffect\"], [\n        connections,\n        onConnect,\n        onDisconnect\n    ]);\n    return (0,react__WEBPACK_IMPORTED_MODULE_1__.useMemo)({\n        \"useNodeConnections.useMemo\": ()=>Array.from(connections?.values() ?? [])\n    }[\"useNodeConnections.useMemo\"], [\n        connections\n    ]);\n}\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction useNodesData(nodeIds) {\n    const nodesData = useStore((0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"useNodesData.useStore[nodesData]\": (s)=>{\n            const data = [];\n            const isArrayOfIds = Array.isArray(nodeIds);\n            const _nodeIds = isArrayOfIds ? nodeIds : [\n                nodeIds\n            ];\n            for (const nodeId of _nodeIds){\n                const node = s.nodeLookup.get(nodeId);\n                if (node) {\n                    data.push({\n                        id: node.id,\n                        type: node.type,\n                        data: node.data\n                    });\n                }\n            }\n            return isArrayOfIds ? data : data[0] ?? null;\n        }\n    }[\"useNodesData.useStore[nodesData]\"], [\n        nodeIds\n    ]), _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.shallowNodeData);\n    return nodesData;\n}\n/**\n * This hook returns the internal representation of a specific node.\n * Components that use this hook will re-render **whenever the node changes**,\n * including when a node is selected or moved.\n *\n * @public\n * @param id - id of the node\n * @returns array with visible node ids\n *\n * @example\n * ```tsx\n *import { useInternalNode } from '@xyflow/react';\n *\n *export default function () {\n *  const internalNode = useInternalNode('node-1');\n *  const absolutePosition = internalNode.internals.positionAbsolute;\n *\n *  return (\n *    <div>\n *      The absolute position of the node is at:\n *      <p>x: {absolutePosition.x}</p>\n *      <p>y: {absolutePosition.y}</p>\n *    </div>\n *  );\n *}\n *```\n */ function useInternalNode(id) {\n    const node = useStore((0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"useInternalNode.useStore[node]\": (s)=>s.nodeLookup.get(id)\n    }[\"useInternalNode.useStore[node]\"], [\n        id\n    ]), zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    return node;\n}\nfunction LinePattern({ dimensions, lineWidth, variant, className }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n        strokeWidth: lineWidth,\n        d: `M${dimensions[0] / 2} 0 V${dimensions[1]} M0 ${dimensions[1] / 2} H${dimensions[0]}`,\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            'react-flow__background-pattern',\n            variant,\n            className\n        ])\n    });\n}\nfunction DotPattern({ radius, className }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"circle\", {\n        cx: radius,\n        cy: radius,\n        r: radius,\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            'react-flow__background-pattern',\n            'dots',\n            className\n        ])\n    });\n}\n/**\n * The three variants are exported as an enum for convenience. You can either import\n * the enum and use it like `BackgroundVariant.Lines` or you can use the raw string\n * value directly.\n * @public\n */ var BackgroundVariant;\n(function(BackgroundVariant) {\n    BackgroundVariant[\"Lines\"] = \"lines\";\n    BackgroundVariant[\"Dots\"] = \"dots\";\n    BackgroundVariant[\"Cross\"] = \"cross\";\n})(BackgroundVariant || (BackgroundVariant = {}));\nconst defaultSize = {\n    [BackgroundVariant.Dots]: 1,\n    [BackgroundVariant.Lines]: 1,\n    [BackgroundVariant.Cross]: 6\n};\nconst selector$3 = (s)=>({\n        transform: s.transform,\n        patternId: `pattern-${s.rfId}`\n    });\nfunction BackgroundComponent({ id, variant = BackgroundVariant.Dots, // only used for dots and cross\ngap = 20, // only used for lines and cross\nsize, lineWidth = 1, offset = 0, color, bgColor, style, className, patternClassName }) {\n    const ref = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const { transform, patternId } = useStore(selector$3, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const patternSize = size || defaultSize[variant];\n    const isDots = variant === BackgroundVariant.Dots;\n    const isCross = variant === BackgroundVariant.Cross;\n    const gapXY = Array.isArray(gap) ? gap : [\n        gap,\n        gap\n    ];\n    const scaledGap = [\n        gapXY[0] * transform[2] || 1,\n        gapXY[1] * transform[2] || 1\n    ];\n    const scaledSize = patternSize * transform[2];\n    const offsetXY = Array.isArray(offset) ? offset : [\n        offset,\n        offset\n    ];\n    const patternDimensions = isCross ? [\n        scaledSize,\n        scaledSize\n    ] : scaledGap;\n    const scaledOffset = [\n        offsetXY[0] * transform[2] || 1 + patternDimensions[0] / 2,\n        offsetXY[1] * transform[2] || 1 + patternDimensions[1] / 2\n    ];\n    const _patternId = `${patternId}${id ? id : ''}`;\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"svg\", {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            'react-flow__background',\n            className\n        ]),\n        style: {\n            ...style,\n            ...containerStyle,\n            '--xy-background-color-props': bgColor,\n            '--xy-background-pattern-color-props': color\n        },\n        ref: ref,\n        \"data-testid\": \"rf__background\",\n        children: [\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"pattern\", {\n                id: _patternId,\n                x: transform[0] % scaledGap[0],\n                y: transform[1] % scaledGap[1],\n                width: scaledGap[0],\n                height: scaledGap[1],\n                patternUnits: \"userSpaceOnUse\",\n                patternTransform: `translate(-${scaledOffset[0]},-${scaledOffset[1]})`,\n                children: isDots ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(DotPattern, {\n                    radius: scaledSize / 2,\n                    className: patternClassName\n                }) : (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(LinePattern, {\n                    dimensions: patternDimensions,\n                    lineWidth: lineWidth,\n                    variant: variant,\n                    className: patternClassName\n                })\n            }),\n            (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"rect\", {\n                x: \"0\",\n                y: \"0\",\n                width: \"100%\",\n                height: \"100%\",\n                fill: `url(#${_patternId})`\n            })\n        ]\n    });\n}\nBackgroundComponent.displayName = 'Background';\n/**\n * The `<Background />` component makes it convenient to render different types of backgrounds common in node-based UIs. It comes with three variants: lines, dots and cross.\n *\n * @example\n *\n * A simple example of how to use the Background component.\n *\n * ```tsx\n * import { useState } from 'react';\n * import { ReactFlow, Background, BackgroundVariant } from '@xyflow/react';\n *\n * export default function Flow() {\n *   return (\n *     <ReactFlow defaultNodes={[...]} defaultEdges={[...]}>\n *       <Background color=\"#ccc\" variant={BackgroundVariant.Dots} />\n *     </ReactFlow>\n *   );\n * }\n * ```\n *\n * @example\n *\n * In this example you can see how to combine multiple backgrounds\n *\n * ```tsx\n * import { ReactFlow, Background, BackgroundVariant } from '@xyflow/react';\n * import '@xyflow/react/dist/style.css';\n *\n * export default function Flow() {\n *   return (\n *     <ReactFlow defaultNodes={[...]} defaultEdges={[...]}>\n *       <Background\n *         id=\"1\"\n *         gap={10}\n *         color=\"#f1f1f1\"\n *         variant={BackgroundVariant.Lines}\n *       />\n *       <Background\n *         id=\"2\"\n *         gap={100}\n *         color=\"#ccc\"\n *         variant={BackgroundVariant.Lines}\n *       />\n *     </ReactFlow>\n *   );\n * }\n * ```\n *\n * @remarks\n *\n * When combining multiple <Background /> components its important to give each of them a unique id prop!\n *\n */ const Background = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(BackgroundComponent);\nfunction PlusIcon() {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n        xmlns: \"http://www.w3.org/2000/svg\",\n        viewBox: \"0 0 32 32\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n            d: \"M32 18.133H18.133V32h-4.266V18.133H0v-4.266h13.867V0h4.266v13.867H32z\"\n        })\n    });\n}\nfunction MinusIcon() {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n        xmlns: \"http://www.w3.org/2000/svg\",\n        viewBox: \"0 0 32 5\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n            d: \"M0 0h32v4.2H0z\"\n        })\n    });\n}\nfunction FitViewIcon() {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n        xmlns: \"http://www.w3.org/2000/svg\",\n        viewBox: \"0 0 32 30\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n            d: \"M3.692 4.63c0-.53.4-.938.939-.938h5.215V0H4.708C2.13 0 0 2.054 0 4.63v5.216h3.692V4.631zM27.354 0h-5.2v3.692h5.17c.53 0 .984.4.984.939v5.215H32V4.631A4.624 4.624 0 0027.354 0zm.954 24.83c0 .532-.4.94-.939.94h-5.215v3.768h5.215c2.577 0 4.631-2.13 4.631-4.707v-5.139h-3.692v5.139zm-23.677.94c-.531 0-.939-.4-.939-.94v-5.138H0v5.139c0 2.577 2.13 4.707 4.708 4.707h5.138V25.77H4.631z\"\n        })\n    });\n}\nfunction LockIcon() {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n        xmlns: \"http://www.w3.org/2000/svg\",\n        viewBox: \"0 0 25 32\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n            d: \"M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0 8 0 4.571 3.429 4.571 7.619v3.048H3.048A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047zm4.724-13.866H7.467V7.619c0-2.59 2.133-4.724 4.723-4.724 2.591 0 4.724 2.133 4.724 4.724v3.048z\"\n        })\n    });\n}\nfunction UnlockIcon() {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"svg\", {\n        xmlns: \"http://www.w3.org/2000/svg\",\n        viewBox: \"0 0 25 32\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n            d: \"M21.333 10.667H19.81V7.619C19.81 3.429 16.38 0 12.19 0c-4.114 1.828-1.37 2.133.305 2.438 1.676.305 4.42 2.59 4.42 5.181v3.048H3.047A3.056 3.056 0 000 13.714v15.238A3.056 3.056 0 003.048 32h18.285a3.056 3.056 0 003.048-3.048V13.714a3.056 3.056 0 00-3.048-3.047zM12.19 24.533a3.056 3.056 0 01-3.047-3.047 3.056 3.056 0 013.047-3.048 3.056 3.056 0 013.048 3.048 3.056 3.056 0 01-3.048 3.047z\"\n        })\n    });\n}\n/**\n * You can add buttons to the control panel by using the `<ControlButton />` component\n * and pass it as a child to the [`<Controls />`](/api-reference/components/controls) component.\n *\n * @public\n * @example\n *```jsx\n *import { MagicWand } from '@radix-ui/react-icons'\n *import { ReactFlow, Controls, ControlButton } from '@xyflow/react'\n *\n *export default function Flow() {\n *  return (\n *    <ReactFlow nodes={[...]} edges={[...]}>\n *      <Controls>\n *        <ControlButton onClick={() => alert('Something magical just happened. ')}>\n *          <MagicWand />\n *        </ControlButton>\n *      </Controls>\n *    </ReactFlow>\n *  )\n *}\n *```\n */ function ControlButton({ children, className, ...rest }) {\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"button\", {\n        type: \"button\",\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            'react-flow__controls-button',\n            className\n        ]),\n        ...rest,\n        children: children\n    });\n}\nconst selector$2 = (s)=>({\n        isInteractive: s.nodesDraggable || s.nodesConnectable || s.elementsSelectable,\n        minZoomReached: s.transform[2] <= s.minZoom,\n        maxZoomReached: s.transform[2] >= s.maxZoom\n    });\nfunction ControlsComponent({ style, showZoom = true, showFitView = true, showInteractive = true, fitViewOptions, onZoomIn, onZoomOut, onFitView, onInteractiveChange, className, children, position = 'bottom-left', orientation = 'vertical', 'aria-label': ariaLabel = 'React Flow controls' }) {\n    const store = useStoreApi();\n    const { isInteractive, minZoomReached, maxZoomReached } = useStore(selector$2, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const { zoomIn, zoomOut, fitView } = useReactFlow();\n    const onZoomInHandler = ()=>{\n        zoomIn();\n        onZoomIn?.();\n    };\n    const onZoomOutHandler = ()=>{\n        zoomOut();\n        onZoomOut?.();\n    };\n    const onFitViewHandler = ()=>{\n        fitView(fitViewOptions);\n        onFitView?.();\n    };\n    const onToggleInteractivity = ()=>{\n        store.setState({\n            nodesDraggable: !isInteractive,\n            nodesConnectable: !isInteractive,\n            elementsSelectable: !isInteractive\n        });\n        onInteractiveChange?.(!isInteractive);\n    };\n    const orientationClass = orientation === 'horizontal' ? 'horizontal' : 'vertical';\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(Panel, {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            'react-flow__controls',\n            orientationClass,\n            className\n        ]),\n        position: position,\n        style: style,\n        \"data-testid\": \"rf__controls\",\n        \"aria-label\": ariaLabel,\n        children: [\n            showZoom && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n                children: [\n                    (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ControlButton, {\n                        onClick: onZoomInHandler,\n                        className: \"react-flow__controls-zoomin\",\n                        title: \"zoom in\",\n                        \"aria-label\": \"zoom in\",\n                        disabled: maxZoomReached,\n                        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(PlusIcon, {})\n                    }),\n                    (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ControlButton, {\n                        onClick: onZoomOutHandler,\n                        className: \"react-flow__controls-zoomout\",\n                        title: \"zoom out\",\n                        \"aria-label\": \"zoom out\",\n                        disabled: minZoomReached,\n                        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(MinusIcon, {})\n                    })\n                ]\n            }),\n            showFitView && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ControlButton, {\n                className: \"react-flow__controls-fitview\",\n                onClick: onFitViewHandler,\n                title: \"fit view\",\n                \"aria-label\": \"fit view\",\n                children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(FitViewIcon, {})\n            }),\n            showInteractive && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(ControlButton, {\n                className: \"react-flow__controls-interactive\",\n                onClick: onToggleInteractivity,\n                title: \"toggle interactivity\",\n                \"aria-label\": \"toggle interactivity\",\n                children: isInteractive ? (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(UnlockIcon, {}) : (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(LockIcon, {})\n            }),\n            children\n        ]\n    });\n}\nControlsComponent.displayName = 'Controls';\n/**\n * The `<Controls />` component renders a small panel that contains convenient\n * buttons to zoom in, zoom out, fit the view, and lock the viewport.\n *\n * @public\n * @example\n *```tsx\n *import { ReactFlow, Controls } from '@xyflow/react'\n *\n *export default function Flow() {\n *  return (\n *    <ReactFlow nodes={[...]} edges={[...]}>\n *      <Controls />\n *    </ReactFlow>\n *  )\n *}\n *```\n *\n * @remarks To extend or customise the controls, you can use the [`<ControlButton />`](/api-reference/components/control-button) component\n *\n */ const Controls = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(ControlsComponent);\nfunction MiniMapNodeComponent({ id, x, y, width, height, style, color, strokeColor, strokeWidth, className, borderRadius, shapeRendering, selected, onClick }) {\n    const { background, backgroundColor } = style || {};\n    const fill = color || background || backgroundColor;\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"rect\", {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            'react-flow__minimap-node',\n            {\n                selected\n            },\n            className\n        ]),\n        x: x,\n        y: y,\n        rx: borderRadius,\n        ry: borderRadius,\n        width: width,\n        height: height,\n        style: {\n            fill,\n            stroke: strokeColor,\n            strokeWidth\n        },\n        shapeRendering: shapeRendering,\n        onClick: onClick ? (event)=>onClick(event, id) : undefined\n    });\n}\nconst MiniMapNode = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(MiniMapNodeComponent);\nconst selectorNodeIds = (s)=>s.nodes.map((node)=>node.id);\nconst getAttrFunction = (func)=>func instanceof Function ? func : ()=>func;\nfunction MiniMapNodes({ nodeStrokeColor, nodeColor, nodeClassName = '', nodeBorderRadius = 5, nodeStrokeWidth, /*\n * We need to rename the prop to be `CapitalCase` so that JSX will render it as\n * a component properly.\n */ nodeComponent: NodeComponent = MiniMapNode, onClick }) {\n    const nodeIds = useStore(selectorNodeIds, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const nodeColorFunc = getAttrFunction(nodeColor);\n    const nodeStrokeColorFunc = getAttrFunction(nodeStrokeColor);\n    const nodeClassNameFunc = getAttrFunction(nodeClassName);\n    const shapeRendering =  true ? 'crispEdges' : 0;\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: nodeIds.map((nodeId)=>/*\n         * The split of responsibilities between MiniMapNodes and\n         * NodeComponentWrapper may appear weird. However, its designed to\n         * minimize the cost of updates when individual nodes change.\n         *\n         * For more details, see a similar commit in `NodeRenderer/index.tsx`.\n         */ (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeComponentWrapper, {\n                id: nodeId,\n                nodeColorFunc: nodeColorFunc,\n                nodeStrokeColorFunc: nodeStrokeColorFunc,\n                nodeClassNameFunc: nodeClassNameFunc,\n                nodeBorderRadius: nodeBorderRadius,\n                nodeStrokeWidth: nodeStrokeWidth,\n                NodeComponent: NodeComponent,\n                onClick: onClick,\n                shapeRendering: shapeRendering\n            }, nodeId))\n    });\n}\nfunction NodeComponentWrapperInner({ id, nodeColorFunc, nodeStrokeColorFunc, nodeClassNameFunc, nodeBorderRadius, nodeStrokeWidth, shapeRendering, NodeComponent, onClick }) {\n    const { node, x, y, width, height } = useStore({\n        \"NodeComponentWrapperInner.useStore\": (s)=>{\n            const node = s.nodeLookup.get(id);\n            const { x, y } = node.internals.positionAbsolute;\n            const { width, height } = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getNodeDimensions)(node);\n            return {\n                node,\n                x,\n                y,\n                width,\n                height\n            };\n        }\n    }[\"NodeComponentWrapperInner.useStore\"], zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    if (!node || node.hidden || !(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.nodeHasDimensions)(node)) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeComponent, {\n        x: x,\n        y: y,\n        width: width,\n        height: height,\n        style: node.style,\n        selected: !!node.selected,\n        className: nodeClassNameFunc(node),\n        color: nodeColorFunc(node),\n        borderRadius: nodeBorderRadius,\n        strokeColor: nodeStrokeColorFunc(node),\n        strokeWidth: nodeStrokeWidth,\n        shapeRendering: shapeRendering,\n        onClick: onClick,\n        id: node.id\n    });\n}\nconst NodeComponentWrapper = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(NodeComponentWrapperInner);\nvar MiniMapNodes$1 = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(MiniMapNodes);\nconst defaultWidth = 200;\nconst defaultHeight = 150;\nconst selector$1 = (s)=>{\n    const viewBB = {\n        x: -s.transform[0] / s.transform[2],\n        y: -s.transform[1] / s.transform[2],\n        width: s.width / s.transform[2],\n        height: s.height / s.transform[2]\n    };\n    return {\n        viewBB,\n        boundingRect: s.nodeLookup.size > 0 ? (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getBoundsOfRects)((0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getInternalNodesBounds)(s.nodeLookup), viewBB) : viewBB,\n        rfId: s.rfId,\n        panZoom: s.panZoom,\n        translateExtent: s.translateExtent,\n        flowWidth: s.width,\n        flowHeight: s.height\n    };\n};\nconst ARIA_LABEL_KEY = 'react-flow__minimap-desc';\nfunction MiniMapComponent({ style, className, nodeStrokeColor, nodeColor, nodeClassName = '', nodeBorderRadius = 5, nodeStrokeWidth, /*\n * We need to rename the prop to be `CapitalCase` so that JSX will render it as\n * a component properly.\n */ nodeComponent, bgColor, maskColor, maskStrokeColor, maskStrokeWidth, position = 'bottom-right', onClick, onNodeClick, pannable = false, zoomable = false, ariaLabel = 'React Flow mini map', inversePan, zoomStep = 10, offsetScale = 5 }) {\n    const store = useStoreApi();\n    const svg = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const { boundingRect, viewBB, rfId, panZoom, translateExtent, flowWidth, flowHeight } = useStore(selector$1, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    const elementWidth = style?.width ?? defaultWidth;\n    const elementHeight = style?.height ?? defaultHeight;\n    const scaledWidth = boundingRect.width / elementWidth;\n    const scaledHeight = boundingRect.height / elementHeight;\n    const viewScale = Math.max(scaledWidth, scaledHeight);\n    const viewWidth = viewScale * elementWidth;\n    const viewHeight = viewScale * elementHeight;\n    const offset = offsetScale * viewScale;\n    const x = boundingRect.x - (viewWidth - boundingRect.width) / 2 - offset;\n    const y = boundingRect.y - (viewHeight - boundingRect.height) / 2 - offset;\n    const width = viewWidth + offset * 2;\n    const height = viewHeight + offset * 2;\n    const labelledBy = `${ARIA_LABEL_KEY}-${rfId}`;\n    const viewScaleRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(0);\n    const minimapInstance = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)();\n    viewScaleRef.current = viewScale;\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"MiniMapComponent.useEffect\": ()=>{\n            if (svg.current && panZoom) {\n                minimapInstance.current = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.XYMinimap)({\n                    domNode: svg.current,\n                    panZoom,\n                    getTransform: {\n                        \"MiniMapComponent.useEffect\": ()=>store.getState().transform\n                    }[\"MiniMapComponent.useEffect\"],\n                    getViewScale: {\n                        \"MiniMapComponent.useEffect\": ()=>viewScaleRef.current\n                    }[\"MiniMapComponent.useEffect\"]\n                });\n                return ({\n                    \"MiniMapComponent.useEffect\": ()=>{\n                        minimapInstance.current?.destroy();\n                    }\n                })[\"MiniMapComponent.useEffect\"];\n            }\n        }\n    }[\"MiniMapComponent.useEffect\"], [\n        panZoom\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"MiniMapComponent.useEffect\": ()=>{\n            minimapInstance.current?.update({\n                translateExtent,\n                width: flowWidth,\n                height: flowHeight,\n                inversePan,\n                pannable,\n                zoomStep,\n                zoomable\n            });\n        }\n    }[\"MiniMapComponent.useEffect\"], [\n        pannable,\n        zoomable,\n        inversePan,\n        zoomStep,\n        translateExtent,\n        flowWidth,\n        flowHeight\n    ]);\n    const onSvgClick = onClick ? (event)=>{\n        const [x, y] = minimapInstance.current?.pointer(event) || [\n            0,\n            0\n        ];\n        onClick(event, {\n            x,\n            y\n        });\n    } : undefined;\n    const onSvgNodeClick = onNodeClick ? (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"MiniMapComponent.useCallback\": (event, nodeId)=>{\n            const node = store.getState().nodeLookup.get(nodeId);\n            onNodeClick(event, node);\n        }\n    }[\"MiniMapComponent.useCallback\"], []) : undefined;\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(Panel, {\n        position: position,\n        style: {\n            ...style,\n            '--xy-minimap-background-color-props': typeof bgColor === 'string' ? bgColor : undefined,\n            '--xy-minimap-mask-background-color-props': typeof maskColor === 'string' ? maskColor : undefined,\n            '--xy-minimap-mask-stroke-color-props': typeof maskStrokeColor === 'string' ? maskStrokeColor : undefined,\n            '--xy-minimap-mask-stroke-width-props': typeof maskStrokeWidth === 'number' ? maskStrokeWidth * viewScale : undefined,\n            '--xy-minimap-node-background-color-props': typeof nodeColor === 'string' ? nodeColor : undefined,\n            '--xy-minimap-node-stroke-color-props': typeof nodeStrokeColor === 'string' ? nodeStrokeColor : undefined,\n            '--xy-minimap-node-stroke-width-props': typeof nodeStrokeWidth === 'string' ? nodeStrokeWidth : undefined\n        },\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            'react-flow__minimap',\n            className\n        ]),\n        \"data-testid\": \"rf__minimap\",\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(\"svg\", {\n            width: elementWidth,\n            height: elementHeight,\n            viewBox: `${x} ${y} ${width} ${height}`,\n            className: \"react-flow__minimap-svg\",\n            role: \"img\",\n            \"aria-labelledby\": labelledBy,\n            ref: svg,\n            onClick: onSvgClick,\n            children: [\n                ariaLabel && (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"title\", {\n                    id: labelledBy,\n                    children: ariaLabel\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(MiniMapNodes$1, {\n                    onClick: onSvgNodeClick,\n                    nodeColor: nodeColor,\n                    nodeStrokeColor: nodeStrokeColor,\n                    nodeBorderRadius: nodeBorderRadius,\n                    nodeClassName: nodeClassName,\n                    nodeStrokeWidth: nodeStrokeWidth,\n                    nodeComponent: nodeComponent\n                }),\n                (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"path\", {\n                    className: \"react-flow__minimap-mask\",\n                    d: `M${x - offset},${y - offset}h${width + offset * 2}v${height + offset * 2}h${-width - offset * 2}z\n        M${viewBB.x},${viewBB.y}h${viewBB.width}v${viewBB.height}h${-viewBB.width}z`,\n                    fillRule: \"evenodd\",\n                    pointerEvents: \"none\"\n                })\n            ]\n        })\n    });\n}\nMiniMapComponent.displayName = 'MiniMap';\n/**\n * The `<MiniMap />` component can be used to render an overview of your flow. It\n * renders each node as an SVG element and visualizes where the current viewport is\n * in relation to the rest of the flow.\n *\n * @public\n * @example\n *\n * ```jsx\n *import { ReactFlow, MiniMap } from '@xyflow/react';\n *\n *export default function Flow() {\n *  return (\n *    <ReactFlow nodes={[...]]} edges={[...]]}>\n *      <MiniMap nodeStrokeWidth={3} />\n *    </ReactFlow>\n *  );\n *}\n *```\n */ const MiniMap = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(MiniMapComponent);\nfunction ResizeControl({ nodeId, position, variant = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ResizeControlVariant.Handle, className, style = {}, children, color, minWidth = 10, minHeight = 10, maxWidth = Number.MAX_VALUE, maxHeight = Number.MAX_VALUE, keepAspectRatio = false, shouldResize, onResizeStart, onResize, onResizeEnd }) {\n    const contextNodeId = useNodeId();\n    const id = typeof nodeId === 'string' ? nodeId : contextNodeId;\n    const store = useStoreApi();\n    const resizeControlRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const defaultPosition = variant === _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ResizeControlVariant.Line ? 'right' : 'bottom-right';\n    const controlPosition = position ?? defaultPosition;\n    const resizer = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ResizeControl.useEffect\": ()=>{\n            if (!resizeControlRef.current || !id) {\n                return;\n            }\n            if (!resizer.current) {\n                resizer.current = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.XYResizer)({\n                    domNode: resizeControlRef.current,\n                    nodeId: id,\n                    getStoreItems: {\n                        \"ResizeControl.useEffect\": ()=>{\n                            const { nodeLookup, transform, snapGrid, snapToGrid, nodeOrigin, domNode } = store.getState();\n                            return {\n                                nodeLookup,\n                                transform,\n                                snapGrid,\n                                snapToGrid,\n                                nodeOrigin,\n                                paneDomNode: domNode\n                            };\n                        }\n                    }[\"ResizeControl.useEffect\"],\n                    onChange: {\n                        \"ResizeControl.useEffect\": (change, childChanges)=>{\n                            const { triggerNodeChanges, nodeLookup, parentLookup, nodeOrigin } = store.getState();\n                            const changes = [];\n                            const nextPosition = {\n                                x: change.x,\n                                y: change.y\n                            };\n                            const node = nodeLookup.get(id);\n                            if (node && node.expandParent && node.parentId) {\n                                const origin = node.origin ?? nodeOrigin;\n                                const width = change.width ?? node.measured.width ?? 0;\n                                const height = change.height ?? node.measured.height ?? 0;\n                                const child = {\n                                    id: node.id,\n                                    parentId: node.parentId,\n                                    rect: {\n                                        width,\n                                        height,\n                                        ...(0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.evaluateAbsolutePosition)({\n                                            x: change.x ?? node.position.x,\n                                            y: change.y ?? node.position.y\n                                        }, {\n                                            width,\n                                            height\n                                        }, node.parentId, nodeLookup, origin)\n                                    }\n                                };\n                                const parentExpandChanges = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.handleExpandParent)([\n                                    child\n                                ], nodeLookup, parentLookup, nodeOrigin);\n                                changes.push(...parentExpandChanges);\n                                /*\n                         * when the parent was expanded by the child node, its position will be clamped at\n                         * 0,0 when node origin is 0,0 and to width, height if it's 1,1\n                         */ nextPosition.x = change.x ? Math.max(origin[0] * width, change.x) : undefined;\n                                nextPosition.y = change.y ? Math.max(origin[1] * height, change.y) : undefined;\n                            }\n                            if (nextPosition.x !== undefined && nextPosition.y !== undefined) {\n                                const positionChange = {\n                                    id,\n                                    type: 'position',\n                                    position: {\n                                        ...nextPosition\n                                    }\n                                };\n                                changes.push(positionChange);\n                            }\n                            if (change.width !== undefined && change.height !== undefined) {\n                                const dimensionChange = {\n                                    id,\n                                    type: 'dimensions',\n                                    resizing: true,\n                                    setAttributes: true,\n                                    dimensions: {\n                                        width: change.width,\n                                        height: change.height\n                                    }\n                                };\n                                changes.push(dimensionChange);\n                            }\n                            for (const childChange of childChanges){\n                                const positionChange = {\n                                    ...childChange,\n                                    type: 'position'\n                                };\n                                changes.push(positionChange);\n                            }\n                            triggerNodeChanges(changes);\n                        }\n                    }[\"ResizeControl.useEffect\"],\n                    onEnd: {\n                        \"ResizeControl.useEffect\": ()=>{\n                            const dimensionChange = {\n                                id: id,\n                                type: 'dimensions',\n                                resizing: false\n                            };\n                            store.getState().triggerNodeChanges([\n                                dimensionChange\n                            ]);\n                        }\n                    }[\"ResizeControl.useEffect\"]\n                });\n            }\n            resizer.current.update({\n                controlPosition,\n                boundaries: {\n                    minWidth,\n                    minHeight,\n                    maxWidth,\n                    maxHeight\n                },\n                keepAspectRatio,\n                onResizeStart,\n                onResize,\n                onResizeEnd,\n                shouldResize\n            });\n            return ({\n                \"ResizeControl.useEffect\": ()=>{\n                    resizer.current?.destroy();\n                }\n            })[\"ResizeControl.useEffect\"];\n        }\n    }[\"ResizeControl.useEffect\"], [\n        controlPosition,\n        minWidth,\n        minHeight,\n        maxWidth,\n        maxHeight,\n        keepAspectRatio,\n        onResizeStart,\n        onResize,\n        onResizeEnd,\n        shouldResize\n    ]);\n    const positionClassNames = controlPosition.split('-');\n    const colorStyleProp = variant === _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ResizeControlVariant.Line ? 'borderColor' : 'backgroundColor';\n    const controlStyle = color ? {\n        ...style,\n        [colorStyleProp]: color\n    } : style;\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n        className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            'react-flow__resize-control',\n            'nodrag',\n            ...positionClassNames,\n            variant,\n            className\n        ]),\n        ref: resizeControlRef,\n        style: controlStyle,\n        children: children\n    });\n}\n/**\n * To create your own resizing UI, you can use the `NodeResizeControl` component where you can pass children (such as icons).\n * @public\n *\n */ const NodeResizeControl = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_1__.memo)(ResizeControl);\n/**\n * The `<NodeResizer />` component can be used to add a resize functionality to your\n * nodes. It renders draggable controls around the node to resize in all directions.\n * @public\n *\n * @example\n *```jsx\n *import { memo } from 'react';\n *import { Handle, Position, NodeResizer } from '@xyflow/react';\n *\n *function ResizableNode({ data }) {\n *  return (\n *    <>\n *      <NodeResizer minWidth={100} minHeight={30} />\n *      <Handle type=\"target\" position={Position.Left} />\n *      <div style={{ padding: 10 }}>{data.label}</div>\n *      <Handle type=\"source\" position={Position.Right} />\n *    </>\n *  );\n *};\n *\n *export default memo(ResizableNode);\n *```\n */ function NodeResizer({ nodeId, isVisible = true, handleClassName, handleStyle, lineClassName, lineStyle, color, minWidth = 10, minHeight = 10, maxWidth = Number.MAX_VALUE, maxHeight = Number.MAX_VALUE, keepAspectRatio = false, shouldResize, onResizeStart, onResize, onResizeEnd }) {\n    if (!isVisible) {\n        return null;\n    }\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxs)(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.XY_RESIZER_LINE_POSITIONS.map((position)=>(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeResizeControl, {\n                    className: lineClassName,\n                    style: lineStyle,\n                    nodeId: nodeId,\n                    position: position,\n                    variant: _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.ResizeControlVariant.Line,\n                    color: color,\n                    minWidth: minWidth,\n                    minHeight: minHeight,\n                    maxWidth: maxWidth,\n                    maxHeight: maxHeight,\n                    onResizeStart: onResizeStart,\n                    keepAspectRatio: keepAspectRatio,\n                    shouldResize: shouldResize,\n                    onResize: onResize,\n                    onResizeEnd: onResizeEnd\n                }, position)),\n            _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.XY_RESIZER_HANDLE_POSITIONS.map((position)=>(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeResizeControl, {\n                    className: handleClassName,\n                    style: handleStyle,\n                    nodeId: nodeId,\n                    position: position,\n                    color: color,\n                    minWidth: minWidth,\n                    minHeight: minHeight,\n                    maxWidth: maxWidth,\n                    maxHeight: maxHeight,\n                    onResizeStart: onResizeStart,\n                    keepAspectRatio: keepAspectRatio,\n                    shouldResize: shouldResize,\n                    onResize: onResize,\n                    onResizeEnd: onResizeEnd\n                }, position))\n        ]\n    });\n}\nconst selector = (state)=>state.domNode?.querySelector('.react-flow__renderer');\nfunction NodeToolbarPortal({ children }) {\n    const wrapperRef = useStore(selector);\n    if (!wrapperRef) {\n        return null;\n    }\n    return /*#__PURE__*/ (0,react_dom__WEBPACK_IMPORTED_MODULE_4__.createPortal)(children, wrapperRef);\n}\nconst nodeEqualityFn = (a, b)=>a?.internals.positionAbsolute.x !== b?.internals.positionAbsolute.x || a?.internals.positionAbsolute.y !== b?.internals.positionAbsolute.y || a?.measured.width !== b?.measured.width || a?.measured.height !== b?.measured.height || a?.selected !== b?.selected || a?.internals.z !== b?.internals.z;\nconst nodesEqualityFn = (a, b)=>{\n    if (a.size !== b.size) {\n        return false;\n    }\n    for (const [key, node] of a){\n        if (nodeEqualityFn(node, b.get(key))) {\n            return false;\n        }\n    }\n    return true;\n};\nconst storeSelector = (state)=>({\n        x: state.transform[0],\n        y: state.transform[1],\n        zoom: state.transform[2],\n        selectedNodesCount: state.nodes.filter((node)=>node.selected).length\n    });\n/**\n * This component can render a toolbar or tooltip to one side of a custom node. This\n * toolbar doesn't scale with the viewport so that the content is always visible.\n *\n * @public\n * @example\n * ```jsx\n *import { memo } from 'react';\n *import { Handle, Position, NodeToolbar } from '@xyflow/react';\n *\n *function CustomNode({ data }) {\n *  return (\n *    <>\n *      <NodeToolbar isVisible={data.toolbarVisible} position={data.toolbarPosition}>\n *        <button>delete</button>\n *        <button>copy</button>\n *        <button>expand</button>\n *      </NodeToolbar>\n *\n *      <div style={{ padding: '10px 20px' }}>\n *        {data.label}\n *      </div>\n *\n *      <Handle type=\"target\" position={Position.Left} />\n *      <Handle type=\"source\" position={Position.Right} />\n *    </>\n *  );\n *};\n *\n *export default memo(CustomNode);\n *```\n * @remarks By default, the toolbar is only visible when a node is selected. If multiple\n * nodes are selected it will not be visible to prevent overlapping toolbars or\n * clutter. You can override this behavior by setting the `isVisible` prop to `true`.\n */ function NodeToolbar({ nodeId, children, className, style, isVisible, position = _xyflow_system__WEBPACK_IMPORTED_MODULE_3__.Position.Top, offset = 10, align = 'center', ...rest }) {\n    const contextNodeId = useNodeId();\n    const nodesSelector = (0,react__WEBPACK_IMPORTED_MODULE_1__.useCallback)({\n        \"NodeToolbar.useCallback[nodesSelector]\": (state)=>{\n            const nodeIds = Array.isArray(nodeId) ? nodeId : [\n                nodeId || contextNodeId || ''\n            ];\n            const internalNodes = nodeIds.reduce({\n                \"NodeToolbar.useCallback[nodesSelector].internalNodes\": (res, id)=>{\n                    const node = state.nodeLookup.get(id);\n                    if (node) {\n                        res.set(node.id, node);\n                    }\n                    return res;\n                }\n            }[\"NodeToolbar.useCallback[nodesSelector].internalNodes\"], new Map());\n            return internalNodes;\n        }\n    }[\"NodeToolbar.useCallback[nodesSelector]\"], [\n        nodeId,\n        contextNodeId\n    ]);\n    const nodes = useStore(nodesSelector, nodesEqualityFn);\n    const { x, y, zoom, selectedNodesCount } = useStore(storeSelector, zustand_shallow__WEBPACK_IMPORTED_MODULE_6__.shallow);\n    // if isVisible is not set, we show the toolbar only if its node is selected and no other node is selected\n    const isActive = typeof isVisible === 'boolean' ? isVisible : nodes.size === 1 && nodes.values().next().value?.selected && selectedNodesCount === 1;\n    if (!isActive || !nodes.size) {\n        return null;\n    }\n    const nodeRect = (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getInternalNodesBounds)(nodes);\n    const nodesArray = Array.from(nodes.values());\n    const zIndex = Math.max(...nodesArray.map((node)=>node.internals.z + 1));\n    const wrapperStyle = {\n        position: 'absolute',\n        transform: (0,_xyflow_system__WEBPACK_IMPORTED_MODULE_3__.getNodeToolbarTransform)(nodeRect, {\n            x,\n            y,\n            zoom\n        }, position, offset, align),\n        zIndex,\n        ...style\n    };\n    return (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(NodeToolbarPortal, {\n        children: (0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx)(\"div\", {\n            style: wrapperStyle,\n            className: (0,classcat__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n                'react-flow__node-toolbar',\n                className\n            ]),\n            ...rest,\n            \"data-id\": nodesArray.reduce((acc, node)=>`${acc}${node.id} `, '').trim(),\n            children: children\n        })\n    });\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHh5Zmxvdy9yZWFjdC9kaXN0L2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztvN0JBQ3dEO0FBQ2dGO0FBQzlHO0FBQ2twQztBQUMxMUI7QUFDL1A7QUFDekM7QUFDRDtBQUV6QyxNQUFNMkYsNkJBQWV4RixvREFBYUEsQ0FBQztBQUNuQyxNQUFNeUYsYUFBYUQsYUFBYUUsUUFBUTtBQUV4QyxNQUFNQyxzQkFBc0JoRix5REFBYSxDQUFDLFdBQVc7QUFDckQ7Ozs7Ozs7Ozs7Ozs7Ozs7OztDQWtCQyxHQUNELFNBQVNpRixTQUFTQyxRQUFRLEVBQUVDLFVBQVU7SUFDbEMsTUFBTUMsUUFBUTlGLGlEQUFVQSxDQUFDdUY7SUFDekIsSUFBSU8sVUFBVSxNQUFNO1FBQ2hCLE1BQU0sSUFBSUMsTUFBTUw7SUFDcEI7SUFDQSxPQUFPUCwyRUFBc0JBLENBQUNXLE9BQU9GLFVBQVVDO0FBQ25EO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Q0FhQyxHQUNELFNBQVNHO0lBQ0wsTUFBTUYsUUFBUTlGLGlEQUFVQSxDQUFDdUY7SUFDekIsSUFBSU8sVUFBVSxNQUFNO1FBQ2hCLE1BQU0sSUFBSUMsTUFBTUw7SUFDcEI7SUFDQSxPQUFPekYsOENBQU9BOytCQUFDLElBQU87Z0JBQ2xCZ0csVUFBVUgsTUFBTUcsUUFBUTtnQkFDeEJDLFVBQVVKLE1BQU1JLFFBQVE7Z0JBQ3hCQyxXQUFXTCxNQUFNSyxTQUFTO1lBQzlCOzhCQUFJO1FBQUNMO0tBQU07QUFDZjtBQUVBLE1BQU1NLFFBQVE7SUFBRUMsU0FBUztBQUFPO0FBQ2hDLE1BQU1DLGdCQUFnQjtJQUNsQkMsVUFBVTtJQUNWQyxPQUFPO0lBQ1BDLFFBQVE7SUFDUkMsUUFBUSxDQUFDO0lBQ1RDLFFBQVE7SUFDUkMsU0FBUztJQUNUQyxVQUFVO0lBQ1ZDLE1BQU07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LGVBQWU7UUFDakJyNkIsVUFBVTtRQUNWZ0wsV0FBVzFNLHVFQUF1QkEsQ0FBQzJWLFVBQVU7WUFBRTlQO1lBQUdDO1lBQUdDO1FBQUssR0FBR3JFLFVBQVV5dkIsUUFBUXFZO1FBQy9FL2U7UUFDQSxHQUFHbHBCLEtBQUs7SUFDWjtJQUNBLE9BQVF0RyxzREFBR0EsQ0FBQ2d1QyxtQkFBbUI7UUFBRXJtQyxVQUFVM0gsc0RBQUdBLENBQUMsT0FBTztZQUFFc0csT0FBT3c2QjtZQUFjNzRCLFdBQVd0SCxvREFBRUEsQ0FBQztnQkFBQztnQkFBNEJzSDthQUFVO1lBQUcsR0FBR0MsSUFBSTtZQUFFLFdBQVd1bUMsV0FBVzEvQixNQUFNLENBQUMsQ0FBQzIvQixLQUFLemxDLE9BQVMsR0FBR3lsQyxNQUFNemxDLEtBQUt2QixFQUFFLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSWluQyxJQUFJO1lBQUlobkMsVUFBVUE7UUFBUztJQUFHO0FBQ3JQO0FBRWdxQiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxzdXJ5YVxcRG93bmxvYWRzXFxGaWxlc1xcVlNjb2RlXFxzdXBlcnZhaXNvcl90YXNrXFxub2RlX21vZHVsZXNcXEB4eWZsb3dcXHJlYWN0XFxkaXN0XFxlc21cXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIGNsaWVudFwiXG5pbXBvcnQgeyBqc3hzLCBGcmFnbWVudCwganN4IH0gZnJvbSAncmVhY3QvanN4LXJ1bnRpbWUnO1xuaW1wb3J0IHsgY3JlYXRlQ29udGV4dCwgdXNlQ29udGV4dCwgdXNlTWVtbywgZm9yd2FyZFJlZiwgdXNlRWZmZWN0LCB1c2VSZWYsIHVzZVN0YXRlLCB1c2VMYXlvdXRFZmZlY3QsIHVzZUNhbGxiYWNrLCBtZW1vIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IGNjIGZyb20gJ2NsYXNzY2F0JztcbmltcG9ydCB7IGVycm9yTWVzc2FnZXMsIGluZmluaXRlRXh0ZW50LCBpc0lucHV0RE9NTm9kZSwgZ2V0Rml0Vmlld05vZGVzLCBnZXREaW1lbnNpb25zLCBmaXRWaWV3LCBnZXRWaWV3cG9ydEZvckJvdW5kcywgcG9pbnRUb1JlbmRlcmVyUG9pbnQsIHJlbmRlcmVyUG9pbnRUb1BvaW50LCBpc05vZGVCYXNlLCBpc0VkZ2VCYXNlLCBnZXRFbGVtZW50c1RvUmVtb3ZlLCBpc1JlY3RPYmplY3QsIG5vZGVUb1JlY3QsIGdldE92ZXJsYXBwaW5nQXJlYSwgZ2V0Tm9kZXNCb3VuZHMsIGV2YWx1YXRlQWJzb2x1dGVQb3NpdGlvbiwgWFlQYW5ab29tLCBQYW5PblNjcm9sbE1vZGUsIFNlbGVjdGlvbk1vZGUsIGdldEV2ZW50UG9zaXRpb24sIGdldE5vZGVzSW5zaWRlLCBhcmVTZXRzRXF1YWwsIFhZRHJhZywgc25hcFBvc2l0aW9uLCBjYWxjdWxhdGVOb2RlUG9zaXRpb24sIFBvc2l0aW9uLCBDb25uZWN0aW9uTW9kZSwgaXNNb3VzZUV2ZW50LCBYWUhhbmRsZSwgZ2V0SG9zdEZvckVsZW1lbnQsIGFkZEVkZ2UsIGdldEludGVybmFsTm9kZXNCb3VuZHMsIGlzTnVtZXJpYywgbm9kZUhhc0RpbWVuc2lvbnMsIGdldE5vZGVEaW1lbnNpb25zLCBlbGVtZW50U2VsZWN0aW9uS2V5cywgaXNFZGdlVmlzaWJsZSwgTWFya2VyVHlwZSwgY3JlYXRlTWFya2VySWRzLCBnZXRCZXppZXJFZGdlQ2VudGVyLCBnZXRTbW9vdGhTdGVwUGF0aCwgZ2V0U3RyYWlnaHRQYXRoLCBnZXRCZXppZXJQYXRoLCBnZXRFZGdlUG9zaXRpb24sIGdldEVsZXZhdGVkRWRnZVpJbmRleCwgZ2V0TWFya2VySWQsIGdldENvbm5lY3Rpb25TdGF0dXMsIENvbm5lY3Rpb25MaW5lVHlwZSwgdXBkYXRlQ29ubmVjdGlvbkxvb2t1cCwgYWRvcHRVc2VyTm9kZXMsIGluaXRpYWxDb25uZWN0aW9uLCBkZXZXYXJuLCB1cGRhdGVOb2RlSW50ZXJuYWxzLCB1cGRhdGVBYnNvbHV0ZVBvc2l0aW9ucywgaGFuZGxlRXhwYW5kUGFyZW50LCBwYW5CeSwgaXNNYWNPcywgYXJlQ29ubmVjdGlvbk1hcHNFcXVhbCwgaGFuZGxlQ29ubmVjdGlvbkNoYW5nZSwgc2hhbGxvd05vZGVEYXRhLCBYWU1pbmltYXAsIGdldEJvdW5kc09mUmVjdHMsIFJlc2l6ZUNvbnRyb2xWYXJpYW50LCBYWVJlc2l6ZXIsIFhZX1JFU0laRVJfTElORV9QT1NJVElPTlMsIFhZX1JFU0laRVJfSEFORExFX1BPU0lUSU9OUywgZ2V0Tm9kZVRvb2xiYXJUcmFuc2Zvcm0gfSBmcm9tICdAeHlmbG93L3N5c3RlbSc7XG5leHBvcnQgeyBDb25uZWN0aW9uTGluZVR5cGUsIENvbm5lY3Rpb25Nb2RlLCBNYXJrZXJUeXBlLCBQYW5PblNjcm9sbE1vZGUsIFBvc2l0aW9uLCBSZXNpemVDb250cm9sVmFyaWFudCwgU2VsZWN0aW9uTW9kZSwgYWRkRWRnZSwgZ2V0QmV6aWVyRWRnZUNlbnRlciwgZ2V0QmV6aWVyUGF0aCwgZ2V0Q29ubmVjdGVkRWRnZXMsIGdldEVkZ2VDZW50ZXIsIGdldEluY29tZXJzLCBnZXROb2Rlc0JvdW5kcywgZ2V0T3V0Z29lcnMsIGdldFNtb290aFN0ZXBQYXRoLCBnZXRTdHJhaWdodFBhdGgsIGdldFZpZXdwb3J0Rm9yQm91bmRzLCByZWNvbm5lY3RFZGdlIH0gZnJvbSAnQHh5Zmxvdy9zeXN0ZW0nO1xuaW1wb3J0IHsgdXNlU3RvcmVXaXRoRXF1YWxpdHlGbiwgY3JlYXRlV2l0aEVxdWFsaXR5Rm4gfSBmcm9tICd6dXN0YW5kL3RyYWRpdGlvbmFsJztcbmltcG9ydCB7IHNoYWxsb3cgfSBmcm9tICd6dXN0YW5kL3NoYWxsb3cnO1xuaW1wb3J0IHsgY3JlYXRlUG9ydGFsIH0gZnJvbSAncmVhY3QtZG9tJztcblxuY29uc3QgU3RvcmVDb250ZXh0ID0gY3JlYXRlQ29udGV4dChudWxsKTtcbmNvbnN0IFByb3ZpZGVyJDEgPSBTdG9yZUNvbnRleHQuUHJvdmlkZXI7XG5cbmNvbnN0IHp1c3RhbmRFcnJvck1lc3NhZ2UgPSBlcnJvck1lc3NhZ2VzWydlcnJvcjAwMSddKCk7XG4vKipcbiAqIFRoaXMgaG9vayBjYW4gYmUgdXNlZCB0byBzdWJzY3JpYmUgdG8gaW50ZXJuYWwgc3RhdGUgY2hhbmdlcyBvZiB0aGUgUmVhY3QgRmxvd1xuICogY29tcG9uZW50LiBUaGUgYHVzZVN0b3JlYCBob29rIGlzIHJlLWV4cG9ydGVkIGZyb20gdGhlIFtadXN0YW5kXShodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3p1c3RhbmQpXG4gKiBzdGF0ZSBtYW5hZ2VtZW50IGxpYnJhcnksIHNvIHlvdSBzaG91bGQgY2hlY2sgb3V0IHRoZWlyIGRvY3MgZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBAcHVibGljXG4gKiBAcGFyYW0gc2VsZWN0b3JcbiAqIEBwYXJhbSBlcXVhbGl0eUZuXG4gKiBAcmV0dXJucyBUaGUgc2VsZWN0ZWQgc3RhdGUgc2xpY2VcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGNvbnN0IG5vZGVzID0gdXNlU3RvcmUoKHN0YXRlKSA9PiBzdGF0ZS5ub2Rlcyk7XG4gKiBgYGBcbiAqXG4gKiBAcmVtYXJrcyBUaGlzIGhvb2sgc2hvdWxkIG9ubHkgYmUgdXNlZCBpZiB0aGVyZSBpcyBubyBvdGhlciB3YXkgdG8gYWNjZXNzIHRoZSBpbnRlcm5hbFxuICogc3RhdGUuIEZvciBtYW55IG9mIHRoZSBjb21tb24gdXNlIGNhc2VzLCB0aGVyZSBhcmUgZGVkaWNhdGVkIGhvb2tzIGF2YWlsYWJsZVxuICogc3VjaCBhcyB7QGxpbmsgdXNlUmVhY3RGbG93fSwge0BsaW5rIHVzZVZpZXdwb3J0fSwgZXRjLlxuICovXG5mdW5jdGlvbiB1c2VTdG9yZShzZWxlY3RvciwgZXF1YWxpdHlGbikge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlQ29udGV4dChTdG9yZUNvbnRleHQpO1xuICAgIGlmIChzdG9yZSA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoenVzdGFuZEVycm9yTWVzc2FnZSk7XG4gICAgfVxuICAgIHJldHVybiB1c2VTdG9yZVdpdGhFcXVhbGl0eUZuKHN0b3JlLCBzZWxlY3RvciwgZXF1YWxpdHlGbik7XG59XG4vKipcbiAqIEluIHNvbWUgY2FzZXMsIHlvdSBtaWdodCBuZWVkIHRvIGFjY2VzcyB0aGUgc3RvcmUgZGlyZWN0bHkuIFRoaXMgaG9vayByZXR1cm5zIHRoZSBzdG9yZSBvYmplY3Qgd2hpY2ggY2FuIGJlIHVzZWQgb24gZGVtYW5kIHRvIGFjY2VzcyB0aGUgc3RhdGUgb3IgZGlzcGF0Y2ggYWN0aW9ucy5cbiAqXG4gKiBAcmV0dXJucyBUaGUgc3RvcmUgb2JqZWN0XG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gKiBgYGBcbiAqXG4gKiBAcmVtYXJrcyBUaGlzIGhvb2sgc2hvdWxkIG9ubHkgYmUgdXNlZCBpZiB0aGVyZSBpcyBubyBvdGhlciB3YXkgdG8gYWNjZXNzIHRoZSBpbnRlcm5hbFxuICogc3RhdGUuIEZvciBtYW55IG9mIHRoZSBjb21tb24gdXNlIGNhc2VzLCB0aGVyZSBhcmUgZGVkaWNhdGVkIGhvb2tzIGF2YWlsYWJsZVxuICogc3VjaCBhcyB7QGxpbmsgdXNlUmVhY3RGbG93fSwge0BsaW5rIHVzZVZpZXdwb3J0fSwgZXRjLlxuICovXG5mdW5jdGlvbiB1c2VTdG9yZUFwaSgpIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZUNvbnRleHQoU3RvcmVDb250ZXh0KTtcbiAgICBpZiAoc3RvcmUgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHp1c3RhbmRFcnJvck1lc3NhZ2UpO1xuICAgIH1cbiAgICByZXR1cm4gdXNlTWVtbygoKSA9PiAoe1xuICAgICAgICBnZXRTdGF0ZTogc3RvcmUuZ2V0U3RhdGUsXG4gICAgICAgIHNldFN0YXRlOiBzdG9yZS5zZXRTdGF0ZSxcbiAgICAgICAgc3Vic2NyaWJlOiBzdG9yZS5zdWJzY3JpYmUsXG4gICAgfSksIFtzdG9yZV0pO1xufVxuXG5jb25zdCBzdHlsZSA9IHsgZGlzcGxheTogJ25vbmUnIH07XG5jb25zdCBhcmlhTGl2ZVN0eWxlID0ge1xuICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgIHdpZHRoOiAxLFxuICAgIGhlaWdodDogMSxcbiAgICBtYXJnaW46IC0xLFxuICAgIGJvcmRlcjogMCxcbiAgICBwYWRkaW5nOiAwLFxuICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgICBjbGlwOiAncmVjdCgwcHgsIDBweCwgMHB4LCAwcHgpJyxcbiAgICBjbGlwUGF0aDogJ2luc2V0KDEwMCUpJyxcbn07XG5jb25zdCBBUklBX05PREVfREVTQ19LRVkgPSAncmVhY3QtZmxvd19fbm9kZS1kZXNjJztcbmNvbnN0IEFSSUFfRURHRV9ERVNDX0tFWSA9ICdyZWFjdC1mbG93X19lZGdlLWRlc2MnO1xuY29uc3QgQVJJQV9MSVZFX01FU1NBR0UgPSAncmVhY3QtZmxvd19fYXJpYS1saXZlJztcbmNvbnN0IHNlbGVjdG9yJG8gPSAocykgPT4gcy5hcmlhTGl2ZU1lc3NhZ2U7XG5mdW5jdGlvbiBBcmlhTGl2ZU1lc3NhZ2UoeyByZklkIH0pIHtcbiAgICBjb25zdCBhcmlhTGl2ZU1lc3NhZ2UgPSB1c2VTdG9yZShzZWxlY3RvciRvKTtcbiAgICByZXR1cm4gKGpzeChcImRpdlwiLCB7IGlkOiBgJHtBUklBX0xJVkVfTUVTU0FHRX0tJHtyZklkfWAsIFwiYXJpYS1saXZlXCI6IFwiYXNzZXJ0aXZlXCIsIFwiYXJpYS1hdG9taWNcIjogXCJ0cnVlXCIsIHN0eWxlOiBhcmlhTGl2ZVN0eWxlLCBjaGlsZHJlbjogYXJpYUxpdmVNZXNzYWdlIH0pKTtcbn1cbmZ1bmN0aW9uIEExMXlEZXNjcmlwdGlvbnMoeyByZklkLCBkaXNhYmxlS2V5Ym9hcmRBMTF5IH0pIHtcbiAgICByZXR1cm4gKGpzeHMoRnJhZ21lbnQsIHsgY2hpbGRyZW46IFtqc3hzKFwiZGl2XCIsIHsgaWQ6IGAke0FSSUFfTk9ERV9ERVNDX0tFWX0tJHtyZklkfWAsIHN0eWxlOiBzdHlsZSwgY2hpbGRyZW46IFtcIlByZXNzIGVudGVyIG9yIHNwYWNlIHRvIHNlbGVjdCBhIG5vZGUuXCIsICFkaXNhYmxlS2V5Ym9hcmRBMTF5ICYmICdZb3UgY2FuIHRoZW4gdXNlIHRoZSBhcnJvdyBrZXlzIHRvIG1vdmUgdGhlIG5vZGUgYXJvdW5kLicsIFwiIFByZXNzIGRlbGV0ZSB0byByZW1vdmUgaXQgYW5kIGVzY2FwZSB0byBjYW5jZWwuXCIsICcgJ10gfSksIGpzeChcImRpdlwiLCB7IGlkOiBgJHtBUklBX0VER0VfREVTQ19LRVl9LSR7cmZJZH1gLCBzdHlsZTogc3R5bGUsIGNoaWxkcmVuOiBcIlByZXNzIGVudGVyIG9yIHNwYWNlIHRvIHNlbGVjdCBhbiBlZGdlLiBZb3UgY2FuIHRoZW4gcHJlc3MgZGVsZXRlIHRvIHJlbW92ZSBpdCBvciBlc2NhcGUgdG8gY2FuY2VsLlwiIH0pLCAhZGlzYWJsZUtleWJvYXJkQTExeSAmJiBqc3goQXJpYUxpdmVNZXNzYWdlLCB7IHJmSWQ6IHJmSWQgfSldIH0pKTtcbn1cblxuY29uc3Qgc2VsZWN0b3IkbiA9IChzKSA9PiAocy51c2VyU2VsZWN0aW9uQWN0aXZlID8gJ25vbmUnIDogJ2FsbCcpO1xuLyoqXG4gKiBUaGUgYDxQYW5lbCAvPmAgY29tcG9uZW50IGhlbHBzIHlvdSBwb3NpdGlvbiBjb250ZW50IGFib3ZlIHRoZSB2aWV3cG9ydC5cbiAqIEl0IGlzIHVzZWQgaW50ZXJuYWxseSBieSB0aGUgW2A8TWluaU1hcCAvPmBdKC9hcGktcmVmZXJlbmNlL2NvbXBvbmVudHMvbWluaW1hcClcbiAqIGFuZCBbYDxDb250cm9scyAvPmBdKC9hcGktcmVmZXJlbmNlL2NvbXBvbmVudHMvY29udHJvbHMpIGNvbXBvbmVudHMuXG4gKlxuICogQHB1YmxpY1xuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc3hcbiAqaW1wb3J0IHsgUmVhY3RGbG93LCBCYWNrZ3JvdW5kLCBQYW5lbCB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRmxvdygpIHtcbiAqICByZXR1cm4gKFxuICogICAgPFJlYWN0RmxvdyBub2Rlcz17W119IGZpdFZpZXc+XG4gKiAgICAgIDxQYW5lbCBwb3NpdGlvbj1cInRvcC1sZWZ0XCI+dG9wLWxlZnQ8L1BhbmVsPlxuICogICAgICA8UGFuZWwgcG9zaXRpb249XCJ0b3AtY2VudGVyXCI+dG9wLWNlbnRlcjwvUGFuZWw+XG4gKiAgICAgIDxQYW5lbCBwb3NpdGlvbj1cInRvcC1yaWdodFwiPnRvcC1yaWdodDwvUGFuZWw+XG4gKiAgICAgIDxQYW5lbCBwb3NpdGlvbj1cImJvdHRvbS1sZWZ0XCI+Ym90dG9tLWxlZnQ8L1BhbmVsPlxuICogICAgICA8UGFuZWwgcG9zaXRpb249XCJib3R0b20tY2VudGVyXCI+Ym90dG9tLWNlbnRlcjwvUGFuZWw+XG4gKiAgICAgIDxQYW5lbCBwb3NpdGlvbj1cImJvdHRvbS1yaWdodFwiPmJvdHRvbS1yaWdodDwvUGFuZWw+XG4gKiAgICA8L1JlYWN0Rmxvdz5cbiAqICApO1xuICp9XG4gKmBgYFxuICovXG5jb25zdCBQYW5lbCA9IGZvcndhcmRSZWYoKHsgcG9zaXRpb24gPSAndG9wLWxlZnQnLCBjaGlsZHJlbiwgY2xhc3NOYW1lLCBzdHlsZSwgLi4ucmVzdCB9LCByZWYpID0+IHtcbiAgICBjb25zdCBwb2ludGVyRXZlbnRzID0gdXNlU3RvcmUoc2VsZWN0b3Ikbik7XG4gICAgY29uc3QgcG9zaXRpb25DbGFzc2VzID0gYCR7cG9zaXRpb259YC5zcGxpdCgnLScpO1xuICAgIHJldHVybiAoanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBjYyhbJ3JlYWN0LWZsb3dfX3BhbmVsJywgY2xhc3NOYW1lLCAuLi5wb3NpdGlvbkNsYXNzZXNdKSwgc3R5bGU6IHsgLi4uc3R5bGUsIHBvaW50ZXJFdmVudHMgfSwgcmVmOiByZWYsIC4uLnJlc3QsIGNoaWxkcmVuOiBjaGlsZHJlbiB9KSk7XG59KTtcblBhbmVsLmRpc3BsYXlOYW1lID0gJ1BhbmVsJztcblxuZnVuY3Rpb24gQXR0cmlidXRpb24oeyBwcm9PcHRpb25zLCBwb3NpdGlvbiA9ICdib3R0b20tcmlnaHQnIH0pIHtcbiAgICBpZiAocHJvT3B0aW9ucz8uaGlkZUF0dHJpYnV0aW9uKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gKGpzeChQYW5lbCwgeyBwb3NpdGlvbjogcG9zaXRpb24sIGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19hdHRyaWJ1dGlvblwiLCBcImRhdGEtbWVzc2FnZVwiOiBcIlBsZWFzZSBvbmx5IGhpZGUgdGhpcyBhdHRyaWJ1dGlvbiB3aGVuIHlvdSBhcmUgc3Vic2NyaWJlZCB0byBSZWFjdCBGbG93IFBybzogaHR0cHM6Ly9wcm8ucmVhY3RmbG93LmRldlwiLCBjaGlsZHJlbjoganN4KFwiYVwiLCB7IGhyZWY6IFwiaHR0cHM6Ly9yZWFjdGZsb3cuZGV2XCIsIHRhcmdldDogXCJfYmxhbmtcIiwgcmVsOiBcIm5vb3BlbmVyIG5vcmVmZXJyZXJcIiwgXCJhcmlhLWxhYmVsXCI6IFwiUmVhY3QgRmxvdyBhdHRyaWJ1dGlvblwiLCBjaGlsZHJlbjogXCJSZWFjdCBGbG93XCIgfSkgfSkpO1xufVxuXG5jb25zdCBzZWxlY3RvciRtID0gKHMpID0+IHtcbiAgICBjb25zdCBzZWxlY3RlZE5vZGVzID0gW107XG4gICAgY29uc3Qgc2VsZWN0ZWRFZGdlcyA9IFtdO1xuICAgIGZvciAoY29uc3QgWywgbm9kZV0gb2Ygcy5ub2RlTG9va3VwKSB7XG4gICAgICAgIGlmIChub2RlLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICBzZWxlY3RlZE5vZGVzLnB1c2gobm9kZS5pbnRlcm5hbHMudXNlck5vZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgWywgZWRnZV0gb2Ygcy5lZGdlTG9va3VwKSB7XG4gICAgICAgIGlmIChlZGdlLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICBzZWxlY3RlZEVkZ2VzLnB1c2goZWRnZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgc2VsZWN0ZWROb2Rlcywgc2VsZWN0ZWRFZGdlcyB9O1xufTtcbmNvbnN0IHNlbGVjdElkID0gKG9iaikgPT4gb2JqLmlkO1xuZnVuY3Rpb24gYXJlRXF1YWwoYSwgYikge1xuICAgIHJldHVybiAoc2hhbGxvdyhhLnNlbGVjdGVkTm9kZXMubWFwKHNlbGVjdElkKSwgYi5zZWxlY3RlZE5vZGVzLm1hcChzZWxlY3RJZCkpICYmXG4gICAgICAgIHNoYWxsb3coYS5zZWxlY3RlZEVkZ2VzLm1hcChzZWxlY3RJZCksIGIuc2VsZWN0ZWRFZGdlcy5tYXAoc2VsZWN0SWQpKSk7XG59XG5mdW5jdGlvbiBTZWxlY3Rpb25MaXN0ZW5lcklubmVyKHsgb25TZWxlY3Rpb25DaGFuZ2UsIH0pIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3QgeyBzZWxlY3RlZE5vZGVzLCBzZWxlY3RlZEVkZ2VzIH0gPSB1c2VTdG9yZShzZWxlY3RvciRtLCBhcmVFcXVhbCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29uc3QgcGFyYW1zID0geyBub2Rlczogc2VsZWN0ZWROb2RlcywgZWRnZXM6IHNlbGVjdGVkRWRnZXMgfTtcbiAgICAgICAgb25TZWxlY3Rpb25DaGFuZ2U/LihwYXJhbXMpO1xuICAgICAgICBzdG9yZS5nZXRTdGF0ZSgpLm9uU2VsZWN0aW9uQ2hhbmdlSGFuZGxlcnMuZm9yRWFjaCgoZm4pID0+IGZuKHBhcmFtcykpO1xuICAgIH0sIFtzZWxlY3RlZE5vZGVzLCBzZWxlY3RlZEVkZ2VzLCBvblNlbGVjdGlvbkNoYW5nZV0pO1xuICAgIHJldHVybiBudWxsO1xufVxuY29uc3QgY2hhbmdlU2VsZWN0b3IgPSAocykgPT4gISFzLm9uU2VsZWN0aW9uQ2hhbmdlSGFuZGxlcnM7XG5mdW5jdGlvbiBTZWxlY3Rpb25MaXN0ZW5lcih7IG9uU2VsZWN0aW9uQ2hhbmdlLCB9KSB7XG4gICAgY29uc3Qgc3RvcmVIYXNTZWxlY3Rpb25DaGFuZ2VIYW5kbGVycyA9IHVzZVN0b3JlKGNoYW5nZVNlbGVjdG9yKTtcbiAgICBpZiAob25TZWxlY3Rpb25DaGFuZ2UgfHwgc3RvcmVIYXNTZWxlY3Rpb25DaGFuZ2VIYW5kbGVycykge1xuICAgICAgICByZXR1cm4ganN4KFNlbGVjdGlvbkxpc3RlbmVySW5uZXIsIHsgb25TZWxlY3Rpb25DaGFuZ2U6IG9uU2VsZWN0aW9uQ2hhbmdlIH0pO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cblxuY29uc3QgZGVmYXVsdE5vZGVPcmlnaW4gPSBbMCwgMF07XG5jb25zdCBkZWZhdWx0Vmlld3BvcnQgPSB7IHg6IDAsIHk6IDAsIHpvb206IDEgfTtcblxuLypcbiAqIFRoaXMgY29tcG9uZW50IGhlbHBzIHVzIHRvIHVwZGF0ZSB0aGUgc3RvcmUgd2l0aCB0aGUgdmFsdWVzIGNvbWluZyBmcm9tIHRoZSB1c2VyLlxuICogV2UgZGlzdGluZ3Vpc2ggYmV0d2VlbiB2YWx1ZXMgd2UgY2FuIHVwZGF0ZSBkaXJlY3RseSB3aXRoIGB1c2VEaXJlY3RTdG9yZVVwZGF0ZXJgIChsaWtlIGBzbmFwR3JpZGApXG4gKiBhbmQgdmFsdWVzIHRoYXQgaGF2ZSBhIGRlZGljYXRlZCBzZXR0ZXIgZnVuY3Rpb24gaW4gdGhlIHN0b3JlIChsaWtlIGBzZXROb2Rlc2ApLlxuICovXG4vLyB0aGVzZSBmaWVsZHMgZXhpc3QgaW4gdGhlIGdsb2JhbCBzdG9yZSBhbmQgd2UgbmVlZCB0byBrZWVwIHRoZW0gdXAgdG8gZGF0ZVxuY29uc3QgcmVhY3RGbG93RmllbGRzVG9UcmFjayA9IFtcbiAgICAnbm9kZXMnLFxuICAgICdlZGdlcycsXG4gICAgJ2RlZmF1bHROb2RlcycsXG4gICAgJ2RlZmF1bHRFZGdlcycsXG4gICAgJ29uQ29ubmVjdCcsXG4gICAgJ29uQ29ubmVjdFN0YXJ0JyxcbiAgICAnb25Db25uZWN0RW5kJyxcbiAgICAnb25DbGlja0Nvbm5lY3RTdGFydCcsXG4gICAgJ29uQ2xpY2tDb25uZWN0RW5kJyxcbiAgICAnbm9kZXNEcmFnZ2FibGUnLFxuICAgICdub2Rlc0Nvbm5lY3RhYmxlJyxcbiAgICAnbm9kZXNGb2N1c2FibGUnLFxuICAgICdlZGdlc0ZvY3VzYWJsZScsXG4gICAgJ2VkZ2VzUmVjb25uZWN0YWJsZScsXG4gICAgJ2VsZXZhdGVOb2Rlc09uU2VsZWN0JyxcbiAgICAnZWxldmF0ZUVkZ2VzT25TZWxlY3QnLFxuICAgICdtaW5ab29tJyxcbiAgICAnbWF4Wm9vbScsXG4gICAgJ25vZGVFeHRlbnQnLFxuICAgICdvbk5vZGVzQ2hhbmdlJyxcbiAgICAnb25FZGdlc0NoYW5nZScsXG4gICAgJ2VsZW1lbnRzU2VsZWN0YWJsZScsXG4gICAgJ2Nvbm5lY3Rpb25Nb2RlJyxcbiAgICAnc25hcEdyaWQnLFxuICAgICdzbmFwVG9HcmlkJyxcbiAgICAndHJhbnNsYXRlRXh0ZW50JyxcbiAgICAnY29ubmVjdE9uQ2xpY2snLFxuICAgICdkZWZhdWx0RWRnZU9wdGlvbnMnLFxuICAgICdmaXRWaWV3JyxcbiAgICAnZml0Vmlld09wdGlvbnMnLFxuICAgICdvbk5vZGVzRGVsZXRlJyxcbiAgICAnb25FZGdlc0RlbGV0ZScsXG4gICAgJ29uRGVsZXRlJyxcbiAgICAnb25Ob2RlRHJhZycsXG4gICAgJ29uTm9kZURyYWdTdGFydCcsXG4gICAgJ29uTm9kZURyYWdTdG9wJyxcbiAgICAnb25TZWxlY3Rpb25EcmFnJyxcbiAgICAnb25TZWxlY3Rpb25EcmFnU3RhcnQnLFxuICAgICdvblNlbGVjdGlvbkRyYWdTdG9wJyxcbiAgICAnb25Nb3ZlU3RhcnQnLFxuICAgICdvbk1vdmUnLFxuICAgICdvbk1vdmVFbmQnLFxuICAgICdub1BhbkNsYXNzTmFtZScsXG4gICAgJ25vZGVPcmlnaW4nLFxuICAgICdhdXRvUGFuT25Db25uZWN0JyxcbiAgICAnYXV0b1Bhbk9uTm9kZURyYWcnLFxuICAgICdvbkVycm9yJyxcbiAgICAnY29ubmVjdGlvblJhZGl1cycsXG4gICAgJ2lzVmFsaWRDb25uZWN0aW9uJyxcbiAgICAnc2VsZWN0Tm9kZXNPbkRyYWcnLFxuICAgICdub2RlRHJhZ1RocmVzaG9sZCcsXG4gICAgJ29uQmVmb3JlRGVsZXRlJyxcbiAgICAnZGVidWcnLFxuICAgICdhdXRvUGFuU3BlZWQnLFxuICAgICdwYW5lQ2xpY2tEaXN0YW5jZScsXG5dO1xuLy8gcmZJZCBkb2Vzbid0IGV4aXN0IGluIFJlYWN0Rmxvd1Byb3BzLCBidXQgaXQncyBvbmUgb2YgdGhlIGZpZWxkcyB3ZSB3YW50IHRvIHVwZGF0ZVxuY29uc3QgZmllbGRzVG9UcmFjayA9IFsuLi5yZWFjdEZsb3dGaWVsZHNUb1RyYWNrLCAncmZJZCddO1xuY29uc3Qgc2VsZWN0b3IkbCA9IChzKSA9PiAoe1xuICAgIHNldE5vZGVzOiBzLnNldE5vZGVzLFxuICAgIHNldEVkZ2VzOiBzLnNldEVkZ2VzLFxuICAgIHNldE1pblpvb206IHMuc2V0TWluWm9vbSxcbiAgICBzZXRNYXhab29tOiBzLnNldE1heFpvb20sXG4gICAgc2V0VHJhbnNsYXRlRXh0ZW50OiBzLnNldFRyYW5zbGF0ZUV4dGVudCxcbiAgICBzZXROb2RlRXh0ZW50OiBzLnNldE5vZGVFeHRlbnQsXG4gICAgcmVzZXQ6IHMucmVzZXQsXG4gICAgc2V0RGVmYXVsdE5vZGVzQW5kRWRnZXM6IHMuc2V0RGVmYXVsdE5vZGVzQW5kRWRnZXMsXG4gICAgc2V0UGFuZUNsaWNrRGlzdGFuY2U6IHMuc2V0UGFuZUNsaWNrRGlzdGFuY2UsXG59KTtcbmNvbnN0IGluaXRQcmV2VmFsdWVzID0ge1xuICAgIC8qXG4gICAgICogdGhlc2UgYXJlIHZhbHVlcyB0aGF0IGFyZSBhbHNvIHBhc3NlZCBkaXJlY3RseSB0byBvdGhlciBjb21wb25lbnRzXG4gICAgICogdGhhbiB0aGUgU3RvcmVVcGRhdGVyLiBXZSBjYW4gcmVkdWNlIHRoZSBudW1iZXIgb2Ygc2V0U3RvcmUgY2FsbHNcbiAgICAgKiBieSBzZXR0aW5nIHRoZSBzYW1lIHZhbHVlcyBoZXJlIGFzIHByZXYgZmllbGRzLlxuICAgICAqL1xuICAgIHRyYW5zbGF0ZUV4dGVudDogaW5maW5pdGVFeHRlbnQsXG4gICAgbm9kZU9yaWdpbjogZGVmYXVsdE5vZGVPcmlnaW4sXG4gICAgbWluWm9vbTogMC41LFxuICAgIG1heFpvb206IDIsXG4gICAgZWxlbWVudHNTZWxlY3RhYmxlOiB0cnVlLFxuICAgIG5vUGFuQ2xhc3NOYW1lOiAnbm9wYW4nLFxuICAgIHJmSWQ6ICcxJyxcbiAgICBwYW5lQ2xpY2tEaXN0YW5jZTogMCxcbn07XG5mdW5jdGlvbiBTdG9yZVVwZGF0ZXIocHJvcHMpIHtcbiAgICBjb25zdCB7IHNldE5vZGVzLCBzZXRFZGdlcywgc2V0TWluWm9vbSwgc2V0TWF4Wm9vbSwgc2V0VHJhbnNsYXRlRXh0ZW50LCBzZXROb2RlRXh0ZW50LCByZXNldCwgc2V0RGVmYXVsdE5vZGVzQW5kRWRnZXMsIHNldFBhbmVDbGlja0Rpc3RhbmNlLCB9ID0gdXNlU3RvcmUoc2VsZWN0b3IkbCwgc2hhbGxvdyk7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHNldERlZmF1bHROb2Rlc0FuZEVkZ2VzKHByb3BzLmRlZmF1bHROb2RlcywgcHJvcHMuZGVmYXVsdEVkZ2VzKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIC8vIHdoZW4gd2UgcmVzZXQgdGhlIHN0b3JlIHdlIGFsc28gbmVlZCB0byByZXNldCB0aGUgcHJldmlvdXMgZmllbGRzXG4gICAgICAgICAgICBwcmV2aW91c0ZpZWxkcy5jdXJyZW50ID0gaW5pdFByZXZWYWx1ZXM7XG4gICAgICAgICAgICByZXNldCgpO1xuICAgICAgICB9O1xuICAgIH0sIFtdKTtcbiAgICBjb25zdCBwcmV2aW91c0ZpZWxkcyA9IHVzZVJlZihpbml0UHJldlZhbHVlcyk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBmaWVsZE5hbWUgb2YgZmllbGRzVG9UcmFjaykge1xuICAgICAgICAgICAgY29uc3QgZmllbGRWYWx1ZSA9IHByb3BzW2ZpZWxkTmFtZV07XG4gICAgICAgICAgICBjb25zdCBwcmV2aW91c0ZpZWxkVmFsdWUgPSBwcmV2aW91c0ZpZWxkcy5jdXJyZW50W2ZpZWxkTmFtZV07XG4gICAgICAgICAgICBpZiAoZmllbGRWYWx1ZSA9PT0gcHJldmlvdXNGaWVsZFZhbHVlKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm9wc1tmaWVsZE5hbWVdID09PSAndW5kZWZpbmVkJylcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIC8vIEN1c3RvbSBoYW5kbGluZyB3aXRoIGRlZGljYXRlZCBzZXR0ZXJzIGZvciBzb21lIGZpZWxkc1xuICAgICAgICAgICAgaWYgKGZpZWxkTmFtZSA9PT0gJ25vZGVzJylcbiAgICAgICAgICAgICAgICBzZXROb2RlcyhmaWVsZFZhbHVlKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGZpZWxkTmFtZSA9PT0gJ2VkZ2VzJylcbiAgICAgICAgICAgICAgICBzZXRFZGdlcyhmaWVsZFZhbHVlKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGZpZWxkTmFtZSA9PT0gJ21pblpvb20nKVxuICAgICAgICAgICAgICAgIHNldE1pblpvb20oZmllbGRWYWx1ZSk7XG4gICAgICAgICAgICBlbHNlIGlmIChmaWVsZE5hbWUgPT09ICdtYXhab29tJylcbiAgICAgICAgICAgICAgICBzZXRNYXhab29tKGZpZWxkVmFsdWUpO1xuICAgICAgICAgICAgZWxzZSBpZiAoZmllbGROYW1lID09PSAndHJhbnNsYXRlRXh0ZW50JylcbiAgICAgICAgICAgICAgICBzZXRUcmFuc2xhdGVFeHRlbnQoZmllbGRWYWx1ZSk7XG4gICAgICAgICAgICBlbHNlIGlmIChmaWVsZE5hbWUgPT09ICdub2RlRXh0ZW50JylcbiAgICAgICAgICAgICAgICBzZXROb2RlRXh0ZW50KGZpZWxkVmFsdWUpO1xuICAgICAgICAgICAgZWxzZSBpZiAoZmllbGROYW1lID09PSAncGFuZUNsaWNrRGlzdGFuY2UnKVxuICAgICAgICAgICAgICAgIHNldFBhbmVDbGlja0Rpc3RhbmNlKGZpZWxkVmFsdWUpO1xuICAgICAgICAgICAgLy8gUmVuYW1lZCBmaWVsZHNcbiAgICAgICAgICAgIGVsc2UgaWYgKGZpZWxkTmFtZSA9PT0gJ2ZpdFZpZXcnKVxuICAgICAgICAgICAgICAgIHN0b3JlLnNldFN0YXRlKHsgZml0Vmlld09uSW5pdDogZmllbGRWYWx1ZSB9KTtcbiAgICAgICAgICAgIGVsc2UgaWYgKGZpZWxkTmFtZSA9PT0gJ2ZpdFZpZXdPcHRpb25zJylcbiAgICAgICAgICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7IGZpdFZpZXdPbkluaXRPcHRpb25zOiBmaWVsZFZhbHVlIH0pO1xuICAgICAgICAgICAgLy8gR2VuZXJhbCBjYXNlXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgc3RvcmUuc2V0U3RhdGUoeyBbZmllbGROYW1lXTogZmllbGRWYWx1ZSB9KTtcbiAgICAgICAgfVxuICAgICAgICBwcmV2aW91c0ZpZWxkcy5jdXJyZW50ID0gcHJvcHM7XG4gICAgfSwgXG4gICAgLy8gT25seSByZS1ydW4gdGhlIGVmZmVjdCBpZiBvbmUgb2YgdGhlIGZpZWxkcyB3ZSB0cmFjayBjaGFuZ2VzXG4gICAgZmllbGRzVG9UcmFjay5tYXAoKGZpZWxkTmFtZSkgPT4gcHJvcHNbZmllbGROYW1lXSkpO1xuICAgIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRNZWRpYVF1ZXJ5KCkge1xuICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyB8fCAhd2luZG93Lm1hdGNoTWVkaWEpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiB3aW5kb3cubWF0Y2hNZWRpYSgnKHByZWZlcnMtY29sb3Itc2NoZW1lOiBkYXJrKScpO1xufVxuLyoqXG4gKiBIb29rIGZvciByZWNlaXZpbmcgdGhlIGN1cnJlbnQgY29sb3IgbW9kZSBjbGFzcyAnZGFyaycgb3IgJ2xpZ2h0Jy5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSBjb2xvck1vZGUgLSBUaGUgY29sb3IgbW9kZSB0byB1c2UgKCdkYXJrJywgJ2xpZ2h0JyBvciAnc3lzdGVtJylcbiAqL1xuZnVuY3Rpb24gdXNlQ29sb3JNb2RlQ2xhc3MoY29sb3JNb2RlKSB7XG4gICAgY29uc3QgW2NvbG9yTW9kZUNsYXNzLCBzZXRDb2xvck1vZGVDbGFzc10gPSB1c2VTdGF0ZShjb2xvck1vZGUgPT09ICdzeXN0ZW0nID8gbnVsbCA6IGNvbG9yTW9kZSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKGNvbG9yTW9kZSAhPT0gJ3N5c3RlbScpIHtcbiAgICAgICAgICAgIHNldENvbG9yTW9kZUNsYXNzKGNvbG9yTW9kZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWVkaWFRdWVyeSA9IGdldE1lZGlhUXVlcnkoKTtcbiAgICAgICAgY29uc3QgdXBkYXRlQ29sb3JNb2RlQ2xhc3MgPSAoKSA9PiBzZXRDb2xvck1vZGVDbGFzcyhtZWRpYVF1ZXJ5Py5tYXRjaGVzID8gJ2RhcmsnIDogJ2xpZ2h0Jyk7XG4gICAgICAgIHVwZGF0ZUNvbG9yTW9kZUNsYXNzKCk7XG4gICAgICAgIG1lZGlhUXVlcnk/LmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHVwZGF0ZUNvbG9yTW9kZUNsYXNzKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIG1lZGlhUXVlcnk/LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHVwZGF0ZUNvbG9yTW9kZUNsYXNzKTtcbiAgICAgICAgfTtcbiAgICB9LCBbY29sb3JNb2RlXSk7XG4gICAgcmV0dXJuIGNvbG9yTW9kZUNsYXNzICE9PSBudWxsID8gY29sb3JNb2RlQ2xhc3MgOiBnZXRNZWRpYVF1ZXJ5KCk/Lm1hdGNoZXMgPyAnZGFyaycgOiAnbGlnaHQnO1xufVxuXG5jb25zdCBkZWZhdWx0RG9jID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyA/IGRvY3VtZW50IDogbnVsbDtcbi8qKlxuICogVGhpcyBob29rIGxldHMgeW91IGxpc3RlbiBmb3Igc3BlY2lmaWMga2V5IGNvZGVzIGFuZCB0ZWxscyB5b3Ugd2hldGhlciB0aGV5IGFyZVxuICogY3VycmVudGx5IHByZXNzZWQgb3Igbm90LlxuICpcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSBwYXJhbS5rZXlDb2RlIC0gVGhlIGtleSBjb2RlIChzdHJpbmcgb3IgYXJyYXkgb2Ygc3RyaW5ncykgdG8gdXNlXG4gKiBAcGFyYW0gcGFyYW0ub3B0aW9ucyAtIE9wdGlvbnNcbiAqIEByZXR1cm5zIGJvb2xlYW5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHN4XG4gKmltcG9ydCB7IHVzZUtleVByZXNzIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoKSB7XG4gKiAgY29uc3Qgc3BhY2VQcmVzc2VkID0gdXNlS2V5UHJlc3MoJ1NwYWNlJyk7XG4gKiAgY29uc3QgY21kQW5kU1ByZXNzZWQgPSB1c2VLZXlQcmVzcyhbJ01ldGErcycsICdTdHJnK3MnXSk7XG4gKlxuICogIHJldHVybiAoXG4gKiAgICA8ZGl2PlxuICogICAgIHtzcGFjZVByZXNzZWQgJiYgPHA+U3BhY2UgcHJlc3NlZCE8L3A+fVxuICogICAgIHtjbWRBbmRTUHJlc3NlZCAmJiA8cD5DbWQgKyBTIHByZXNzZWQhPC9wPn1cbiAqICAgIDwvZGl2PlxuICogICk7XG4gKn1cbiAqYGBgXG4gKi9cbmZ1bmN0aW9uIHVzZUtleVByZXNzKFxuLypcbiAqIHRoZSBrZXljb2RlIGNhbiBiZSBhIHN0cmluZyAnYScgb3IgYW4gYXJyYXkgb2Ygc3RyaW5ncyBbJ2EnLCAnYStkJ11cbiAqIGEgc3RyaW5nIG1lYW5zIGEgc2luZ2xlIGtleSAnYScgb3IgYSBjb21iaW5hdGlvbiB3aGVuICcrJyBpcyB1c2VkICdhK2QnXG4gKiBhbiBhcnJheSBtZWFucyBkaWZmZXJlbnQgcG9zc2liaWxpdGVzLiBFeHBsYWluZXI6IFsnYScsICdkK3MnXSBoZXJlIHRoZVxuICogdXNlciBjYW4gdXNlIHRoZSBzaW5nbGUga2V5ICdhJyBvciB0aGUgY29tYmluYXRpb24gJ2QnICsgJ3MnXG4gKi9cbmtleUNvZGUgPSBudWxsLCBvcHRpb25zID0geyB0YXJnZXQ6IGRlZmF1bHREb2MsIGFjdEluc2lkZUlucHV0V2l0aE1vZGlmaWVyOiB0cnVlIH0pIHtcbiAgICBjb25zdCBba2V5UHJlc3NlZCwgc2V0S2V5UHJlc3NlZF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gICAgLy8gd2UgbmVlZCB0byByZW1lbWJlciBpZiBhIG1vZGlmaWVyIGtleSBpcyBwcmVzc2VkIGluIG9yZGVyIHRvIHRyYWNrIGl0XG4gICAgY29uc3QgbW9kaWZpZXJQcmVzc2VkID0gdXNlUmVmKGZhbHNlKTtcbiAgICAvLyB3ZSBuZWVkIHRvIHJlbWVtYmVyIHRoZSBwcmVzc2VkIGtleXMgaW4gb3JkZXIgdG8gc3VwcG9ydCBjb21iaW5hdGlvbnNcbiAgICBjb25zdCBwcmVzc2VkS2V5cyA9IHVzZVJlZihuZXcgU2V0KFtdKSk7XG4gICAgLypcbiAgICAgKiBrZXlDb2RlcyA9IGFycmF5IHdpdGggc2luZ2xlIGtleXMgW1snYSddXSBvciBrZXkgY29tYmluYXRpb25zIFtbJ2EnLCAncyddXVxuICAgICAqIGtleXNUb1dhdGNoID0gYXJyYXkgd2l0aCBhbGwga2V5cyBmbGF0dGVuZWQgWydhJywgJ2QnLCAnU2hpZnRMZWZ0J11cbiAgICAgKiB1c2VkIHRvIGNoZWNrIGlmIHdlIHN0b3JlIGV2ZW50LmNvZGUgb3IgZXZlbnQua2V5LiBXaGVuIHRoZSBjb2RlIGlzIGluIHRoZSBsaXN0IG9mIGtleXNUb1dhdGNoXG4gICAgICogd2UgdXNlIHRoZSBjb2RlIG90aGVyd2lzZSB0aGUga2V5LiBFeHBsYWluZXI6IFdoZW4geW91IHByZXNzIHRoZSBsZWZ0IFwiY29tbWFuZFwiIGtleSwgdGhlIGNvZGUgaXMgXCJNZXRhTGVmdFwiXG4gICAgICogYW5kIHRoZSBrZXkgaXMgXCJNZXRhXCIuIFdlIHdhbnQgdXNlcnMgdG8gYmUgYWJsZSB0byBwYXNzIGtleXMgYW5kIGNvZGVzIHNvIHdlIGFzc3VtZSB0aGF0IHRoZSBrZXkgaXMgbWVhbnQgd2hlblxuICAgICAqIHdlIGNhbid0IGZpbmQgaXQgaW4gdGhlIGxpc3Qgb2Yga2V5c1RvV2F0Y2guXG4gICAgICovXG4gICAgY29uc3QgW2tleUNvZGVzLCBrZXlzVG9XYXRjaF0gPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgaWYgKGtleUNvZGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleUNvZGVBcnIgPSBBcnJheS5pc0FycmF5KGtleUNvZGUpID8ga2V5Q29kZSA6IFtrZXlDb2RlXTtcbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSBrZXlDb2RlQXJyXG4gICAgICAgICAgICAgICAgLmZpbHRlcigoa2MpID0+IHR5cGVvZiBrYyA9PT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiB3ZSBmaXJzdCByZXBsYWNlIGFsbCAnKycgd2l0aCAnXFxuJyAgd2hpY2ggd2Ugd2lsbCB1c2UgdG8gc3BsaXQgdGhlIGtleXMgb25cbiAgICAgICAgICAgICAgICAgKiB0aGVuIHdlIHJlcGxhY2UgJ1xcblxcbicgd2l0aCAnXFxuKycsIHRoaXMgd2F5IHdlIGNhbiBhbHNvIHN1cHBvcnQgdGhlIGNvbWJpbmF0aW9uICdrZXkrKydcbiAgICAgICAgICAgICAgICAgKiBpbiB0aGUgZW5kIHdlIHNpbXBseSBzcGxpdCBvbiAnXFxuJyB0byBnZXQgdGhlIGtleSBhcnJheVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIC5tYXAoKGtjKSA9PiBrYy5yZXBsYWNlKCcrJywgJ1xcbicpLnJlcGxhY2UoJ1xcblxcbicsICdcXG4rJykuc3BsaXQoJ1xcbicpKTtcbiAgICAgICAgICAgIGNvbnN0IGtleXNGbGF0ID0ga2V5cy5yZWR1Y2UoKHJlcywgaXRlbSkgPT4gcmVzLmNvbmNhdCguLi5pdGVtKSwgW10pO1xuICAgICAgICAgICAgcmV0dXJuIFtrZXlzLCBrZXlzRmxhdF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtbXSwgW11dO1xuICAgIH0sIFtrZXlDb2RlXSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gb3B0aW9ucz8udGFyZ2V0IHx8IGRlZmF1bHREb2M7XG4gICAgICAgIGlmIChrZXlDb2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBkb3duSGFuZGxlciA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIG1vZGlmaWVyUHJlc3NlZC5jdXJyZW50ID0gZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5IHx8IGV2ZW50LnNoaWZ0S2V5O1xuICAgICAgICAgICAgICAgIGNvbnN0IHByZXZlbnRBY3Rpb24gPSAoIW1vZGlmaWVyUHJlc3NlZC5jdXJyZW50IHx8IChtb2RpZmllclByZXNzZWQuY3VycmVudCAmJiAhb3B0aW9ucy5hY3RJbnNpZGVJbnB1dFdpdGhNb2RpZmllcikpICYmXG4gICAgICAgICAgICAgICAgICAgIGlzSW5wdXRET01Ob2RlKGV2ZW50KTtcbiAgICAgICAgICAgICAgICBpZiAocHJldmVudEFjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGtleU9yQ29kZSA9IHVzZUtleU9yQ29kZShldmVudC5jb2RlLCBrZXlzVG9XYXRjaCk7XG4gICAgICAgICAgICAgICAgcHJlc3NlZEtleXMuY3VycmVudC5hZGQoZXZlbnRba2V5T3JDb2RlXSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzTWF0Y2hpbmdLZXkoa2V5Q29kZXMsIHByZXNzZWRLZXlzLmN1cnJlbnQsIGZhbHNlKSkge1xuICAgICAgICAgICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBzZXRLZXlQcmVzc2VkKHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCB1cEhhbmRsZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2ZW50QWN0aW9uID0gKCFtb2RpZmllclByZXNzZWQuY3VycmVudCB8fCAobW9kaWZpZXJQcmVzc2VkLmN1cnJlbnQgJiYgIW9wdGlvbnMuYWN0SW5zaWRlSW5wdXRXaXRoTW9kaWZpZXIpKSAmJlxuICAgICAgICAgICAgICAgICAgICBpc0lucHV0RE9NTm9kZShldmVudCk7XG4gICAgICAgICAgICAgICAgaWYgKHByZXZlbnRBY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBrZXlPckNvZGUgPSB1c2VLZXlPckNvZGUoZXZlbnQuY29kZSwga2V5c1RvV2F0Y2gpO1xuICAgICAgICAgICAgICAgIGlmIChpc01hdGNoaW5nS2V5KGtleUNvZGVzLCBwcmVzc2VkS2V5cy5jdXJyZW50LCB0cnVlKSkge1xuICAgICAgICAgICAgICAgICAgICBzZXRLZXlQcmVzc2VkKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgcHJlc3NlZEtleXMuY3VycmVudC5jbGVhcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlc3NlZEtleXMuY3VycmVudC5kZWxldGUoZXZlbnRba2V5T3JDb2RlXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGZpeCBmb3IgTWFjOiB3aGVuIGNtZCBrZXkgaXMgcHJlc3NlZCwga2V5dXAgaXMgbm90IHRyaWdnZXJlZCBmb3IgYW55IG90aGVyIGtleSwgc2VlOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yNzM4MDAxOC93aGVuLWNtZC1rZXktaXMta2VwdC1wcmVzc2VkLWtleXVwLWlzLW5vdC10cmlnZ2VyZWQtZm9yLWFueS1vdGhlci1rZXlcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQua2V5ID09PSAnTWV0YScpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlc3NlZEtleXMuY3VycmVudC5jbGVhcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtb2RpZmllclByZXNzZWQuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IHJlc2V0SGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBwcmVzc2VkS2V5cy5jdXJyZW50LmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgc2V0S2V5UHJlc3NlZChmYWxzZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGFyZ2V0Py5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZG93bkhhbmRsZXIpO1xuICAgICAgICAgICAgdGFyZ2V0Py5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIHVwSGFuZGxlcik7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIHJlc2V0SGFuZGxlcik7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCByZXNldEhhbmRsZXIpO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICB0YXJnZXQ/LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBkb3duSGFuZGxlcik7XG4gICAgICAgICAgICAgICAgdGFyZ2V0Py5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXl1cCcsIHVwSGFuZGxlcik7XG4gICAgICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2JsdXInLCByZXNldEhhbmRsZXIpO1xuICAgICAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIHJlc2V0SGFuZGxlcik7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSwgW2tleUNvZGUsIHNldEtleVByZXNzZWRdKTtcbiAgICByZXR1cm4ga2V5UHJlc3NlZDtcbn1cbi8vIHV0aWxzXG5mdW5jdGlvbiBpc01hdGNoaW5nS2V5KGtleUNvZGVzLCBwcmVzc2VkS2V5cywgaXNVcCkge1xuICAgIHJldHVybiAoa2V5Q29kZXNcbiAgICAgICAgLypcbiAgICAgICAgICogd2Ugb25seSB3YW50IHRvIGNvbXBhcmUgc2FtZSBzaXplcyBvZiBrZXlDb2RlIGRlZmluaXRpb25zXG4gICAgICAgICAqIGFuZCBwcmVzc2VkIGtleXMuIFdoZW4gdGhlIHVzZXIgc3BlY2lmaWVkICdNZXRhJyBhcyBhIGtleSBzb21ld2hlcmVcbiAgICAgICAgICogdGhpcyB3b3VsZCBhbHNvIGJlIHRydXRoeSB3aXRob3V0IHRoaXMgZmlsdGVyIHdoZW4gdXNlciBwcmVzc2VzICdNZXRhJyArICdyJ1xuICAgICAgICAgKi9cbiAgICAgICAgLmZpbHRlcigoa2V5cykgPT4gaXNVcCB8fCBrZXlzLmxlbmd0aCA9PT0gcHJlc3NlZEtleXMuc2l6ZSlcbiAgICAgICAgLypcbiAgICAgICAgICogc2luY2Ugd2Ugd2FudCB0byBzdXBwb3J0IG11bHRpcGxlIHBvc3NpYmlsaXRpZXMgb25seSBvbmUgb2YgdGhlXG4gICAgICAgICAqIGNvbWJpbmF0aW9ucyBuZWVkIHRvIGJlIHBhcnQgb2YgdGhlIHByZXNzZWQga2V5c1xuICAgICAgICAgKi9cbiAgICAgICAgLnNvbWUoKGtleXMpID0+IGtleXMuZXZlcnkoKGspID0+IHByZXNzZWRLZXlzLmhhcyhrKSkpKTtcbn1cbmZ1bmN0aW9uIHVzZUtleU9yQ29kZShldmVudENvZGUsIGtleXNUb1dhdGNoKSB7XG4gICAgcmV0dXJuIGtleXNUb1dhdGNoLmluY2x1ZGVzKGV2ZW50Q29kZSkgPyAnY29kZScgOiAna2V5Jztcbn1cblxuLyoqXG4gKiBIb29rIGZvciBnZXR0aW5nIHZpZXdwb3J0IGhlbHBlciBmdW5jdGlvbnMuXG4gKlxuICogQGludGVybmFsXG4gKiBAcmV0dXJucyB2aWV3cG9ydCBoZWxwZXIgZnVuY3Rpb25zXG4gKi9cbmNvbnN0IHVzZVZpZXdwb3J0SGVscGVyID0gKCkgPT4ge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICByZXR1cm4gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB6b29tSW46IChvcHRpb25zKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwYW5ab29tIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBwYW5ab29tID8gcGFuWm9vbS5zY2FsZUJ5KDEuMiwgeyBkdXJhdGlvbjogb3B0aW9ucz8uZHVyYXRpb24gfSkgOiBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHpvb21PdXQ6IChvcHRpb25zKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBwYW5ab29tIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBwYW5ab29tID8gcGFuWm9vbS5zY2FsZUJ5KDEgLyAxLjIsIHsgZHVyYXRpb246IG9wdGlvbnM/LmR1cmF0aW9uIH0pIDogUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB6b29tVG86ICh6b29tTGV2ZWwsIG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHBhblpvb20gfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBhblpvb20gPyBwYW5ab29tLnNjYWxlVG8oem9vbUxldmVsLCB7IGR1cmF0aW9uOiBvcHRpb25zPy5kdXJhdGlvbiB9KSA6IFByb21pc2UucmVzb2x2ZShmYWxzZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0Wm9vbTogKCkgPT4gc3RvcmUuZ2V0U3RhdGUoKS50cmFuc2Zvcm1bMl0sXG4gICAgICAgICAgICBzZXRWaWV3cG9ydDogYXN5bmMgKHZpZXdwb3J0LCBvcHRpb25zKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB0cmFuc2Zvcm06IFt0WCwgdFksIHRab29tXSwgcGFuWm9vbSwgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgaWYgKCFwYW5ab29tKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBhd2FpdCBwYW5ab29tLnNldFZpZXdwb3J0KHtcbiAgICAgICAgICAgICAgICAgICAgeDogdmlld3BvcnQueCA/PyB0WCxcbiAgICAgICAgICAgICAgICAgICAgeTogdmlld3BvcnQueSA/PyB0WSxcbiAgICAgICAgICAgICAgICAgICAgem9vbTogdmlld3BvcnQuem9vbSA/PyB0Wm9vbSxcbiAgICAgICAgICAgICAgICB9LCB7IGR1cmF0aW9uOiBvcHRpb25zPy5kdXJhdGlvbiB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRydWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldFZpZXdwb3J0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgW3gsIHksIHpvb21dID0gc3RvcmUuZ2V0U3RhdGUoKS50cmFuc2Zvcm07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgeCwgeSwgem9vbSB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZpdFZpZXc6IChvcHRpb25zKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBub2RlTG9va3VwLCBtaW5ab29tLCBtYXhab29tLCBwYW5ab29tLCBkb21Ob2RlIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIGlmICghcGFuWm9vbSB8fCAhZG9tTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZml0Vmlld05vZGVzID0gZ2V0Rml0Vmlld05vZGVzKG5vZGVMb29rdXAsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gZ2V0RGltZW5zaW9ucyhkb21Ob2RlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZml0Vmlldyh7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzOiBmaXRWaWV3Tm9kZXMsXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgIG1pblpvb20sXG4gICAgICAgICAgICAgICAgICAgIG1heFpvb20sXG4gICAgICAgICAgICAgICAgICAgIHBhblpvb20sXG4gICAgICAgICAgICAgICAgfSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0Q2VudGVyOiBhc3luYyAoeCwgeSwgb3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCwgbWF4Wm9vbSwgcGFuWm9vbSB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0Wm9vbSA9IHR5cGVvZiBvcHRpb25zPy56b29tICE9PSAndW5kZWZpbmVkJyA/IG9wdGlvbnMuem9vbSA6IG1heFpvb207XG4gICAgICAgICAgICAgICAgY29uc3QgY2VudGVyWCA9IHdpZHRoIC8gMiAtIHggKiBuZXh0Wm9vbTtcbiAgICAgICAgICAgICAgICBjb25zdCBjZW50ZXJZID0gaGVpZ2h0IC8gMiAtIHkgKiBuZXh0Wm9vbTtcbiAgICAgICAgICAgICAgICBpZiAoIXBhblpvb20pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGF3YWl0IHBhblpvb20uc2V0Vmlld3BvcnQoe1xuICAgICAgICAgICAgICAgICAgICB4OiBjZW50ZXJYLFxuICAgICAgICAgICAgICAgICAgICB5OiBjZW50ZXJZLFxuICAgICAgICAgICAgICAgICAgICB6b29tOiBuZXh0Wm9vbSxcbiAgICAgICAgICAgICAgICB9LCB7IGR1cmF0aW9uOiBvcHRpb25zPy5kdXJhdGlvbiB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRydWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZpdEJvdW5kczogYXN5bmMgKGJvdW5kcywgb3B0aW9ucykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCwgbWluWm9vbSwgbWF4Wm9vbSwgcGFuWm9vbSB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgICAgICBjb25zdCB2aWV3cG9ydCA9IGdldFZpZXdwb3J0Rm9yQm91bmRzKGJvdW5kcywgd2lkdGgsIGhlaWdodCwgbWluWm9vbSwgbWF4Wm9vbSwgb3B0aW9ucz8ucGFkZGluZyA/PyAwLjEpO1xuICAgICAgICAgICAgICAgIGlmICghcGFuWm9vbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXdhaXQgcGFuWm9vbS5zZXRWaWV3cG9ydCh2aWV3cG9ydCwgeyBkdXJhdGlvbjogb3B0aW9ucz8uZHVyYXRpb24gfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0cnVlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzY3JlZW5Ub0Zsb3dQb3NpdGlvbjogKGNsaWVudFBvc2l0aW9uLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHRyYW5zZm9ybSwgc25hcEdyaWQsIHNuYXBUb0dyaWQsIGRvbU5vZGUgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgaWYgKCFkb21Ob2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjbGllbnRQb3NpdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgeyB4OiBkb21YLCB5OiBkb21ZIH0gPSBkb21Ob2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvcnJlY3RlZFBvc2l0aW9uID0ge1xuICAgICAgICAgICAgICAgICAgICB4OiBjbGllbnRQb3NpdGlvbi54IC0gZG9tWCxcbiAgICAgICAgICAgICAgICAgICAgeTogY2xpZW50UG9zaXRpb24ueSAtIGRvbVksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBjb25zdCBfc25hcEdyaWQgPSBvcHRpb25zLnNuYXBHcmlkID8/IHNuYXBHcmlkO1xuICAgICAgICAgICAgICAgIGNvbnN0IF9zbmFwVG9HcmlkID0gb3B0aW9ucy5zbmFwVG9HcmlkID8/IHNuYXBUb0dyaWQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBvaW50VG9SZW5kZXJlclBvaW50KGNvcnJlY3RlZFBvc2l0aW9uLCB0cmFuc2Zvcm0sIF9zbmFwVG9HcmlkLCBfc25hcEdyaWQpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZsb3dUb1NjcmVlblBvc2l0aW9uOiAoZmxvd1Bvc2l0aW9uKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB0cmFuc2Zvcm0sIGRvbU5vZGUgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgaWYgKCFkb21Ob2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmbG93UG9zaXRpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHsgeDogZG9tWCwgeTogZG9tWSB9ID0gZG9tTm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZW5kZXJlclBvc2l0aW9uID0gcmVuZGVyZXJQb2ludFRvUG9pbnQoZmxvd1Bvc2l0aW9uLCB0cmFuc2Zvcm0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHg6IHJlbmRlcmVyUG9zaXRpb24ueCArIGRvbVgsXG4gICAgICAgICAgICAgICAgICAgIHk6IHJlbmRlcmVyUG9zaXRpb24ueSArIGRvbVksXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfSwgW10pO1xufTtcblxuLypcbiAqIFRoaXMgZnVuY3Rpb24gYXBwbGllcyBjaGFuZ2VzIHRvIG5vZGVzIG9yIGVkZ2VzIHRoYXQgYXJlIHRyaWdnZXJlZCBieSBSZWFjdCBGbG93IGludGVybmFsbHkuXG4gKiBXaGVuIHlvdSBkcmFnIGEgbm9kZSBmb3IgZXhhbXBsZSwgUmVhY3QgRmxvdyB3aWxsIHNlbmQgYSBwb3NpdGlvbiBjaGFuZ2UgdXBkYXRlLlxuICogVGhpcyBmdW5jdGlvbiB0aGVuIGFwcGxpZXMgdGhlIGNoYW5nZXMgYW5kIHJldHVybnMgdGhlIHVwZGF0ZWQgZWxlbWVudHMuXG4gKi9cbmZ1bmN0aW9uIGFwcGx5Q2hhbmdlcyhjaGFuZ2VzLCBlbGVtZW50cykge1xuICAgIGNvbnN0IHVwZGF0ZWRFbGVtZW50cyA9IFtdO1xuICAgIC8qXG4gICAgICogQnkgc3RvcmluZyBhIG1hcCBvZiBjaGFuZ2VzIGZvciBlYWNoIGVsZW1lbnQsIHdlIGNhbiBhIHF1aWNrIGxvb2t1cCBhcyB3ZVxuICAgICAqIGl0ZXJhdGUgb3ZlciB0aGUgZWxlbWVudHMgYXJyYXkhXG4gICAgICovXG4gICAgY29uc3QgY2hhbmdlc01hcCA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBhZGRJdGVtQ2hhbmdlcyA9IFtdO1xuICAgIGZvciAoY29uc3QgY2hhbmdlIG9mIGNoYW5nZXMpIHtcbiAgICAgICAgaWYgKGNoYW5nZS50eXBlID09PSAnYWRkJykge1xuICAgICAgICAgICAgYWRkSXRlbUNoYW5nZXMucHVzaChjaGFuZ2UpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2hhbmdlLnR5cGUgPT09ICdyZW1vdmUnIHx8IGNoYW5nZS50eXBlID09PSAncmVwbGFjZScpIHtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBGb3IgYSAncmVtb3ZlJyBjaGFuZ2Ugd2UgY2FuIHNhZmVseSBpZ25vcmUgYW55IG90aGVyIGNoYW5nZXMgcXVldWVkIGZvclxuICAgICAgICAgICAgICogdGhlIHNhbWUgZWxlbWVudCwgaXQncyBnb2luZyB0byBiZSByZW1vdmVkIGFueXdheSFcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY2hhbmdlc01hcC5zZXQoY2hhbmdlLmlkLCBbY2hhbmdlXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50Q2hhbmdlcyA9IGNoYW5nZXNNYXAuZ2V0KGNoYW5nZS5pZCk7XG4gICAgICAgICAgICBpZiAoZWxlbWVudENoYW5nZXMpIHtcbiAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAqIElmIHdlIGhhdmUgc29tZSBjaGFuZ2VzIHF1ZXVlZCBhbHJlYWR5LCB3ZSBjYW4gZG8gYSBtdXRhYmxlIHVwZGF0ZSBvZlxuICAgICAgICAgICAgICAgICAqIHRoYXQgYXJyYXkgYW5kIHNhdmUgb3Vyc2VsdmVzIHNvbWUgY29weWluZy5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBlbGVtZW50Q2hhbmdlcy5wdXNoKGNoYW5nZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VzTWFwLnNldChjaGFuZ2UuaWQsIFtjaGFuZ2VdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgZWxlbWVudHMpIHtcbiAgICAgICAgY29uc3QgY2hhbmdlcyA9IGNoYW5nZXNNYXAuZ2V0KGVsZW1lbnQuaWQpO1xuICAgICAgICAvKlxuICAgICAgICAgKiBXaGVuIHRoZXJlIGFyZSBubyBjaGFuZ2VzIGZvciBhbiBlbGVtZW50IHdlIGNhbiBqdXN0IHB1c2ggaXQgdW5tb2RpZmllZCxcbiAgICAgICAgICogbm8gbmVlZCB0byBjb3B5IGl0LlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKCFjaGFuZ2VzKSB7XG4gICAgICAgICAgICB1cGRhdGVkRWxlbWVudHMucHVzaChlbGVtZW50KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIGhhdmUgYSAncmVtb3ZlJyBjaGFuZ2UgcXVldWVkLCBpdCdsbCBiZSB0aGUgb25seSBjaGFuZ2UgaW4gdGhlIGFycmF5XG4gICAgICAgIGlmIChjaGFuZ2VzWzBdLnR5cGUgPT09ICdyZW1vdmUnKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhbmdlc1swXS50eXBlID09PSAncmVwbGFjZScpIHtcbiAgICAgICAgICAgIHVwZGF0ZWRFbGVtZW50cy5wdXNoKHsgLi4uY2hhbmdlc1swXS5pdGVtIH0pO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZvciBvdGhlciB0eXBlcyBvZiBjaGFuZ2VzLCB3ZSB3YW50IHRvIHN0YXJ0IHdpdGggYSBzaGFsbG93IGNvcHkgb2YgdGhlXG4gICAgICAgICAqIG9iamVjdCBzbyBSZWFjdCBrbm93cyB0aGlzIGVsZW1lbnQgaGFzIGNoYW5nZWQuIFNlcXVlbnRpYWwgY2hhbmdlcyB3aWxsXG4gICAgICAgICAqIGVhY2ggX211dGF0ZV8gdGhpcyBvYmplY3QsIHNvIHRoZXJlJ3Mgb25seSBldmVyIG9uZSBjb3B5LlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgdXBkYXRlZEVsZW1lbnQgPSB7IC4uLmVsZW1lbnQgfTtcbiAgICAgICAgZm9yIChjb25zdCBjaGFuZ2Ugb2YgY2hhbmdlcykge1xuICAgICAgICAgICAgYXBwbHlDaGFuZ2UoY2hhbmdlLCB1cGRhdGVkRWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlZEVsZW1lbnRzLnB1c2godXBkYXRlZEVsZW1lbnQpO1xuICAgIH1cbiAgICAvKlxuICAgICAqIHdlIG5lZWQgdG8gd2FpdCBmb3IgYWxsIGNoYW5nZXMgdG8gYmUgYXBwbGllZCBiZWZvcmUgYWRkaW5nIG5ldyBpdGVtc1xuICAgICAqIHRvIGJlIGFibGUgdG8gYWRkIHRoZW0gYXQgdGhlIGNvcnJlY3QgaW5kZXhcbiAgICAgKi9cbiAgICBpZiAoYWRkSXRlbUNoYW5nZXMubGVuZ3RoKSB7XG4gICAgICAgIGFkZEl0ZW1DaGFuZ2VzLmZvckVhY2goKGNoYW5nZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGNoYW5nZS5pbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlZEVsZW1lbnRzLnNwbGljZShjaGFuZ2UuaW5kZXgsIDAsIHsgLi4uY2hhbmdlLml0ZW0gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVkRWxlbWVudHMucHVzaCh7IC4uLmNoYW5nZS5pdGVtIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHVwZGF0ZWRFbGVtZW50cztcbn1cbi8vIEFwcGxpZXMgYSBzaW5nbGUgY2hhbmdlIHRvIGFuIGVsZW1lbnQuIFRoaXMgaXMgYSAqbXV0YWJsZSogdXBkYXRlLlxuZnVuY3Rpb24gYXBwbHlDaGFuZ2UoY2hhbmdlLCBlbGVtZW50KSB7XG4gICAgc3dpdGNoIChjaGFuZ2UudHlwZSkge1xuICAgICAgICBjYXNlICdzZWxlY3QnOiB7XG4gICAgICAgICAgICBlbGVtZW50LnNlbGVjdGVkID0gY2hhbmdlLnNlbGVjdGVkO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAncG9zaXRpb24nOiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNoYW5nZS5wb3NpdGlvbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBlbGVtZW50LnBvc2l0aW9uID0gY2hhbmdlLnBvc2l0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjaGFuZ2UuZHJhZ2dpbmcgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5kcmFnZ2luZyA9IGNoYW5nZS5kcmFnZ2luZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2RpbWVuc2lvbnMnOiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNoYW5nZS5kaW1lbnNpb25zICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGVsZW1lbnQubWVhc3VyZWQgPz89IHt9O1xuICAgICAgICAgICAgICAgIGVsZW1lbnQubWVhc3VyZWQud2lkdGggPSBjaGFuZ2UuZGltZW5zaW9ucy53aWR0aDtcbiAgICAgICAgICAgICAgICBlbGVtZW50Lm1lYXN1cmVkLmhlaWdodCA9IGNoYW5nZS5kaW1lbnNpb25zLmhlaWdodDtcbiAgICAgICAgICAgICAgICBpZiAoY2hhbmdlLnNldEF0dHJpYnV0ZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC53aWR0aCA9IGNoYW5nZS5kaW1lbnNpb25zLndpZHRoO1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LmhlaWdodCA9IGNoYW5nZS5kaW1lbnNpb25zLmhlaWdodDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNoYW5nZS5yZXNpemluZyA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudC5yZXNpemluZyA9IGNoYW5nZS5yZXNpemluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxufVxuLyoqXG4gKiBEcm9wIGluIGZ1bmN0aW9uIHRoYXQgYXBwbGllcyBub2RlIGNoYW5nZXMgdG8gYW4gYXJyYXkgb2Ygbm9kZXMuXG4gKiBAcHVibGljXG4gKiBAcGFyYW0gY2hhbmdlcyAtIEFycmF5IG9mIGNoYW5nZXMgdG8gYXBwbHlcbiAqIEBwYXJhbSBub2RlcyAtIEFycmF5IG9mIG5vZGVzIHRvIGFwcGx5IHRoZSBjaGFuZ2VzIHRvXG4gKiBAcmV0dXJucyBBcnJheSBvZiB1cGRhdGVkIG5vZGVzXG4gKiBAZXhhbXBsZVxuICpgYGB0c3hcbiAqaW1wb3J0IHsgdXNlU3RhdGUsIHVzZUNhbGxiYWNrIH0gZnJvbSAncmVhY3QnO1xuICppbXBvcnQgeyBSZWFjdEZsb3csIGFwcGx5Tm9kZUNoYW5nZXMsIHR5cGUgTm9kZSwgdHlwZSBFZGdlLCB0eXBlIE9uTm9kZXNDaGFuZ2UgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEZsb3coKSB7XG4gKiAgY29uc3QgW25vZGVzLCBzZXROb2Rlc10gPSB1c2VTdGF0ZTxOb2RlW10+KFtdKTtcbiAqICBjb25zdCBbZWRnZXMsIHNldEVkZ2VzXSA9IHVzZVN0YXRlPEVkZ2VbXT4oW10pO1xuICogIGNvbnN0IG9uTm9kZXNDaGFuZ2U6IE9uTm9kZXNDaGFuZ2UgPSB1c2VDYWxsYmFjayhcbiAqICAgIChjaGFuZ2VzKSA9PiB7XG4gKiAgICAgIHNldE5vZGVzKChvbGROb2RlcykgPT4gYXBwbHlOb2RlQ2hhbmdlcyhjaGFuZ2VzLCBvbGROb2RlcykpO1xuICogICAgfSxcbiAqICAgIFtzZXROb2Rlc10sXG4gKiAgKTtcbiAqXG4gKiAgcmV0dXJuIChcbiAqICAgIDxSZWFjdEZsb3cgbm9kZXM9e25vZGVzfSBlZGdlcz17ZWRnZXN9IG9uTm9kZXNDaGFuZ2U9e29uTm9kZXNDaGFuZ2V9IC8+XG4gKiAgKTtcbiAqfVxuICpgYGBcbiAqIEByZW1hcmtzIFZhcmlvdXMgZXZlbnRzIG9uIHRoZSA8UmVhY3RGbG93IC8+IGNvbXBvbmVudCBjYW4gcHJvZHVjZSBhbiB7QGxpbmsgTm9kZUNoYW5nZX1cbiAqIHRoYXQgZGVzY3JpYmVzIGhvdyB0byB1cGRhdGUgdGhlIGVkZ2VzIG9mIHlvdXIgZmxvdyBpbiBzb21lIHdheS5cbiAqIElmIHlvdSBkb24ndCBuZWVkIGFueSBjdXN0b20gYmVoYXZpb3VyLCB0aGlzIHV0aWwgY2FuIGJlIHVzZWQgdG8gdGFrZSBhbiBhcnJheVxuICogb2YgdGhlc2UgY2hhbmdlcyBhbmQgYXBwbHkgdGhlbSB0byB5b3VyIGVkZ2VzLlxuICovXG5mdW5jdGlvbiBhcHBseU5vZGVDaGFuZ2VzKGNoYW5nZXMsIG5vZGVzKSB7XG4gICAgcmV0dXJuIGFwcGx5Q2hhbmdlcyhjaGFuZ2VzLCBub2Rlcyk7XG59XG4vKipcbiAqIERyb3AgaW4gZnVuY3Rpb24gdGhhdCBhcHBsaWVzIGVkZ2UgY2hhbmdlcyB0byBhbiBhcnJheSBvZiBlZGdlcy5cbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSBjaGFuZ2VzIC0gQXJyYXkgb2YgY2hhbmdlcyB0byBhcHBseVxuICogQHBhcmFtIGVkZ2VzIC0gQXJyYXkgb2YgZWRnZSB0byBhcHBseSB0aGUgY2hhbmdlcyB0b1xuICogQHJldHVybnMgQXJyYXkgb2YgdXBkYXRlZCBlZGdlc1xuICogQGV4YW1wbGVcbiAqIGBgYHRzeFxuICppbXBvcnQgeyB1c2VTdGF0ZSwgdXNlQ2FsbGJhY2sgfSBmcm9tICdyZWFjdCc7XG4gKmltcG9ydCB7IFJlYWN0RmxvdywgYXBwbHlFZGdlQ2hhbmdlcyB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRmxvdygpIHtcbiAqICBjb25zdCBbbm9kZXMsIHNldE5vZGVzXSA9IHVzZVN0YXRlKFtdKTtcbiAqICBjb25zdCBbZWRnZXMsIHNldEVkZ2VzXSA9IHVzZVN0YXRlKFtdKTtcbiAqICBjb25zdCBvbkVkZ2VzQ2hhbmdlID0gdXNlQ2FsbGJhY2soXG4gKiAgICAoY2hhbmdlcykgPT4ge1xuICogICAgICBzZXRFZGdlcygob2xkRWRnZXMpID0+IGFwcGx5RWRnZUNoYW5nZXMoY2hhbmdlcywgb2xkRWRnZXMpKTtcbiAqICAgIH0sXG4gKiAgICBbc2V0RWRnZXNdLFxuICogICk7XG4gKlxuICogIHJldHVybiAoXG4gKiAgICA8UmVhY3RGbG93IG5vZGVzPXtub2Rlc30gZWRnZXM9e2VkZ2VzfSBvbkVkZ2VzQ2hhbmdlPXtvbkVkZ2VzQ2hhbmdlfSAvPlxuICogICk7XG4gKn1cbiAqYGBgXG4gKiBAcmVtYXJrcyBWYXJpb3VzIGV2ZW50cyBvbiB0aGUgPFJlYWN0RmxvdyAvPiBjb21wb25lbnQgY2FuIHByb2R1Y2UgYW4ge0BsaW5rIEVkZ2VDaGFuZ2V9XG4gKiB0aGF0IGRlc2NyaWJlcyBob3cgdG8gdXBkYXRlIHRoZSBlZGdlcyBvZiB5b3VyIGZsb3cgaW4gc29tZSB3YXkuXG4gKiBJZiB5b3UgZG9uJ3QgbmVlZCBhbnkgY3VzdG9tIGJlaGF2aW91ciwgdGhpcyB1dGlsIGNhbiBiZSB1c2VkIHRvIHRha2UgYW4gYXJyYXlcbiAqIG9mIHRoZXNlIGNoYW5nZXMgYW5kIGFwcGx5IHRoZW0gdG8geW91ciBlZGdlcy5cbiAqL1xuZnVuY3Rpb24gYXBwbHlFZGdlQ2hhbmdlcyhjaGFuZ2VzLCBlZGdlcykge1xuICAgIHJldHVybiBhcHBseUNoYW5nZXMoY2hhbmdlcywgZWRnZXMpO1xufVxuZnVuY3Rpb24gY3JlYXRlU2VsZWN0aW9uQ2hhbmdlKGlkLCBzZWxlY3RlZCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGlkLFxuICAgICAgICB0eXBlOiAnc2VsZWN0JyxcbiAgICAgICAgc2VsZWN0ZWQsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGdldFNlbGVjdGlvbkNoYW5nZXMoaXRlbXMsIHNlbGVjdGVkSWRzID0gbmV3IFNldCgpLCBtdXRhdGVJdGVtID0gZmFsc2UpIHtcbiAgICBjb25zdCBjaGFuZ2VzID0gW107XG4gICAgZm9yIChjb25zdCBbaWQsIGl0ZW1dIG9mIGl0ZW1zKSB7XG4gICAgICAgIGNvbnN0IHdpbGxCZVNlbGVjdGVkID0gc2VsZWN0ZWRJZHMuaGFzKGlkKTtcbiAgICAgICAgLy8gd2UgZG9uJ3Qgd2FudCB0byBzZXQgYWxsIGl0ZW1zIHRvIHNlbGVjdGVkPWZhbHNlIG9uIHRoZSBmaXJzdCBzZWxlY3Rpb25cbiAgICAgICAgaWYgKCEoaXRlbS5zZWxlY3RlZCA9PT0gdW5kZWZpbmVkICYmICF3aWxsQmVTZWxlY3RlZCkgJiYgaXRlbS5zZWxlY3RlZCAhPT0gd2lsbEJlU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIGlmIChtdXRhdGVJdGVtKSB7XG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiB0aGlzIGhhY2sgaXMgbmVlZGVkIGZvciBub2Rlcy4gV2hlbiB0aGUgdXNlciBkcmFnZ2VkIGEgbm9kZSwgaXQncyBzZWxlY3RlZC5cbiAgICAgICAgICAgICAgICAgKiBXaGVuIGFub3RoZXIgbm9kZSBnZXRzIGRyYWdnZWQsIHdlIG5lZWQgdG8gZGVzZWxlY3QgdGhlIHByZXZpb3VzIG9uZSxcbiAgICAgICAgICAgICAgICAgKiBpbiBvcmRlciB0byBoYXZlIG9ubHkgb25lIHNlbGVjdGVkIG5vZGUgYXQgYSB0aW1lIC0gdGhlIG9uTm9kZXNDaGFuZ2UgY2FsbGJhY2sgY29tZXMgdG9vIGxhdGUgaGVyZSA6L1xuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGl0ZW0uc2VsZWN0ZWQgPSB3aWxsQmVTZWxlY3RlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoYW5nZXMucHVzaChjcmVhdGVTZWxlY3Rpb25DaGFuZ2UoaXRlbS5pZCwgd2lsbEJlU2VsZWN0ZWQpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2hhbmdlcztcbn1cbmZ1bmN0aW9uIGdldEVsZW1lbnRzRGlmZkNoYW5nZXMoeyBpdGVtcyA9IFtdLCBsb29rdXAsIH0pIHtcbiAgICBjb25zdCBjaGFuZ2VzID0gW107XG4gICAgY29uc3QgaXRlbXNMb29rdXAgPSBuZXcgTWFwKGl0ZW1zLm1hcCgoaXRlbSkgPT4gW2l0ZW0uaWQsIGl0ZW1dKSk7XG4gICAgZm9yIChjb25zdCBbaW5kZXgsIGl0ZW1dIG9mIGl0ZW1zLmVudHJpZXMoKSkge1xuICAgICAgICBjb25zdCBsb29rdXBJdGVtID0gbG9va3VwLmdldChpdGVtLmlkKTtcbiAgICAgICAgY29uc3Qgc3RvcmVJdGVtID0gbG9va3VwSXRlbT8uaW50ZXJuYWxzPy51c2VyTm9kZSA/PyBsb29rdXBJdGVtO1xuICAgICAgICBpZiAoc3RvcmVJdGVtICE9PSB1bmRlZmluZWQgJiYgc3RvcmVJdGVtICE9PSBpdGVtKSB7XG4gICAgICAgICAgICBjaGFuZ2VzLnB1c2goeyBpZDogaXRlbS5pZCwgaXRlbTogaXRlbSwgdHlwZTogJ3JlcGxhY2UnIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdG9yZUl0ZW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHsgaXRlbTogaXRlbSwgdHlwZTogJ2FkZCcsIGluZGV4IH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvciAoY29uc3QgW2lkXSBvZiBsb29rdXApIHtcbiAgICAgICAgY29uc3QgbmV4dE5vZGUgPSBpdGVtc0xvb2t1cC5nZXQoaWQpO1xuICAgICAgICBpZiAobmV4dE5vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHsgaWQsIHR5cGU6ICdyZW1vdmUnIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjaGFuZ2VzO1xufVxuZnVuY3Rpb24gZWxlbWVudFRvUmVtb3ZlQ2hhbmdlKGl0ZW0pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBpZDogaXRlbS5pZCxcbiAgICAgICAgdHlwZTogJ3JlbW92ZScsXG4gICAgfTtcbn1cblxuLyoqXG4gKiBUZXN0IHdoZXRoZXIgYW4gb2JqZWN0IGlzIHVzZWFibGUgYXMgYW4gW2BOb2RlYF0oL2FwaS1yZWZlcmVuY2UvdHlwZXMvbm9kZSkuXG4gKiBJbiBUeXBlU2NyaXB0IHRoaXMgaXMgYSB0eXBlIGd1YXJkIHRoYXQgd2lsbCBuYXJyb3cgdGhlIHR5cGUgb2Ygd2hhdGV2ZXIgeW91IHBhc3MgaW4gdG9cbiAqIFtgTm9kZWBdKC9hcGktcmVmZXJlbmNlL3R5cGVzL25vZGUpIGlmIGl0IHJldHVybnMgYHRydWVgLlxuICpcbiAqIEBwdWJsaWNcbiAqIEByZW1hcmtzIEluIFR5cGVTY3JpcHQgdGhpcyBpcyBhIHR5cGUgZ3VhcmQgdGhhdCB3aWxsIG5hcnJvdyB0aGUgdHlwZSBvZiB3aGF0ZXZlciB5b3UgcGFzcyBpbiB0byBOb2RlIGlmIGl0IHJldHVybnMgdHJ1ZVxuICogQHBhcmFtIGVsZW1lbnQgLSBUaGUgZWxlbWVudCB0byB0ZXN0XG4gKiBAcmV0dXJucyBBIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIGFuIE5vZGVcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqaW1wb3J0IHsgaXNOb2RlIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICppZiAoaXNOb2RlKG5vZGUpKSB7XG4gKiAvLyAuLlxuICp9XG4gKmBgYFxuICovXG5jb25zdCBpc05vZGUgPSAoZWxlbWVudCkgPT4gaXNOb2RlQmFzZShlbGVtZW50KTtcbi8qKlxuICogVGVzdCB3aGV0aGVyIGFuIG9iamVjdCBpcyB1c2VhYmxlIGFzIGFuIFtgRWRnZWBdKC9hcGktcmVmZXJlbmNlL3R5cGVzL2VkZ2UpLlxuICogSW4gVHlwZVNjcmlwdCB0aGlzIGlzIGEgdHlwZSBndWFyZCB0aGF0IHdpbGwgbmFycm93IHRoZSB0eXBlIG9mIHdoYXRldmVyIHlvdSBwYXNzIGluIHRvXG4gKiBbYEVkZ2VgXSgvYXBpLXJlZmVyZW5jZS90eXBlcy9lZGdlKSBpZiBpdCByZXR1cm5zIGB0cnVlYC5cbiAqXG4gKiBAcHVibGljXG4gKiBAcmVtYXJrcyBJbiBUeXBlU2NyaXB0IHRoaXMgaXMgYSB0eXBlIGd1YXJkIHRoYXQgd2lsbCBuYXJyb3cgdGhlIHR5cGUgb2Ygd2hhdGV2ZXIgeW91IHBhc3MgaW4gdG8gRWRnZSBpZiBpdCByZXR1cm5zIHRydWVcbiAqIEBwYXJhbSBlbGVtZW50IC0gVGhlIGVsZW1lbnQgdG8gdGVzdFxuICogQHJldHVybnMgQSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgZWxlbWVudCBpcyBhbiBFZGdlXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKmltcG9ydCB7IGlzRWRnZSB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqaWYgKGlzRWRnZShlZGdlKSkge1xuICogLy8gLi5cbiAqfVxuICpgYGBcbiAqL1xuY29uc3QgaXNFZGdlID0gKGVsZW1lbnQpID0+IGlzRWRnZUJhc2UoZWxlbWVudCk7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWVtcHR5LW9iamVjdC10eXBlXG5mdW5jdGlvbiBmaXhlZEZvcndhcmRSZWYocmVuZGVyKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICByZXR1cm4gZm9yd2FyZFJlZihyZW5kZXIpO1xufVxuXG4vLyB3ZSBuZWVkIHRoaXMgaG9vayB0byBwcmV2ZW50IGEgd2FybmluZyB3aGVuIHVzaW5nIHJlYWN0LWZsb3cgaW4gU1NSXG5jb25zdCB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB1c2VMYXlvdXRFZmZlY3QgOiB1c2VFZmZlY3Q7XG5cbi8qKlxuICogVGhpcyBob29rIHJldHVybnMgYSBxdWV1ZSB0aGF0IGNhbiBiZSB1c2VkIHRvIGJhdGNoIHVwZGF0ZXMuXG4gKlxuICogQHBhcmFtIHJ1blF1ZXVlIC0gYSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIHdoZW4gdGhlIHF1ZXVlIGlzIGZsdXNoZWRcbiAqIEBpbnRlcm5hbFxuICpcbiAqIEByZXR1cm5zIGEgUXVldWUgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIHVzZVF1ZXVlKHJ1blF1ZXVlKSB7XG4gICAgLypcbiAgICAgKiBCZWNhdXNlIHdlJ3JlIHVzaW5nIGEgcmVmIGFib3ZlLCB3ZSBuZWVkIHNvbWUgd2F5IHRvIGxldCBSZWFjdCBrbm93IHdoZW4gdG9cbiAgICAgKiBhY3R1YWxseSBwcm9jZXNzIHRoZSBxdWV1ZS4gV2UgaW5jcmVtZW50IHRoaXMgbnVtYmVyIGFueSB0aW1lIHdlIG11dGF0ZSB0aGVcbiAgICAgKiBxdWV1ZSwgY3JlYXRpbmcgYSBuZXcgc3RhdGUgdG8gdHJpZ2dlciB0aGUgbGF5b3V0IGVmZmVjdCBiZWxvdy5cbiAgICAgKiBVc2luZyBhIGJvb2xlYW4gZGlydHkgZmxhZyBoZXJlIGluc3RlYWQgd291bGQgbGVhZCB0byBpc3N1ZXMgcmVsYXRlZCB0b1xuICAgICAqIGF1dG9tYXRpYyBiYXRjaGluZy4gKGh0dHBzOi8vZ2l0aHViLmNvbS94eWZsb3cveHlmbG93L2lzc3Vlcy80Nzc5KVxuICAgICAqL1xuICAgIGNvbnN0IFtzZXJpYWwsIHNldFNlcmlhbF0gPSB1c2VTdGF0ZShCaWdJbnQoMCkpO1xuICAgIC8qXG4gICAgICogQSByZWZlcmVuY2Ugb2YgYWxsIHRoZSBiYXRjaGVkIHVwZGF0ZXMgdG8gcHJvY2VzcyBiZWZvcmUgdGhlIG5leHQgcmVuZGVyLiBXZVxuICAgICAqIHdhbnQgYSByZWZlcmVuY2UgaGVyZSBzbyBtdWx0aXBsZSBzeW5jaHJvbm91cyBjYWxscyB0byBgc2V0Tm9kZXNgIGV0YyBjYW4gYmVcbiAgICAgKiBiYXRjaGVkIHRvZ2V0aGVyLlxuICAgICAqL1xuICAgIGNvbnN0IFtxdWV1ZV0gPSB1c2VTdGF0ZSgoKSA9PiBjcmVhdGVRdWV1ZSgoKSA9PiBzZXRTZXJpYWwobiA9PiBuICsgQmlnSW50KDEpKSkpO1xuICAgIC8qXG4gICAgICogTGF5b3V0IGVmZmVjdHMgYXJlIGd1YXJhbnRlZWQgdG8gcnVuIGJlZm9yZSB0aGUgbmV4dCByZW5kZXIgd2hpY2ggbWVhbnMgd2VcbiAgICAgKiBzaG91bGRuJ3QgcnVuIGludG8gYW55IGlzc3VlcyB3aXRoIHN0YWxlIHN0YXRlIG9yIHdlaXJkIGlzc3VlcyB0aGF0IGNvbWUgZnJvbVxuICAgICAqIHJlbmRlcmluZyB0aGluZ3Mgb25lIGZyYW1lIGxhdGVyIHRoYW4gZXhwZWN0ZWQgKHdlIHVzZWQgdG8gdXNlIGBzZXRUaW1lb3V0YCkuXG4gICAgICovXG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHF1ZXVlSXRlbXMgPSBxdWV1ZS5nZXQoKTtcbiAgICAgICAgaWYgKHF1ZXVlSXRlbXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBydW5RdWV1ZShxdWV1ZUl0ZW1zKTtcbiAgICAgICAgICAgIHF1ZXVlLnJlc2V0KCk7XG4gICAgICAgIH1cbiAgICB9LCBbc2VyaWFsXSk7XG4gICAgcmV0dXJuIHF1ZXVlO1xufVxuZnVuY3Rpb24gY3JlYXRlUXVldWUoY2IpIHtcbiAgICBsZXQgcXVldWUgPSBbXTtcbiAgICByZXR1cm4ge1xuICAgICAgICBnZXQ6ICgpID0+IHF1ZXVlLFxuICAgICAgICByZXNldDogKCkgPT4ge1xuICAgICAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgfSxcbiAgICAgICAgcHVzaDogKGl0ZW0pID0+IHtcbiAgICAgICAgICAgIHF1ZXVlLnB1c2goaXRlbSk7XG4gICAgICAgICAgICBjYigpO1xuICAgICAgICB9LFxuICAgIH07XG59XG5cbmNvbnN0IEJhdGNoQ29udGV4dCA9IGNyZWF0ZUNvbnRleHQobnVsbCk7XG4vKipcbiAqIFRoaXMgaXMgYSBjb250ZXh0IHByb3ZpZGVyIHRoYXQgaG9sZHMgYW5kIHByb2Nlc3NlcyB0aGUgbm9kZSBhbmQgZWRnZSB1cGRhdGUgcXVldWVzXG4gKiB0aGF0IGFyZSBuZWVkZWQgdG8gaGFuZGxlIHNldE5vZGVzLCBhZGROb2Rlcywgc2V0RWRnZXMgYW5kIGFkZEVkZ2VzLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBCYXRjaFByb3ZpZGVyKHsgY2hpbGRyZW4sIH0pIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3Qgbm9kZVF1ZXVlSGFuZGxlciA9IHVzZUNhbGxiYWNrKChxdWV1ZUl0ZW1zKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgbm9kZXMgPSBbXSwgc2V0Tm9kZXMsIGhhc0RlZmF1bHROb2Rlcywgb25Ob2Rlc0NoYW5nZSwgbm9kZUxvb2t1cCB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgLypcbiAgICAgICAgICogVGhpcyBpcyBlc3NlbnRpYWxseSBhbiBgQXJyYXkucmVkdWNlYCBpbiBpbXBlcmF0aXZlIGNsb3RoaW5nLiBQcm9jZXNzaW5nXG4gICAgICAgICAqIHRoaXMgcXVldWUgaXMgYSByZWxhdGl2ZWx5IGhvdCBwYXRoIHNvIHdlJ2QgbGlrZSB0byBhdm9pZCB0aGUgb3ZlcmhlYWQgb2ZcbiAgICAgICAgICogYXJyYXkgbWV0aG9kcyB3aGVyZSB3ZSBjYW4uXG4gICAgICAgICAqL1xuICAgICAgICBsZXQgbmV4dCA9IG5vZGVzO1xuICAgICAgICBmb3IgKGNvbnN0IHBheWxvYWQgb2YgcXVldWVJdGVtcykge1xuICAgICAgICAgICAgbmV4dCA9IHR5cGVvZiBwYXlsb2FkID09PSAnZnVuY3Rpb24nID8gcGF5bG9hZChuZXh0KSA6IHBheWxvYWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc0RlZmF1bHROb2Rlcykge1xuICAgICAgICAgICAgc2V0Tm9kZXMobmV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob25Ob2Rlc0NoYW5nZSkge1xuICAgICAgICAgICAgb25Ob2Rlc0NoYW5nZShnZXRFbGVtZW50c0RpZmZDaGFuZ2VzKHtcbiAgICAgICAgICAgICAgICBpdGVtczogbmV4dCxcbiAgICAgICAgICAgICAgICBsb29rdXA6IG5vZGVMb29rdXAsXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG4gICAgY29uc3Qgbm9kZVF1ZXVlID0gdXNlUXVldWUobm9kZVF1ZXVlSGFuZGxlcik7XG4gICAgY29uc3QgZWRnZVF1ZXVlSGFuZGxlciA9IHVzZUNhbGxiYWNrKChxdWV1ZUl0ZW1zKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgZWRnZXMgPSBbXSwgc2V0RWRnZXMsIGhhc0RlZmF1bHRFZGdlcywgb25FZGdlc0NoYW5nZSwgZWRnZUxvb2t1cCB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgbGV0IG5leHQgPSBlZGdlcztcbiAgICAgICAgZm9yIChjb25zdCBwYXlsb2FkIG9mIHF1ZXVlSXRlbXMpIHtcbiAgICAgICAgICAgIG5leHQgPSB0eXBlb2YgcGF5bG9hZCA9PT0gJ2Z1bmN0aW9uJyA/IHBheWxvYWQobmV4dCkgOiBwYXlsb2FkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNEZWZhdWx0RWRnZXMpIHtcbiAgICAgICAgICAgIHNldEVkZ2VzKG5leHQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG9uRWRnZXNDaGFuZ2UpIHtcbiAgICAgICAgICAgIG9uRWRnZXNDaGFuZ2UoZ2V0RWxlbWVudHNEaWZmQ2hhbmdlcyh7XG4gICAgICAgICAgICAgICAgaXRlbXM6IG5leHQsXG4gICAgICAgICAgICAgICAgbG9va3VwOiBlZGdlTG9va3VwLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgfSwgW10pO1xuICAgIGNvbnN0IGVkZ2VRdWV1ZSA9IHVzZVF1ZXVlKGVkZ2VRdWV1ZUhhbmRsZXIpO1xuICAgIGNvbnN0IHZhbHVlID0gdXNlTWVtbygoKSA9PiAoeyBub2RlUXVldWUsIGVkZ2VRdWV1ZSB9KSwgW10pO1xuICAgIHJldHVybiBqc3goQmF0Y2hDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiB2YWx1ZSwgY2hpbGRyZW46IGNoaWxkcmVuIH0pO1xufVxuZnVuY3Rpb24gdXNlQmF0Y2hDb250ZXh0KCkge1xuICAgIGNvbnN0IGJhdGNoQ29udGV4dCA9IHVzZUNvbnRleHQoQmF0Y2hDb250ZXh0KTtcbiAgICBpZiAoIWJhdGNoQ29udGV4dCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VzZUJhdGNoQ29udGV4dCBtdXN0IGJlIHVzZWQgd2l0aGluIGEgQmF0Y2hQcm92aWRlcicpO1xuICAgIH1cbiAgICByZXR1cm4gYmF0Y2hDb250ZXh0O1xufVxuXG5jb25zdCBzZWxlY3RvciRrID0gKHMpID0+ICEhcy5wYW5ab29tO1xuLyoqXG4gKiBUaGlzIGhvb2sgcmV0dXJucyBhIFJlYWN0Rmxvd0luc3RhbmNlIHRoYXQgY2FuIGJlIHVzZWQgdG8gdXBkYXRlIG5vZGVzIGFuZCBlZGdlcywgbWFuaXB1bGF0ZSB0aGUgdmlld3BvcnQsIG9yIHF1ZXJ5IHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBmbG93LlxuICpcbiAqIEBwdWJsaWNcbiAqIEByZXR1cm5zIFJlYWN0Rmxvd0luc3RhbmNlXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzeFxuICppbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG4gKmltcG9ydCB7IHVzZVJlYWN0RmxvdyB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqZXhwb3J0IGZ1bmN0aW9uIE5vZGVDb3VudGVyKCkge1xuICogIGNvbnN0IHJlYWN0RmxvdyA9IHVzZVJlYWN0RmxvdygpO1xuICogIGNvbnN0IFtjb3VudCwgc2V0Q291bnRdID0gdXNlU3RhdGUoMCk7XG4gKiAgY29uc3QgY291bnROb2RlcyA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAqICAgIHNldENvdW50KHJlYWN0Rmxvdy5nZXROb2RlcygpLmxlbmd0aCk7XG4gKiAgICAvLyB5b3UgbmVlZCB0byBwYXNzIGl0IGFzIGEgZGVwZW5kZW5jeSBpZiB5b3UgYXJlIHVzaW5nIGl0IHdpdGggdXNlRWZmZWN0IG9yIHVzZUNhbGxiYWNrXG4gKiAgICAvLyBiZWNhdXNlIGF0IHRoZSBmaXJzdCByZW5kZXIsIGl0J3Mgbm90IGluaXRpYWxpemVkIHlldCBhbmQgc29tZSBmdW5jdGlvbnMgbWlnaHQgbm90IHdvcmsuXG4gKiAgfSwgW3JlYWN0Rmxvd10pO1xuICpcbiAqICByZXR1cm4gKFxuICogICAgPGRpdj5cbiAqICAgICAgPGJ1dHRvbiBvbkNsaWNrPXtjb3VudE5vZGVzfT5VcGRhdGUgY291bnQ8L2J1dHRvbj5cbiAqICAgICAgPHA+VGhlcmUgYXJlIHtjb3VudH0gbm9kZXMgaW4gdGhlIGZsb3cuPC9wPlxuICogICAgPC9kaXY+XG4gKiAgKTtcbiAqfVxuICpgYGBcbiAqL1xuZnVuY3Rpb24gdXNlUmVhY3RGbG93KCkge1xuICAgIGNvbnN0IHZpZXdwb3J0SGVscGVyID0gdXNlVmlld3BvcnRIZWxwZXIoKTtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3QgYmF0Y2hDb250ZXh0ID0gdXNlQmF0Y2hDb250ZXh0KCk7XG4gICAgY29uc3Qgdmlld3BvcnRJbml0aWFsaXplZCA9IHVzZVN0b3JlKHNlbGVjdG9yJGspO1xuICAgIGNvbnN0IGdlbmVyYWxIZWxwZXIgPSB1c2VNZW1vKCgpID0+IHtcbiAgICAgICAgY29uc3QgZ2V0SW50ZXJuYWxOb2RlID0gKGlkKSA9PiBzdG9yZS5nZXRTdGF0ZSgpLm5vZGVMb29rdXAuZ2V0KGlkKTtcbiAgICAgICAgY29uc3Qgc2V0Tm9kZXMgPSAocGF5bG9hZCkgPT4ge1xuICAgICAgICAgICAgYmF0Y2hDb250ZXh0Lm5vZGVRdWV1ZS5wdXNoKHBheWxvYWQpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBzZXRFZGdlcyA9IChwYXlsb2FkKSA9PiB7XG4gICAgICAgICAgICBiYXRjaENvbnRleHQuZWRnZVF1ZXVlLnB1c2gocGF5bG9hZCk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGdldE5vZGVSZWN0ID0gKG5vZGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgbm9kZUxvb2t1cCwgbm9kZU9yaWdpbiB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgIGNvbnN0IG5vZGVUb1VzZSA9IGlzTm9kZShub2RlKSA/IG5vZGUgOiBub2RlTG9va3VwLmdldChub2RlLmlkKTtcbiAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uID0gbm9kZVRvVXNlLnBhcmVudElkXG4gICAgICAgICAgICAgICAgPyBldmFsdWF0ZUFic29sdXRlUG9zaXRpb24obm9kZVRvVXNlLnBvc2l0aW9uLCBub2RlVG9Vc2UubWVhc3VyZWQsIG5vZGVUb1VzZS5wYXJlbnRJZCwgbm9kZUxvb2t1cCwgbm9kZU9yaWdpbilcbiAgICAgICAgICAgICAgICA6IG5vZGVUb1VzZS5wb3NpdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IG5vZGVXaXRoUG9zaXRpb24gPSB7XG4gICAgICAgICAgICAgICAgLi4ubm9kZVRvVXNlLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uLFxuICAgICAgICAgICAgICAgIHdpZHRoOiBub2RlVG9Vc2UubWVhc3VyZWQ/LndpZHRoID8/IG5vZGVUb1VzZS53aWR0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IG5vZGVUb1VzZS5tZWFzdXJlZD8uaGVpZ2h0ID8/IG5vZGVUb1VzZS5oZWlnaHQsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIG5vZGVUb1JlY3Qobm9kZVdpdGhQb3NpdGlvbik7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHVwZGF0ZU5vZGUgPSAoaWQsIG5vZGVVcGRhdGUsIG9wdGlvbnMgPSB7IHJlcGxhY2U6IGZhbHNlIH0pID0+IHtcbiAgICAgICAgICAgIHNldE5vZGVzKChwcmV2Tm9kZXMpID0+IHByZXZOb2Rlcy5tYXAoKG5vZGUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5pZCA9PT0gaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dE5vZGUgPSB0eXBlb2Ygbm9kZVVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJyA/IG5vZGVVcGRhdGUobm9kZSkgOiBub2RlVXBkYXRlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5yZXBsYWNlICYmIGlzTm9kZShuZXh0Tm9kZSkgPyBuZXh0Tm9kZSA6IHsgLi4ubm9kZSwgLi4ubmV4dE5vZGUgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHVwZGF0ZUVkZ2UgPSAoaWQsIGVkZ2VVcGRhdGUsIG9wdGlvbnMgPSB7IHJlcGxhY2U6IGZhbHNlIH0pID0+IHtcbiAgICAgICAgICAgIHNldEVkZ2VzKChwcmV2RWRnZXMpID0+IHByZXZFZGdlcy5tYXAoKGVkZ2UpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZWRnZS5pZCA9PT0gaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dEVkZ2UgPSB0eXBlb2YgZWRnZVVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJyA/IGVkZ2VVcGRhdGUoZWRnZSkgOiBlZGdlVXBkYXRlO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5yZXBsYWNlICYmIGlzRWRnZShuZXh0RWRnZSkgPyBuZXh0RWRnZSA6IHsgLi4uZWRnZSwgLi4ubmV4dEVkZ2UgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVkZ2U7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBnZXROb2RlczogKCkgPT4gc3RvcmUuZ2V0U3RhdGUoKS5ub2Rlcy5tYXAoKG4pID0+ICh7IC4uLm4gfSkpLFxuICAgICAgICAgICAgZ2V0Tm9kZTogKGlkKSA9PiBnZXRJbnRlcm5hbE5vZGUoaWQpPy5pbnRlcm5hbHMudXNlck5vZGUsXG4gICAgICAgICAgICBnZXRJbnRlcm5hbE5vZGUsXG4gICAgICAgICAgICBnZXRFZGdlczogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZWRnZXMgPSBbXSB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZWRnZXMubWFwKChlKSA9PiAoeyAuLi5lIH0pKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRFZGdlOiAoaWQpID0+IHN0b3JlLmdldFN0YXRlKCkuZWRnZUxvb2t1cC5nZXQoaWQpLFxuICAgICAgICAgICAgc2V0Tm9kZXMsXG4gICAgICAgICAgICBzZXRFZGdlcyxcbiAgICAgICAgICAgIGFkZE5vZGVzOiAocGF5bG9hZCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld05vZGVzID0gQXJyYXkuaXNBcnJheShwYXlsb2FkKSA/IHBheWxvYWQgOiBbcGF5bG9hZF07XG4gICAgICAgICAgICAgICAgYmF0Y2hDb250ZXh0Lm5vZGVRdWV1ZS5wdXNoKChub2RlcykgPT4gWy4uLm5vZGVzLCAuLi5uZXdOb2Rlc10pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFkZEVkZ2VzOiAocGF5bG9hZCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0VkZ2VzID0gQXJyYXkuaXNBcnJheShwYXlsb2FkKSA/IHBheWxvYWQgOiBbcGF5bG9hZF07XG4gICAgICAgICAgICAgICAgYmF0Y2hDb250ZXh0LmVkZ2VRdWV1ZS5wdXNoKChlZGdlcykgPT4gWy4uLmVkZ2VzLCAuLi5uZXdFZGdlc10pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRvT2JqZWN0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBub2RlcyA9IFtdLCBlZGdlcyA9IFtdLCB0cmFuc2Zvcm0gfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgW3gsIHksIHpvb21dID0gdHJhbnNmb3JtO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzOiBub2Rlcy5tYXAoKG4pID0+ICh7IC4uLm4gfSkpLFxuICAgICAgICAgICAgICAgICAgICBlZGdlczogZWRnZXMubWFwKChlKSA9PiAoeyAuLi5lIH0pKSxcbiAgICAgICAgICAgICAgICAgICAgdmlld3BvcnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHgsXG4gICAgICAgICAgICAgICAgICAgICAgICB5LFxuICAgICAgICAgICAgICAgICAgICAgICAgem9vbSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGRlbGV0ZUVsZW1lbnRzOiBhc3luYyAoeyBub2Rlczogbm9kZXNUb1JlbW92ZSA9IFtdLCBlZGdlczogZWRnZXNUb1JlbW92ZSA9IFtdIH0pID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IG5vZGVzLCBlZGdlcywgb25Ob2Rlc0RlbGV0ZSwgb25FZGdlc0RlbGV0ZSwgdHJpZ2dlck5vZGVDaGFuZ2VzLCB0cmlnZ2VyRWRnZUNoYW5nZXMsIG9uRGVsZXRlLCBvbkJlZm9yZURlbGV0ZSwgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBub2RlczogbWF0Y2hpbmdOb2RlcywgZWRnZXM6IG1hdGNoaW5nRWRnZXMgfSA9IGF3YWl0IGdldEVsZW1lbnRzVG9SZW1vdmUoe1xuICAgICAgICAgICAgICAgICAgICBub2Rlc1RvUmVtb3ZlLFxuICAgICAgICAgICAgICAgICAgICBlZGdlc1RvUmVtb3ZlLFxuICAgICAgICAgICAgICAgICAgICBub2RlcyxcbiAgICAgICAgICAgICAgICAgICAgZWRnZXMsXG4gICAgICAgICAgICAgICAgICAgIG9uQmVmb3JlRGVsZXRlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhc01hdGNoaW5nRWRnZXMgPSBtYXRjaGluZ0VkZ2VzLmxlbmd0aCA+IDA7XG4gICAgICAgICAgICAgICAgY29uc3QgaGFzTWF0Y2hpbmdOb2RlcyA9IG1hdGNoaW5nTm9kZXMubGVuZ3RoID4gMDtcbiAgICAgICAgICAgICAgICBpZiAoaGFzTWF0Y2hpbmdFZGdlcykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlZGdlQ2hhbmdlcyA9IG1hdGNoaW5nRWRnZXMubWFwKGVsZW1lbnRUb1JlbW92ZUNoYW5nZSk7XG4gICAgICAgICAgICAgICAgICAgIG9uRWRnZXNEZWxldGU/LihtYXRjaGluZ0VkZ2VzKTtcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlckVkZ2VDaGFuZ2VzKGVkZ2VDaGFuZ2VzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGhhc01hdGNoaW5nTm9kZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm9kZUNoYW5nZXMgPSBtYXRjaGluZ05vZGVzLm1hcChlbGVtZW50VG9SZW1vdmVDaGFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICBvbk5vZGVzRGVsZXRlPy4obWF0Y2hpbmdOb2Rlcyk7XG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXJOb2RlQ2hhbmdlcyhub2RlQ2hhbmdlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChoYXNNYXRjaGluZ05vZGVzIHx8IGhhc01hdGNoaW5nRWRnZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgb25EZWxldGU/Lih7IG5vZGVzOiBtYXRjaGluZ05vZGVzLCBlZGdlczogbWF0Y2hpbmdFZGdlcyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZGVsZXRlZE5vZGVzOiBtYXRjaGluZ05vZGVzLCBkZWxldGVkRWRnZXM6IG1hdGNoaW5nRWRnZXMgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRJbnRlcnNlY3RpbmdOb2RlczogKG5vZGVPclJlY3QsIHBhcnRpYWxseSA9IHRydWUsIG5vZGVzKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNSZWN0ID0gaXNSZWN0T2JqZWN0KG5vZGVPclJlY3QpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vZGVSZWN0ID0gaXNSZWN0ID8gbm9kZU9yUmVjdCA6IGdldE5vZGVSZWN0KG5vZGVPclJlY3QpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhc05vZGVzT3B0aW9uID0gbm9kZXMgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBpZiAoIW5vZGVSZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIChub2RlcyB8fCBzdG9yZS5nZXRTdGF0ZSgpLm5vZGVzKS5maWx0ZXIoKG4pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaW50ZXJuYWxOb2RlID0gc3RvcmUuZ2V0U3RhdGUoKS5ub2RlTG9va3VwLmdldChuLmlkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGludGVybmFsTm9kZSAmJiAhaXNSZWN0ICYmIChuLmlkID09PSBub2RlT3JSZWN0LmlkIHx8ICFpbnRlcm5hbE5vZGUuaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY3Vyck5vZGVSZWN0ID0gbm9kZVRvUmVjdChoYXNOb2Rlc09wdGlvbiA/IG4gOiBpbnRlcm5hbE5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvdmVybGFwcGluZ0FyZWEgPSBnZXRPdmVybGFwcGluZ0FyZWEoY3Vyck5vZGVSZWN0LCBub2RlUmVjdCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcnRpYWxseVZpc2libGUgPSBwYXJ0aWFsbHkgJiYgb3ZlcmxhcHBpbmdBcmVhID4gMDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnRpYWxseVZpc2libGUgfHwgb3ZlcmxhcHBpbmdBcmVhID49IG5vZGVSZWN0LndpZHRoICogbm9kZVJlY3QuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGlzTm9kZUludGVyc2VjdGluZzogKG5vZGVPclJlY3QsIGFyZWEsIHBhcnRpYWxseSA9IHRydWUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpc1JlY3QgPSBpc1JlY3RPYmplY3Qobm9kZU9yUmVjdCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZVJlY3QgPSBpc1JlY3QgPyBub2RlT3JSZWN0IDogZ2V0Tm9kZVJlY3Qobm9kZU9yUmVjdCk7XG4gICAgICAgICAgICAgICAgaWYgKCFub2RlUmVjdCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IG92ZXJsYXBwaW5nQXJlYSA9IGdldE92ZXJsYXBwaW5nQXJlYShub2RlUmVjdCwgYXJlYSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFydGlhbGx5VmlzaWJsZSA9IHBhcnRpYWxseSAmJiBvdmVybGFwcGluZ0FyZWEgPiAwO1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXJ0aWFsbHlWaXNpYmxlIHx8IG92ZXJsYXBwaW5nQXJlYSA+PSBub2RlUmVjdC53aWR0aCAqIG5vZGVSZWN0LmhlaWdodDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1cGRhdGVOb2RlLFxuICAgICAgICAgICAgdXBkYXRlTm9kZURhdGE6IChpZCwgZGF0YVVwZGF0ZSwgb3B0aW9ucyA9IHsgcmVwbGFjZTogZmFsc2UgfSkgPT4ge1xuICAgICAgICAgICAgICAgIHVwZGF0ZU5vZGUoaWQsIChub2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHREYXRhID0gdHlwZW9mIGRhdGFVcGRhdGUgPT09ICdmdW5jdGlvbicgPyBkYXRhVXBkYXRlKG5vZGUpIDogZGF0YVVwZGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMucmVwbGFjZSA/IHsgLi4ubm9kZSwgZGF0YTogbmV4dERhdGEgfSA6IHsgLi4ubm9kZSwgZGF0YTogeyAuLi5ub2RlLmRhdGEsIC4uLm5leHREYXRhIH0gfTtcbiAgICAgICAgICAgICAgICB9LCBvcHRpb25zKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB1cGRhdGVFZGdlLFxuICAgICAgICAgICAgdXBkYXRlRWRnZURhdGE6IChpZCwgZGF0YVVwZGF0ZSwgb3B0aW9ucyA9IHsgcmVwbGFjZTogZmFsc2UgfSkgPT4ge1xuICAgICAgICAgICAgICAgIHVwZGF0ZUVkZ2UoaWQsIChlZGdlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5leHREYXRhID0gdHlwZW9mIGRhdGFVcGRhdGUgPT09ICdmdW5jdGlvbicgPyBkYXRhVXBkYXRlKGVkZ2UpIDogZGF0YVVwZGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMucmVwbGFjZSA/IHsgLi4uZWRnZSwgZGF0YTogbmV4dERhdGEgfSA6IHsgLi4uZWRnZSwgZGF0YTogeyAuLi5lZGdlLmRhdGEsIC4uLm5leHREYXRhIH0gfTtcbiAgICAgICAgICAgICAgICB9LCBvcHRpb25zKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXROb2Rlc0JvdW5kczogKG5vZGVzKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBub2RlTG9va3VwLCBub2RlT3JpZ2luIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXROb2Rlc0JvdW5kcyhub2RlcywgeyBub2RlTG9va3VwLCBub2RlT3JpZ2luIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldEhhbmRsZUNvbm5lY3Rpb25zOiAoeyB0eXBlLCBpZCwgbm9kZUlkIH0pID0+IEFycmF5LmZyb20oc3RvcmVcbiAgICAgICAgICAgICAgICAuZ2V0U3RhdGUoKVxuICAgICAgICAgICAgICAgIC5jb25uZWN0aW9uTG9va3VwLmdldChgJHtub2RlSWR9LSR7dHlwZX0ke2lkID8gYC0ke2lkfWAgOiAnJ31gKVxuICAgICAgICAgICAgICAgID8udmFsdWVzKCkgPz8gW10pLFxuICAgICAgICAgICAgZ2V0Tm9kZUNvbm5lY3Rpb25zOiAoeyB0eXBlLCBoYW5kbGVJZCwgbm9kZUlkIH0pID0+IEFycmF5LmZyb20oc3RvcmVcbiAgICAgICAgICAgICAgICAuZ2V0U3RhdGUoKVxuICAgICAgICAgICAgICAgIC5jb25uZWN0aW9uTG9va3VwLmdldChgJHtub2RlSWR9JHt0eXBlID8gKGhhbmRsZUlkID8gYC0ke3R5cGV9LSR7aGFuZGxlSWR9YCA6IGAtJHt0eXBlfWApIDogJyd9YClcbiAgICAgICAgICAgICAgICA/LnZhbHVlcygpID8/IFtdKSxcbiAgICAgICAgfTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uZ2VuZXJhbEhlbHBlcixcbiAgICAgICAgICAgIC4uLnZpZXdwb3J0SGVscGVyLFxuICAgICAgICAgICAgdmlld3BvcnRJbml0aWFsaXplZCxcbiAgICAgICAgfTtcbiAgICB9LCBbdmlld3BvcnRJbml0aWFsaXplZF0pO1xufVxuXG5jb25zdCBzZWxlY3RlZCA9IChpdGVtKSA9PiBpdGVtLnNlbGVjdGVkO1xuY29uc3QgZGVsZXRlS2V5T3B0aW9ucyA9IHsgYWN0SW5zaWRlSW5wdXRXaXRoTW9kaWZpZXI6IGZhbHNlIH07XG5jb25zdCB3aW4kMSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdW5kZWZpbmVkO1xuLyoqXG4gKiBIb29rIGZvciBoYW5kbGluZyBnbG9iYWwga2V5IGV2ZW50cy5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gdXNlR2xvYmFsS2V5SGFuZGxlcih7IGRlbGV0ZUtleUNvZGUsIG11bHRpU2VsZWN0aW9uS2V5Q29kZSwgfSkge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICBjb25zdCB7IGRlbGV0ZUVsZW1lbnRzIH0gPSB1c2VSZWFjdEZsb3coKTtcbiAgICBjb25zdCBkZWxldGVLZXlQcmVzc2VkID0gdXNlS2V5UHJlc3MoZGVsZXRlS2V5Q29kZSwgZGVsZXRlS2V5T3B0aW9ucyk7XG4gICAgY29uc3QgbXVsdGlTZWxlY3Rpb25LZXlQcmVzc2VkID0gdXNlS2V5UHJlc3MobXVsdGlTZWxlY3Rpb25LZXlDb2RlLCB7IHRhcmdldDogd2luJDEgfSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKGRlbGV0ZUtleVByZXNzZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZWRnZXMsIG5vZGVzIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgZGVsZXRlRWxlbWVudHMoeyBub2Rlczogbm9kZXMuZmlsdGVyKHNlbGVjdGVkKSwgZWRnZXM6IGVkZ2VzLmZpbHRlcihzZWxlY3RlZCkgfSk7XG4gICAgICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7IG5vZGVzU2VsZWN0aW9uQWN0aXZlOiBmYWxzZSB9KTtcbiAgICAgICAgfVxuICAgIH0sIFtkZWxldGVLZXlQcmVzc2VkXSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgc3RvcmUuc2V0U3RhdGUoeyBtdWx0aVNlbGVjdGlvbkFjdGl2ZTogbXVsdGlTZWxlY3Rpb25LZXlQcmVzc2VkIH0pO1xuICAgIH0sIFttdWx0aVNlbGVjdGlvbktleVByZXNzZWRdKTtcbn1cblxuLyoqXG4gKiBIb29rIGZvciBoYW5kbGluZyByZXNpemUgZXZlbnRzLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiB1c2VSZXNpemVIYW5kbGVyKGRvbU5vZGUpIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29uc3QgdXBkYXRlRGltZW5zaW9ucyA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICghZG9tTm9kZS5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IGdldERpbWVuc2lvbnMoZG9tTm9kZS5jdXJyZW50KTtcbiAgICAgICAgICAgIGlmIChzaXplLmhlaWdodCA9PT0gMCB8fCBzaXplLndpZHRoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgc3RvcmUuZ2V0U3RhdGUoKS5vbkVycm9yPy4oJzAwNCcsIGVycm9yTWVzc2FnZXNbJ2Vycm9yMDA0J10oKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7IHdpZHRoOiBzaXplLndpZHRoIHx8IDUwMCwgaGVpZ2h0OiBzaXplLmhlaWdodCB8fCA1MDAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChkb21Ob2RlLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHVwZGF0ZURpbWVuc2lvbnMoKTtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCB1cGRhdGVEaW1lbnNpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKCgpID0+IHVwZGF0ZURpbWVuc2lvbnMoKSk7XG4gICAgICAgICAgICByZXNpemVPYnNlcnZlci5vYnNlcnZlKGRvbU5vZGUuY3VycmVudCk7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB1cGRhdGVEaW1lbnNpb25zKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzaXplT2JzZXJ2ZXIgJiYgZG9tTm9kZS5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc2l6ZU9ic2VydmVyLnVub2JzZXJ2ZShkb21Ob2RlLmN1cnJlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG59XG5cbmNvbnN0IGNvbnRhaW5lclN0eWxlID0ge1xuICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgIHdpZHRoOiAnMTAwJScsXG4gICAgaGVpZ2h0OiAnMTAwJScsXG4gICAgdG9wOiAwLFxuICAgIGxlZnQ6IDAsXG59O1xuXG5jb25zdCBzZWxlY3RvciRqID0gKHMpID0+ICh7XG4gICAgdXNlclNlbGVjdGlvbkFjdGl2ZTogcy51c2VyU2VsZWN0aW9uQWN0aXZlLFxuICAgIGxpYjogcy5saWIsXG59KTtcbmZ1bmN0aW9uIFpvb21QYW5lKHsgb25QYW5lQ29udGV4dE1lbnUsIHpvb21PblNjcm9sbCA9IHRydWUsIHpvb21PblBpbmNoID0gdHJ1ZSwgcGFuT25TY3JvbGwgPSBmYWxzZSwgcGFuT25TY3JvbGxTcGVlZCA9IDAuNSwgcGFuT25TY3JvbGxNb2RlID0gUGFuT25TY3JvbGxNb2RlLkZyZWUsIHpvb21PbkRvdWJsZUNsaWNrID0gdHJ1ZSwgcGFuT25EcmFnID0gdHJ1ZSwgZGVmYXVsdFZpZXdwb3J0LCB0cmFuc2xhdGVFeHRlbnQsIG1pblpvb20sIG1heFpvb20sIHpvb21BY3RpdmF0aW9uS2V5Q29kZSwgcHJldmVudFNjcm9sbGluZyA9IHRydWUsIGNoaWxkcmVuLCBub1doZWVsQ2xhc3NOYW1lLCBub1BhbkNsYXNzTmFtZSwgb25WaWV3cG9ydENoYW5nZSwgaXNDb250cm9sbGVkVmlld3BvcnQsIHBhbmVDbGlja0Rpc3RhbmNlLCB9KSB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIGNvbnN0IHpvb21QYW5lID0gdXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IHsgdXNlclNlbGVjdGlvbkFjdGl2ZSwgbGliIH0gPSB1c2VTdG9yZShzZWxlY3RvciRqLCBzaGFsbG93KTtcbiAgICBjb25zdCB6b29tQWN0aXZhdGlvbktleVByZXNzZWQgPSB1c2VLZXlQcmVzcyh6b29tQWN0aXZhdGlvbktleUNvZGUpO1xuICAgIGNvbnN0IHBhblpvb20gPSB1c2VSZWYoKTtcbiAgICB1c2VSZXNpemVIYW5kbGVyKHpvb21QYW5lKTtcbiAgICBjb25zdCBvblRyYW5zZm9ybUNoYW5nZSA9IHVzZUNhbGxiYWNrKCh0cmFuc2Zvcm0pID0+IHtcbiAgICAgICAgb25WaWV3cG9ydENoYW5nZT8uKHsgeDogdHJhbnNmb3JtWzBdLCB5OiB0cmFuc2Zvcm1bMV0sIHpvb206IHRyYW5zZm9ybVsyXSB9KTtcbiAgICAgICAgaWYgKCFpc0NvbnRyb2xsZWRWaWV3cG9ydCkge1xuICAgICAgICAgICAgc3RvcmUuc2V0U3RhdGUoeyB0cmFuc2Zvcm0gfSk7XG4gICAgICAgIH1cbiAgICB9LCBbb25WaWV3cG9ydENoYW5nZSwgaXNDb250cm9sbGVkVmlld3BvcnRdKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoem9vbVBhbmUuY3VycmVudCkge1xuICAgICAgICAgICAgcGFuWm9vbS5jdXJyZW50ID0gWFlQYW5ab29tKHtcbiAgICAgICAgICAgICAgICBkb21Ob2RlOiB6b29tUGFuZS5jdXJyZW50LFxuICAgICAgICAgICAgICAgIG1pblpvb20sXG4gICAgICAgICAgICAgICAgbWF4Wm9vbSxcbiAgICAgICAgICAgICAgICB0cmFuc2xhdGVFeHRlbnQsXG4gICAgICAgICAgICAgICAgdmlld3BvcnQ6IGRlZmF1bHRWaWV3cG9ydCxcbiAgICAgICAgICAgICAgICBwYW5lQ2xpY2tEaXN0YW5jZSxcbiAgICAgICAgICAgICAgICBvbkRyYWdnaW5nQ2hhbmdlOiAocGFuZURyYWdnaW5nKSA9PiBzdG9yZS5zZXRTdGF0ZSh7IHBhbmVEcmFnZ2luZyB9KSxcbiAgICAgICAgICAgICAgICBvblBhblpvb21TdGFydDogKGV2ZW50LCB2cCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IG9uVmlld3BvcnRDaGFuZ2VTdGFydCwgb25Nb3ZlU3RhcnQgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIG9uTW92ZVN0YXJ0Py4oZXZlbnQsIHZwKTtcbiAgICAgICAgICAgICAgICAgICAgb25WaWV3cG9ydENoYW5nZVN0YXJ0Py4odnApO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb25QYW5ab29tOiAoZXZlbnQsIHZwKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgb25WaWV3cG9ydENoYW5nZSwgb25Nb3ZlIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBvbk1vdmU/LihldmVudCwgdnApO1xuICAgICAgICAgICAgICAgICAgICBvblZpZXdwb3J0Q2hhbmdlPy4odnApO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb25QYW5ab29tRW5kOiAoZXZlbnQsIHZwKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgb25WaWV3cG9ydENoYW5nZUVuZCwgb25Nb3ZlRW5kIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICBvbk1vdmVFbmQ/LihldmVudCwgdnApO1xuICAgICAgICAgICAgICAgICAgICBvblZpZXdwb3J0Q2hhbmdlRW5kPy4odnApO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHsgeCwgeSwgem9vbSB9ID0gcGFuWm9vbS5jdXJyZW50LmdldFZpZXdwb3J0KCk7XG4gICAgICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgcGFuWm9vbTogcGFuWm9vbS5jdXJyZW50LFxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogW3gsIHksIHpvb21dLFxuICAgICAgICAgICAgICAgIGRvbU5vZGU6IHpvb21QYW5lLmN1cnJlbnQuY2xvc2VzdCgnLnJlYWN0LWZsb3cnKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICBwYW5ab29tLmN1cnJlbnQ/LmRlc3Ryb3koKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgcGFuWm9vbS5jdXJyZW50Py51cGRhdGUoe1xuICAgICAgICAgICAgb25QYW5lQ29udGV4dE1lbnUsXG4gICAgICAgICAgICB6b29tT25TY3JvbGwsXG4gICAgICAgICAgICB6b29tT25QaW5jaCxcbiAgICAgICAgICAgIHBhbk9uU2Nyb2xsLFxuICAgICAgICAgICAgcGFuT25TY3JvbGxTcGVlZCxcbiAgICAgICAgICAgIHBhbk9uU2Nyb2xsTW9kZSxcbiAgICAgICAgICAgIHpvb21PbkRvdWJsZUNsaWNrLFxuICAgICAgICAgICAgcGFuT25EcmFnLFxuICAgICAgICAgICAgem9vbUFjdGl2YXRpb25LZXlQcmVzc2VkLFxuICAgICAgICAgICAgcHJldmVudFNjcm9sbGluZyxcbiAgICAgICAgICAgIG5vUGFuQ2xhc3NOYW1lLFxuICAgICAgICAgICAgdXNlclNlbGVjdGlvbkFjdGl2ZSxcbiAgICAgICAgICAgIG5vV2hlZWxDbGFzc05hbWUsXG4gICAgICAgICAgICBsaWIsXG4gICAgICAgICAgICBvblRyYW5zZm9ybUNoYW5nZSxcbiAgICAgICAgfSk7XG4gICAgfSwgW1xuICAgICAgICBvblBhbmVDb250ZXh0TWVudSxcbiAgICAgICAgem9vbU9uU2Nyb2xsLFxuICAgICAgICB6b29tT25QaW5jaCxcbiAgICAgICAgcGFuT25TY3JvbGwsXG4gICAgICAgIHBhbk9uU2Nyb2xsU3BlZWQsXG4gICAgICAgIHBhbk9uU2Nyb2xsTW9kZSxcbiAgICAgICAgem9vbU9uRG91YmxlQ2xpY2ssXG4gICAgICAgIHBhbk9uRHJhZyxcbiAgICAgICAgem9vbUFjdGl2YXRpb25LZXlQcmVzc2VkLFxuICAgICAgICBwcmV2ZW50U2Nyb2xsaW5nLFxuICAgICAgICBub1BhbkNsYXNzTmFtZSxcbiAgICAgICAgdXNlclNlbGVjdGlvbkFjdGl2ZSxcbiAgICAgICAgbm9XaGVlbENsYXNzTmFtZSxcbiAgICAgICAgbGliLFxuICAgICAgICBvblRyYW5zZm9ybUNoYW5nZSxcbiAgICBdKTtcbiAgICByZXR1cm4gKGpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19yZW5kZXJlclwiLCByZWY6IHpvb21QYW5lLCBzdHlsZTogY29udGFpbmVyU3R5bGUsIGNoaWxkcmVuOiBjaGlsZHJlbiB9KSk7XG59XG5cbmNvbnN0IHNlbGVjdG9yJGkgPSAocykgPT4gKHtcbiAgICB1c2VyU2VsZWN0aW9uQWN0aXZlOiBzLnVzZXJTZWxlY3Rpb25BY3RpdmUsXG4gICAgdXNlclNlbGVjdGlvblJlY3Q6IHMudXNlclNlbGVjdGlvblJlY3QsXG59KTtcbmZ1bmN0aW9uIFVzZXJTZWxlY3Rpb24oKSB7XG4gICAgY29uc3QgeyB1c2VyU2VsZWN0aW9uQWN0aXZlLCB1c2VyU2VsZWN0aW9uUmVjdCB9ID0gdXNlU3RvcmUoc2VsZWN0b3IkaSwgc2hhbGxvdyk7XG4gICAgY29uc3QgaXNBY3RpdmUgPSB1c2VyU2VsZWN0aW9uQWN0aXZlICYmIHVzZXJTZWxlY3Rpb25SZWN0O1xuICAgIGlmICghaXNBY3RpdmUpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiAoanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX3NlbGVjdGlvbiByZWFjdC1mbG93X19jb250YWluZXJcIiwgc3R5bGU6IHtcbiAgICAgICAgICAgIHdpZHRoOiB1c2VyU2VsZWN0aW9uUmVjdC53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogdXNlclNlbGVjdGlvblJlY3QuaGVpZ2h0LFxuICAgICAgICAgICAgdHJhbnNmb3JtOiBgdHJhbnNsYXRlKCR7dXNlclNlbGVjdGlvblJlY3QueH1weCwgJHt1c2VyU2VsZWN0aW9uUmVjdC55fXB4KWAsXG4gICAgICAgIH0gfSkpO1xufVxuXG5jb25zdCB3cmFwSGFuZGxlciA9IChoYW5kbGVyLCBjb250YWluZXJSZWYpID0+IHtcbiAgICByZXR1cm4gKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChldmVudC50YXJnZXQgIT09IGNvbnRhaW5lclJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaGFuZGxlcj8uKGV2ZW50KTtcbiAgICB9O1xufTtcbmNvbnN0IHNlbGVjdG9yJGggPSAocykgPT4gKHtcbiAgICB1c2VyU2VsZWN0aW9uQWN0aXZlOiBzLnVzZXJTZWxlY3Rpb25BY3RpdmUsXG4gICAgZWxlbWVudHNTZWxlY3RhYmxlOiBzLmVsZW1lbnRzU2VsZWN0YWJsZSxcbiAgICBkcmFnZ2luZzogcy5wYW5lRHJhZ2dpbmcsXG59KTtcbmZ1bmN0aW9uIFBhbmUoeyBpc1NlbGVjdGluZywgc2VsZWN0aW9uS2V5UHJlc3NlZCwgc2VsZWN0aW9uTW9kZSA9IFNlbGVjdGlvbk1vZGUuRnVsbCwgcGFuT25EcmFnLCBzZWxlY3Rpb25PbkRyYWcsIG9uU2VsZWN0aW9uU3RhcnQsIG9uU2VsZWN0aW9uRW5kLCBvblBhbmVDbGljaywgb25QYW5lQ29udGV4dE1lbnUsIG9uUGFuZVNjcm9sbCwgb25QYW5lTW91c2VFbnRlciwgb25QYW5lTW91c2VNb3ZlLCBvblBhbmVNb3VzZUxlYXZlLCBjaGlsZHJlbiwgfSkge1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICBjb25zdCB7IHVzZXJTZWxlY3Rpb25BY3RpdmUsIGVsZW1lbnRzU2VsZWN0YWJsZSwgZHJhZ2dpbmcgfSA9IHVzZVN0b3JlKHNlbGVjdG9yJGgsIHNoYWxsb3cpO1xuICAgIGNvbnN0IGhhc0FjdGl2ZVNlbGVjdGlvbiA9IGVsZW1lbnRzU2VsZWN0YWJsZSAmJiAoaXNTZWxlY3RpbmcgfHwgdXNlclNlbGVjdGlvbkFjdGl2ZSk7XG4gICAgY29uc3QgY29udGFpbmVyID0gdXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IGNvbnRhaW5lckJvdW5kcyA9IHVzZVJlZigpO1xuICAgIGNvbnN0IHNlbGVjdGVkTm9kZUlkcyA9IHVzZVJlZihuZXcgU2V0KCkpO1xuICAgIGNvbnN0IHNlbGVjdGVkRWRnZUlkcyA9IHVzZVJlZihuZXcgU2V0KCkpO1xuICAgIC8vIFVzZWQgdG8gcHJldmVudCBjbGljayBldmVudHMgd2hlbiB0aGUgdXNlciBsZXRzIGdvIG9mIHRoZSBzZWxlY3Rpb25LZXkgZHVyaW5nIGEgc2VsZWN0aW9uXG4gICAgY29uc3Qgc2VsZWN0aW9uSW5Qcm9ncmVzcyA9IHVzZVJlZihmYWxzZSk7XG4gICAgY29uc3Qgc2VsZWN0aW9uU3RhcnRlZCA9IHVzZVJlZihmYWxzZSk7XG4gICAgY29uc3Qgb25DbGljayA9IChldmVudCkgPT4ge1xuICAgICAgICAvLyBXZSBwcmV2ZW50IGNsaWNrIGV2ZW50cyB3aGVuIHRoZSB1c2VyIGxldCBnbyBvZiB0aGUgc2VsZWN0aW9uS2V5IGR1cmluZyBhIHNlbGVjdGlvblxuICAgICAgICBpZiAoc2VsZWN0aW9uSW5Qcm9ncmVzcy5jdXJyZW50KSB7XG4gICAgICAgICAgICBzZWxlY3Rpb25JblByb2dyZXNzLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBvblBhbmVDbGljaz8uKGV2ZW50KTtcbiAgICAgICAgc3RvcmUuZ2V0U3RhdGUoKS5yZXNldFNlbGVjdGVkRWxlbWVudHMoKTtcbiAgICAgICAgc3RvcmUuc2V0U3RhdGUoeyBub2Rlc1NlbGVjdGlvbkFjdGl2ZTogZmFsc2UgfSk7XG4gICAgfTtcbiAgICBjb25zdCBvbkNvbnRleHRNZW51ID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhbk9uRHJhZykgJiYgcGFuT25EcmFnPy5pbmNsdWRlcygyKSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBvblBhbmVDb250ZXh0TWVudT8uKGV2ZW50KTtcbiAgICB9O1xuICAgIGNvbnN0IG9uV2hlZWwgPSBvblBhbmVTY3JvbGwgPyAoZXZlbnQpID0+IG9uUGFuZVNjcm9sbChldmVudCkgOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qgb25Qb2ludGVyRG93biA9IChldmVudCkgPT4ge1xuICAgICAgICBjb25zdCB7IHJlc2V0U2VsZWN0ZWRFbGVtZW50cywgZG9tTm9kZSB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgY29udGFpbmVyQm91bmRzLmN1cnJlbnQgPSBkb21Ob2RlPy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgaWYgKCFlbGVtZW50c1NlbGVjdGFibGUgfHxcbiAgICAgICAgICAgICFpc1NlbGVjdGluZyB8fFxuICAgICAgICAgICAgZXZlbnQuYnV0dG9uICE9PSAwIHx8XG4gICAgICAgICAgICBldmVudC50YXJnZXQgIT09IGNvbnRhaW5lci5jdXJyZW50IHx8XG4gICAgICAgICAgICAhY29udGFpbmVyQm91bmRzLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBldmVudC50YXJnZXQ/LnNldFBvaW50ZXJDYXB0dXJlPy4oZXZlbnQucG9pbnRlcklkKTtcbiAgICAgICAgc2VsZWN0aW9uU3RhcnRlZC5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgc2VsZWN0aW9uSW5Qcm9ncmVzcy5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IHsgeCwgeSB9ID0gZ2V0RXZlbnRQb3NpdGlvbihldmVudC5uYXRpdmVFdmVudCwgY29udGFpbmVyQm91bmRzLmN1cnJlbnQpO1xuICAgICAgICByZXNldFNlbGVjdGVkRWxlbWVudHMoKTtcbiAgICAgICAgc3RvcmUuc2V0U3RhdGUoe1xuICAgICAgICAgICAgdXNlclNlbGVjdGlvblJlY3Q6IHtcbiAgICAgICAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgICAgICAgICAgc3RhcnRYOiB4LFxuICAgICAgICAgICAgICAgIHN0YXJ0WTogeSxcbiAgICAgICAgICAgICAgICB4LFxuICAgICAgICAgICAgICAgIHksXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgb25TZWxlY3Rpb25TdGFydD8uKGV2ZW50KTtcbiAgICB9O1xuICAgIGNvbnN0IG9uUG9pbnRlck1vdmUgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgY29uc3QgeyB1c2VyU2VsZWN0aW9uUmVjdCwgdHJhbnNmb3JtLCBub2RlTG9va3VwLCBlZGdlTG9va3VwLCBjb25uZWN0aW9uTG9va3VwLCB0cmlnZ2VyTm9kZUNoYW5nZXMsIHRyaWdnZXJFZGdlQ2hhbmdlcywgZGVmYXVsdEVkZ2VPcHRpb25zLCB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgaWYgKCFjb250YWluZXJCb3VuZHMuY3VycmVudCB8fCAhdXNlclNlbGVjdGlvblJlY3QpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzZWxlY3Rpb25JblByb2dyZXNzLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICBjb25zdCB7IHg6IG1vdXNlWCwgeTogbW91c2VZIH0gPSBnZXRFdmVudFBvc2l0aW9uKGV2ZW50Lm5hdGl2ZUV2ZW50LCBjb250YWluZXJCb3VuZHMuY3VycmVudCk7XG4gICAgICAgIGNvbnN0IHsgc3RhcnRYLCBzdGFydFkgfSA9IHVzZXJTZWxlY3Rpb25SZWN0O1xuICAgICAgICBjb25zdCBuZXh0VXNlclNlbGVjdFJlY3QgPSB7XG4gICAgICAgICAgICBzdGFydFgsXG4gICAgICAgICAgICBzdGFydFksXG4gICAgICAgICAgICB4OiBtb3VzZVggPCBzdGFydFggPyBtb3VzZVggOiBzdGFydFgsXG4gICAgICAgICAgICB5OiBtb3VzZVkgPCBzdGFydFkgPyBtb3VzZVkgOiBzdGFydFksXG4gICAgICAgICAgICB3aWR0aDogTWF0aC5hYnMobW91c2VYIC0gc3RhcnRYKSxcbiAgICAgICAgICAgIGhlaWdodDogTWF0aC5hYnMobW91c2VZIC0gc3RhcnRZKSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcHJldlNlbGVjdGVkTm9kZUlkcyA9IHNlbGVjdGVkTm9kZUlkcy5jdXJyZW50O1xuICAgICAgICBjb25zdCBwcmV2U2VsZWN0ZWRFZGdlSWRzID0gc2VsZWN0ZWRFZGdlSWRzLmN1cnJlbnQ7XG4gICAgICAgIHNlbGVjdGVkTm9kZUlkcy5jdXJyZW50ID0gbmV3IFNldChnZXROb2Rlc0luc2lkZShub2RlTG9va3VwLCBuZXh0VXNlclNlbGVjdFJlY3QsIHRyYW5zZm9ybSwgc2VsZWN0aW9uTW9kZSA9PT0gU2VsZWN0aW9uTW9kZS5QYXJ0aWFsLCB0cnVlKS5tYXAoKG5vZGUpID0+IG5vZGUuaWQpKTtcbiAgICAgICAgc2VsZWN0ZWRFZGdlSWRzLmN1cnJlbnQgPSBuZXcgU2V0KCk7XG4gICAgICAgIGNvbnN0IGVkZ2VzU2VsZWN0YWJsZSA9IGRlZmF1bHRFZGdlT3B0aW9ucz8uc2VsZWN0YWJsZSA/PyB0cnVlO1xuICAgICAgICAvLyBXZSBsb29rIGZvciBhbGwgZWRnZXMgY29ubmVjdGVkIHRvIHRoZSBzZWxlY3RlZCBub2Rlc1xuICAgICAgICBmb3IgKGNvbnN0IG5vZGVJZCBvZiBzZWxlY3RlZE5vZGVJZHMuY3VycmVudCkge1xuICAgICAgICAgICAgY29uc3QgY29ubmVjdGlvbnMgPSBjb25uZWN0aW9uTG9va3VwLmdldChub2RlSWQpO1xuICAgICAgICAgICAgaWYgKCFjb25uZWN0aW9ucylcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgeyBlZGdlSWQgfSBvZiBjb25uZWN0aW9ucy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVkZ2UgPSBlZGdlTG9va3VwLmdldChlZGdlSWQpO1xuICAgICAgICAgICAgICAgIGlmIChlZGdlICYmIChlZGdlLnNlbGVjdGFibGUgPz8gZWRnZXNTZWxlY3RhYmxlKSkge1xuICAgICAgICAgICAgICAgICAgICBzZWxlY3RlZEVkZ2VJZHMuY3VycmVudC5hZGQoZWRnZUlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhcmVTZXRzRXF1YWwocHJldlNlbGVjdGVkTm9kZUlkcywgc2VsZWN0ZWROb2RlSWRzLmN1cnJlbnQpKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFuZ2VzID0gZ2V0U2VsZWN0aW9uQ2hhbmdlcyhub2RlTG9va3VwLCBzZWxlY3RlZE5vZGVJZHMuY3VycmVudCwgdHJ1ZSk7XG4gICAgICAgICAgICB0cmlnZ2VyTm9kZUNoYW5nZXMoY2hhbmdlcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhcmVTZXRzRXF1YWwocHJldlNlbGVjdGVkRWRnZUlkcywgc2VsZWN0ZWRFZGdlSWRzLmN1cnJlbnQpKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFuZ2VzID0gZ2V0U2VsZWN0aW9uQ2hhbmdlcyhlZGdlTG9va3VwLCBzZWxlY3RlZEVkZ2VJZHMuY3VycmVudCk7XG4gICAgICAgICAgICB0cmlnZ2VyRWRnZUNoYW5nZXMoY2hhbmdlcyk7XG4gICAgICAgIH1cbiAgICAgICAgc3RvcmUuc2V0U3RhdGUoe1xuICAgICAgICAgICAgdXNlclNlbGVjdGlvblJlY3Q6IG5leHRVc2VyU2VsZWN0UmVjdCxcbiAgICAgICAgICAgIHVzZXJTZWxlY3Rpb25BY3RpdmU6IHRydWUsXG4gICAgICAgICAgICBub2Rlc1NlbGVjdGlvbkFjdGl2ZTogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3Qgb25Qb2ludGVyVXAgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKGV2ZW50LmJ1dHRvbiAhPT0gMCB8fCAhc2VsZWN0aW9uU3RhcnRlZC5jdXJyZW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnQudGFyZ2V0Py5yZWxlYXNlUG9pbnRlckNhcHR1cmU/LihldmVudC5wb2ludGVySWQpO1xuICAgICAgICBjb25zdCB7IHVzZXJTZWxlY3Rpb25SZWN0IH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAvKlxuICAgICAgICAgKiBXZSBvbmx5IHdhbnQgdG8gdHJpZ2dlciBjbGljayBmdW5jdGlvbnMgd2hlbiBpbiBzZWxlY3Rpb24gbW9kZSBpZlxuICAgICAgICAgKiB0aGUgdXNlciBkaWQgbm90IG1vdmUgdGhlIG1vdXNlLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKCF1c2VyU2VsZWN0aW9uQWN0aXZlICYmIHVzZXJTZWxlY3Rpb25SZWN0ICYmIGV2ZW50LnRhcmdldCA9PT0gY29udGFpbmVyLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIG9uQ2xpY2s/LihldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RvcmUuc2V0U3RhdGUoe1xuICAgICAgICAgICAgdXNlclNlbGVjdGlvbkFjdGl2ZTogZmFsc2UsXG4gICAgICAgICAgICB1c2VyU2VsZWN0aW9uUmVjdDogbnVsbCxcbiAgICAgICAgICAgIG5vZGVzU2VsZWN0aW9uQWN0aXZlOiBzZWxlY3RlZE5vZGVJZHMuY3VycmVudC5zaXplID4gMCxcbiAgICAgICAgfSk7XG4gICAgICAgIG9uU2VsZWN0aW9uRW5kPy4oZXZlbnQpO1xuICAgICAgICAvKlxuICAgICAgICAgKiBJZiB0aGUgdXNlciBrZXB0IGhvbGRpbmcgdGhlIHNlbGVjdGlvbktleSBkdXJpbmcgdGhlIHNlbGVjdGlvbixcbiAgICAgICAgICogd2UgbmVlZCB0byByZXNldCB0aGUgc2VsZWN0aW9uSW5Qcm9ncmVzcywgc28gdGhlIG5leHQgY2xpY2sgZXZlbnQgaXMgbm90IHByZXZlbnRlZFxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHNlbGVjdGlvbktleVByZXNzZWQgfHwgc2VsZWN0aW9uT25EcmFnKSB7XG4gICAgICAgICAgICBzZWxlY3Rpb25JblByb2dyZXNzLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBzZWxlY3Rpb25TdGFydGVkLmN1cnJlbnQgPSBmYWxzZTtcbiAgICB9O1xuICAgIGNvbnN0IGRyYWdnYWJsZSA9IHBhbk9uRHJhZyA9PT0gdHJ1ZSB8fCAoQXJyYXkuaXNBcnJheShwYW5PbkRyYWcpICYmIHBhbk9uRHJhZy5pbmNsdWRlcygwKSk7XG4gICAgcmV0dXJuIChqc3hzKFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBjYyhbJ3JlYWN0LWZsb3dfX3BhbmUnLCB7IGRyYWdnYWJsZSwgZHJhZ2dpbmcsIHNlbGVjdGlvbjogaXNTZWxlY3RpbmcgfV0pLCBvbkNsaWNrOiBoYXNBY3RpdmVTZWxlY3Rpb24gPyB1bmRlZmluZWQgOiB3cmFwSGFuZGxlcihvbkNsaWNrLCBjb250YWluZXIpLCBvbkNvbnRleHRNZW51OiB3cmFwSGFuZGxlcihvbkNvbnRleHRNZW51LCBjb250YWluZXIpLCBvbldoZWVsOiB3cmFwSGFuZGxlcihvbldoZWVsLCBjb250YWluZXIpLCBvblBvaW50ZXJFbnRlcjogaGFzQWN0aXZlU2VsZWN0aW9uID8gdW5kZWZpbmVkIDogb25QYW5lTW91c2VFbnRlciwgb25Qb2ludGVyRG93bjogaGFzQWN0aXZlU2VsZWN0aW9uID8gb25Qb2ludGVyRG93biA6IG9uUGFuZU1vdXNlTW92ZSwgb25Qb2ludGVyTW92ZTogaGFzQWN0aXZlU2VsZWN0aW9uID8gb25Qb2ludGVyTW92ZSA6IG9uUGFuZU1vdXNlTW92ZSwgb25Qb2ludGVyVXA6IGhhc0FjdGl2ZVNlbGVjdGlvbiA/IG9uUG9pbnRlclVwIDogdW5kZWZpbmVkLCBvblBvaW50ZXJMZWF2ZTogb25QYW5lTW91c2VMZWF2ZSwgcmVmOiBjb250YWluZXIsIHN0eWxlOiBjb250YWluZXJTdHlsZSwgY2hpbGRyZW46IFtjaGlsZHJlbiwganN4KFVzZXJTZWxlY3Rpb24sIHt9KV0gfSkpO1xufVxuXG4vKlxuICogdGhpcyBoYW5kbGVyIGlzIGNhbGxlZCBieVxuICogMS4gdGhlIGNsaWNrIGhhbmRsZXIgd2hlbiBub2RlIGlzIG5vdCBkcmFnZ2FibGUgb3Igc2VsZWN0Tm9kZXNPbkRyYWcgPSBmYWxzZVxuICogb3JcbiAqIDIuIHRoZSBvbiBkcmFnIHN0YXJ0IGhhbmRsZXIgd2hlbiBub2RlIGlzIGRyYWdnYWJsZSBhbmQgc2VsZWN0Tm9kZXNPbkRyYWcgPSB0cnVlXG4gKi9cbmZ1bmN0aW9uIGhhbmRsZU5vZGVDbGljayh7IGlkLCBzdG9yZSwgdW5zZWxlY3QgPSBmYWxzZSwgbm9kZVJlZiwgfSkge1xuICAgIGNvbnN0IHsgYWRkU2VsZWN0ZWROb2RlcywgdW5zZWxlY3ROb2Rlc0FuZEVkZ2VzLCBtdWx0aVNlbGVjdGlvbkFjdGl2ZSwgbm9kZUxvb2t1cCwgb25FcnJvciB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICBjb25zdCBub2RlID0gbm9kZUxvb2t1cC5nZXQoaWQpO1xuICAgIGlmICghbm9kZSkge1xuICAgICAgICBvbkVycm9yPy4oJzAxMicsIGVycm9yTWVzc2FnZXNbJ2Vycm9yMDEyJ10oaWQpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdG9yZS5zZXRTdGF0ZSh7IG5vZGVzU2VsZWN0aW9uQWN0aXZlOiBmYWxzZSB9KTtcbiAgICBpZiAoIW5vZGUuc2VsZWN0ZWQpIHtcbiAgICAgICAgYWRkU2VsZWN0ZWROb2RlcyhbaWRdKTtcbiAgICB9XG4gICAgZWxzZSBpZiAodW5zZWxlY3QgfHwgKG5vZGUuc2VsZWN0ZWQgJiYgbXVsdGlTZWxlY3Rpb25BY3RpdmUpKSB7XG4gICAgICAgIHVuc2VsZWN0Tm9kZXNBbmRFZGdlcyh7IG5vZGVzOiBbbm9kZV0sIGVkZ2VzOiBbXSB9KTtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IG5vZGVSZWY/LmN1cnJlbnQ/LmJsdXIoKSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEhvb2sgZm9yIGNhbGxpbmcgWFlEcmFnIGhlbHBlciBmcm9tIEB4eWZsb3cvc3lzdGVtLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiB1c2VEcmFnKHsgbm9kZVJlZiwgZGlzYWJsZWQgPSBmYWxzZSwgbm9EcmFnQ2xhc3NOYW1lLCBoYW5kbGVTZWxlY3Rvciwgbm9kZUlkLCBpc1NlbGVjdGFibGUsIG5vZGVDbGlja0Rpc3RhbmNlLCB9KSB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIGNvbnN0IFtkcmFnZ2luZywgc2V0RHJhZ2dpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IHh5RHJhZyA9IHVzZVJlZigpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHh5RHJhZy5jdXJyZW50ID0gWFlEcmFnKHtcbiAgICAgICAgICAgIGdldFN0b3JlSXRlbXM6ICgpID0+IHN0b3JlLmdldFN0YXRlKCksXG4gICAgICAgICAgICBvbk5vZGVNb3VzZURvd246IChpZCkgPT4ge1xuICAgICAgICAgICAgICAgIGhhbmRsZU5vZGVDbGljayh7XG4gICAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgICBzdG9yZSxcbiAgICAgICAgICAgICAgICAgICAgbm9kZVJlZixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkRyYWdTdGFydDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIHNldERyYWdnaW5nKHRydWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uRHJhZ1N0b3A6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBzZXREcmFnZ2luZyhmYWxzZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9LCBbXSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKGRpc2FibGVkKSB7XG4gICAgICAgICAgICB4eURyYWcuY3VycmVudD8uZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5vZGVSZWYuY3VycmVudCkge1xuICAgICAgICAgICAgeHlEcmFnLmN1cnJlbnQ/LnVwZGF0ZSh7XG4gICAgICAgICAgICAgICAgbm9EcmFnQ2xhc3NOYW1lLFxuICAgICAgICAgICAgICAgIGhhbmRsZVNlbGVjdG9yLFxuICAgICAgICAgICAgICAgIGRvbU5vZGU6IG5vZGVSZWYuY3VycmVudCxcbiAgICAgICAgICAgICAgICBpc1NlbGVjdGFibGUsXG4gICAgICAgICAgICAgICAgbm9kZUlkLFxuICAgICAgICAgICAgICAgIG5vZGVDbGlja0Rpc3RhbmNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHh5RHJhZy5jdXJyZW50Py5kZXN0cm95KCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSwgW25vRHJhZ0NsYXNzTmFtZSwgaGFuZGxlU2VsZWN0b3IsIGRpc2FibGVkLCBpc1NlbGVjdGFibGUsIG5vZGVSZWYsIG5vZGVJZF0pO1xuICAgIHJldHVybiBkcmFnZ2luZztcbn1cblxuY29uc3Qgc2VsZWN0ZWRBbmREcmFnZ2FibGUgPSAobm9kZXNEcmFnZ2FibGUpID0+IChuKSA9PiBuLnNlbGVjdGVkICYmIChuLmRyYWdnYWJsZSB8fCAobm9kZXNEcmFnZ2FibGUgJiYgdHlwZW9mIG4uZHJhZ2dhYmxlID09PSAndW5kZWZpbmVkJykpO1xuLyoqXG4gKiBIb29rIGZvciB1cGRhdGluZyBub2RlIHBvc2l0aW9ucyBieSBwYXNzaW5nIGEgZGlyZWN0aW9uIGFuZCBmYWN0b3JcbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEByZXR1cm5zIGZ1bmN0aW9uIGZvciB1cGRhdGluZyBub2RlIHBvc2l0aW9uc1xuICovXG5mdW5jdGlvbiB1c2VNb3ZlU2VsZWN0ZWROb2RlcygpIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3QgbW92ZVNlbGVjdGVkTm9kZXMgPSB1c2VDYWxsYmFjaygocGFyYW1zKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgbm9kZUV4dGVudCwgc25hcFRvR3JpZCwgc25hcEdyaWQsIG5vZGVzRHJhZ2dhYmxlLCBvbkVycm9yLCB1cGRhdGVOb2RlUG9zaXRpb25zLCBub2RlTG9va3VwLCBub2RlT3JpZ2luIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICBjb25zdCBub2RlVXBkYXRlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgY29uc3QgaXNTZWxlY3RlZCA9IHNlbGVjdGVkQW5kRHJhZ2dhYmxlKG5vZGVzRHJhZ2dhYmxlKTtcbiAgICAgICAgLypcbiAgICAgICAgICogYnkgZGVmYXVsdCBhIG5vZGUgbW92ZXMgNXB4IG9uIGVhY2gga2V5IHByZXNzXG4gICAgICAgICAqIGlmIHNuYXAgZ3JpZCBpcyBlbmFibGVkLCB3ZSB1c2UgdGhhdCBmb3IgdGhlIHZlbG9jaXR5XG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCB4VmVsbyA9IHNuYXBUb0dyaWQgPyBzbmFwR3JpZFswXSA6IDU7XG4gICAgICAgIGNvbnN0IHlWZWxvID0gc25hcFRvR3JpZCA/IHNuYXBHcmlkWzFdIDogNTtcbiAgICAgICAgY29uc3QgeERpZmYgPSBwYXJhbXMuZGlyZWN0aW9uLnggKiB4VmVsbyAqIHBhcmFtcy5mYWN0b3I7XG4gICAgICAgIGNvbnN0IHlEaWZmID0gcGFyYW1zLmRpcmVjdGlvbi55ICogeVZlbG8gKiBwYXJhbXMuZmFjdG9yO1xuICAgICAgICBmb3IgKGNvbnN0IFssIG5vZGVdIG9mIG5vZGVMb29rdXApIHtcbiAgICAgICAgICAgIGlmICghaXNTZWxlY3RlZChub2RlKSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IG5leHRQb3NpdGlvbiA9IHtcbiAgICAgICAgICAgICAgICB4OiBub2RlLmludGVybmFscy5wb3NpdGlvbkFic29sdXRlLnggKyB4RGlmZixcbiAgICAgICAgICAgICAgICB5OiBub2RlLmludGVybmFscy5wb3NpdGlvbkFic29sdXRlLnkgKyB5RGlmZixcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoc25hcFRvR3JpZCkge1xuICAgICAgICAgICAgICAgIG5leHRQb3NpdGlvbiA9IHNuYXBQb3NpdGlvbihuZXh0UG9zaXRpb24sIHNuYXBHcmlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHsgcG9zaXRpb24sIHBvc2l0aW9uQWJzb2x1dGUgfSA9IGNhbGN1bGF0ZU5vZGVQb3NpdGlvbih7XG4gICAgICAgICAgICAgICAgbm9kZUlkOiBub2RlLmlkLFxuICAgICAgICAgICAgICAgIG5leHRQb3NpdGlvbixcbiAgICAgICAgICAgICAgICBub2RlTG9va3VwLFxuICAgICAgICAgICAgICAgIG5vZGVFeHRlbnQsXG4gICAgICAgICAgICAgICAgbm9kZU9yaWdpbixcbiAgICAgICAgICAgICAgICBvbkVycm9yLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBub2RlLnBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgICAgICAgICBub2RlLmludGVybmFscy5wb3NpdGlvbkFic29sdXRlID0gcG9zaXRpb25BYnNvbHV0ZTtcbiAgICAgICAgICAgIG5vZGVVcGRhdGVzLnNldChub2RlLmlkLCBub2RlKTtcbiAgICAgICAgfVxuICAgICAgICB1cGRhdGVOb2RlUG9zaXRpb25zKG5vZGVVcGRhdGVzKTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIG1vdmVTZWxlY3RlZE5vZGVzO1xufVxuXG5jb25zdCBOb2RlSWRDb250ZXh0ID0gY3JlYXRlQ29udGV4dChudWxsKTtcbmNvbnN0IFByb3ZpZGVyID0gTm9kZUlkQ29udGV4dC5Qcm92aWRlcjtcbk5vZGVJZENvbnRleHQuQ29uc3VtZXI7XG4vKipcbiAqIFlvdSBjYW4gdXNlIHRoaXMgaG9vayB0byBnZXQgdGhlIGlkIG9mIHRoZSBub2RlIGl0IGlzIHVzZWQgaW5zaWRlLiBJdCBpcyB1c2VmdWxcbiAqIGlmIHlvdSBuZWVkIHRoZSBub2RlJ3MgaWQgZGVlcGVyIGluIHRoZSByZW5kZXIgdHJlZSBidXQgZG9uJ3Qgd2FudCB0byBtYW51YWxseVxuICogZHJpbGwgZG93biB0aGUgaWQgYXMgYSBwcm9wLlxuICpcbiAqIEBwdWJsaWNcbiAqIEByZXR1cm5zIGlkIG9mIHRoZSBub2RlXG4gKlxuICogQGV4YW1wbGVcbiAqYGBganN4XG4gKmltcG9ydCB7IHVzZU5vZGVJZCB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQ3VzdG9tTm9kZSgpIHtcbiAqICByZXR1cm4gKFxuICogICAgPGRpdj5cbiAqICAgICAgPHNwYW4+VGhpcyBub2RlIGhhcyBhbiBpZCBvZiA8L3NwYW4+XG4gKiAgICAgIDxOb2RlSWREaXNwbGF5IC8+XG4gKiAgICA8L2Rpdj5cbiAqICApO1xuICp9XG4gKlxuICpmdW5jdGlvbiBOb2RlSWREaXNwbGF5KCkge1xuICogIGNvbnN0IG5vZGVJZCA9IHVzZU5vZGVJZCgpO1xuICpcbiAqICByZXR1cm4gPHNwYW4+e25vZGVJZH08L3NwYW4+O1xuICp9XG4gKmBgYFxuICovXG5jb25zdCB1c2VOb2RlSWQgPSAoKSA9PiB7XG4gICAgY29uc3Qgbm9kZUlkID0gdXNlQ29udGV4dChOb2RlSWRDb250ZXh0KTtcbiAgICByZXR1cm4gbm9kZUlkO1xufTtcblxuY29uc3Qgc2VsZWN0b3IkZyA9IChzKSA9PiAoe1xuICAgIGNvbm5lY3RPbkNsaWNrOiBzLmNvbm5lY3RPbkNsaWNrLFxuICAgIG5vUGFuQ2xhc3NOYW1lOiBzLm5vUGFuQ2xhc3NOYW1lLFxuICAgIHJmSWQ6IHMucmZJZCxcbn0pO1xuY29uc3QgY29ubmVjdGluZ1NlbGVjdG9yID0gKG5vZGVJZCwgaGFuZGxlSWQsIHR5cGUpID0+IChzdGF0ZSkgPT4ge1xuICAgIGNvbnN0IHsgY29ubmVjdGlvbkNsaWNrU3RhcnRIYW5kbGU6IGNsaWNrSGFuZGxlLCBjb25uZWN0aW9uTW9kZSwgY29ubmVjdGlvbiB9ID0gc3RhdGU7XG4gICAgY29uc3QgeyBmcm9tSGFuZGxlLCB0b0hhbmRsZSwgaXNWYWxpZCB9ID0gY29ubmVjdGlvbjtcbiAgICBjb25zdCBjb25uZWN0aW5nVG8gPSB0b0hhbmRsZT8ubm9kZUlkID09PSBub2RlSWQgJiYgdG9IYW5kbGU/LmlkID09PSBoYW5kbGVJZCAmJiB0b0hhbmRsZT8udHlwZSA9PT0gdHlwZTtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb25uZWN0aW5nRnJvbTogZnJvbUhhbmRsZT8ubm9kZUlkID09PSBub2RlSWQgJiYgZnJvbUhhbmRsZT8uaWQgPT09IGhhbmRsZUlkICYmIGZyb21IYW5kbGU/LnR5cGUgPT09IHR5cGUsXG4gICAgICAgIGNvbm5lY3RpbmdUbyxcbiAgICAgICAgY2xpY2tDb25uZWN0aW5nOiBjbGlja0hhbmRsZT8ubm9kZUlkID09PSBub2RlSWQgJiYgY2xpY2tIYW5kbGU/LmlkID09PSBoYW5kbGVJZCAmJiBjbGlja0hhbmRsZT8udHlwZSA9PT0gdHlwZSxcbiAgICAgICAgaXNQb3NzaWJsZUVuZEhhbmRsZTogY29ubmVjdGlvbk1vZGUgPT09IENvbm5lY3Rpb25Nb2RlLlN0cmljdFxuICAgICAgICAgICAgPyBmcm9tSGFuZGxlPy50eXBlICE9PSB0eXBlXG4gICAgICAgICAgICA6IG5vZGVJZCAhPT0gZnJvbUhhbmRsZT8ubm9kZUlkIHx8IGhhbmRsZUlkICE9PSBmcm9tSGFuZGxlPy5pZCxcbiAgICAgICAgY29ubmVjdGlvbkluUHJvY2VzczogISFmcm9tSGFuZGxlLFxuICAgICAgICBjbGlja0Nvbm5lY3Rpb25JblByb2Nlc3M6ICEhY2xpY2tIYW5kbGUsXG4gICAgICAgIHZhbGlkOiBjb25uZWN0aW5nVG8gJiYgaXNWYWxpZCxcbiAgICB9O1xufTtcbmZ1bmN0aW9uIEhhbmRsZUNvbXBvbmVudCh7IHR5cGUgPSAnc291cmNlJywgcG9zaXRpb24gPSBQb3NpdGlvbi5Ub3AsIGlzVmFsaWRDb25uZWN0aW9uLCBpc0Nvbm5lY3RhYmxlID0gdHJ1ZSwgaXNDb25uZWN0YWJsZVN0YXJ0ID0gdHJ1ZSwgaXNDb25uZWN0YWJsZUVuZCA9IHRydWUsIGlkLCBvbkNvbm5lY3QsIGNoaWxkcmVuLCBjbGFzc05hbWUsIG9uTW91c2VEb3duLCBvblRvdWNoU3RhcnQsIC4uLnJlc3QgfSwgcmVmKSB7XG4gICAgY29uc3QgaGFuZGxlSWQgPSBpZCB8fCBudWxsO1xuICAgIGNvbnN0IGlzVGFyZ2V0ID0gdHlwZSA9PT0gJ3RhcmdldCc7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIGNvbnN0IG5vZGVJZCA9IHVzZU5vZGVJZCgpO1xuICAgIGNvbnN0IHsgY29ubmVjdE9uQ2xpY2ssIG5vUGFuQ2xhc3NOYW1lLCByZklkIH0gPSB1c2VTdG9yZShzZWxlY3RvciRnLCBzaGFsbG93KTtcbiAgICBjb25zdCB7IGNvbm5lY3RpbmdGcm9tLCBjb25uZWN0aW5nVG8sIGNsaWNrQ29ubmVjdGluZywgaXNQb3NzaWJsZUVuZEhhbmRsZSwgY29ubmVjdGlvbkluUHJvY2VzcywgY2xpY2tDb25uZWN0aW9uSW5Qcm9jZXNzLCB2YWxpZCwgfSA9IHVzZVN0b3JlKGNvbm5lY3RpbmdTZWxlY3Rvcihub2RlSWQsIGhhbmRsZUlkLCB0eXBlKSwgc2hhbGxvdyk7XG4gICAgaWYgKCFub2RlSWQpIHtcbiAgICAgICAgc3RvcmUuZ2V0U3RhdGUoKS5vbkVycm9yPy4oJzAxMCcsIGVycm9yTWVzc2FnZXNbJ2Vycm9yMDEwJ10oKSk7XG4gICAgfVxuICAgIGNvbnN0IG9uQ29ubmVjdEV4dGVuZGVkID0gKHBhcmFtcykgPT4ge1xuICAgICAgICBjb25zdCB7IGRlZmF1bHRFZGdlT3B0aW9ucywgb25Db25uZWN0OiBvbkNvbm5lY3RBY3Rpb24sIGhhc0RlZmF1bHRFZGdlcyB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgY29uc3QgZWRnZVBhcmFtcyA9IHtcbiAgICAgICAgICAgIC4uLmRlZmF1bHRFZGdlT3B0aW9ucyxcbiAgICAgICAgICAgIC4uLnBhcmFtcyxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKGhhc0RlZmF1bHRFZGdlcykge1xuICAgICAgICAgICAgY29uc3QgeyBlZGdlcywgc2V0RWRnZXMgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICBzZXRFZGdlcyhhZGRFZGdlKGVkZ2VQYXJhbXMsIGVkZ2VzKSk7XG4gICAgICAgIH1cbiAgICAgICAgb25Db25uZWN0QWN0aW9uPy4oZWRnZVBhcmFtcyk7XG4gICAgICAgIG9uQ29ubmVjdD8uKGVkZ2VQYXJhbXMpO1xuICAgIH07XG4gICAgY29uc3Qgb25Qb2ludGVyRG93biA9IChldmVudCkgPT4ge1xuICAgICAgICBpZiAoIW5vZGVJZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzTW91c2VUcmlnZ2VyZWQgPSBpc01vdXNlRXZlbnQoZXZlbnQubmF0aXZlRXZlbnQpO1xuICAgICAgICBpZiAoaXNDb25uZWN0YWJsZVN0YXJ0ICYmXG4gICAgICAgICAgICAoKGlzTW91c2VUcmlnZ2VyZWQgJiYgZXZlbnQuYnV0dG9uID09PSAwKSB8fCAhaXNNb3VzZVRyaWdnZXJlZCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRTdG9yZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICBYWUhhbmRsZS5vblBvaW50ZXJEb3duKGV2ZW50Lm5hdGl2ZUV2ZW50LCB7XG4gICAgICAgICAgICAgICAgYXV0b1Bhbk9uQ29ubmVjdDogY3VycmVudFN0b3JlLmF1dG9QYW5PbkNvbm5lY3QsXG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbk1vZGU6IGN1cnJlbnRTdG9yZS5jb25uZWN0aW9uTW9kZSxcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uUmFkaXVzOiBjdXJyZW50U3RvcmUuY29ubmVjdGlvblJhZGl1cyxcbiAgICAgICAgICAgICAgICBkb21Ob2RlOiBjdXJyZW50U3RvcmUuZG9tTm9kZSxcbiAgICAgICAgICAgICAgICBub2RlTG9va3VwOiBjdXJyZW50U3RvcmUubm9kZUxvb2t1cCxcbiAgICAgICAgICAgICAgICBsaWI6IGN1cnJlbnRTdG9yZS5saWIsXG4gICAgICAgICAgICAgICAgaXNUYXJnZXQsXG4gICAgICAgICAgICAgICAgaGFuZGxlSWQsXG4gICAgICAgICAgICAgICAgbm9kZUlkLFxuICAgICAgICAgICAgICAgIGZsb3dJZDogY3VycmVudFN0b3JlLnJmSWQsXG4gICAgICAgICAgICAgICAgcGFuQnk6IGN1cnJlbnRTdG9yZS5wYW5CeSxcbiAgICAgICAgICAgICAgICBjYW5jZWxDb25uZWN0aW9uOiBjdXJyZW50U3RvcmUuY2FuY2VsQ29ubmVjdGlvbixcbiAgICAgICAgICAgICAgICBvbkNvbm5lY3RTdGFydDogY3VycmVudFN0b3JlLm9uQ29ubmVjdFN0YXJ0LFxuICAgICAgICAgICAgICAgIG9uQ29ubmVjdEVuZDogY3VycmVudFN0b3JlLm9uQ29ubmVjdEVuZCxcbiAgICAgICAgICAgICAgICB1cGRhdGVDb25uZWN0aW9uOiBjdXJyZW50U3RvcmUudXBkYXRlQ29ubmVjdGlvbixcbiAgICAgICAgICAgICAgICBvbkNvbm5lY3Q6IG9uQ29ubmVjdEV4dGVuZGVkLFxuICAgICAgICAgICAgICAgIGlzVmFsaWRDb25uZWN0aW9uOiBpc1ZhbGlkQ29ubmVjdGlvbiB8fCBjdXJyZW50U3RvcmUuaXNWYWxpZENvbm5lY3Rpb24sXG4gICAgICAgICAgICAgICAgZ2V0VHJhbnNmb3JtOiAoKSA9PiBzdG9yZS5nZXRTdGF0ZSgpLnRyYW5zZm9ybSxcbiAgICAgICAgICAgICAgICBnZXRGcm9tSGFuZGxlOiAoKSA9PiBzdG9yZS5nZXRTdGF0ZSgpLmNvbm5lY3Rpb24uZnJvbUhhbmRsZSxcbiAgICAgICAgICAgICAgICBhdXRvUGFuU3BlZWQ6IGN1cnJlbnRTdG9yZS5hdXRvUGFuU3BlZWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNNb3VzZVRyaWdnZXJlZCkge1xuICAgICAgICAgICAgb25Nb3VzZURvd24/LihldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvblRvdWNoU3RhcnQ/LihldmVudCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IG9uQ2xpY2sgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgY29uc3QgeyBvbkNsaWNrQ29ubmVjdFN0YXJ0LCBvbkNsaWNrQ29ubmVjdEVuZCwgY29ubmVjdGlvbkNsaWNrU3RhcnRIYW5kbGUsIGNvbm5lY3Rpb25Nb2RlLCBpc1ZhbGlkQ29ubmVjdGlvbjogaXNWYWxpZENvbm5lY3Rpb25TdG9yZSwgbGliLCByZklkOiBmbG93SWQsIG5vZGVMb29rdXAsIGNvbm5lY3Rpb246IGNvbm5lY3Rpb25TdGF0ZSwgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgIGlmICghbm9kZUlkIHx8ICghY29ubmVjdGlvbkNsaWNrU3RhcnRIYW5kbGUgJiYgIWlzQ29ubmVjdGFibGVTdGFydCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWNvbm5lY3Rpb25DbGlja1N0YXJ0SGFuZGxlKSB7XG4gICAgICAgICAgICBvbkNsaWNrQ29ubmVjdFN0YXJ0Py4oZXZlbnQubmF0aXZlRXZlbnQsIHsgbm9kZUlkLCBoYW5kbGVJZCwgaGFuZGxlVHlwZTogdHlwZSB9KTtcbiAgICAgICAgICAgIHN0b3JlLnNldFN0YXRlKHsgY29ubmVjdGlvbkNsaWNrU3RhcnRIYW5kbGU6IHsgbm9kZUlkLCB0eXBlLCBpZDogaGFuZGxlSWQgfSB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkb2MgPSBnZXRIb3N0Rm9yRWxlbWVudChldmVudC50YXJnZXQpO1xuICAgICAgICBjb25zdCBpc1ZhbGlkQ29ubmVjdGlvbkhhbmRsZXIgPSBpc1ZhbGlkQ29ubmVjdGlvbiB8fCBpc1ZhbGlkQ29ubmVjdGlvblN0b3JlO1xuICAgICAgICBjb25zdCB7IGNvbm5lY3Rpb24sIGlzVmFsaWQgfSA9IFhZSGFuZGxlLmlzVmFsaWQoZXZlbnQubmF0aXZlRXZlbnQsIHtcbiAgICAgICAgICAgIGhhbmRsZToge1xuICAgICAgICAgICAgICAgIG5vZGVJZCxcbiAgICAgICAgICAgICAgICBpZDogaGFuZGxlSWQsXG4gICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb25uZWN0aW9uTW9kZSxcbiAgICAgICAgICAgIGZyb21Ob2RlSWQ6IGNvbm5lY3Rpb25DbGlja1N0YXJ0SGFuZGxlLm5vZGVJZCxcbiAgICAgICAgICAgIGZyb21IYW5kbGVJZDogY29ubmVjdGlvbkNsaWNrU3RhcnRIYW5kbGUuaWQgfHwgbnVsbCxcbiAgICAgICAgICAgIGZyb21UeXBlOiBjb25uZWN0aW9uQ2xpY2tTdGFydEhhbmRsZS50eXBlLFxuICAgICAgICAgICAgaXNWYWxpZENvbm5lY3Rpb246IGlzVmFsaWRDb25uZWN0aW9uSGFuZGxlcixcbiAgICAgICAgICAgIGZsb3dJZCxcbiAgICAgICAgICAgIGRvYyxcbiAgICAgICAgICAgIGxpYixcbiAgICAgICAgICAgIG5vZGVMb29rdXAsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaXNWYWxpZCAmJiBjb25uZWN0aW9uKSB7XG4gICAgICAgICAgICBvbkNvbm5lY3RFeHRlbmRlZChjb25uZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb25uZWN0aW9uQ2xvbmUgPSBzdHJ1Y3R1cmVkQ2xvbmUoY29ubmVjdGlvblN0YXRlKTtcbiAgICAgICAgZGVsZXRlIGNvbm5lY3Rpb25DbG9uZS5pblByb2dyZXNzO1xuICAgICAgICBjb25uZWN0aW9uQ2xvbmUudG9Qb3NpdGlvbiA9IGNvbm5lY3Rpb25DbG9uZS50b0hhbmRsZSA/IGNvbm5lY3Rpb25DbG9uZS50b0hhbmRsZS5wb3NpdGlvbiA6IG51bGw7XG4gICAgICAgIG9uQ2xpY2tDb25uZWN0RW5kPy4oZXZlbnQsIGNvbm5lY3Rpb25DbG9uZSk7XG4gICAgICAgIHN0b3JlLnNldFN0YXRlKHsgY29ubmVjdGlvbkNsaWNrU3RhcnRIYW5kbGU6IG51bGwgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gKGpzeChcImRpdlwiLCB7IFwiZGF0YS1oYW5kbGVpZFwiOiBoYW5kbGVJZCwgXCJkYXRhLW5vZGVpZFwiOiBub2RlSWQsIFwiZGF0YS1oYW5kbGVwb3NcIjogcG9zaXRpb24sIFwiZGF0YS1pZFwiOiBgJHtyZklkfS0ke25vZGVJZH0tJHtoYW5kbGVJZH0tJHt0eXBlfWAsIGNsYXNzTmFtZTogY2MoW1xuICAgICAgICAgICAgJ3JlYWN0LWZsb3dfX2hhbmRsZScsXG4gICAgICAgICAgICBgcmVhY3QtZmxvd19faGFuZGxlLSR7cG9zaXRpb259YCxcbiAgICAgICAgICAgICdub2RyYWcnLFxuICAgICAgICAgICAgbm9QYW5DbGFzc05hbWUsXG4gICAgICAgICAgICBjbGFzc05hbWUsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc291cmNlOiAhaXNUYXJnZXQsXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiBpc1RhcmdldCxcbiAgICAgICAgICAgICAgICBjb25uZWN0YWJsZTogaXNDb25uZWN0YWJsZSxcbiAgICAgICAgICAgICAgICBjb25uZWN0YWJsZXN0YXJ0OiBpc0Nvbm5lY3RhYmxlU3RhcnQsXG4gICAgICAgICAgICAgICAgY29ubmVjdGFibGVlbmQ6IGlzQ29ubmVjdGFibGVFbmQsXG4gICAgICAgICAgICAgICAgY2xpY2tjb25uZWN0aW5nOiBjbGlja0Nvbm5lY3RpbmcsXG4gICAgICAgICAgICAgICAgY29ubmVjdGluZ2Zyb206IGNvbm5lY3RpbmdGcm9tLFxuICAgICAgICAgICAgICAgIGNvbm5lY3Rpbmd0bzogY29ubmVjdGluZ1RvLFxuICAgICAgICAgICAgICAgIHZhbGlkLFxuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogc2hvd3Mgd2hlcmUgeW91IGNhbiBzdGFydCBhIGNvbm5lY3Rpb24gZnJvbVxuICAgICAgICAgICAgICAgICAqIGFuZCB3aGVyZSB5b3UgY2FuIGVuZCBpdCB3aGlsZSBjb25uZWN0aW5nXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbmluZGljYXRvcjogaXNDb25uZWN0YWJsZSAmJlxuICAgICAgICAgICAgICAgICAgICAoIWNvbm5lY3Rpb25JblByb2Nlc3MgfHwgaXNQb3NzaWJsZUVuZEhhbmRsZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgKGNvbm5lY3Rpb25JblByb2Nlc3MgfHwgY2xpY2tDb25uZWN0aW9uSW5Qcm9jZXNzID8gaXNDb25uZWN0YWJsZUVuZCA6IGlzQ29ubmVjdGFibGVTdGFydCksXG4gICAgICAgICAgICB9LFxuICAgICAgICBdKSwgb25Nb3VzZURvd246IG9uUG9pbnRlckRvd24sIG9uVG91Y2hTdGFydDogb25Qb2ludGVyRG93biwgb25DbGljazogY29ubmVjdE9uQ2xpY2sgPyBvbkNsaWNrIDogdW5kZWZpbmVkLCByZWY6IHJlZiwgLi4ucmVzdCwgY2hpbGRyZW46IGNoaWxkcmVuIH0pKTtcbn1cbi8qKlxuICogVGhlIGA8SGFuZGxlIC8+YCBjb21wb25lbnQgaXMgdXNlZCBpbiB5b3VyIFtjdXN0b20gbm9kZXNdKC9sZWFybi9jdXN0b21pemF0aW9uL2N1c3RvbS1ub2RlcylcbiAqIHRvIGRlZmluZSBjb25uZWN0aW9uIHBvaW50cy5cbiAqXG4gKkBwdWJsaWNcbiAqXG4gKkBleGFtcGxlXG4gKlxuICpgYGBqc3hcbiAqaW1wb3J0IHsgSGFuZGxlLCBQb3NpdGlvbiB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqZXhwb3J0IGZ1bmN0aW9uIEN1c3RvbU5vZGUoeyBkYXRhIH0pIHtcbiAqICByZXR1cm4gKFxuICogICAgPD5cbiAqICAgICAgPGRpdiBzdHlsZT17eyBwYWRkaW5nOiAnMTBweCAyMHB4JyB9fT5cbiAqICAgICAgICB7ZGF0YS5sYWJlbH1cbiAqICAgICAgPC9kaXY+XG4gKlxuICogICAgICA8SGFuZGxlIHR5cGU9XCJ0YXJnZXRcIiBwb3NpdGlvbj17UG9zaXRpb24uTGVmdH0gLz5cbiAqICAgICAgPEhhbmRsZSB0eXBlPVwic291cmNlXCIgcG9zaXRpb249e1Bvc2l0aW9uLlJpZ2h0fSAvPlxuICogICAgPC8+XG4gKiAgKTtcbiAqfTtcbiAqYGBgXG4gKi9cbmNvbnN0IEhhbmRsZSA9IG1lbW8oZml4ZWRGb3J3YXJkUmVmKEhhbmRsZUNvbXBvbmVudCkpO1xuXG5mdW5jdGlvbiBJbnB1dE5vZGUoeyBkYXRhLCBpc0Nvbm5lY3RhYmxlLCBzb3VyY2VQb3NpdGlvbiA9IFBvc2l0aW9uLkJvdHRvbSB9KSB7XG4gICAgcmV0dXJuIChqc3hzKEZyYWdtZW50LCB7IGNoaWxkcmVuOiBbZGF0YT8ubGFiZWwsIGpzeChIYW5kbGUsIHsgdHlwZTogXCJzb3VyY2VcIiwgcG9zaXRpb246IHNvdXJjZVBvc2l0aW9uLCBpc0Nvbm5lY3RhYmxlOiBpc0Nvbm5lY3RhYmxlIH0pXSB9KSk7XG59XG5cbmZ1bmN0aW9uIERlZmF1bHROb2RlKHsgZGF0YSwgaXNDb25uZWN0YWJsZSwgdGFyZ2V0UG9zaXRpb24gPSBQb3NpdGlvbi5Ub3AsIHNvdXJjZVBvc2l0aW9uID0gUG9zaXRpb24uQm90dG9tLCB9KSB7XG4gICAgcmV0dXJuIChqc3hzKEZyYWdtZW50LCB7IGNoaWxkcmVuOiBbanN4KEhhbmRsZSwgeyB0eXBlOiBcInRhcmdldFwiLCBwb3NpdGlvbjogdGFyZ2V0UG9zaXRpb24sIGlzQ29ubmVjdGFibGU6IGlzQ29ubmVjdGFibGUgfSksIGRhdGE/LmxhYmVsLCBqc3goSGFuZGxlLCB7IHR5cGU6IFwic291cmNlXCIsIHBvc2l0aW9uOiBzb3VyY2VQb3NpdGlvbiwgaXNDb25uZWN0YWJsZTogaXNDb25uZWN0YWJsZSB9KV0gfSkpO1xufVxuXG5mdW5jdGlvbiBHcm91cE5vZGUoKSB7XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIE91dHB1dE5vZGUoeyBkYXRhLCBpc0Nvbm5lY3RhYmxlLCB0YXJnZXRQb3NpdGlvbiA9IFBvc2l0aW9uLlRvcCB9KSB7XG4gICAgcmV0dXJuIChqc3hzKEZyYWdtZW50LCB7IGNoaWxkcmVuOiBbanN4KEhhbmRsZSwgeyB0eXBlOiBcInRhcmdldFwiLCBwb3NpdGlvbjogdGFyZ2V0UG9zaXRpb24sIGlzQ29ubmVjdGFibGU6IGlzQ29ubmVjdGFibGUgfSksIGRhdGE/LmxhYmVsXSB9KSk7XG59XG5cbmNvbnN0IGFycm93S2V5RGlmZnMgPSB7XG4gICAgQXJyb3dVcDogeyB4OiAwLCB5OiAtMSB9LFxuICAgIEFycm93RG93bjogeyB4OiAwLCB5OiAxIH0sXG4gICAgQXJyb3dMZWZ0OiB7IHg6IC0xLCB5OiAwIH0sXG4gICAgQXJyb3dSaWdodDogeyB4OiAxLCB5OiAwIH0sXG59O1xuY29uc3QgYnVpbHRpbk5vZGVUeXBlcyA9IHtcbiAgICBpbnB1dDogSW5wdXROb2RlLFxuICAgIGRlZmF1bHQ6IERlZmF1bHROb2RlLFxuICAgIG91dHB1dDogT3V0cHV0Tm9kZSxcbiAgICBncm91cDogR3JvdXBOb2RlLFxufTtcbmZ1bmN0aW9uIGdldE5vZGVJbmxpbmVTdHlsZURpbWVuc2lvbnMobm9kZSkge1xuICAgIGlmIChub2RlLmludGVybmFscy5oYW5kbGVCb3VuZHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgd2lkdGg6IG5vZGUud2lkdGggPz8gbm9kZS5pbml0aWFsV2lkdGggPz8gbm9kZS5zdHlsZT8ud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IG5vZGUuaGVpZ2h0ID8/IG5vZGUuaW5pdGlhbEhlaWdodCA/PyBub2RlLnN0eWxlPy5oZWlnaHQsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiBub2RlLndpZHRoID8/IG5vZGUuc3R5bGU/LndpZHRoLFxuICAgICAgICBoZWlnaHQ6IG5vZGUuaGVpZ2h0ID8/IG5vZGUuc3R5bGU/LmhlaWdodCxcbiAgICB9O1xufVxuXG5jb25zdCBzZWxlY3RvciRmID0gKHMpID0+IHtcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQsIHgsIHkgfSA9IGdldEludGVybmFsTm9kZXNCb3VuZHMocy5ub2RlTG9va3VwLCB7XG4gICAgICAgIGZpbHRlcjogKG5vZGUpID0+ICEhbm9kZS5zZWxlY3RlZCxcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aDogaXNOdW1lcmljKHdpZHRoKSA/IHdpZHRoIDogbnVsbCxcbiAgICAgICAgaGVpZ2h0OiBpc051bWVyaWMoaGVpZ2h0KSA/IGhlaWdodCA6IG51bGwsXG4gICAgICAgIHVzZXJTZWxlY3Rpb25BY3RpdmU6IHMudXNlclNlbGVjdGlvbkFjdGl2ZSxcbiAgICAgICAgdHJhbnNmb3JtU3RyaW5nOiBgdHJhbnNsYXRlKCR7cy50cmFuc2Zvcm1bMF19cHgsJHtzLnRyYW5zZm9ybVsxXX1weCkgc2NhbGUoJHtzLnRyYW5zZm9ybVsyXX0pIHRyYW5zbGF0ZSgke3h9cHgsJHt5fXB4KWAsXG4gICAgfTtcbn07XG5mdW5jdGlvbiBOb2Rlc1NlbGVjdGlvbih7IG9uU2VsZWN0aW9uQ29udGV4dE1lbnUsIG5vUGFuQ2xhc3NOYW1lLCBkaXNhYmxlS2V5Ym9hcmRBMTF5LCB9KSB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCwgdHJhbnNmb3JtU3RyaW5nLCB1c2VyU2VsZWN0aW9uQWN0aXZlIH0gPSB1c2VTdG9yZShzZWxlY3RvciRmLCBzaGFsbG93KTtcbiAgICBjb25zdCBtb3ZlU2VsZWN0ZWROb2RlcyA9IHVzZU1vdmVTZWxlY3RlZE5vZGVzKCk7XG4gICAgY29uc3Qgbm9kZVJlZiA9IHVzZVJlZihudWxsKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIWRpc2FibGVLZXlib2FyZEExMXkpIHtcbiAgICAgICAgICAgIG5vZGVSZWYuY3VycmVudD8uZm9jdXMoe1xuICAgICAgICAgICAgICAgIHByZXZlbnRTY3JvbGw6IHRydWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sIFtkaXNhYmxlS2V5Ym9hcmRBMTF5XSk7XG4gICAgdXNlRHJhZyh7XG4gICAgICAgIG5vZGVSZWYsXG4gICAgfSk7XG4gICAgaWYgKHVzZXJTZWxlY3Rpb25BY3RpdmUgfHwgIXdpZHRoIHx8ICFoZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IG9uQ29udGV4dE1lbnUgPSBvblNlbGVjdGlvbkNvbnRleHRNZW51XG4gICAgICAgID8gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzZWxlY3RlZE5vZGVzID0gc3RvcmUuZ2V0U3RhdGUoKS5ub2Rlcy5maWx0ZXIoKG4pID0+IG4uc2VsZWN0ZWQpO1xuICAgICAgICAgICAgb25TZWxlY3Rpb25Db250ZXh0TWVudShldmVudCwgc2VsZWN0ZWROb2Rlcyk7XG4gICAgICAgIH1cbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qgb25LZXlEb3duID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYXJyb3dLZXlEaWZmcywgZXZlbnQua2V5KSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIG1vdmVTZWxlY3RlZE5vZGVzKHtcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb246IGFycm93S2V5RGlmZnNbZXZlbnQua2V5XSxcbiAgICAgICAgICAgICAgICBmYWN0b3I6IGV2ZW50LnNoaWZ0S2V5ID8gNCA6IDEsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIChqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IGNjKFsncmVhY3QtZmxvd19fbm9kZXNzZWxlY3Rpb24nLCAncmVhY3QtZmxvd19fY29udGFpbmVyJywgbm9QYW5DbGFzc05hbWVdKSwgc3R5bGU6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNmb3JtU3RyaW5nLFxuICAgICAgICB9LCBjaGlsZHJlbjoganN4KFwiZGl2XCIsIHsgcmVmOiBub2RlUmVmLCBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fbm9kZXNzZWxlY3Rpb24tcmVjdFwiLCBvbkNvbnRleHRNZW51OiBvbkNvbnRleHRNZW51LCB0YWJJbmRleDogZGlzYWJsZUtleWJvYXJkQTExeSA/IHVuZGVmaW5lZCA6IC0xLCBvbktleURvd246IGRpc2FibGVLZXlib2FyZEExMXkgPyB1bmRlZmluZWQgOiBvbktleURvd24sIHN0eWxlOiB7XG4gICAgICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgICAgfSB9KSB9KSk7XG59XG5cbmNvbnN0IHdpbiA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogdW5kZWZpbmVkO1xuY29uc3Qgc2VsZWN0b3IkZSA9IChzKSA9PiB7XG4gICAgcmV0dXJuIHsgbm9kZXNTZWxlY3Rpb25BY3RpdmU6IHMubm9kZXNTZWxlY3Rpb25BY3RpdmUsIHVzZXJTZWxlY3Rpb25BY3RpdmU6IHMudXNlclNlbGVjdGlvbkFjdGl2ZSB9O1xufTtcbmZ1bmN0aW9uIEZsb3dSZW5kZXJlckNvbXBvbmVudCh7IGNoaWxkcmVuLCBvblBhbmVDbGljaywgb25QYW5lTW91c2VFbnRlciwgb25QYW5lTW91c2VNb3ZlLCBvblBhbmVNb3VzZUxlYXZlLCBvblBhbmVDb250ZXh0TWVudSwgb25QYW5lU2Nyb2xsLCBwYW5lQ2xpY2tEaXN0YW5jZSwgZGVsZXRlS2V5Q29kZSwgc2VsZWN0aW9uS2V5Q29kZSwgc2VsZWN0aW9uT25EcmFnLCBzZWxlY3Rpb25Nb2RlLCBvblNlbGVjdGlvblN0YXJ0LCBvblNlbGVjdGlvbkVuZCwgbXVsdGlTZWxlY3Rpb25LZXlDb2RlLCBwYW5BY3RpdmF0aW9uS2V5Q29kZSwgem9vbUFjdGl2YXRpb25LZXlDb2RlLCBlbGVtZW50c1NlbGVjdGFibGUsIHpvb21PblNjcm9sbCwgem9vbU9uUGluY2gsIHBhbk9uU2Nyb2xsOiBfcGFuT25TY3JvbGwsIHBhbk9uU2Nyb2xsU3BlZWQsIHBhbk9uU2Nyb2xsTW9kZSwgem9vbU9uRG91YmxlQ2xpY2ssIHBhbk9uRHJhZzogX3Bhbk9uRHJhZywgZGVmYXVsdFZpZXdwb3J0LCB0cmFuc2xhdGVFeHRlbnQsIG1pblpvb20sIG1heFpvb20sIHByZXZlbnRTY3JvbGxpbmcsIG9uU2VsZWN0aW9uQ29udGV4dE1lbnUsIG5vV2hlZWxDbGFzc05hbWUsIG5vUGFuQ2xhc3NOYW1lLCBkaXNhYmxlS2V5Ym9hcmRBMTF5LCBvblZpZXdwb3J0Q2hhbmdlLCBpc0NvbnRyb2xsZWRWaWV3cG9ydCwgfSkge1xuICAgIGNvbnN0IHsgbm9kZXNTZWxlY3Rpb25BY3RpdmUsIHVzZXJTZWxlY3Rpb25BY3RpdmUgfSA9IHVzZVN0b3JlKHNlbGVjdG9yJGUpO1xuICAgIGNvbnN0IHNlbGVjdGlvbktleVByZXNzZWQgPSB1c2VLZXlQcmVzcyhzZWxlY3Rpb25LZXlDb2RlLCB7IHRhcmdldDogd2luIH0pO1xuICAgIGNvbnN0IHBhbkFjdGl2YXRpb25LZXlQcmVzc2VkID0gdXNlS2V5UHJlc3MocGFuQWN0aXZhdGlvbktleUNvZGUsIHsgdGFyZ2V0OiB3aW4gfSk7XG4gICAgY29uc3QgcGFuT25EcmFnID0gcGFuQWN0aXZhdGlvbktleVByZXNzZWQgfHwgX3Bhbk9uRHJhZztcbiAgICBjb25zdCBwYW5PblNjcm9sbCA9IHBhbkFjdGl2YXRpb25LZXlQcmVzc2VkIHx8IF9wYW5PblNjcm9sbDtcbiAgICBjb25zdCBfc2VsZWN0aW9uT25EcmFnID0gc2VsZWN0aW9uT25EcmFnICYmIHBhbk9uRHJhZyAhPT0gdHJ1ZTtcbiAgICBjb25zdCBpc1NlbGVjdGluZyA9IHNlbGVjdGlvbktleVByZXNzZWQgfHwgdXNlclNlbGVjdGlvbkFjdGl2ZSB8fCBfc2VsZWN0aW9uT25EcmFnO1xuICAgIHVzZUdsb2JhbEtleUhhbmRsZXIoeyBkZWxldGVLZXlDb2RlLCBtdWx0aVNlbGVjdGlvbktleUNvZGUgfSk7XG4gICAgcmV0dXJuIChqc3goWm9vbVBhbmUsIHsgb25QYW5lQ29udGV4dE1lbnU6IG9uUGFuZUNvbnRleHRNZW51LCBlbGVtZW50c1NlbGVjdGFibGU6IGVsZW1lbnRzU2VsZWN0YWJsZSwgem9vbU9uU2Nyb2xsOiB6b29tT25TY3JvbGwsIHpvb21PblBpbmNoOiB6b29tT25QaW5jaCwgcGFuT25TY3JvbGw6IHBhbk9uU2Nyb2xsLCBwYW5PblNjcm9sbFNwZWVkOiBwYW5PblNjcm9sbFNwZWVkLCBwYW5PblNjcm9sbE1vZGU6IHBhbk9uU2Nyb2xsTW9kZSwgem9vbU9uRG91YmxlQ2xpY2s6IHpvb21PbkRvdWJsZUNsaWNrLCBwYW5PbkRyYWc6ICFzZWxlY3Rpb25LZXlQcmVzc2VkICYmIHBhbk9uRHJhZywgZGVmYXVsdFZpZXdwb3J0OiBkZWZhdWx0Vmlld3BvcnQsIHRyYW5zbGF0ZUV4dGVudDogdHJhbnNsYXRlRXh0ZW50LCBtaW5ab29tOiBtaW5ab29tLCBtYXhab29tOiBtYXhab29tLCB6b29tQWN0aXZhdGlvbktleUNvZGU6IHpvb21BY3RpdmF0aW9uS2V5Q29kZSwgcHJldmVudFNjcm9sbGluZzogcHJldmVudFNjcm9sbGluZywgbm9XaGVlbENsYXNzTmFtZTogbm9XaGVlbENsYXNzTmFtZSwgbm9QYW5DbGFzc05hbWU6IG5vUGFuQ2xhc3NOYW1lLCBvblZpZXdwb3J0Q2hhbmdlOiBvblZpZXdwb3J0Q2hhbmdlLCBpc0NvbnRyb2xsZWRWaWV3cG9ydDogaXNDb250cm9sbGVkVmlld3BvcnQsIHBhbmVDbGlja0Rpc3RhbmNlOiBwYW5lQ2xpY2tEaXN0YW5jZSwgY2hpbGRyZW46IGpzeHMoUGFuZSwgeyBvblNlbGVjdGlvblN0YXJ0OiBvblNlbGVjdGlvblN0YXJ0LCBvblNlbGVjdGlvbkVuZDogb25TZWxlY3Rpb25FbmQsIG9uUGFuZUNsaWNrOiBvblBhbmVDbGljaywgb25QYW5lTW91c2VFbnRlcjogb25QYW5lTW91c2VFbnRlciwgb25QYW5lTW91c2VNb3ZlOiBvblBhbmVNb3VzZU1vdmUsIG9uUGFuZU1vdXNlTGVhdmU6IG9uUGFuZU1vdXNlTGVhdmUsIG9uUGFuZUNvbnRleHRNZW51OiBvblBhbmVDb250ZXh0TWVudSwgb25QYW5lU2Nyb2xsOiBvblBhbmVTY3JvbGwsIHBhbk9uRHJhZzogcGFuT25EcmFnLCBpc1NlbGVjdGluZzogISFpc1NlbGVjdGluZywgc2VsZWN0aW9uTW9kZTogc2VsZWN0aW9uTW9kZSwgc2VsZWN0aW9uS2V5UHJlc3NlZDogc2VsZWN0aW9uS2V5UHJlc3NlZCwgc2VsZWN0aW9uT25EcmFnOiBfc2VsZWN0aW9uT25EcmFnLCBjaGlsZHJlbjogW2NoaWxkcmVuLCBub2Rlc1NlbGVjdGlvbkFjdGl2ZSAmJiAoanN4KE5vZGVzU2VsZWN0aW9uLCB7IG9uU2VsZWN0aW9uQ29udGV4dE1lbnU6IG9uU2VsZWN0aW9uQ29udGV4dE1lbnUsIG5vUGFuQ2xhc3NOYW1lOiBub1BhbkNsYXNzTmFtZSwgZGlzYWJsZUtleWJvYXJkQTExeTogZGlzYWJsZUtleWJvYXJkQTExeSB9KSldIH0pIH0pKTtcbn1cbkZsb3dSZW5kZXJlckNvbXBvbmVudC5kaXNwbGF5TmFtZSA9ICdGbG93UmVuZGVyZXInO1xuY29uc3QgRmxvd1JlbmRlcmVyID0gbWVtbyhGbG93UmVuZGVyZXJDb21wb25lbnQpO1xuXG5jb25zdCBzZWxlY3RvciRkID0gKG9ubHlSZW5kZXJWaXNpYmxlKSA9PiAocykgPT4ge1xuICAgIHJldHVybiBvbmx5UmVuZGVyVmlzaWJsZVxuICAgICAgICA/IGdldE5vZGVzSW5zaWRlKHMubm9kZUxvb2t1cCwgeyB4OiAwLCB5OiAwLCB3aWR0aDogcy53aWR0aCwgaGVpZ2h0OiBzLmhlaWdodCB9LCBzLnRyYW5zZm9ybSwgdHJ1ZSkubWFwKChub2RlKSA9PiBub2RlLmlkKVxuICAgICAgICA6IEFycmF5LmZyb20ocy5ub2RlTG9va3VwLmtleXMoKSk7XG59O1xuLyoqXG4gKiBIb29rIGZvciBnZXR0aW5nIHRoZSB2aXNpYmxlIG5vZGUgaWRzIGZyb20gdGhlIHN0b3JlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIG9ubHlSZW5kZXJWaXNpYmxlXG4gKiBAcmV0dXJucyBhcnJheSB3aXRoIHZpc2libGUgbm9kZSBpZHNcbiAqL1xuZnVuY3Rpb24gdXNlVmlzaWJsZU5vZGVJZHMob25seVJlbmRlclZpc2libGUpIHtcbiAgICBjb25zdCBub2RlSWRzID0gdXNlU3RvcmUodXNlQ2FsbGJhY2soc2VsZWN0b3IkZChvbmx5UmVuZGVyVmlzaWJsZSksIFtvbmx5UmVuZGVyVmlzaWJsZV0pLCBzaGFsbG93KTtcbiAgICByZXR1cm4gbm9kZUlkcztcbn1cblxuY29uc3Qgc2VsZWN0b3IkYyA9IChzKSA9PiBzLnVwZGF0ZU5vZGVJbnRlcm5hbHM7XG5mdW5jdGlvbiB1c2VSZXNpemVPYnNlcnZlcigpIHtcbiAgICBjb25zdCB1cGRhdGVOb2RlSW50ZXJuYWxzID0gdXNlU3RvcmUoc2VsZWN0b3IkYyk7XG4gICAgY29uc3QgW3Jlc2l6ZU9ic2VydmVyXSA9IHVzZVN0YXRlKCgpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBSZXNpemVPYnNlcnZlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUmVzaXplT2JzZXJ2ZXIoKGVudHJpZXMpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICBlbnRyaWVzLmZvckVhY2goKGVudHJ5KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaWQgPSBlbnRyeS50YXJnZXQuZ2V0QXR0cmlidXRlKCdkYXRhLWlkJyk7XG4gICAgICAgICAgICAgICAgdXBkYXRlcy5zZXQoaWQsIHtcbiAgICAgICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgICAgIG5vZGVFbGVtZW50OiBlbnRyeS50YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgIGZvcmNlOiB0cnVlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB1cGRhdGVOb2RlSW50ZXJuYWxzKHVwZGF0ZXMpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgcmVzaXplT2JzZXJ2ZXI/LmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfTtcbiAgICB9LCBbcmVzaXplT2JzZXJ2ZXJdKTtcbiAgICByZXR1cm4gcmVzaXplT2JzZXJ2ZXI7XG59XG5cbi8qKlxuICogSG9vayB0byBoYW5kbGUgdGhlIHJlc2l6ZSBvYnNlcnZhdGlvbiArIGludGVybmFsIHVwZGF0ZXMgZm9yIHRoZSBwYXNzZWQgbm9kZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEByZXR1cm5zIG5vZGVSZWYgLSByZWZlcmVuY2UgdG8gdGhlIG5vZGUgZWxlbWVudFxuICovXG5mdW5jdGlvbiB1c2VOb2RlT2JzZXJ2ZXIoeyBub2RlLCBub2RlVHlwZSwgaGFzRGltZW5zaW9ucywgcmVzaXplT2JzZXJ2ZXIsIH0pIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3Qgbm9kZVJlZiA9IHVzZVJlZihudWxsKTtcbiAgICBjb25zdCBvYnNlcnZlZE5vZGUgPSB1c2VSZWYobnVsbCk7XG4gICAgY29uc3QgcHJldlNvdXJjZVBvc2l0aW9uID0gdXNlUmVmKG5vZGUuc291cmNlUG9zaXRpb24pO1xuICAgIGNvbnN0IHByZXZUYXJnZXRQb3NpdGlvbiA9IHVzZVJlZihub2RlLnRhcmdldFBvc2l0aW9uKTtcbiAgICBjb25zdCBwcmV2VHlwZSA9IHVzZVJlZihub2RlVHlwZSk7XG4gICAgY29uc3QgaXNJbml0aWFsaXplZCA9IGhhc0RpbWVuc2lvbnMgJiYgISFub2RlLmludGVybmFscy5oYW5kbGVCb3VuZHM7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKG5vZGVSZWYuY3VycmVudCAmJiAhbm9kZS5oaWRkZW4gJiYgKCFpc0luaXRpYWxpemVkIHx8IG9ic2VydmVkTm9kZS5jdXJyZW50ICE9PSBub2RlUmVmLmN1cnJlbnQpKSB7XG4gICAgICAgICAgICBpZiAob2JzZXJ2ZWROb2RlLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICByZXNpemVPYnNlcnZlcj8udW5vYnNlcnZlKG9ic2VydmVkTm9kZS5jdXJyZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc2l6ZU9ic2VydmVyPy5vYnNlcnZlKG5vZGVSZWYuY3VycmVudCk7XG4gICAgICAgICAgICBvYnNlcnZlZE5vZGUuY3VycmVudCA9IG5vZGVSZWYuY3VycmVudDtcbiAgICAgICAgfVxuICAgIH0sIFtpc0luaXRpYWxpemVkLCBub2RlLmhpZGRlbl0pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBpZiAob2JzZXJ2ZWROb2RlLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICByZXNpemVPYnNlcnZlcj8udW5vYnNlcnZlKG9ic2VydmVkTm9kZS5jdXJyZW50KTtcbiAgICAgICAgICAgICAgICBvYnNlcnZlZE5vZGUuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSwgW10pO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChub2RlUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiB3aGVuIHRoZSB1c2VyIHByb2dyYW1tYXRpY2FsbHkgY2hhbmdlcyB0aGUgc291cmNlIG9yIGhhbmRsZSBwb3NpdGlvbiwgd2UgbmVlZCB0byB1cGRhdGUgdGhlIGludGVybmFsc1xuICAgICAgICAgICAgICogdG8gbWFrZSBzdXJlIHRoZSBlZGdlcyBhcmUgdXBkYXRlZCBjb3JyZWN0bHlcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29uc3QgdHlwZUNoYW5nZWQgPSBwcmV2VHlwZS5jdXJyZW50ICE9PSBub2RlVHlwZTtcbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZVBvc0NoYW5nZWQgPSBwcmV2U291cmNlUG9zaXRpb24uY3VycmVudCAhPT0gbm9kZS5zb3VyY2VQb3NpdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldFBvc0NoYW5nZWQgPSBwcmV2VGFyZ2V0UG9zaXRpb24uY3VycmVudCAhPT0gbm9kZS50YXJnZXRQb3NpdGlvbjtcbiAgICAgICAgICAgIGlmICh0eXBlQ2hhbmdlZCB8fCBzb3VyY2VQb3NDaGFuZ2VkIHx8IHRhcmdldFBvc0NoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICBwcmV2VHlwZS5jdXJyZW50ID0gbm9kZVR5cGU7XG4gICAgICAgICAgICAgICAgcHJldlNvdXJjZVBvc2l0aW9uLmN1cnJlbnQgPSBub2RlLnNvdXJjZVBvc2l0aW9uO1xuICAgICAgICAgICAgICAgIHByZXZUYXJnZXRQb3NpdGlvbi5jdXJyZW50ID0gbm9kZS50YXJnZXRQb3NpdGlvbjtcbiAgICAgICAgICAgICAgICBzdG9yZVxuICAgICAgICAgICAgICAgICAgICAuZ2V0U3RhdGUoKVxuICAgICAgICAgICAgICAgICAgICAudXBkYXRlTm9kZUludGVybmFscyhuZXcgTWFwKFtbbm9kZS5pZCwgeyBpZDogbm9kZS5pZCwgbm9kZUVsZW1lbnQ6IG5vZGVSZWYuY3VycmVudCwgZm9yY2U6IHRydWUgfV1dKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbbm9kZS5pZCwgbm9kZVR5cGUsIG5vZGUuc291cmNlUG9zaXRpb24sIG5vZGUudGFyZ2V0UG9zaXRpb25dKTtcbiAgICByZXR1cm4gbm9kZVJlZjtcbn1cblxuZnVuY3Rpb24gTm9kZVdyYXBwZXIoeyBpZCwgb25DbGljaywgb25Nb3VzZUVudGVyLCBvbk1vdXNlTW92ZSwgb25Nb3VzZUxlYXZlLCBvbkNvbnRleHRNZW51LCBvbkRvdWJsZUNsaWNrLCBub2Rlc0RyYWdnYWJsZSwgZWxlbWVudHNTZWxlY3RhYmxlLCBub2Rlc0Nvbm5lY3RhYmxlLCBub2Rlc0ZvY3VzYWJsZSwgcmVzaXplT2JzZXJ2ZXIsIG5vRHJhZ0NsYXNzTmFtZSwgbm9QYW5DbGFzc05hbWUsIGRpc2FibGVLZXlib2FyZEExMXksIHJmSWQsIG5vZGVUeXBlcywgbm9kZUNsaWNrRGlzdGFuY2UsIG9uRXJyb3IsIH0pIHtcbiAgICBjb25zdCB7IG5vZGUsIGludGVybmFscywgaXNQYXJlbnQgfSA9IHVzZVN0b3JlKChzKSA9PiB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBzLm5vZGVMb29rdXAuZ2V0KGlkKTtcbiAgICAgICAgY29uc3QgaXNQYXJlbnQgPSBzLnBhcmVudExvb2t1cC5oYXMoaWQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgIGludGVybmFsczogbm9kZS5pbnRlcm5hbHMsXG4gICAgICAgICAgICBpc1BhcmVudCxcbiAgICAgICAgfTtcbiAgICB9LCBzaGFsbG93KTtcbiAgICBsZXQgbm9kZVR5cGUgPSBub2RlLnR5cGUgfHwgJ2RlZmF1bHQnO1xuICAgIGxldCBOb2RlQ29tcG9uZW50ID0gbm9kZVR5cGVzPy5bbm9kZVR5cGVdIHx8IGJ1aWx0aW5Ob2RlVHlwZXNbbm9kZVR5cGVdO1xuICAgIGlmIChOb2RlQ29tcG9uZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb25FcnJvcj8uKCcwMDMnLCBlcnJvck1lc3NhZ2VzWydlcnJvcjAwMyddKG5vZGVUeXBlKSk7XG4gICAgICAgIG5vZGVUeXBlID0gJ2RlZmF1bHQnO1xuICAgICAgICBOb2RlQ29tcG9uZW50ID0gYnVpbHRpbk5vZGVUeXBlcy5kZWZhdWx0O1xuICAgIH1cbiAgICBjb25zdCBpc0RyYWdnYWJsZSA9ICEhKG5vZGUuZHJhZ2dhYmxlIHx8IChub2Rlc0RyYWdnYWJsZSAmJiB0eXBlb2Ygbm9kZS5kcmFnZ2FibGUgPT09ICd1bmRlZmluZWQnKSk7XG4gICAgY29uc3QgaXNTZWxlY3RhYmxlID0gISEobm9kZS5zZWxlY3RhYmxlIHx8IChlbGVtZW50c1NlbGVjdGFibGUgJiYgdHlwZW9mIG5vZGUuc2VsZWN0YWJsZSA9PT0gJ3VuZGVmaW5lZCcpKTtcbiAgICBjb25zdCBpc0Nvbm5lY3RhYmxlID0gISEobm9kZS5jb25uZWN0YWJsZSB8fCAobm9kZXNDb25uZWN0YWJsZSAmJiB0eXBlb2Ygbm9kZS5jb25uZWN0YWJsZSA9PT0gJ3VuZGVmaW5lZCcpKTtcbiAgICBjb25zdCBpc0ZvY3VzYWJsZSA9ICEhKG5vZGUuZm9jdXNhYmxlIHx8IChub2Rlc0ZvY3VzYWJsZSAmJiB0eXBlb2Ygbm9kZS5mb2N1c2FibGUgPT09ICd1bmRlZmluZWQnKSk7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIGNvbnN0IGhhc0RpbWVuc2lvbnMgPSBub2RlSGFzRGltZW5zaW9ucyhub2RlKTtcbiAgICBjb25zdCBub2RlUmVmID0gdXNlTm9kZU9ic2VydmVyKHsgbm9kZSwgbm9kZVR5cGUsIGhhc0RpbWVuc2lvbnMsIHJlc2l6ZU9ic2VydmVyIH0pO1xuICAgIGNvbnN0IGRyYWdnaW5nID0gdXNlRHJhZyh7XG4gICAgICAgIG5vZGVSZWYsXG4gICAgICAgIGRpc2FibGVkOiBub2RlLmhpZGRlbiB8fCAhaXNEcmFnZ2FibGUsXG4gICAgICAgIG5vRHJhZ0NsYXNzTmFtZSxcbiAgICAgICAgaGFuZGxlU2VsZWN0b3I6IG5vZGUuZHJhZ0hhbmRsZSxcbiAgICAgICAgbm9kZUlkOiBpZCxcbiAgICAgICAgaXNTZWxlY3RhYmxlLFxuICAgICAgICBub2RlQ2xpY2tEaXN0YW5jZSxcbiAgICB9KTtcbiAgICBjb25zdCBtb3ZlU2VsZWN0ZWROb2RlcyA9IHVzZU1vdmVTZWxlY3RlZE5vZGVzKCk7XG4gICAgaWYgKG5vZGUuaGlkZGVuKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBub2RlRGltZW5zaW9ucyA9IGdldE5vZGVEaW1lbnNpb25zKG5vZGUpO1xuICAgIGNvbnN0IGlubGluZURpbWVuc2lvbnMgPSBnZXROb2RlSW5saW5lU3R5bGVEaW1lbnNpb25zKG5vZGUpO1xuICAgIGNvbnN0IGhhc1BvaW50ZXJFdmVudHMgPSBpc1NlbGVjdGFibGUgfHwgaXNEcmFnZ2FibGUgfHwgb25DbGljayB8fCBvbk1vdXNlRW50ZXIgfHwgb25Nb3VzZU1vdmUgfHwgb25Nb3VzZUxlYXZlO1xuICAgIGNvbnN0IG9uTW91c2VFbnRlckhhbmRsZXIgPSBvbk1vdXNlRW50ZXJcbiAgICAgICAgPyAoZXZlbnQpID0+IG9uTW91c2VFbnRlcihldmVudCwgeyAuLi5pbnRlcm5hbHMudXNlck5vZGUgfSlcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qgb25Nb3VzZU1vdmVIYW5kbGVyID0gb25Nb3VzZU1vdmVcbiAgICAgICAgPyAoZXZlbnQpID0+IG9uTW91c2VNb3ZlKGV2ZW50LCB7IC4uLmludGVybmFscy51c2VyTm9kZSB9KVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBvbk1vdXNlTGVhdmVIYW5kbGVyID0gb25Nb3VzZUxlYXZlXG4gICAgICAgID8gKGV2ZW50KSA9PiBvbk1vdXNlTGVhdmUoZXZlbnQsIHsgLi4uaW50ZXJuYWxzLnVzZXJOb2RlIH0pXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IG9uQ29udGV4dE1lbnVIYW5kbGVyID0gb25Db250ZXh0TWVudVxuICAgICAgICA/IChldmVudCkgPT4gb25Db250ZXh0TWVudShldmVudCwgeyAuLi5pbnRlcm5hbHMudXNlck5vZGUgfSlcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qgb25Eb3VibGVDbGlja0hhbmRsZXIgPSBvbkRvdWJsZUNsaWNrXG4gICAgICAgID8gKGV2ZW50KSA9PiBvbkRvdWJsZUNsaWNrKGV2ZW50LCB7IC4uLmludGVybmFscy51c2VyTm9kZSB9KVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBvblNlbGVjdE5vZGVIYW5kbGVyID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgc2VsZWN0Tm9kZXNPbkRyYWcsIG5vZGVEcmFnVGhyZXNob2xkIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICBpZiAoaXNTZWxlY3RhYmxlICYmICghc2VsZWN0Tm9kZXNPbkRyYWcgfHwgIWlzRHJhZ2dhYmxlIHx8IG5vZGVEcmFnVGhyZXNob2xkID4gMCkpIHtcbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiB0aGlzIGhhbmRsZXIgZ2V0cyBjYWxsZWQgYnkgWFlEcmFnIG9uIGRyYWcgc3RhcnQgd2hlbiBzZWxlY3ROb2Rlc09uRHJhZz10cnVlXG4gICAgICAgICAgICAgKiBoZXJlIHdlIG9ubHkgbmVlZCB0byBjYWxsIGl0IHdoZW4gc2VsZWN0Tm9kZXNPbkRyYWc9ZmFsc2VcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaGFuZGxlTm9kZUNsaWNrKHtcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICBzdG9yZSxcbiAgICAgICAgICAgICAgICBub2RlUmVmLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uQ2xpY2spIHtcbiAgICAgICAgICAgIG9uQ2xpY2soZXZlbnQsIHsgLi4uaW50ZXJuYWxzLnVzZXJOb2RlIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBvbktleURvd24gPSAoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKGlzSW5wdXRET01Ob2RlKGV2ZW50Lm5hdGl2ZUV2ZW50KSB8fCBkaXNhYmxlS2V5Ym9hcmRBMTF5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsZW1lbnRTZWxlY3Rpb25LZXlzLmluY2x1ZGVzKGV2ZW50LmtleSkgJiYgaXNTZWxlY3RhYmxlKSB7XG4gICAgICAgICAgICBjb25zdCB1bnNlbGVjdCA9IGV2ZW50LmtleSA9PT0gJ0VzY2FwZSc7XG4gICAgICAgICAgICBoYW5kbGVOb2RlQ2xpY2soe1xuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIHN0b3JlLFxuICAgICAgICAgICAgICAgIHVuc2VsZWN0LFxuICAgICAgICAgICAgICAgIG5vZGVSZWYsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0RyYWdnYWJsZSAmJiBub2RlLnNlbGVjdGVkICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhcnJvd0tleURpZmZzLCBldmVudC5rZXkpKSB7XG4gICAgICAgICAgICAvLyBwcmV2ZW50IGRlZmF1bHQgc2Nyb2xsaW5nIGJlaGF2aW9yIG9uIGFycm93IGtleSBwcmVzcyB3aGVuIG5vZGUgaXMgbW92ZWRcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7XG4gICAgICAgICAgICAgICAgYXJpYUxpdmVNZXNzYWdlOiBgTW92ZWQgc2VsZWN0ZWQgbm9kZSAke2V2ZW50LmtleVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgnQXJyb3cnLCAnJylcbiAgICAgICAgICAgICAgICAgICAgLnRvTG93ZXJDYXNlKCl9LiBOZXcgcG9zaXRpb24sIHg6ICR7fn5pbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZS54fSwgeTogJHt+fmludGVybmFscy5wb3NpdGlvbkFic29sdXRlLnl9YCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbW92ZVNlbGVjdGVkTm9kZXMoe1xuICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogYXJyb3dLZXlEaWZmc1tldmVudC5rZXldLFxuICAgICAgICAgICAgICAgIGZhY3RvcjogZXZlbnQuc2hpZnRLZXkgPyA0IDogMSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gKGpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogY2MoW1xuICAgICAgICAgICAgJ3JlYWN0LWZsb3dfX25vZGUnLFxuICAgICAgICAgICAgYHJlYWN0LWZsb3dfX25vZGUtJHtub2RlVHlwZX1gLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgb3ZlcndyaXRhYmxlIGJ5IHBhc3NpbmcgYG5vcGFuYCBhcyBhIGNsYXNzIG5hbWVcbiAgICAgICAgICAgICAgICBbbm9QYW5DbGFzc05hbWVdOiBpc0RyYWdnYWJsZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBub2RlLmNsYXNzTmFtZSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RlZDogbm9kZS5zZWxlY3RlZCxcbiAgICAgICAgICAgICAgICBzZWxlY3RhYmxlOiBpc1NlbGVjdGFibGUsXG4gICAgICAgICAgICAgICAgcGFyZW50OiBpc1BhcmVudCxcbiAgICAgICAgICAgICAgICBkcmFnZ2FibGU6IGlzRHJhZ2dhYmxlLFxuICAgICAgICAgICAgICAgIGRyYWdnaW5nLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXSksIHJlZjogbm9kZVJlZiwgc3R5bGU6IHtcbiAgICAgICAgICAgIHpJbmRleDogaW50ZXJuYWxzLnosXG4gICAgICAgICAgICB0cmFuc2Zvcm06IGB0cmFuc2xhdGUoJHtpbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZS54fXB4LCR7aW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUueX1weClgLFxuICAgICAgICAgICAgcG9pbnRlckV2ZW50czogaGFzUG9pbnRlckV2ZW50cyA/ICdhbGwnIDogJ25vbmUnLFxuICAgICAgICAgICAgdmlzaWJpbGl0eTogaGFzRGltZW5zaW9ucyA/ICd2aXNpYmxlJyA6ICdoaWRkZW4nLFxuICAgICAgICAgICAgLi4ubm9kZS5zdHlsZSxcbiAgICAgICAgICAgIC4uLmlubGluZURpbWVuc2lvbnMsXG4gICAgICAgIH0sIFwiZGF0YS1pZFwiOiBpZCwgXCJkYXRhLXRlc3RpZFwiOiBgcmZfX25vZGUtJHtpZH1gLCBvbk1vdXNlRW50ZXI6IG9uTW91c2VFbnRlckhhbmRsZXIsIG9uTW91c2VNb3ZlOiBvbk1vdXNlTW92ZUhhbmRsZXIsIG9uTW91c2VMZWF2ZTogb25Nb3VzZUxlYXZlSGFuZGxlciwgb25Db250ZXh0TWVudTogb25Db250ZXh0TWVudUhhbmRsZXIsIG9uQ2xpY2s6IG9uU2VsZWN0Tm9kZUhhbmRsZXIsIG9uRG91YmxlQ2xpY2s6IG9uRG91YmxlQ2xpY2tIYW5kbGVyLCBvbktleURvd246IGlzRm9jdXNhYmxlID8gb25LZXlEb3duIDogdW5kZWZpbmVkLCB0YWJJbmRleDogaXNGb2N1c2FibGUgPyAwIDogdW5kZWZpbmVkLCByb2xlOiBpc0ZvY3VzYWJsZSA/ICdidXR0b24nIDogdW5kZWZpbmVkLCBcImFyaWEtZGVzY3JpYmVkYnlcIjogZGlzYWJsZUtleWJvYXJkQTExeSA/IHVuZGVmaW5lZCA6IGAke0FSSUFfTk9ERV9ERVNDX0tFWX0tJHtyZklkfWAsIFwiYXJpYS1sYWJlbFwiOiBub2RlLmFyaWFMYWJlbCwgY2hpbGRyZW46IGpzeChQcm92aWRlciwgeyB2YWx1ZTogaWQsIGNoaWxkcmVuOiBqc3goTm9kZUNvbXBvbmVudCwgeyBpZDogaWQsIGRhdGE6IG5vZGUuZGF0YSwgdHlwZTogbm9kZVR5cGUsIHBvc2l0aW9uQWJzb2x1dGVYOiBpbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZS54LCBwb3NpdGlvbkFic29sdXRlWTogaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUueSwgc2VsZWN0ZWQ6IG5vZGUuc2VsZWN0ZWQgPz8gZmFsc2UsIHNlbGVjdGFibGU6IGlzU2VsZWN0YWJsZSwgZHJhZ2dhYmxlOiBpc0RyYWdnYWJsZSwgZGVsZXRhYmxlOiBub2RlLmRlbGV0YWJsZSA/PyB0cnVlLCBpc0Nvbm5lY3RhYmxlOiBpc0Nvbm5lY3RhYmxlLCBzb3VyY2VQb3NpdGlvbjogbm9kZS5zb3VyY2VQb3NpdGlvbiwgdGFyZ2V0UG9zaXRpb246IG5vZGUudGFyZ2V0UG9zaXRpb24sIGRyYWdnaW5nOiBkcmFnZ2luZywgZHJhZ0hhbmRsZTogbm9kZS5kcmFnSGFuZGxlLCB6SW5kZXg6IGludGVybmFscy56LCBwYXJlbnRJZDogbm9kZS5wYXJlbnRJZCwgLi4ubm9kZURpbWVuc2lvbnMgfSkgfSkgfSkpO1xufVxuXG5jb25zdCBzZWxlY3RvciRiID0gKHMpID0+ICh7XG4gICAgbm9kZXNEcmFnZ2FibGU6IHMubm9kZXNEcmFnZ2FibGUsXG4gICAgbm9kZXNDb25uZWN0YWJsZTogcy5ub2Rlc0Nvbm5lY3RhYmxlLFxuICAgIG5vZGVzRm9jdXNhYmxlOiBzLm5vZGVzRm9jdXNhYmxlLFxuICAgIGVsZW1lbnRzU2VsZWN0YWJsZTogcy5lbGVtZW50c1NlbGVjdGFibGUsXG4gICAgb25FcnJvcjogcy5vbkVycm9yLFxufSk7XG5mdW5jdGlvbiBOb2RlUmVuZGVyZXJDb21wb25lbnQocHJvcHMpIHtcbiAgICBjb25zdCB7IG5vZGVzRHJhZ2dhYmxlLCBub2Rlc0Nvbm5lY3RhYmxlLCBub2Rlc0ZvY3VzYWJsZSwgZWxlbWVudHNTZWxlY3RhYmxlLCBvbkVycm9yIH0gPSB1c2VTdG9yZShzZWxlY3RvciRiLCBzaGFsbG93KTtcbiAgICBjb25zdCBub2RlSWRzID0gdXNlVmlzaWJsZU5vZGVJZHMocHJvcHMub25seVJlbmRlclZpc2libGVFbGVtZW50cyk7XG4gICAgY29uc3QgcmVzaXplT2JzZXJ2ZXIgPSB1c2VSZXNpemVPYnNlcnZlcigpO1xuICAgIHJldHVybiAoanN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX25vZGVzXCIsIHN0eWxlOiBjb250YWluZXJTdHlsZSwgY2hpbGRyZW46IG5vZGVJZHMubWFwKChub2RlSWQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogVGhlIHNwbGl0IG9mIHJlc3BvbnNpYmlsaXRpZXMgYmV0d2VlbiBOb2RlUmVuZGVyZXIgYW5kXG4gICAgICAgICAgICAgKiBOb2RlQ29tcG9uZW50V3JhcHBlciBtYXkgYXBwZWFyIHdlaXJkLiBIb3dldmVyLCBpdOKAmXMgZGVzaWduZWQgdG9cbiAgICAgICAgICAgICAqIG1pbmltaXplIHRoZSBjb3N0IG9mIHVwZGF0ZXMgd2hlbiBpbmRpdmlkdWFsIG5vZGVzIGNoYW5nZS5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBGb3IgZXhhbXBsZSwgd2hlbiB5b3XigJlyZSBkcmFnZ2luZyBhIHNpbmdsZSBub2RlLCB0aGF0IG5vZGUgZ2V0c1xuICAgICAgICAgICAgICogdXBkYXRlZCBtdWx0aXBsZSB0aW1lcyBwZXIgc2Vjb25kLiBJZiBgTm9kZVJlbmRlcmVyYCB3ZXJlIHRvIHVwZGF0ZVxuICAgICAgICAgICAgICogZXZlcnkgdGltZSwgaXQgd291bGQgaGF2ZSB0byByZS1ydW4gdGhlIGBub2Rlcy5tYXAoKWAgbG9vcCBldmVyeVxuICAgICAgICAgICAgICogdGltZS4gVGhpcyBnZXRzIHByaWNleSB3aXRoIGh1bmRyZWRzIG9mIG5vZGVzLCBlc3BlY2lhbGx5IGlmIGV2ZXJ5XG4gICAgICAgICAgICAgKiBsb29wIGN5Y2xlIGRvZXMgbW9yZSB0aGFuIGp1c3QgcmVuZGVyaW5nIGEgSlNYIGVsZW1lbnQhXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQXMgYSByZXN1bHQgb2YgdGhpcyBjaG9pY2UsIHdlIHRvb2sgdGhlIGZvbGxvd2luZyBpbXBsZW1lbnRhdGlvblxuICAgICAgICAgICAgICogZGVjaXNpb25zOlxuICAgICAgICAgICAgICogLSBOb2RlUmVuZGVyZXIgc3Vic2NyaWJlcyAqb25seSogdG8gbm9kZSBJRHMg4oCTIGFuZCB0aGVyZWZvcmVcbiAgICAgICAgICAgICAqICAgcmVyZW5kZXIgKm9ubHkqIHdoZW4gdmlzaWJsZSBub2RlcyBhcmUgYWRkZWQgb3IgcmVtb3ZlZC5cbiAgICAgICAgICAgICAqIC0gTm9kZVJlbmRlcmVyIHBlcmZvcm1zIGFsbCBvcGVyYXRpb25zIHRoZSByZXN1bHQgb2Ygd2hpY2ggY2FuIGJlXG4gICAgICAgICAgICAgKiAgIHNoYXJlZCBiZXR3ZWVuIG5vZGVzIChzdWNoIGFzIGNyZWF0aW5nIHRoZSBgUmVzaXplT2JzZXJ2ZXJgXG4gICAgICAgICAgICAgKiAgIGluc3RhbmNlLCBvciBzdWJzY3JpYmluZyB0byBgc2VsZWN0b3JgKS4gVGhpcyBtZWFucyBleHRyYSBwcm9wXG4gICAgICAgICAgICAgKiAgIGRyaWxsaW5nIGludG8gYE5vZGVDb21wb25lbnRXcmFwcGVyYCwgYnV0IGl0IG1lYW5zIHdlIG5lZWQgdG8gcnVuXG4gICAgICAgICAgICAgKiAgIHRoZXNlIG9wZXJhdGlvbnMgb25seSBvbmNlIOKAkyBpbnN0ZWFkIG9mIG9uY2UgcGVyIG5vZGUuXG4gICAgICAgICAgICAgKiAtIEFueSBvcGVyYXRpb25zIHRoYXQgeW914oCZZCBub3JtYWxseSB3cml0ZSBpbnNpZGUgYG5vZGVzLm1hcGAgYXJlXG4gICAgICAgICAgICAgKiAgIG1vdmVkIGludG8gYE5vZGVDb21wb25lbnRXcmFwcGVyYC4gVGhpcyBlbnN1cmVzIHRoZXkgYXJlXG4gICAgICAgICAgICAgKiAgIG1lbW9yaXplZCDigJMgc28gaWYgYE5vZGVSZW5kZXJlcmAgKmhhcyogdG8gcmVyZW5kZXIsIGl0IG9ubHlcbiAgICAgICAgICAgICAqICAgbmVlZHMgdG8gcmVnZW5lcmF0ZSB0aGUgbGlzdCBvZiBub2Rlcywgbm90aGluZyBlbHNlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBqc3goTm9kZVdyYXBwZXIsIHsgaWQ6IG5vZGVJZCwgbm9kZVR5cGVzOiBwcm9wcy5ub2RlVHlwZXMsIG5vZGVFeHRlbnQ6IHByb3BzLm5vZGVFeHRlbnQsIG9uQ2xpY2s6IHByb3BzLm9uTm9kZUNsaWNrLCBvbk1vdXNlRW50ZXI6IHByb3BzLm9uTm9kZU1vdXNlRW50ZXIsIG9uTW91c2VNb3ZlOiBwcm9wcy5vbk5vZGVNb3VzZU1vdmUsIG9uTW91c2VMZWF2ZTogcHJvcHMub25Ob2RlTW91c2VMZWF2ZSwgb25Db250ZXh0TWVudTogcHJvcHMub25Ob2RlQ29udGV4dE1lbnUsIG9uRG91YmxlQ2xpY2s6IHByb3BzLm9uTm9kZURvdWJsZUNsaWNrLCBub0RyYWdDbGFzc05hbWU6IHByb3BzLm5vRHJhZ0NsYXNzTmFtZSwgbm9QYW5DbGFzc05hbWU6IHByb3BzLm5vUGFuQ2xhc3NOYW1lLCByZklkOiBwcm9wcy5yZklkLCBkaXNhYmxlS2V5Ym9hcmRBMTF5OiBwcm9wcy5kaXNhYmxlS2V5Ym9hcmRBMTF5LCByZXNpemVPYnNlcnZlcjogcmVzaXplT2JzZXJ2ZXIsIG5vZGVzRHJhZ2dhYmxlOiBub2Rlc0RyYWdnYWJsZSwgbm9kZXNDb25uZWN0YWJsZTogbm9kZXNDb25uZWN0YWJsZSwgbm9kZXNGb2N1c2FibGU6IG5vZGVzRm9jdXNhYmxlLCBlbGVtZW50c1NlbGVjdGFibGU6IGVsZW1lbnRzU2VsZWN0YWJsZSwgbm9kZUNsaWNrRGlzdGFuY2U6IHByb3BzLm5vZGVDbGlja0Rpc3RhbmNlLCBvbkVycm9yOiBvbkVycm9yIH0sIG5vZGVJZCkpO1xuICAgICAgICB9KSB9KSk7XG59XG5Ob2RlUmVuZGVyZXJDb21wb25lbnQuZGlzcGxheU5hbWUgPSAnTm9kZVJlbmRlcmVyJztcbmNvbnN0IE5vZGVSZW5kZXJlciA9IG1lbW8oTm9kZVJlbmRlcmVyQ29tcG9uZW50KTtcblxuLyoqXG4gKiBIb29rIGZvciBnZXR0aW5nIHRoZSB2aXNpYmxlIGVkZ2UgaWRzIGZyb20gdGhlIHN0b3JlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIG9ubHlSZW5kZXJWaXNpYmxlXG4gKiBAcmV0dXJucyBhcnJheSB3aXRoIHZpc2libGUgZWRnZSBpZHNcbiAqL1xuZnVuY3Rpb24gdXNlVmlzaWJsZUVkZ2VJZHMob25seVJlbmRlclZpc2libGUpIHtcbiAgICBjb25zdCBlZGdlSWRzID0gdXNlU3RvcmUodXNlQ2FsbGJhY2soKHMpID0+IHtcbiAgICAgICAgaWYgKCFvbmx5UmVuZGVyVmlzaWJsZSkge1xuICAgICAgICAgICAgcmV0dXJuIHMuZWRnZXMubWFwKChlZGdlKSA9PiBlZGdlLmlkKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2aXNpYmxlRWRnZUlkcyA9IFtdO1xuICAgICAgICBpZiAocy53aWR0aCAmJiBzLmhlaWdodCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBlZGdlIG9mIHMuZWRnZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzb3VyY2VOb2RlID0gcy5ub2RlTG9va3VwLmdldChlZGdlLnNvdXJjZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0Tm9kZSA9IHMubm9kZUxvb2t1cC5nZXQoZWRnZS50YXJnZXQpO1xuICAgICAgICAgICAgICAgIGlmIChzb3VyY2VOb2RlICYmXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldE5vZGUgJiZcbiAgICAgICAgICAgICAgICAgICAgaXNFZGdlVmlzaWJsZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2VOb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Tm9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpZHRoOiBzLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBzLmhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybTogcy50cmFuc2Zvcm0sXG4gICAgICAgICAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHZpc2libGVFZGdlSWRzLnB1c2goZWRnZS5pZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2aXNpYmxlRWRnZUlkcztcbiAgICB9LCBbb25seVJlbmRlclZpc2libGVdKSwgc2hhbGxvdyk7XG4gICAgcmV0dXJuIGVkZ2VJZHM7XG59XG5cbmNvbnN0IEFycm93U3ltYm9sID0gKHsgY29sb3IgPSAnbm9uZScsIHN0cm9rZVdpZHRoID0gMSB9KSA9PiB7XG4gICAgcmV0dXJuIChqc3goXCJwb2x5bGluZVwiLCB7IHN0eWxlOiB7XG4gICAgICAgICAgICBzdHJva2U6IGNvbG9yLFxuICAgICAgICAgICAgc3Ryb2tlV2lkdGgsXG4gICAgICAgIH0sIHN0cm9rZUxpbmVjYXA6IFwicm91bmRcIiwgc3Ryb2tlTGluZWpvaW46IFwicm91bmRcIiwgZmlsbDogXCJub25lXCIsIHBvaW50czogXCItNSwtNCAwLDAgLTUsNFwiIH0pKTtcbn07XG5jb25zdCBBcnJvd0Nsb3NlZFN5bWJvbCA9ICh7IGNvbG9yID0gJ25vbmUnLCBzdHJva2VXaWR0aCA9IDEgfSkgPT4ge1xuICAgIHJldHVybiAoanN4KFwicG9seWxpbmVcIiwgeyBzdHlsZToge1xuICAgICAgICAgICAgc3Ryb2tlOiBjb2xvcixcbiAgICAgICAgICAgIGZpbGw6IGNvbG9yLFxuICAgICAgICAgICAgc3Ryb2tlV2lkdGgsXG4gICAgICAgIH0sIHN0cm9rZUxpbmVjYXA6IFwicm91bmRcIiwgc3Ryb2tlTGluZWpvaW46IFwicm91bmRcIiwgcG9pbnRzOiBcIi01LC00IDAsMCAtNSw0IC01LC00XCIgfSkpO1xufTtcbmNvbnN0IE1hcmtlclN5bWJvbHMgPSB7XG4gICAgW01hcmtlclR5cGUuQXJyb3ddOiBBcnJvd1N5bWJvbCxcbiAgICBbTWFya2VyVHlwZS5BcnJvd0Nsb3NlZF06IEFycm93Q2xvc2VkU3ltYm9sLFxufTtcbmZ1bmN0aW9uIHVzZU1hcmtlclN5bWJvbCh0eXBlKSB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIGNvbnN0IHN5bWJvbCA9IHVzZU1lbW8oKCkgPT4ge1xuICAgICAgICBjb25zdCBzeW1ib2xFeGlzdHMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoTWFya2VyU3ltYm9scywgdHlwZSk7XG4gICAgICAgIGlmICghc3ltYm9sRXhpc3RzKSB7XG4gICAgICAgICAgICBzdG9yZS5nZXRTdGF0ZSgpLm9uRXJyb3I/LignMDA5JywgZXJyb3JNZXNzYWdlc1snZXJyb3IwMDknXSh0eXBlKSk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gTWFya2VyU3ltYm9sc1t0eXBlXTtcbiAgICB9LCBbdHlwZV0pO1xuICAgIHJldHVybiBzeW1ib2w7XG59XG5cbmNvbnN0IE1hcmtlciA9ICh7IGlkLCB0eXBlLCBjb2xvciwgd2lkdGggPSAxMi41LCBoZWlnaHQgPSAxMi41LCBtYXJrZXJVbml0cyA9ICdzdHJva2VXaWR0aCcsIHN0cm9rZVdpZHRoLCBvcmllbnQgPSAnYXV0by1zdGFydC1yZXZlcnNlJywgfSkgPT4ge1xuICAgIGNvbnN0IFN5bWJvbCA9IHVzZU1hcmtlclN5bWJvbCh0eXBlKTtcbiAgICBpZiAoIVN5bWJvbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIChqc3goXCJtYXJrZXJcIiwgeyBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fYXJyb3doZWFkXCIsIGlkOiBpZCwgbWFya2VyV2lkdGg6IGAke3dpZHRofWAsIG1hcmtlckhlaWdodDogYCR7aGVpZ2h0fWAsIHZpZXdCb3g6IFwiLTEwIC0xMCAyMCAyMFwiLCBtYXJrZXJVbml0czogbWFya2VyVW5pdHMsIG9yaWVudDogb3JpZW50LCByZWZYOiBcIjBcIiwgcmVmWTogXCIwXCIsIGNoaWxkcmVuOiBqc3goU3ltYm9sLCB7IGNvbG9yOiBjb2xvciwgc3Ryb2tlV2lkdGg6IHN0cm9rZVdpZHRoIH0pIH0pKTtcbn07XG4vKlxuICogd2hlbiB5b3UgaGF2ZSBtdWx0aXBsZSBmbG93cyBvbiBhIHBhZ2UgYW5kIHlvdSBoaWRlIHRoZSBmaXJzdCBvbmUsIHRoZSBvdGhlciBvbmVzIGhhdmUgbm8gbWFya2VycyBhbnltb3JlXG4gKiB3aGVuIHRoZXkgZG8gaGF2ZSBtYXJrZXJzIHdpdGggdGhlIHNhbWUgaWRzLiBUbyBwcmV2ZW50IHRoaXMgdGhlIHVzZXIgY2FuIHBhc3MgYSB1bmlxdWUgaWQgdG8gdGhlIHJlYWN0IGZsb3cgd3JhcHBlclxuICogdGhhdCB3ZSBjYW4gdGhlbiB1c2UgZm9yIGNyZWF0aW5nIG91ciB1bmlxdWUgbWFya2VyIGlkc1xuICovXG5jb25zdCBNYXJrZXJEZWZpbml0aW9ucyA9ICh7IGRlZmF1bHRDb2xvciwgcmZJZCB9KSA9PiB7XG4gICAgY29uc3QgZWRnZXMgPSB1c2VTdG9yZSgocykgPT4gcy5lZGdlcyk7XG4gICAgY29uc3QgZGVmYXVsdEVkZ2VPcHRpb25zID0gdXNlU3RvcmUoKHMpID0+IHMuZGVmYXVsdEVkZ2VPcHRpb25zKTtcbiAgICBjb25zdCBtYXJrZXJzID0gdXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGNvbnN0IG1hcmtlcnMgPSBjcmVhdGVNYXJrZXJJZHMoZWRnZXMsIHtcbiAgICAgICAgICAgIGlkOiByZklkLFxuICAgICAgICAgICAgZGVmYXVsdENvbG9yLFxuICAgICAgICAgICAgZGVmYXVsdE1hcmtlclN0YXJ0OiBkZWZhdWx0RWRnZU9wdGlvbnM/Lm1hcmtlclN0YXJ0LFxuICAgICAgICAgICAgZGVmYXVsdE1hcmtlckVuZDogZGVmYXVsdEVkZ2VPcHRpb25zPy5tYXJrZXJFbmQsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbWFya2VycztcbiAgICB9LCBbZWRnZXMsIGRlZmF1bHRFZGdlT3B0aW9ucywgcmZJZCwgZGVmYXVsdENvbG9yXSk7XG4gICAgaWYgKCFtYXJrZXJzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIChqc3goXCJzdmdcIiwgeyBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fbWFya2VyXCIsIGNoaWxkcmVuOiBqc3goXCJkZWZzXCIsIHsgY2hpbGRyZW46IG1hcmtlcnMubWFwKChtYXJrZXIpID0+IChqc3goTWFya2VyLCB7IGlkOiBtYXJrZXIuaWQsIHR5cGU6IG1hcmtlci50eXBlLCBjb2xvcjogbWFya2VyLmNvbG9yLCB3aWR0aDogbWFya2VyLndpZHRoLCBoZWlnaHQ6IG1hcmtlci5oZWlnaHQsIG1hcmtlclVuaXRzOiBtYXJrZXIubWFya2VyVW5pdHMsIHN0cm9rZVdpZHRoOiBtYXJrZXIuc3Ryb2tlV2lkdGgsIG9yaWVudDogbWFya2VyLm9yaWVudCB9LCBtYXJrZXIuaWQpKSkgfSkgfSkpO1xufTtcbk1hcmtlckRlZmluaXRpb25zLmRpc3BsYXlOYW1lID0gJ01hcmtlckRlZmluaXRpb25zJztcbnZhciBNYXJrZXJEZWZpbml0aW9ucyQxID0gbWVtbyhNYXJrZXJEZWZpbml0aW9ucyk7XG5cbmZ1bmN0aW9uIEVkZ2VUZXh0Q29tcG9uZW50KHsgeCwgeSwgbGFiZWwsIGxhYmVsU3R5bGUgPSB7fSwgbGFiZWxTaG93QmcgPSB0cnVlLCBsYWJlbEJnU3R5bGUgPSB7fSwgbGFiZWxCZ1BhZGRpbmcgPSBbMiwgNF0sIGxhYmVsQmdCb3JkZXJSYWRpdXMgPSAyLCBjaGlsZHJlbiwgY2xhc3NOYW1lLCAuLi5yZXN0IH0pIHtcbiAgICBjb25zdCBbZWRnZVRleHRCYm94LCBzZXRFZGdlVGV4dEJib3hdID0gdXNlU3RhdGUoeyB4OiAxLCB5OiAwLCB3aWR0aDogMCwgaGVpZ2h0OiAwIH0pO1xuICAgIGNvbnN0IGVkZ2VUZXh0Q2xhc3NlcyA9IGNjKFsncmVhY3QtZmxvd19fZWRnZS10ZXh0d3JhcHBlcicsIGNsYXNzTmFtZV0pO1xuICAgIGNvbnN0IGVkZ2VUZXh0UmVmID0gdXNlUmVmKG51bGwpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChlZGdlVGV4dFJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgICBjb25zdCB0ZXh0QmJveCA9IGVkZ2VUZXh0UmVmLmN1cnJlbnQuZ2V0QkJveCgpO1xuICAgICAgICAgICAgc2V0RWRnZVRleHRCYm94KHtcbiAgICAgICAgICAgICAgICB4OiB0ZXh0QmJveC54LFxuICAgICAgICAgICAgICAgIHk6IHRleHRCYm94LnksXG4gICAgICAgICAgICAgICAgd2lkdGg6IHRleHRCYm94LndpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogdGV4dEJib3guaGVpZ2h0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LCBbbGFiZWxdKTtcbiAgICBpZiAodHlwZW9mIGxhYmVsID09PSAndW5kZWZpbmVkJyB8fCAhbGFiZWwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiAoanN4cyhcImdcIiwgeyB0cmFuc2Zvcm06IGB0cmFuc2xhdGUoJHt4IC0gZWRnZVRleHRCYm94LndpZHRoIC8gMn0gJHt5IC0gZWRnZVRleHRCYm94LmhlaWdodCAvIDJ9KWAsIGNsYXNzTmFtZTogZWRnZVRleHRDbGFzc2VzLCB2aXNpYmlsaXR5OiBlZGdlVGV4dEJib3gud2lkdGggPyAndmlzaWJsZScgOiAnaGlkZGVuJywgLi4ucmVzdCwgY2hpbGRyZW46IFtsYWJlbFNob3dCZyAmJiAoanN4KFwicmVjdFwiLCB7IHdpZHRoOiBlZGdlVGV4dEJib3gud2lkdGggKyAyICogbGFiZWxCZ1BhZGRpbmdbMF0sIHg6IC1sYWJlbEJnUGFkZGluZ1swXSwgeTogLWxhYmVsQmdQYWRkaW5nWzFdLCBoZWlnaHQ6IGVkZ2VUZXh0QmJveC5oZWlnaHQgKyAyICogbGFiZWxCZ1BhZGRpbmdbMV0sIGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19lZGdlLXRleHRiZ1wiLCBzdHlsZTogbGFiZWxCZ1N0eWxlLCByeDogbGFiZWxCZ0JvcmRlclJhZGl1cywgcnk6IGxhYmVsQmdCb3JkZXJSYWRpdXMgfSkpLCBqc3goXCJ0ZXh0XCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX2VkZ2UtdGV4dFwiLCB5OiBlZGdlVGV4dEJib3guaGVpZ2h0IC8gMiwgZHk6IFwiMC4zZW1cIiwgcmVmOiBlZGdlVGV4dFJlZiwgc3R5bGU6IGxhYmVsU3R5bGUsIGNoaWxkcmVuOiBsYWJlbCB9KSwgY2hpbGRyZW5dIH0pKTtcbn1cbkVkZ2VUZXh0Q29tcG9uZW50LmRpc3BsYXlOYW1lID0gJ0VkZ2VUZXh0Jztcbi8qKlxuICogWW91IGNhbiB1c2UgdGhlIGA8RWRnZVRleHQgLz5gIGNvbXBvbmVudCBhcyBhIGhlbHBlciBjb21wb25lbnQgdG8gZGlzcGxheSB0ZXh0XG4gKiB3aXRoaW4geW91ciBjdXN0b20gZWRnZXMuXG4gKlxuICpAcHVibGljXG4gKlxuICpAZXhhbXBsZVxuICpgYGBqc3hcbiAqaW1wb3J0IHsgRWRnZVRleHQgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKmV4cG9ydCBmdW5jdGlvbiBDdXN0b21FZGdlTGFiZWwoeyBsYWJlbCB9KSB7XG4gKiAgcmV0dXJuIChcbiAqICAgIDxFZGdlVGV4dFxuICogICAgICB4PXsxMDB9XG4gKiAgICAgIHk9ezEwMH1cbiAqICAgICAgbGFiZWw9e2xhYmVsfVxuICogICAgICBsYWJlbFN0eWxlPXt7IGZpbGw6ICd3aGl0ZScgfX1cbiAqICAgICAgbGFiZWxTaG93QmdcbiAqICAgICAgbGFiZWxCZ1N0eWxlPXt7IGZpbGw6ICdyZWQnIH19XG4gKiAgICAgIGxhYmVsQmdQYWRkaW5nPXtbMiwgNF19XG4gKiAgICAgIGxhYmVsQmdCb3JkZXJSYWRpdXM9ezJ9XG4gKiAgICAvPlxuICogICk7XG4gKn1cbiAqYGBgXG4gKi9cbmNvbnN0IEVkZ2VUZXh0ID0gbWVtbyhFZGdlVGV4dENvbXBvbmVudCk7XG5cbi8qKlxuICogVGhlIGA8QmFzZUVkZ2UgLz5gIGNvbXBvbmVudCBnZXRzIHVzZWQgaW50ZXJuYWxseSBmb3IgYWxsIHRoZSBlZGdlcy4gSXQgY2FuIGJlXG4gKiB1c2VkIGluc2lkZSBhIGN1c3RvbSBlZGdlIGFuZCBoYW5kbGVzIHRoZSBpbnZpc2libGUgaGVscGVyIGVkZ2UgYW5kIHRoZSBlZGdlIGxhYmVsXG4gKiBmb3IgeW91LlxuICpcbiAqIEBwdWJsaWNcbiAqIEBleGFtcGxlXG4gKiBgYGBqc3hcbiAqaW1wb3J0IHsgQmFzZUVkZ2UgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKmV4cG9ydCBmdW5jdGlvbiBDdXN0b21FZGdlKHsgc291cmNlWCwgc291cmNlWSwgdGFyZ2V0WCwgdGFyZ2V0WSwgLi4ucHJvcHMgfSkge1xuICogIGNvbnN0IFtlZGdlUGF0aF0gPSBnZXRTdHJhaWdodFBhdGgoe1xuICogICAgc291cmNlWCxcbiAqICAgIHNvdXJjZVksXG4gKiAgICB0YXJnZXRYLFxuICogICAgdGFyZ2V0WSxcbiAqICB9KTtcbiAqXG4gKiAgcmV0dXJuIDxCYXNlRWRnZSBwYXRoPXtlZGdlUGF0aH0gey4uLnByb3BzfSAvPjtcbiAqfVxuICpgYGBcbiAqXG4gKiBAcmVtYXJrcyBJZiB5b3Ugd2FudCB0byB1c2UgYW4gZWRnZSBtYXJrZXIgd2l0aCB0aGUgW2A8QmFzZUVkZ2UgLz5gXSgvYXBpLXJlZmVyZW5jZS9jb21wb25lbnRzL2Jhc2UtZWRnZSkgY29tcG9uZW50LFxuICogeW91IGNhbiBwYXNzIHRoZSBgbWFya2VyU3RhcnRgIG9yIGBtYXJrZXJFbmRgIHByb3BzIHBhc3NlZCB0byB5b3VyIGN1c3RvbSBlZGdlXG4gKiB0aHJvdWdoIHRvIHRoZSBbYDxCYXNlRWRnZSAvPmBdKC9hcGktcmVmZXJlbmNlL2NvbXBvbmVudHMvYmFzZS1lZGdlKSBjb21wb25lbnQuXG4gKiBZb3UgY2FuIHNlZSBhbGwgdGhlIHByb3BzIHBhc3NlZCB0byBhIGN1c3RvbSBlZGdlIGJ5IGxvb2tpbmcgYXQgdGhlIFtgRWRnZVByb3BzYF0oL2FwaS1yZWZlcmVuY2UvdHlwZXMvZWRnZS1wcm9wcykgdHlwZS5cbiAqL1xuZnVuY3Rpb24gQmFzZUVkZ2UoeyBwYXRoLCBsYWJlbFgsIGxhYmVsWSwgbGFiZWwsIGxhYmVsU3R5bGUsIGxhYmVsU2hvd0JnLCBsYWJlbEJnU3R5bGUsIGxhYmVsQmdQYWRkaW5nLCBsYWJlbEJnQm9yZGVyUmFkaXVzLCBpbnRlcmFjdGlvbldpZHRoID0gMjAsIC4uLnByb3BzIH0pIHtcbiAgICByZXR1cm4gKGpzeHMoRnJhZ21lbnQsIHsgY2hpbGRyZW46IFtqc3goXCJwYXRoXCIsIHsgLi4ucHJvcHMsIGQ6IHBhdGgsIGZpbGw6IFwibm9uZVwiLCBjbGFzc05hbWU6IGNjKFsncmVhY3QtZmxvd19fZWRnZS1wYXRoJywgcHJvcHMuY2xhc3NOYW1lXSkgfSksIGludGVyYWN0aW9uV2lkdGggJiYgKGpzeChcInBhdGhcIiwgeyBkOiBwYXRoLCBmaWxsOiBcIm5vbmVcIiwgc3Ryb2tlT3BhY2l0eTogMCwgc3Ryb2tlV2lkdGg6IGludGVyYWN0aW9uV2lkdGgsIGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19lZGdlLWludGVyYWN0aW9uXCIgfSkpLCBsYWJlbCAmJiBpc051bWVyaWMobGFiZWxYKSAmJiBpc051bWVyaWMobGFiZWxZKSA/IChqc3goRWRnZVRleHQsIHsgeDogbGFiZWxYLCB5OiBsYWJlbFksIGxhYmVsOiBsYWJlbCwgbGFiZWxTdHlsZTogbGFiZWxTdHlsZSwgbGFiZWxTaG93Qmc6IGxhYmVsU2hvd0JnLCBsYWJlbEJnU3R5bGU6IGxhYmVsQmdTdHlsZSwgbGFiZWxCZ1BhZGRpbmc6IGxhYmVsQmdQYWRkaW5nLCBsYWJlbEJnQm9yZGVyUmFkaXVzOiBsYWJlbEJnQm9yZGVyUmFkaXVzIH0pKSA6IG51bGxdIH0pKTtcbn1cblxuZnVuY3Rpb24gZ2V0Q29udHJvbCh7IHBvcywgeDEsIHkxLCB4MiwgeTIgfSkge1xuICAgIGlmIChwb3MgPT09IFBvc2l0aW9uLkxlZnQgfHwgcG9zID09PSBQb3NpdGlvbi5SaWdodCkge1xuICAgICAgICByZXR1cm4gWzAuNSAqICh4MSArIHgyKSwgeTFdO1xuICAgIH1cbiAgICByZXR1cm4gW3gxLCAwLjUgKiAoeTEgKyB5MildO1xufVxuLyoqXG4gKiBUaGUgYGdldFNpbXBsZUJlemllclBhdGhgIHV0aWwgcmV0dXJucyBldmVyeXRoaW5nIHlvdSBuZWVkIHRvIHJlbmRlciBhIHNpbXBsZVxuICogYmV6aWVyIGVkZ2UgYmV0d2VlbiB0d28gbm9kZXMuXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGdldFNpbXBsZUJlemllclBhdGgoeyBzb3VyY2VYLCBzb3VyY2VZLCBzb3VyY2VQb3NpdGlvbiA9IFBvc2l0aW9uLkJvdHRvbSwgdGFyZ2V0WCwgdGFyZ2V0WSwgdGFyZ2V0UG9zaXRpb24gPSBQb3NpdGlvbi5Ub3AsIH0pIHtcbiAgICBjb25zdCBbc291cmNlQ29udHJvbFgsIHNvdXJjZUNvbnRyb2xZXSA9IGdldENvbnRyb2woe1xuICAgICAgICBwb3M6IHNvdXJjZVBvc2l0aW9uLFxuICAgICAgICB4MTogc291cmNlWCxcbiAgICAgICAgeTE6IHNvdXJjZVksXG4gICAgICAgIHgyOiB0YXJnZXRYLFxuICAgICAgICB5MjogdGFyZ2V0WSxcbiAgICB9KTtcbiAgICBjb25zdCBbdGFyZ2V0Q29udHJvbFgsIHRhcmdldENvbnRyb2xZXSA9IGdldENvbnRyb2woe1xuICAgICAgICBwb3M6IHRhcmdldFBvc2l0aW9uLFxuICAgICAgICB4MTogdGFyZ2V0WCxcbiAgICAgICAgeTE6IHRhcmdldFksXG4gICAgICAgIHgyOiBzb3VyY2VYLFxuICAgICAgICB5Mjogc291cmNlWSxcbiAgICB9KTtcbiAgICBjb25zdCBbbGFiZWxYLCBsYWJlbFksIG9mZnNldFgsIG9mZnNldFldID0gZ2V0QmV6aWVyRWRnZUNlbnRlcih7XG4gICAgICAgIHNvdXJjZVgsXG4gICAgICAgIHNvdXJjZVksXG4gICAgICAgIHRhcmdldFgsXG4gICAgICAgIHRhcmdldFksXG4gICAgICAgIHNvdXJjZUNvbnRyb2xYLFxuICAgICAgICBzb3VyY2VDb250cm9sWSxcbiAgICAgICAgdGFyZ2V0Q29udHJvbFgsXG4gICAgICAgIHRhcmdldENvbnRyb2xZLFxuICAgIH0pO1xuICAgIHJldHVybiBbXG4gICAgICAgIGBNJHtzb3VyY2VYfSwke3NvdXJjZVl9IEMke3NvdXJjZUNvbnRyb2xYfSwke3NvdXJjZUNvbnRyb2xZfSAke3RhcmdldENvbnRyb2xYfSwke3RhcmdldENvbnRyb2xZfSAke3RhcmdldFh9LCR7dGFyZ2V0WX1gLFxuICAgICAgICBsYWJlbFgsXG4gICAgICAgIGxhYmVsWSxcbiAgICAgICAgb2Zmc2V0WCxcbiAgICAgICAgb2Zmc2V0WSxcbiAgICBdO1xufVxuZnVuY3Rpb24gY3JlYXRlU2ltcGxlQmV6aWVyRWRnZShwYXJhbXMpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QvZGlzcGxheS1uYW1lXG4gICAgcmV0dXJuIG1lbW8oKHsgaWQsIHNvdXJjZVgsIHNvdXJjZVksIHRhcmdldFgsIHRhcmdldFksIHNvdXJjZVBvc2l0aW9uID0gUG9zaXRpb24uQm90dG9tLCB0YXJnZXRQb3NpdGlvbiA9IFBvc2l0aW9uLlRvcCwgbGFiZWwsIGxhYmVsU3R5bGUsIGxhYmVsU2hvd0JnLCBsYWJlbEJnU3R5bGUsIGxhYmVsQmdQYWRkaW5nLCBsYWJlbEJnQm9yZGVyUmFkaXVzLCBzdHlsZSwgbWFya2VyRW5kLCBtYXJrZXJTdGFydCwgaW50ZXJhY3Rpb25XaWR0aCwgfSkgPT4ge1xuICAgICAgICBjb25zdCBbcGF0aCwgbGFiZWxYLCBsYWJlbFldID0gZ2V0U2ltcGxlQmV6aWVyUGF0aCh7XG4gICAgICAgICAgICBzb3VyY2VYLFxuICAgICAgICAgICAgc291cmNlWSxcbiAgICAgICAgICAgIHNvdXJjZVBvc2l0aW9uLFxuICAgICAgICAgICAgdGFyZ2V0WCxcbiAgICAgICAgICAgIHRhcmdldFksXG4gICAgICAgICAgICB0YXJnZXRQb3NpdGlvbixcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IF9pZCA9IHBhcmFtcy5pc0ludGVybmFsID8gdW5kZWZpbmVkIDogaWQ7XG4gICAgICAgIHJldHVybiAoanN4KEJhc2VFZGdlLCB7IGlkOiBfaWQsIHBhdGg6IHBhdGgsIGxhYmVsWDogbGFiZWxYLCBsYWJlbFk6IGxhYmVsWSwgbGFiZWw6IGxhYmVsLCBsYWJlbFN0eWxlOiBsYWJlbFN0eWxlLCBsYWJlbFNob3dCZzogbGFiZWxTaG93QmcsIGxhYmVsQmdTdHlsZTogbGFiZWxCZ1N0eWxlLCBsYWJlbEJnUGFkZGluZzogbGFiZWxCZ1BhZGRpbmcsIGxhYmVsQmdCb3JkZXJSYWRpdXM6IGxhYmVsQmdCb3JkZXJSYWRpdXMsIHN0eWxlOiBzdHlsZSwgbWFya2VyRW5kOiBtYXJrZXJFbmQsIG1hcmtlclN0YXJ0OiBtYXJrZXJTdGFydCwgaW50ZXJhY3Rpb25XaWR0aDogaW50ZXJhY3Rpb25XaWR0aCB9KSk7XG4gICAgfSk7XG59XG5jb25zdCBTaW1wbGVCZXppZXJFZGdlID0gY3JlYXRlU2ltcGxlQmV6aWVyRWRnZSh7IGlzSW50ZXJuYWw6IGZhbHNlIH0pO1xuY29uc3QgU2ltcGxlQmV6aWVyRWRnZUludGVybmFsID0gY3JlYXRlU2ltcGxlQmV6aWVyRWRnZSh7IGlzSW50ZXJuYWw6IHRydWUgfSk7XG5TaW1wbGVCZXppZXJFZGdlLmRpc3BsYXlOYW1lID0gJ1NpbXBsZUJlemllckVkZ2UnO1xuU2ltcGxlQmV6aWVyRWRnZUludGVybmFsLmRpc3BsYXlOYW1lID0gJ1NpbXBsZUJlemllckVkZ2VJbnRlcm5hbCc7XG5cbmZ1bmN0aW9uIGNyZWF0ZVNtb290aFN0ZXBFZGdlKHBhcmFtcykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9kaXNwbGF5LW5hbWVcbiAgICByZXR1cm4gbWVtbygoeyBpZCwgc291cmNlWCwgc291cmNlWSwgdGFyZ2V0WCwgdGFyZ2V0WSwgbGFiZWwsIGxhYmVsU3R5bGUsIGxhYmVsU2hvd0JnLCBsYWJlbEJnU3R5bGUsIGxhYmVsQmdQYWRkaW5nLCBsYWJlbEJnQm9yZGVyUmFkaXVzLCBzdHlsZSwgc291cmNlUG9zaXRpb24gPSBQb3NpdGlvbi5Cb3R0b20sIHRhcmdldFBvc2l0aW9uID0gUG9zaXRpb24uVG9wLCBtYXJrZXJFbmQsIG1hcmtlclN0YXJ0LCBwYXRoT3B0aW9ucywgaW50ZXJhY3Rpb25XaWR0aCwgfSkgPT4ge1xuICAgICAgICBjb25zdCBbcGF0aCwgbGFiZWxYLCBsYWJlbFldID0gZ2V0U21vb3RoU3RlcFBhdGgoe1xuICAgICAgICAgICAgc291cmNlWCxcbiAgICAgICAgICAgIHNvdXJjZVksXG4gICAgICAgICAgICBzb3VyY2VQb3NpdGlvbixcbiAgICAgICAgICAgIHRhcmdldFgsXG4gICAgICAgICAgICB0YXJnZXRZLFxuICAgICAgICAgICAgdGFyZ2V0UG9zaXRpb24sXG4gICAgICAgICAgICBib3JkZXJSYWRpdXM6IHBhdGhPcHRpb25zPy5ib3JkZXJSYWRpdXMsXG4gICAgICAgICAgICBvZmZzZXQ6IHBhdGhPcHRpb25zPy5vZmZzZXQsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBfaWQgPSBwYXJhbXMuaXNJbnRlcm5hbCA/IHVuZGVmaW5lZCA6IGlkO1xuICAgICAgICByZXR1cm4gKGpzeChCYXNlRWRnZSwgeyBpZDogX2lkLCBwYXRoOiBwYXRoLCBsYWJlbFg6IGxhYmVsWCwgbGFiZWxZOiBsYWJlbFksIGxhYmVsOiBsYWJlbCwgbGFiZWxTdHlsZTogbGFiZWxTdHlsZSwgbGFiZWxTaG93Qmc6IGxhYmVsU2hvd0JnLCBsYWJlbEJnU3R5bGU6IGxhYmVsQmdTdHlsZSwgbGFiZWxCZ1BhZGRpbmc6IGxhYmVsQmdQYWRkaW5nLCBsYWJlbEJnQm9yZGVyUmFkaXVzOiBsYWJlbEJnQm9yZGVyUmFkaXVzLCBzdHlsZTogc3R5bGUsIG1hcmtlckVuZDogbWFya2VyRW5kLCBtYXJrZXJTdGFydDogbWFya2VyU3RhcnQsIGludGVyYWN0aW9uV2lkdGg6IGludGVyYWN0aW9uV2lkdGggfSkpO1xuICAgIH0pO1xufVxuY29uc3QgU21vb3RoU3RlcEVkZ2UgPSBjcmVhdGVTbW9vdGhTdGVwRWRnZSh7IGlzSW50ZXJuYWw6IGZhbHNlIH0pO1xuY29uc3QgU21vb3RoU3RlcEVkZ2VJbnRlcm5hbCA9IGNyZWF0ZVNtb290aFN0ZXBFZGdlKHsgaXNJbnRlcm5hbDogdHJ1ZSB9KTtcblNtb290aFN0ZXBFZGdlLmRpc3BsYXlOYW1lID0gJ1Ntb290aFN0ZXBFZGdlJztcblNtb290aFN0ZXBFZGdlSW50ZXJuYWwuZGlzcGxheU5hbWUgPSAnU21vb3RoU3RlcEVkZ2VJbnRlcm5hbCc7XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0ZXBFZGdlKHBhcmFtcykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9kaXNwbGF5LW5hbWVcbiAgICByZXR1cm4gbWVtbygoeyBpZCwgLi4ucHJvcHMgfSkgPT4ge1xuICAgICAgICBjb25zdCBfaWQgPSBwYXJhbXMuaXNJbnRlcm5hbCA/IHVuZGVmaW5lZCA6IGlkO1xuICAgICAgICByZXR1cm4gKGpzeChTbW9vdGhTdGVwRWRnZSwgeyAuLi5wcm9wcywgaWQ6IF9pZCwgcGF0aE9wdGlvbnM6IHVzZU1lbW8oKCkgPT4gKHsgYm9yZGVyUmFkaXVzOiAwLCBvZmZzZXQ6IHByb3BzLnBhdGhPcHRpb25zPy5vZmZzZXQgfSksIFtwcm9wcy5wYXRoT3B0aW9ucz8ub2Zmc2V0XSkgfSkpO1xuICAgIH0pO1xufVxuY29uc3QgU3RlcEVkZ2UgPSBjcmVhdGVTdGVwRWRnZSh7IGlzSW50ZXJuYWw6IGZhbHNlIH0pO1xuY29uc3QgU3RlcEVkZ2VJbnRlcm5hbCA9IGNyZWF0ZVN0ZXBFZGdlKHsgaXNJbnRlcm5hbDogdHJ1ZSB9KTtcblN0ZXBFZGdlLmRpc3BsYXlOYW1lID0gJ1N0ZXBFZGdlJztcblN0ZXBFZGdlSW50ZXJuYWwuZGlzcGxheU5hbWUgPSAnU3RlcEVkZ2VJbnRlcm5hbCc7XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0cmFpZ2h0RWRnZShwYXJhbXMpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QvZGlzcGxheS1uYW1lXG4gICAgcmV0dXJuIG1lbW8oKHsgaWQsIHNvdXJjZVgsIHNvdXJjZVksIHRhcmdldFgsIHRhcmdldFksIGxhYmVsLCBsYWJlbFN0eWxlLCBsYWJlbFNob3dCZywgbGFiZWxCZ1N0eWxlLCBsYWJlbEJnUGFkZGluZywgbGFiZWxCZ0JvcmRlclJhZGl1cywgc3R5bGUsIG1hcmtlckVuZCwgbWFya2VyU3RhcnQsIGludGVyYWN0aW9uV2lkdGgsIH0pID0+IHtcbiAgICAgICAgY29uc3QgW3BhdGgsIGxhYmVsWCwgbGFiZWxZXSA9IGdldFN0cmFpZ2h0UGF0aCh7IHNvdXJjZVgsIHNvdXJjZVksIHRhcmdldFgsIHRhcmdldFkgfSk7XG4gICAgICAgIGNvbnN0IF9pZCA9IHBhcmFtcy5pc0ludGVybmFsID8gdW5kZWZpbmVkIDogaWQ7XG4gICAgICAgIHJldHVybiAoanN4KEJhc2VFZGdlLCB7IGlkOiBfaWQsIHBhdGg6IHBhdGgsIGxhYmVsWDogbGFiZWxYLCBsYWJlbFk6IGxhYmVsWSwgbGFiZWw6IGxhYmVsLCBsYWJlbFN0eWxlOiBsYWJlbFN0eWxlLCBsYWJlbFNob3dCZzogbGFiZWxTaG93QmcsIGxhYmVsQmdTdHlsZTogbGFiZWxCZ1N0eWxlLCBsYWJlbEJnUGFkZGluZzogbGFiZWxCZ1BhZGRpbmcsIGxhYmVsQmdCb3JkZXJSYWRpdXM6IGxhYmVsQmdCb3JkZXJSYWRpdXMsIHN0eWxlOiBzdHlsZSwgbWFya2VyRW5kOiBtYXJrZXJFbmQsIG1hcmtlclN0YXJ0OiBtYXJrZXJTdGFydCwgaW50ZXJhY3Rpb25XaWR0aDogaW50ZXJhY3Rpb25XaWR0aCB9KSk7XG4gICAgfSk7XG59XG5jb25zdCBTdHJhaWdodEVkZ2UgPSBjcmVhdGVTdHJhaWdodEVkZ2UoeyBpc0ludGVybmFsOiBmYWxzZSB9KTtcbmNvbnN0IFN0cmFpZ2h0RWRnZUludGVybmFsID0gY3JlYXRlU3RyYWlnaHRFZGdlKHsgaXNJbnRlcm5hbDogdHJ1ZSB9KTtcblN0cmFpZ2h0RWRnZS5kaXNwbGF5TmFtZSA9ICdTdHJhaWdodEVkZ2UnO1xuU3RyYWlnaHRFZGdlSW50ZXJuYWwuZGlzcGxheU5hbWUgPSAnU3RyYWlnaHRFZGdlSW50ZXJuYWwnO1xuXG5mdW5jdGlvbiBjcmVhdGVCZXppZXJFZGdlKHBhcmFtcykge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9kaXNwbGF5LW5hbWVcbiAgICByZXR1cm4gbWVtbygoeyBpZCwgc291cmNlWCwgc291cmNlWSwgdGFyZ2V0WCwgdGFyZ2V0WSwgc291cmNlUG9zaXRpb24gPSBQb3NpdGlvbi5Cb3R0b20sIHRhcmdldFBvc2l0aW9uID0gUG9zaXRpb24uVG9wLCBsYWJlbCwgbGFiZWxTdHlsZSwgbGFiZWxTaG93QmcsIGxhYmVsQmdTdHlsZSwgbGFiZWxCZ1BhZGRpbmcsIGxhYmVsQmdCb3JkZXJSYWRpdXMsIHN0eWxlLCBtYXJrZXJFbmQsIG1hcmtlclN0YXJ0LCBwYXRoT3B0aW9ucywgaW50ZXJhY3Rpb25XaWR0aCwgfSkgPT4ge1xuICAgICAgICBjb25zdCBbcGF0aCwgbGFiZWxYLCBsYWJlbFldID0gZ2V0QmV6aWVyUGF0aCh7XG4gICAgICAgICAgICBzb3VyY2VYLFxuICAgICAgICAgICAgc291cmNlWSxcbiAgICAgICAgICAgIHNvdXJjZVBvc2l0aW9uLFxuICAgICAgICAgICAgdGFyZ2V0WCxcbiAgICAgICAgICAgIHRhcmdldFksXG4gICAgICAgICAgICB0YXJnZXRQb3NpdGlvbixcbiAgICAgICAgICAgIGN1cnZhdHVyZTogcGF0aE9wdGlvbnM/LmN1cnZhdHVyZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IF9pZCA9IHBhcmFtcy5pc0ludGVybmFsID8gdW5kZWZpbmVkIDogaWQ7XG4gICAgICAgIHJldHVybiAoanN4KEJhc2VFZGdlLCB7IGlkOiBfaWQsIHBhdGg6IHBhdGgsIGxhYmVsWDogbGFiZWxYLCBsYWJlbFk6IGxhYmVsWSwgbGFiZWw6IGxhYmVsLCBsYWJlbFN0eWxlOiBsYWJlbFN0eWxlLCBsYWJlbFNob3dCZzogbGFiZWxTaG93QmcsIGxhYmVsQmdTdHlsZTogbGFiZWxCZ1N0eWxlLCBsYWJlbEJnUGFkZGluZzogbGFiZWxCZ1BhZGRpbmcsIGxhYmVsQmdCb3JkZXJSYWRpdXM6IGxhYmVsQmdCb3JkZXJSYWRpdXMsIHN0eWxlOiBzdHlsZSwgbWFya2VyRW5kOiBtYXJrZXJFbmQsIG1hcmtlclN0YXJ0OiBtYXJrZXJTdGFydCwgaW50ZXJhY3Rpb25XaWR0aDogaW50ZXJhY3Rpb25XaWR0aCB9KSk7XG4gICAgfSk7XG59XG5jb25zdCBCZXppZXJFZGdlID0gY3JlYXRlQmV6aWVyRWRnZSh7IGlzSW50ZXJuYWw6IGZhbHNlIH0pO1xuY29uc3QgQmV6aWVyRWRnZUludGVybmFsID0gY3JlYXRlQmV6aWVyRWRnZSh7IGlzSW50ZXJuYWw6IHRydWUgfSk7XG5CZXppZXJFZGdlLmRpc3BsYXlOYW1lID0gJ0JlemllckVkZ2UnO1xuQmV6aWVyRWRnZUludGVybmFsLmRpc3BsYXlOYW1lID0gJ0JlemllckVkZ2VJbnRlcm5hbCc7XG5cbmNvbnN0IGJ1aWx0aW5FZGdlVHlwZXMgPSB7XG4gICAgZGVmYXVsdDogQmV6aWVyRWRnZUludGVybmFsLFxuICAgIHN0cmFpZ2h0OiBTdHJhaWdodEVkZ2VJbnRlcm5hbCxcbiAgICBzdGVwOiBTdGVwRWRnZUludGVybmFsLFxuICAgIHNtb290aHN0ZXA6IFNtb290aFN0ZXBFZGdlSW50ZXJuYWwsXG4gICAgc2ltcGxlYmV6aWVyOiBTaW1wbGVCZXppZXJFZGdlSW50ZXJuYWwsXG59O1xuY29uc3QgbnVsbFBvc2l0aW9uID0ge1xuICAgIHNvdXJjZVg6IG51bGwsXG4gICAgc291cmNlWTogbnVsbCxcbiAgICB0YXJnZXRYOiBudWxsLFxuICAgIHRhcmdldFk6IG51bGwsXG4gICAgc291cmNlUG9zaXRpb246IG51bGwsXG4gICAgdGFyZ2V0UG9zaXRpb246IG51bGwsXG59O1xuXG5jb25zdCBzaGlmdFggPSAoeCwgc2hpZnQsIHBvc2l0aW9uKSA9PiB7XG4gICAgaWYgKHBvc2l0aW9uID09PSBQb3NpdGlvbi5MZWZ0KVxuICAgICAgICByZXR1cm4geCAtIHNoaWZ0O1xuICAgIGlmIChwb3NpdGlvbiA9PT0gUG9zaXRpb24uUmlnaHQpXG4gICAgICAgIHJldHVybiB4ICsgc2hpZnQ7XG4gICAgcmV0dXJuIHg7XG59O1xuY29uc3Qgc2hpZnRZID0gKHksIHNoaWZ0LCBwb3NpdGlvbikgPT4ge1xuICAgIGlmIChwb3NpdGlvbiA9PT0gUG9zaXRpb24uVG9wKVxuICAgICAgICByZXR1cm4geSAtIHNoaWZ0O1xuICAgIGlmIChwb3NpdGlvbiA9PT0gUG9zaXRpb24uQm90dG9tKVxuICAgICAgICByZXR1cm4geSArIHNoaWZ0O1xuICAgIHJldHVybiB5O1xufTtcbmNvbnN0IEVkZ2VVcGRhdGVyQ2xhc3NOYW1lID0gJ3JlYWN0LWZsb3dfX2VkZ2V1cGRhdGVyJztcbmZ1bmN0aW9uIEVkZ2VBbmNob3IoeyBwb3NpdGlvbiwgY2VudGVyWCwgY2VudGVyWSwgcmFkaXVzID0gMTAsIG9uTW91c2VEb3duLCBvbk1vdXNlRW50ZXIsIG9uTW91c2VPdXQsIHR5cGUsIH0pIHtcbiAgICByZXR1cm4gKGpzeChcImNpcmNsZVwiLCB7IG9uTW91c2VEb3duOiBvbk1vdXNlRG93biwgb25Nb3VzZUVudGVyOiBvbk1vdXNlRW50ZXIsIG9uTW91c2VPdXQ6IG9uTW91c2VPdXQsIGNsYXNzTmFtZTogY2MoW0VkZ2VVcGRhdGVyQ2xhc3NOYW1lLCBgJHtFZGdlVXBkYXRlckNsYXNzTmFtZX0tJHt0eXBlfWBdKSwgY3g6IHNoaWZ0WChjZW50ZXJYLCByYWRpdXMsIHBvc2l0aW9uKSwgY3k6IHNoaWZ0WShjZW50ZXJZLCByYWRpdXMsIHBvc2l0aW9uKSwgcjogcmFkaXVzLCBzdHJva2U6IFwidHJhbnNwYXJlbnRcIiwgZmlsbDogXCJ0cmFuc3BhcmVudFwiIH0pKTtcbn1cblxuZnVuY3Rpb24gRWRnZVVwZGF0ZUFuY2hvcnMoeyBpc1JlY29ubmVjdGFibGUsIHJlY29ubmVjdFJhZGl1cywgZWRnZSwgc291cmNlWCwgc291cmNlWSwgdGFyZ2V0WCwgdGFyZ2V0WSwgc291cmNlUG9zaXRpb24sIHRhcmdldFBvc2l0aW9uLCBvblJlY29ubmVjdCwgb25SZWNvbm5lY3RTdGFydCwgb25SZWNvbm5lY3RFbmQsIHNldFJlY29ubmVjdGluZywgc2V0VXBkYXRlSG92ZXIsIH0pIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3QgaGFuZGxlRWRnZVVwZGF0ZXIgPSAoZXZlbnQsIG9wcG9zaXRlSGFuZGxlKSA9PiB7XG4gICAgICAgIC8vIGF2b2lkIHRyaWdnZXJpbmcgZWRnZSB1cGRhdGVyIGlmIG1vdXNlIGJ0biBpcyBub3QgbGVmdFxuICAgICAgICBpZiAoZXZlbnQuYnV0dG9uICE9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBhdXRvUGFuT25Db25uZWN0LCBkb21Ob2RlLCBpc1ZhbGlkQ29ubmVjdGlvbiwgY29ubmVjdGlvbk1vZGUsIGNvbm5lY3Rpb25SYWRpdXMsIGxpYiwgb25Db25uZWN0U3RhcnQsIG9uQ29ubmVjdEVuZCwgY2FuY2VsQ29ubmVjdGlvbiwgbm9kZUxvb2t1cCwgcmZJZDogZmxvd0lkLCBwYW5CeSwgdXBkYXRlQ29ubmVjdGlvbiwgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgIGNvbnN0IGlzVGFyZ2V0ID0gb3Bwb3NpdGVIYW5kbGUudHlwZSA9PT0gJ3RhcmdldCc7XG4gICAgICAgIHNldFJlY29ubmVjdGluZyh0cnVlKTtcbiAgICAgICAgb25SZWNvbm5lY3RTdGFydD8uKGV2ZW50LCBlZGdlLCBvcHBvc2l0ZUhhbmRsZS50eXBlKTtcbiAgICAgICAgY29uc3QgX29uUmVjb25uZWN0RW5kID0gKGV2dCwgY29ubmVjdGlvblN0YXRlKSA9PiB7XG4gICAgICAgICAgICBzZXRSZWNvbm5lY3RpbmcoZmFsc2UpO1xuICAgICAgICAgICAgb25SZWNvbm5lY3RFbmQ/LihldnQsIGVkZ2UsIG9wcG9zaXRlSGFuZGxlLnR5cGUsIGNvbm5lY3Rpb25TdGF0ZSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG9uQ29ubmVjdEVkZ2UgPSAoY29ubmVjdGlvbikgPT4gb25SZWNvbm5lY3Q/LihlZGdlLCBjb25uZWN0aW9uKTtcbiAgICAgICAgWFlIYW5kbGUub25Qb2ludGVyRG93bihldmVudC5uYXRpdmVFdmVudCwge1xuICAgICAgICAgICAgYXV0b1Bhbk9uQ29ubmVjdCxcbiAgICAgICAgICAgIGNvbm5lY3Rpb25Nb2RlLFxuICAgICAgICAgICAgY29ubmVjdGlvblJhZGl1cyxcbiAgICAgICAgICAgIGRvbU5vZGUsXG4gICAgICAgICAgICBoYW5kbGVJZDogb3Bwb3NpdGVIYW5kbGUuaWQsXG4gICAgICAgICAgICBub2RlSWQ6IG9wcG9zaXRlSGFuZGxlLm5vZGVJZCxcbiAgICAgICAgICAgIG5vZGVMb29rdXAsXG4gICAgICAgICAgICBpc1RhcmdldCxcbiAgICAgICAgICAgIGVkZ2VVcGRhdGVyVHlwZTogb3Bwb3NpdGVIYW5kbGUudHlwZSxcbiAgICAgICAgICAgIGxpYixcbiAgICAgICAgICAgIGZsb3dJZCxcbiAgICAgICAgICAgIGNhbmNlbENvbm5lY3Rpb24sXG4gICAgICAgICAgICBwYW5CeSxcbiAgICAgICAgICAgIGlzVmFsaWRDb25uZWN0aW9uLFxuICAgICAgICAgICAgb25Db25uZWN0OiBvbkNvbm5lY3RFZGdlLFxuICAgICAgICAgICAgb25Db25uZWN0U3RhcnQsXG4gICAgICAgICAgICBvbkNvbm5lY3RFbmQsXG4gICAgICAgICAgICBvblJlY29ubmVjdEVuZDogX29uUmVjb25uZWN0RW5kLFxuICAgICAgICAgICAgdXBkYXRlQ29ubmVjdGlvbixcbiAgICAgICAgICAgIGdldFRyYW5zZm9ybTogKCkgPT4gc3RvcmUuZ2V0U3RhdGUoKS50cmFuc2Zvcm0sXG4gICAgICAgICAgICBnZXRGcm9tSGFuZGxlOiAoKSA9PiBzdG9yZS5nZXRTdGF0ZSgpLmNvbm5lY3Rpb24uZnJvbUhhbmRsZSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBvblJlY29ubmVjdFNvdXJjZU1vdXNlRG93biA9IChldmVudCkgPT4gaGFuZGxlRWRnZVVwZGF0ZXIoZXZlbnQsIHsgbm9kZUlkOiBlZGdlLnRhcmdldCwgaWQ6IGVkZ2UudGFyZ2V0SGFuZGxlID8/IG51bGwsIHR5cGU6ICd0YXJnZXQnIH0pO1xuICAgIGNvbnN0IG9uUmVjb25uZWN0VGFyZ2V0TW91c2VEb3duID0gKGV2ZW50KSA9PiBoYW5kbGVFZGdlVXBkYXRlcihldmVudCwgeyBub2RlSWQ6IGVkZ2Uuc291cmNlLCBpZDogZWRnZS5zb3VyY2VIYW5kbGUgPz8gbnVsbCwgdHlwZTogJ3NvdXJjZScgfSk7XG4gICAgY29uc3Qgb25SZWNvbm5lY3RNb3VzZUVudGVyID0gKCkgPT4gc2V0VXBkYXRlSG92ZXIodHJ1ZSk7XG4gICAgY29uc3Qgb25SZWNvbm5lY3RNb3VzZU91dCA9ICgpID0+IHNldFVwZGF0ZUhvdmVyKGZhbHNlKTtcbiAgICByZXR1cm4gKGpzeHMoRnJhZ21lbnQsIHsgY2hpbGRyZW46IFsoaXNSZWNvbm5lY3RhYmxlID09PSB0cnVlIHx8IGlzUmVjb25uZWN0YWJsZSA9PT0gJ3NvdXJjZScpICYmIChqc3goRWRnZUFuY2hvciwgeyBwb3NpdGlvbjogc291cmNlUG9zaXRpb24sIGNlbnRlclg6IHNvdXJjZVgsIGNlbnRlclk6IHNvdXJjZVksIHJhZGl1czogcmVjb25uZWN0UmFkaXVzLCBvbk1vdXNlRG93bjogb25SZWNvbm5lY3RTb3VyY2VNb3VzZURvd24sIG9uTW91c2VFbnRlcjogb25SZWNvbm5lY3RNb3VzZUVudGVyLCBvbk1vdXNlT3V0OiBvblJlY29ubmVjdE1vdXNlT3V0LCB0eXBlOiBcInNvdXJjZVwiIH0pKSwgKGlzUmVjb25uZWN0YWJsZSA9PT0gdHJ1ZSB8fCBpc1JlY29ubmVjdGFibGUgPT09ICd0YXJnZXQnKSAmJiAoanN4KEVkZ2VBbmNob3IsIHsgcG9zaXRpb246IHRhcmdldFBvc2l0aW9uLCBjZW50ZXJYOiB0YXJnZXRYLCBjZW50ZXJZOiB0YXJnZXRZLCByYWRpdXM6IHJlY29ubmVjdFJhZGl1cywgb25Nb3VzZURvd246IG9uUmVjb25uZWN0VGFyZ2V0TW91c2VEb3duLCBvbk1vdXNlRW50ZXI6IG9uUmVjb25uZWN0TW91c2VFbnRlciwgb25Nb3VzZU91dDogb25SZWNvbm5lY3RNb3VzZU91dCwgdHlwZTogXCJ0YXJnZXRcIiB9KSldIH0pKTtcbn1cblxuZnVuY3Rpb24gRWRnZVdyYXBwZXIoeyBpZCwgZWRnZXNGb2N1c2FibGUsIGVkZ2VzUmVjb25uZWN0YWJsZSwgZWxlbWVudHNTZWxlY3RhYmxlLCBvbkNsaWNrLCBvbkRvdWJsZUNsaWNrLCBvbkNvbnRleHRNZW51LCBvbk1vdXNlRW50ZXIsIG9uTW91c2VNb3ZlLCBvbk1vdXNlTGVhdmUsIHJlY29ubmVjdFJhZGl1cywgb25SZWNvbm5lY3QsIG9uUmVjb25uZWN0U3RhcnQsIG9uUmVjb25uZWN0RW5kLCByZklkLCBlZGdlVHlwZXMsIG5vUGFuQ2xhc3NOYW1lLCBvbkVycm9yLCBkaXNhYmxlS2V5Ym9hcmRBMTF5LCB9KSB7XG4gICAgbGV0IGVkZ2UgPSB1c2VTdG9yZSgocykgPT4gcy5lZGdlTG9va3VwLmdldChpZCkpO1xuICAgIGNvbnN0IGRlZmF1bHRFZGdlT3B0aW9ucyA9IHVzZVN0b3JlKChzKSA9PiBzLmRlZmF1bHRFZGdlT3B0aW9ucyk7XG4gICAgZWRnZSA9IGRlZmF1bHRFZGdlT3B0aW9ucyA/IHsgLi4uZGVmYXVsdEVkZ2VPcHRpb25zLCAuLi5lZGdlIH0gOiBlZGdlO1xuICAgIGxldCBlZGdlVHlwZSA9IGVkZ2UudHlwZSB8fCAnZGVmYXVsdCc7XG4gICAgbGV0IEVkZ2VDb21wb25lbnQgPSBlZGdlVHlwZXM/LltlZGdlVHlwZV0gfHwgYnVpbHRpbkVkZ2VUeXBlc1tlZGdlVHlwZV07XG4gICAgaWYgKEVkZ2VDb21wb25lbnQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvbkVycm9yPy4oJzAxMScsIGVycm9yTWVzc2FnZXNbJ2Vycm9yMDExJ10oZWRnZVR5cGUpKTtcbiAgICAgICAgZWRnZVR5cGUgPSAnZGVmYXVsdCc7XG4gICAgICAgIEVkZ2VDb21wb25lbnQgPSBidWlsdGluRWRnZVR5cGVzLmRlZmF1bHQ7XG4gICAgfVxuICAgIGNvbnN0IGlzRm9jdXNhYmxlID0gISEoZWRnZS5mb2N1c2FibGUgfHwgKGVkZ2VzRm9jdXNhYmxlICYmIHR5cGVvZiBlZGdlLmZvY3VzYWJsZSA9PT0gJ3VuZGVmaW5lZCcpKTtcbiAgICBjb25zdCBpc1JlY29ubmVjdGFibGUgPSB0eXBlb2Ygb25SZWNvbm5lY3QgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgIChlZGdlLnJlY29ubmVjdGFibGUgfHwgKGVkZ2VzUmVjb25uZWN0YWJsZSAmJiB0eXBlb2YgZWRnZS5yZWNvbm5lY3RhYmxlID09PSAndW5kZWZpbmVkJykpO1xuICAgIGNvbnN0IGlzU2VsZWN0YWJsZSA9ICEhKGVkZ2Uuc2VsZWN0YWJsZSB8fCAoZWxlbWVudHNTZWxlY3RhYmxlICYmIHR5cGVvZiBlZGdlLnNlbGVjdGFibGUgPT09ICd1bmRlZmluZWQnKSk7XG4gICAgY29uc3QgZWRnZVJlZiA9IHVzZVJlZihudWxsKTtcbiAgICBjb25zdCBbdXBkYXRlSG92ZXIsIHNldFVwZGF0ZUhvdmVyXSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCBbcmVjb25uZWN0aW5nLCBzZXRSZWNvbm5lY3RpbmddID0gdXNlU3RhdGUoZmFsc2UpO1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICBjb25zdCB7IHpJbmRleCwgc291cmNlWCwgc291cmNlWSwgdGFyZ2V0WCwgdGFyZ2V0WSwgc291cmNlUG9zaXRpb24sIHRhcmdldFBvc2l0aW9uIH0gPSB1c2VTdG9yZSh1c2VDYWxsYmFjaygoc3RvcmUpID0+IHtcbiAgICAgICAgY29uc3Qgc291cmNlTm9kZSA9IHN0b3JlLm5vZGVMb29rdXAuZ2V0KGVkZ2Uuc291cmNlKTtcbiAgICAgICAgY29uc3QgdGFyZ2V0Tm9kZSA9IHN0b3JlLm5vZGVMb29rdXAuZ2V0KGVkZ2UudGFyZ2V0KTtcbiAgICAgICAgaWYgKCFzb3VyY2VOb2RlIHx8ICF0YXJnZXROb2RlKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHpJbmRleDogZWRnZS56SW5kZXgsXG4gICAgICAgICAgICAgICAgLi4ubnVsbFBvc2l0aW9uLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlZGdlUG9zaXRpb24gPSBnZXRFZGdlUG9zaXRpb24oe1xuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBzb3VyY2VOb2RlLFxuICAgICAgICAgICAgdGFyZ2V0Tm9kZSxcbiAgICAgICAgICAgIHNvdXJjZUhhbmRsZTogZWRnZS5zb3VyY2VIYW5kbGUgfHwgbnVsbCxcbiAgICAgICAgICAgIHRhcmdldEhhbmRsZTogZWRnZS50YXJnZXRIYW5kbGUgfHwgbnVsbCxcbiAgICAgICAgICAgIGNvbm5lY3Rpb25Nb2RlOiBzdG9yZS5jb25uZWN0aW9uTW9kZSxcbiAgICAgICAgICAgIG9uRXJyb3IsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB6SW5kZXggPSBnZXRFbGV2YXRlZEVkZ2VaSW5kZXgoe1xuICAgICAgICAgICAgc2VsZWN0ZWQ6IGVkZ2Uuc2VsZWN0ZWQsXG4gICAgICAgICAgICB6SW5kZXg6IGVkZ2UuekluZGV4LFxuICAgICAgICAgICAgc291cmNlTm9kZSxcbiAgICAgICAgICAgIHRhcmdldE5vZGUsXG4gICAgICAgICAgICBlbGV2YXRlT25TZWxlY3Q6IHN0b3JlLmVsZXZhdGVFZGdlc09uU2VsZWN0LFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHpJbmRleCxcbiAgICAgICAgICAgIC4uLihlZGdlUG9zaXRpb24gfHwgbnVsbFBvc2l0aW9uKSxcbiAgICAgICAgfTtcbiAgICB9LCBbZWRnZS5zb3VyY2UsIGVkZ2UudGFyZ2V0LCBlZGdlLnNvdXJjZUhhbmRsZSwgZWRnZS50YXJnZXRIYW5kbGUsIGVkZ2Uuc2VsZWN0ZWQsIGVkZ2UuekluZGV4XSksIHNoYWxsb3cpO1xuICAgIGNvbnN0IG1hcmtlclN0YXJ0VXJsID0gdXNlTWVtbygoKSA9PiAoZWRnZS5tYXJrZXJTdGFydCA/IGB1cmwoJyMke2dldE1hcmtlcklkKGVkZ2UubWFya2VyU3RhcnQsIHJmSWQpfScpYCA6IHVuZGVmaW5lZCksIFtlZGdlLm1hcmtlclN0YXJ0LCByZklkXSk7XG4gICAgY29uc3QgbWFya2VyRW5kVXJsID0gdXNlTWVtbygoKSA9PiAoZWRnZS5tYXJrZXJFbmQgPyBgdXJsKCcjJHtnZXRNYXJrZXJJZChlZGdlLm1hcmtlckVuZCwgcmZJZCl9JylgIDogdW5kZWZpbmVkKSwgW2VkZ2UubWFya2VyRW5kLCByZklkXSk7XG4gICAgaWYgKGVkZ2UuaGlkZGVuIHx8IHNvdXJjZVggPT09IG51bGwgfHwgc291cmNlWSA9PT0gbnVsbCB8fCB0YXJnZXRYID09PSBudWxsIHx8IHRhcmdldFkgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IG9uRWRnZUNsaWNrID0gKGV2ZW50KSA9PiB7XG4gICAgICAgIGNvbnN0IHsgYWRkU2VsZWN0ZWRFZGdlcywgdW5zZWxlY3ROb2Rlc0FuZEVkZ2VzLCBtdWx0aVNlbGVjdGlvbkFjdGl2ZSB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgaWYgKGlzU2VsZWN0YWJsZSkge1xuICAgICAgICAgICAgc3RvcmUuc2V0U3RhdGUoeyBub2Rlc1NlbGVjdGlvbkFjdGl2ZTogZmFsc2UgfSk7XG4gICAgICAgICAgICBpZiAoZWRnZS5zZWxlY3RlZCAmJiBtdWx0aVNlbGVjdGlvbkFjdGl2ZSkge1xuICAgICAgICAgICAgICAgIHVuc2VsZWN0Tm9kZXNBbmRFZGdlcyh7IG5vZGVzOiBbXSwgZWRnZXM6IFtlZGdlXSB9KTtcbiAgICAgICAgICAgICAgICBlZGdlUmVmLmN1cnJlbnQ/LmJsdXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGFkZFNlbGVjdGVkRWRnZXMoW2lkXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uQ2xpY2spIHtcbiAgICAgICAgICAgIG9uQ2xpY2soZXZlbnQsIGVkZ2UpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBvbkVkZ2VEb3VibGVDbGljayA9IG9uRG91YmxlQ2xpY2tcbiAgICAgICAgPyAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIG9uRG91YmxlQ2xpY2soZXZlbnQsIHsgLi4uZWRnZSB9KTtcbiAgICAgICAgfVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBvbkVkZ2VDb250ZXh0TWVudSA9IG9uQ29udGV4dE1lbnVcbiAgICAgICAgPyAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIG9uQ29udGV4dE1lbnUoZXZlbnQsIHsgLi4uZWRnZSB9KTtcbiAgICAgICAgfVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBvbkVkZ2VNb3VzZUVudGVyID0gb25Nb3VzZUVudGVyXG4gICAgICAgID8gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBvbk1vdXNlRW50ZXIoZXZlbnQsIHsgLi4uZWRnZSB9KTtcbiAgICAgICAgfVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBvbkVkZ2VNb3VzZU1vdmUgPSBvbk1vdXNlTW92ZVxuICAgICAgICA/IChldmVudCkgPT4ge1xuICAgICAgICAgICAgb25Nb3VzZU1vdmUoZXZlbnQsIHsgLi4uZWRnZSB9KTtcbiAgICAgICAgfVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBvbkVkZ2VNb3VzZUxlYXZlID0gb25Nb3VzZUxlYXZlXG4gICAgICAgID8gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBvbk1vdXNlTGVhdmUoZXZlbnQsIHsgLi4uZWRnZSB9KTtcbiAgICAgICAgfVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCBvbktleURvd24gPSAoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKCFkaXNhYmxlS2V5Ym9hcmRBMTF5ICYmIGVsZW1lbnRTZWxlY3Rpb25LZXlzLmluY2x1ZGVzKGV2ZW50LmtleSkgJiYgaXNTZWxlY3RhYmxlKSB7XG4gICAgICAgICAgICBjb25zdCB7IHVuc2VsZWN0Tm9kZXNBbmRFZGdlcywgYWRkU2VsZWN0ZWRFZGdlcyB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgIGNvbnN0IHVuc2VsZWN0ID0gZXZlbnQua2V5ID09PSAnRXNjYXBlJztcbiAgICAgICAgICAgIGlmICh1bnNlbGVjdCkge1xuICAgICAgICAgICAgICAgIGVkZ2VSZWYuY3VycmVudD8uYmx1cigpO1xuICAgICAgICAgICAgICAgIHVuc2VsZWN0Tm9kZXNBbmRFZGdlcyh7IGVkZ2VzOiBbZWRnZV0gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhZGRTZWxlY3RlZEVkZ2VzKFtpZF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gKGpzeChcInN2Z1wiLCB7IHN0eWxlOiB7IHpJbmRleCB9LCBjaGlsZHJlbjoganN4cyhcImdcIiwgeyBjbGFzc05hbWU6IGNjKFtcbiAgICAgICAgICAgICAgICAncmVhY3QtZmxvd19fZWRnZScsXG4gICAgICAgICAgICAgICAgYHJlYWN0LWZsb3dfX2VkZ2UtJHtlZGdlVHlwZX1gLFxuICAgICAgICAgICAgICAgIGVkZ2UuY2xhc3NOYW1lLFxuICAgICAgICAgICAgICAgIG5vUGFuQ2xhc3NOYW1lLFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0ZWQ6IGVkZ2Uuc2VsZWN0ZWQsXG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGVkOiBlZGdlLmFuaW1hdGVkLFxuICAgICAgICAgICAgICAgICAgICBpbmFjdGl2ZTogIWlzU2VsZWN0YWJsZSAmJiAhb25DbGljayxcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRpbmc6IHVwZGF0ZUhvdmVyLFxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RhYmxlOiBpc1NlbGVjdGFibGUsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF0pLCBvbkNsaWNrOiBvbkVkZ2VDbGljaywgb25Eb3VibGVDbGljazogb25FZGdlRG91YmxlQ2xpY2ssIG9uQ29udGV4dE1lbnU6IG9uRWRnZUNvbnRleHRNZW51LCBvbk1vdXNlRW50ZXI6IG9uRWRnZU1vdXNlRW50ZXIsIG9uTW91c2VNb3ZlOiBvbkVkZ2VNb3VzZU1vdmUsIG9uTW91c2VMZWF2ZTogb25FZGdlTW91c2VMZWF2ZSwgb25LZXlEb3duOiBpc0ZvY3VzYWJsZSA/IG9uS2V5RG93biA6IHVuZGVmaW5lZCwgdGFiSW5kZXg6IGlzRm9jdXNhYmxlID8gMCA6IHVuZGVmaW5lZCwgcm9sZTogaXNGb2N1c2FibGUgPyAnYnV0dG9uJyA6ICdpbWcnLCBcImRhdGEtaWRcIjogaWQsIFwiZGF0YS10ZXN0aWRcIjogYHJmX19lZGdlLSR7aWR9YCwgXCJhcmlhLWxhYmVsXCI6IGVkZ2UuYXJpYUxhYmVsID09PSBudWxsID8gdW5kZWZpbmVkIDogZWRnZS5hcmlhTGFiZWwgfHwgYEVkZ2UgZnJvbSAke2VkZ2Uuc291cmNlfSB0byAke2VkZ2UudGFyZ2V0fWAsIFwiYXJpYS1kZXNjcmliZWRieVwiOiBpc0ZvY3VzYWJsZSA/IGAke0FSSUFfRURHRV9ERVNDX0tFWX0tJHtyZklkfWAgOiB1bmRlZmluZWQsIHJlZjogZWRnZVJlZiwgY2hpbGRyZW46IFshcmVjb25uZWN0aW5nICYmIChqc3goRWRnZUNvbXBvbmVudCwgeyBpZDogaWQsIHNvdXJjZTogZWRnZS5zb3VyY2UsIHRhcmdldDogZWRnZS50YXJnZXQsIHR5cGU6IGVkZ2UudHlwZSwgc2VsZWN0ZWQ6IGVkZ2Uuc2VsZWN0ZWQsIGFuaW1hdGVkOiBlZGdlLmFuaW1hdGVkLCBzZWxlY3RhYmxlOiBpc1NlbGVjdGFibGUsIGRlbGV0YWJsZTogZWRnZS5kZWxldGFibGUgPz8gdHJ1ZSwgbGFiZWw6IGVkZ2UubGFiZWwsIGxhYmVsU3R5bGU6IGVkZ2UubGFiZWxTdHlsZSwgbGFiZWxTaG93Qmc6IGVkZ2UubGFiZWxTaG93QmcsIGxhYmVsQmdTdHlsZTogZWRnZS5sYWJlbEJnU3R5bGUsIGxhYmVsQmdQYWRkaW5nOiBlZGdlLmxhYmVsQmdQYWRkaW5nLCBsYWJlbEJnQm9yZGVyUmFkaXVzOiBlZGdlLmxhYmVsQmdCb3JkZXJSYWRpdXMsIHNvdXJjZVg6IHNvdXJjZVgsIHNvdXJjZVk6IHNvdXJjZVksIHRhcmdldFg6IHRhcmdldFgsIHRhcmdldFk6IHRhcmdldFksIHNvdXJjZVBvc2l0aW9uOiBzb3VyY2VQb3NpdGlvbiwgdGFyZ2V0UG9zaXRpb246IHRhcmdldFBvc2l0aW9uLCBkYXRhOiBlZGdlLmRhdGEsIHN0eWxlOiBlZGdlLnN0eWxlLCBzb3VyY2VIYW5kbGVJZDogZWRnZS5zb3VyY2VIYW5kbGUsIHRhcmdldEhhbmRsZUlkOiBlZGdlLnRhcmdldEhhbmRsZSwgbWFya2VyU3RhcnQ6IG1hcmtlclN0YXJ0VXJsLCBtYXJrZXJFbmQ6IG1hcmtlckVuZFVybCwgcGF0aE9wdGlvbnM6ICdwYXRoT3B0aW9ucycgaW4gZWRnZSA/IGVkZ2UucGF0aE9wdGlvbnMgOiB1bmRlZmluZWQsIGludGVyYWN0aW9uV2lkdGg6IGVkZ2UuaW50ZXJhY3Rpb25XaWR0aCB9KSksIGlzUmVjb25uZWN0YWJsZSAmJiAoanN4KEVkZ2VVcGRhdGVBbmNob3JzLCB7IGVkZ2U6IGVkZ2UsIGlzUmVjb25uZWN0YWJsZTogaXNSZWNvbm5lY3RhYmxlLCByZWNvbm5lY3RSYWRpdXM6IHJlY29ubmVjdFJhZGl1cywgb25SZWNvbm5lY3Q6IG9uUmVjb25uZWN0LCBvblJlY29ubmVjdFN0YXJ0OiBvblJlY29ubmVjdFN0YXJ0LCBvblJlY29ubmVjdEVuZDogb25SZWNvbm5lY3RFbmQsIHNvdXJjZVg6IHNvdXJjZVgsIHNvdXJjZVk6IHNvdXJjZVksIHRhcmdldFg6IHRhcmdldFgsIHRhcmdldFk6IHRhcmdldFksIHNvdXJjZVBvc2l0aW9uOiBzb3VyY2VQb3NpdGlvbiwgdGFyZ2V0UG9zaXRpb246IHRhcmdldFBvc2l0aW9uLCBzZXRVcGRhdGVIb3Zlcjogc2V0VXBkYXRlSG92ZXIsIHNldFJlY29ubmVjdGluZzogc2V0UmVjb25uZWN0aW5nIH0pKV0gfSkgfSkpO1xufVxuXG5jb25zdCBzZWxlY3RvciRhID0gKHMpID0+ICh7XG4gICAgZWRnZXNGb2N1c2FibGU6IHMuZWRnZXNGb2N1c2FibGUsXG4gICAgZWRnZXNSZWNvbm5lY3RhYmxlOiBzLmVkZ2VzUmVjb25uZWN0YWJsZSxcbiAgICBlbGVtZW50c1NlbGVjdGFibGU6IHMuZWxlbWVudHNTZWxlY3RhYmxlLFxuICAgIGNvbm5lY3Rpb25Nb2RlOiBzLmNvbm5lY3Rpb25Nb2RlLFxuICAgIG9uRXJyb3I6IHMub25FcnJvcixcbn0pO1xuZnVuY3Rpb24gRWRnZVJlbmRlcmVyQ29tcG9uZW50KHsgZGVmYXVsdE1hcmtlckNvbG9yLCBvbmx5UmVuZGVyVmlzaWJsZUVsZW1lbnRzLCByZklkLCBlZGdlVHlwZXMsIG5vUGFuQ2xhc3NOYW1lLCBvblJlY29ubmVjdCwgb25FZGdlQ29udGV4dE1lbnUsIG9uRWRnZU1vdXNlRW50ZXIsIG9uRWRnZU1vdXNlTW92ZSwgb25FZGdlTW91c2VMZWF2ZSwgb25FZGdlQ2xpY2ssIHJlY29ubmVjdFJhZGl1cywgb25FZGdlRG91YmxlQ2xpY2ssIG9uUmVjb25uZWN0U3RhcnQsIG9uUmVjb25uZWN0RW5kLCBkaXNhYmxlS2V5Ym9hcmRBMTF5LCB9KSB7XG4gICAgY29uc3QgeyBlZGdlc0ZvY3VzYWJsZSwgZWRnZXNSZWNvbm5lY3RhYmxlLCBlbGVtZW50c1NlbGVjdGFibGUsIG9uRXJyb3IgfSA9IHVzZVN0b3JlKHNlbGVjdG9yJGEsIHNoYWxsb3cpO1xuICAgIGNvbnN0IGVkZ2VJZHMgPSB1c2VWaXNpYmxlRWRnZUlkcyhvbmx5UmVuZGVyVmlzaWJsZUVsZW1lbnRzKTtcbiAgICByZXR1cm4gKGpzeHMoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fZWRnZXNcIiwgY2hpbGRyZW46IFtqc3goTWFya2VyRGVmaW5pdGlvbnMkMSwgeyBkZWZhdWx0Q29sb3I6IGRlZmF1bHRNYXJrZXJDb2xvciwgcmZJZDogcmZJZCB9KSwgZWRnZUlkcy5tYXAoKGlkKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChqc3goRWRnZVdyYXBwZXIsIHsgaWQ6IGlkLCBlZGdlc0ZvY3VzYWJsZTogZWRnZXNGb2N1c2FibGUsIGVkZ2VzUmVjb25uZWN0YWJsZTogZWRnZXNSZWNvbm5lY3RhYmxlLCBlbGVtZW50c1NlbGVjdGFibGU6IGVsZW1lbnRzU2VsZWN0YWJsZSwgbm9QYW5DbGFzc05hbWU6IG5vUGFuQ2xhc3NOYW1lLCBvblJlY29ubmVjdDogb25SZWNvbm5lY3QsIG9uQ29udGV4dE1lbnU6IG9uRWRnZUNvbnRleHRNZW51LCBvbk1vdXNlRW50ZXI6IG9uRWRnZU1vdXNlRW50ZXIsIG9uTW91c2VNb3ZlOiBvbkVkZ2VNb3VzZU1vdmUsIG9uTW91c2VMZWF2ZTogb25FZGdlTW91c2VMZWF2ZSwgb25DbGljazogb25FZGdlQ2xpY2ssIHJlY29ubmVjdFJhZGl1czogcmVjb25uZWN0UmFkaXVzLCBvbkRvdWJsZUNsaWNrOiBvbkVkZ2VEb3VibGVDbGljaywgb25SZWNvbm5lY3RTdGFydDogb25SZWNvbm5lY3RTdGFydCwgb25SZWNvbm5lY3RFbmQ6IG9uUmVjb25uZWN0RW5kLCByZklkOiByZklkLCBvbkVycm9yOiBvbkVycm9yLCBlZGdlVHlwZXM6IGVkZ2VUeXBlcywgZGlzYWJsZUtleWJvYXJkQTExeTogZGlzYWJsZUtleWJvYXJkQTExeSB9LCBpZCkpO1xuICAgICAgICAgICAgfSldIH0pKTtcbn1cbkVkZ2VSZW5kZXJlckNvbXBvbmVudC5kaXNwbGF5TmFtZSA9ICdFZGdlUmVuZGVyZXInO1xuY29uc3QgRWRnZVJlbmRlcmVyID0gbWVtbyhFZGdlUmVuZGVyZXJDb21wb25lbnQpO1xuXG5jb25zdCBzZWxlY3RvciQ5ID0gKHMpID0+IGB0cmFuc2xhdGUoJHtzLnRyYW5zZm9ybVswXX1weCwke3MudHJhbnNmb3JtWzFdfXB4KSBzY2FsZSgke3MudHJhbnNmb3JtWzJdfSlgO1xuZnVuY3Rpb24gVmlld3BvcnQoeyBjaGlsZHJlbiB9KSB7XG4gICAgY29uc3QgdHJhbnNmb3JtID0gdXNlU3RvcmUoc2VsZWN0b3IkOSk7XG4gICAgcmV0dXJuIChqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fdmlld3BvcnQgeHlmbG93X192aWV3cG9ydCByZWFjdC1mbG93X19jb250YWluZXJcIiwgc3R5bGU6IHsgdHJhbnNmb3JtIH0sIGNoaWxkcmVuOiBjaGlsZHJlbiB9KSk7XG59XG5cbi8qKlxuICogSG9vayBmb3IgY2FsbGluZyBvbkluaXQgaGFuZGxlci5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gdXNlT25Jbml0SGFuZGxlcihvbkluaXQpIHtcbiAgICBjb25zdCByZkluc3RhbmNlID0gdXNlUmVhY3RGbG93KCk7XG4gICAgY29uc3QgaXNJbml0aWFsaXplZCA9IHVzZVJlZihmYWxzZSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFpc0luaXRpYWxpemVkLmN1cnJlbnQgJiYgcmZJbnN0YW5jZS52aWV3cG9ydEluaXRpYWxpemVkICYmIG9uSW5pdCkge1xuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiBvbkluaXQocmZJbnN0YW5jZSksIDEpO1xuICAgICAgICAgICAgaXNJbml0aWFsaXplZC5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0sIFtvbkluaXQsIHJmSW5zdGFuY2Uudmlld3BvcnRJbml0aWFsaXplZF0pO1xufVxuXG5jb25zdCBzZWxlY3RvciQ4ID0gKHN0YXRlKSA9PiBzdGF0ZS5wYW5ab29tPy5zeW5jVmlld3BvcnQ7XG4vKipcbiAqIEhvb2sgZm9yIHN5bmNpbmcgdGhlIHZpZXdwb3J0IHdpdGggdGhlIHBhbnpvb20gaW5zdGFuY2UuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0gdmlld3BvcnRcbiAqL1xuZnVuY3Rpb24gdXNlVmlld3BvcnRTeW5jKHZpZXdwb3J0KSB7XG4gICAgY29uc3Qgc3luY1ZpZXdwb3J0ID0gdXNlU3RvcmUoc2VsZWN0b3IkOCk7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICh2aWV3cG9ydCkge1xuICAgICAgICAgICAgc3luY1ZpZXdwb3J0Py4odmlld3BvcnQpO1xuICAgICAgICAgICAgc3RvcmUuc2V0U3RhdGUoeyB0cmFuc2Zvcm06IFt2aWV3cG9ydC54LCB2aWV3cG9ydC55LCB2aWV3cG9ydC56b29tXSB9KTtcbiAgICAgICAgfVxuICAgIH0sIFt2aWV3cG9ydCwgc3luY1ZpZXdwb3J0XSk7XG4gICAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHN0b3JlU2VsZWN0b3IkMShzKSB7XG4gICAgcmV0dXJuIHMuY29ubmVjdGlvbi5pblByb2dyZXNzXG4gICAgICAgID8geyAuLi5zLmNvbm5lY3Rpb24sIHRvOiBwb2ludFRvUmVuZGVyZXJQb2ludChzLmNvbm5lY3Rpb24udG8sIHMudHJhbnNmb3JtKSB9XG4gICAgICAgIDogeyAuLi5zLmNvbm5lY3Rpb24gfTtcbn1cbmZ1bmN0aW9uIGdldFNlbGVjdG9yKGNvbm5lY3Rpb25TZWxlY3Rvcikge1xuICAgIGlmIChjb25uZWN0aW9uU2VsZWN0b3IpIHtcbiAgICAgICAgY29uc3QgY29tYmluZWRTZWxlY3RvciA9IChzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb25uZWN0aW9uID0gc3RvcmVTZWxlY3RvciQxKHMpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb25TZWxlY3Rvcihjb25uZWN0aW9uKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGNvbWJpbmVkU2VsZWN0b3I7XG4gICAgfVxuICAgIHJldHVybiBzdG9yZVNlbGVjdG9yJDE7XG59XG4vKipcbiAqIFRoZSBgdXNlQ29ubmVjdGlvbmAgaG9vayByZXR1cm5zIHRoZSBjdXJyZW50IGNvbm5lY3Rpb24gd2hlbiB0aGVyZSBpcyBhbiBhY3RpdmVcbiAqIGNvbm5lY3Rpb24gaW50ZXJhY3Rpb24uIElmIG5vIGNvbm5lY3Rpb24gaW50ZXJhY3Rpb24gaXMgYWN0aXZlLCBpdCByZXR1cm5zIG51bGxcbiAqIGZvciBldmVyeSBwcm9wZXJ0eS4gQSB0eXBpY2FsIHVzZSBjYXNlIGZvciB0aGlzIGhvb2sgaXMgdG8gY29sb3JpemUgaGFuZGxlc1xuICogYmFzZWQgb24gYSBjZXJ0YWluIGNvbmRpdGlvbiAoZS5nLiBpZiB0aGUgY29ubmVjdGlvbiBpcyB2YWxpZCBvciBub3QpLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgdHN4XG4gKmltcG9ydCB7IHVzZUNvbm5lY3Rpb24gfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKmZ1bmN0aW9uIEFwcCgpIHtcbiAqICBjb25zdCBjb25uZWN0aW9uID0gdXNlQ29ubmVjdGlvbigpO1xuICpcbiAqICByZXR1cm4gKFxuICogICAgPGRpdj4ge2Nvbm5lY3Rpb24gPyBgU29tZW9uZSBpcyB0cnlpbmcgdG8gbWFrZSBhIGNvbm5lY3Rpb24gZnJvbSAke2Nvbm5lY3Rpb24uZnJvbU5vZGV9IHRvIHRoaXMgb25lLmAgOiAnVGhlcmUgYXJlIGN1cnJlbnRseSBubyBpbmNvbWluZyBjb25uZWN0aW9ucyEnfVxuICpcbiAqICAgPC9kaXY+XG4gKiAgICk7XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBAcmV0dXJucyBDb25uZWN0aW9uU3RhdGVcbiAqL1xuZnVuY3Rpb24gdXNlQ29ubmVjdGlvbihjb25uZWN0aW9uU2VsZWN0b3IpIHtcbiAgICBjb25zdCBjb21iaW5lZFNlbGVjdG9yID0gZ2V0U2VsZWN0b3IoY29ubmVjdGlvblNlbGVjdG9yKTtcbiAgICByZXR1cm4gdXNlU3RvcmUoY29tYmluZWRTZWxlY3Rvciwgc2hhbGxvdyk7XG59XG5cbmNvbnN0IHNlbGVjdG9yJDcgPSAocykgPT4gKHtcbiAgICBub2Rlc0Nvbm5lY3RhYmxlOiBzLm5vZGVzQ29ubmVjdGFibGUsXG4gICAgaXNWYWxpZDogcy5jb25uZWN0aW9uLmlzVmFsaWQsXG4gICAgaW5Qcm9ncmVzczogcy5jb25uZWN0aW9uLmluUHJvZ3Jlc3MsXG4gICAgd2lkdGg6IHMud2lkdGgsXG4gICAgaGVpZ2h0OiBzLmhlaWdodCxcbn0pO1xuZnVuY3Rpb24gQ29ubmVjdGlvbkxpbmVXcmFwcGVyKHsgY29udGFpbmVyU3R5bGUsIHN0eWxlLCB0eXBlLCBjb21wb25lbnQsIH0pIHtcbiAgICBjb25zdCB7IG5vZGVzQ29ubmVjdGFibGUsIHdpZHRoLCBoZWlnaHQsIGlzVmFsaWQsIGluUHJvZ3Jlc3MgfSA9IHVzZVN0b3JlKHNlbGVjdG9yJDcsIHNoYWxsb3cpO1xuICAgIGNvbnN0IHJlbmRlckNvbm5lY3Rpb24gPSAhISh3aWR0aCAmJiBub2Rlc0Nvbm5lY3RhYmxlICYmIGluUHJvZ3Jlc3MpO1xuICAgIGlmICghcmVuZGVyQ29ubmVjdGlvbikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIChqc3goXCJzdmdcIiwgeyBzdHlsZTogY29udGFpbmVyU3R5bGUsIHdpZHRoOiB3aWR0aCwgaGVpZ2h0OiBoZWlnaHQsIGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19jb25uZWN0aW9ubGluZSByZWFjdC1mbG93X19jb250YWluZXJcIiwgY2hpbGRyZW46IGpzeChcImdcIiwgeyBjbGFzc05hbWU6IGNjKFsncmVhY3QtZmxvd19fY29ubmVjdGlvbicsIGdldENvbm5lY3Rpb25TdGF0dXMoaXNWYWxpZCldKSwgY2hpbGRyZW46IGpzeChDb25uZWN0aW9uTGluZSwgeyBzdHlsZTogc3R5bGUsIHR5cGU6IHR5cGUsIEN1c3RvbUNvbXBvbmVudDogY29tcG9uZW50LCBpc1ZhbGlkOiBpc1ZhbGlkIH0pIH0pIH0pKTtcbn1cbmNvbnN0IENvbm5lY3Rpb25MaW5lID0gKHsgc3R5bGUsIHR5cGUgPSBDb25uZWN0aW9uTGluZVR5cGUuQmV6aWVyLCBDdXN0b21Db21wb25lbnQsIGlzVmFsaWQsIH0pID0+IHtcbiAgICBjb25zdCB7IGluUHJvZ3Jlc3MsIGZyb20sIGZyb21Ob2RlLCBmcm9tSGFuZGxlLCBmcm9tUG9zaXRpb24sIHRvLCB0b05vZGUsIHRvSGFuZGxlLCB0b1Bvc2l0aW9uIH0gPSB1c2VDb25uZWN0aW9uKCk7XG4gICAgaWYgKCFpblByb2dyZXNzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKEN1c3RvbUNvbXBvbmVudCkge1xuICAgICAgICByZXR1cm4gKGpzeChDdXN0b21Db21wb25lbnQsIHsgY29ubmVjdGlvbkxpbmVUeXBlOiB0eXBlLCBjb25uZWN0aW9uTGluZVN0eWxlOiBzdHlsZSwgZnJvbU5vZGU6IGZyb21Ob2RlLCBmcm9tSGFuZGxlOiBmcm9tSGFuZGxlLCBmcm9tWDogZnJvbS54LCBmcm9tWTogZnJvbS55LCB0b1g6IHRvLngsIHRvWTogdG8ueSwgZnJvbVBvc2l0aW9uOiBmcm9tUG9zaXRpb24sIHRvUG9zaXRpb246IHRvUG9zaXRpb24sIGNvbm5lY3Rpb25TdGF0dXM6IGdldENvbm5lY3Rpb25TdGF0dXMoaXNWYWxpZCksIHRvTm9kZTogdG9Ob2RlLCB0b0hhbmRsZTogdG9IYW5kbGUgfSkpO1xuICAgIH1cbiAgICBsZXQgcGF0aCA9ICcnO1xuICAgIGNvbnN0IHBhdGhQYXJhbXMgPSB7XG4gICAgICAgIHNvdXJjZVg6IGZyb20ueCxcbiAgICAgICAgc291cmNlWTogZnJvbS55LFxuICAgICAgICBzb3VyY2VQb3NpdGlvbjogZnJvbVBvc2l0aW9uLFxuICAgICAgICB0YXJnZXRYOiB0by54LFxuICAgICAgICB0YXJnZXRZOiB0by55LFxuICAgICAgICB0YXJnZXRQb3NpdGlvbjogdG9Qb3NpdGlvbixcbiAgICB9O1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIENvbm5lY3Rpb25MaW5lVHlwZS5CZXppZXI6XG4gICAgICAgICAgICBbcGF0aF0gPSBnZXRCZXppZXJQYXRoKHBhdGhQYXJhbXMpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQ29ubmVjdGlvbkxpbmVUeXBlLlNpbXBsZUJlemllcjpcbiAgICAgICAgICAgIFtwYXRoXSA9IGdldFNpbXBsZUJlemllclBhdGgocGF0aFBhcmFtcyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBDb25uZWN0aW9uTGluZVR5cGUuU3RlcDpcbiAgICAgICAgICAgIFtwYXRoXSA9IGdldFNtb290aFN0ZXBQYXRoKHtcbiAgICAgICAgICAgICAgICAuLi5wYXRoUGFyYW1zLFxuICAgICAgICAgICAgICAgIGJvcmRlclJhZGl1czogMCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQ29ubmVjdGlvbkxpbmVUeXBlLlNtb290aFN0ZXA6XG4gICAgICAgICAgICBbcGF0aF0gPSBnZXRTbW9vdGhTdGVwUGF0aChwYXRoUGFyYW1zKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgW3BhdGhdID0gZ2V0U3RyYWlnaHRQYXRoKHBhdGhQYXJhbXMpO1xuICAgIH1cbiAgICByZXR1cm4ganN4KFwicGF0aFwiLCB7IGQ6IHBhdGgsIGZpbGw6IFwibm9uZVwiLCBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fY29ubmVjdGlvbi1wYXRoXCIsIHN0eWxlOiBzdHlsZSB9KTtcbn07XG5Db25uZWN0aW9uTGluZS5kaXNwbGF5TmFtZSA9ICdDb25uZWN0aW9uTGluZSc7XG5cbmNvbnN0IGVtcHR5VHlwZXMgPSB7fTtcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG5mdW5jdGlvbiB1c2VOb2RlT3JFZGdlVHlwZXNXYXJuaW5nKG5vZGVPckVkZ2VUeXBlcyA9IGVtcHR5VHlwZXMpIHtcbiAgICBjb25zdCB0eXBlc1JlZiA9IHVzZVJlZihub2RlT3JFZGdlVHlwZXMpO1xuICAgIGNvbnN0IHN0b3JlID0gdXNlU3RvcmVBcGkoKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgICAgIGNvbnN0IHVzZWRLZXlzID0gbmV3IFNldChbLi4uT2JqZWN0LmtleXModHlwZXNSZWYuY3VycmVudCksIC4uLk9iamVjdC5rZXlzKG5vZGVPckVkZ2VUeXBlcyldKTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHVzZWRLZXlzKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVzUmVmLmN1cnJlbnRba2V5XSAhPT0gbm9kZU9yRWRnZVR5cGVzW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcmUuZ2V0U3RhdGUoKS5vbkVycm9yPy4oJzAwMicsIGVycm9yTWVzc2FnZXNbJ2Vycm9yMDAyJ10oKSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHR5cGVzUmVmLmN1cnJlbnQgPSBub2RlT3JFZGdlVHlwZXM7XG4gICAgICAgIH1cbiAgICB9LCBbbm9kZU9yRWRnZVR5cGVzXSk7XG59XG5cbmZ1bmN0aW9uIHVzZVN0eWxlc0xvYWRlZFdhcm5pbmcoKSB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIGNvbnN0IGNoZWNrZWQgPSB1c2VSZWYoZmFsc2UpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAgICAgaWYgKCFjaGVja2VkLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYW5lID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnJlYWN0LWZsb3dfX3BhbmUnKTtcbiAgICAgICAgICAgICAgICBpZiAocGFuZSAmJiAhKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHBhbmUpLnpJbmRleCA9PT0gJzEnKSkge1xuICAgICAgICAgICAgICAgICAgICBzdG9yZS5nZXRTdGF0ZSgpLm9uRXJyb3I/LignMDEzJywgZXJyb3JNZXNzYWdlc1snZXJyb3IwMTMnXSgncmVhY3QnKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNoZWNrZWQuY3VycmVudCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbXSk7XG59XG5cbmZ1bmN0aW9uIEdyYXBoVmlld0NvbXBvbmVudCh7IG5vZGVUeXBlcywgZWRnZVR5cGVzLCBvbkluaXQsIG9uTm9kZUNsaWNrLCBvbkVkZ2VDbGljaywgb25Ob2RlRG91YmxlQ2xpY2ssIG9uRWRnZURvdWJsZUNsaWNrLCBvbk5vZGVNb3VzZUVudGVyLCBvbk5vZGVNb3VzZU1vdmUsIG9uTm9kZU1vdXNlTGVhdmUsIG9uTm9kZUNvbnRleHRNZW51LCBvblNlbGVjdGlvbkNvbnRleHRNZW51LCBvblNlbGVjdGlvblN0YXJ0LCBvblNlbGVjdGlvbkVuZCwgY29ubmVjdGlvbkxpbmVUeXBlLCBjb25uZWN0aW9uTGluZVN0eWxlLCBjb25uZWN0aW9uTGluZUNvbXBvbmVudCwgY29ubmVjdGlvbkxpbmVDb250YWluZXJTdHlsZSwgc2VsZWN0aW9uS2V5Q29kZSwgc2VsZWN0aW9uT25EcmFnLCBzZWxlY3Rpb25Nb2RlLCBtdWx0aVNlbGVjdGlvbktleUNvZGUsIHBhbkFjdGl2YXRpb25LZXlDb2RlLCB6b29tQWN0aXZhdGlvbktleUNvZGUsIGRlbGV0ZUtleUNvZGUsIG9ubHlSZW5kZXJWaXNpYmxlRWxlbWVudHMsIGVsZW1lbnRzU2VsZWN0YWJsZSwgZGVmYXVsdFZpZXdwb3J0LCB0cmFuc2xhdGVFeHRlbnQsIG1pblpvb20sIG1heFpvb20sIHByZXZlbnRTY3JvbGxpbmcsIGRlZmF1bHRNYXJrZXJDb2xvciwgem9vbU9uU2Nyb2xsLCB6b29tT25QaW5jaCwgcGFuT25TY3JvbGwsIHBhbk9uU2Nyb2xsU3BlZWQsIHBhbk9uU2Nyb2xsTW9kZSwgem9vbU9uRG91YmxlQ2xpY2ssIHBhbk9uRHJhZywgb25QYW5lQ2xpY2ssIG9uUGFuZU1vdXNlRW50ZXIsIG9uUGFuZU1vdXNlTW92ZSwgb25QYW5lTW91c2VMZWF2ZSwgb25QYW5lU2Nyb2xsLCBvblBhbmVDb250ZXh0TWVudSwgcGFuZUNsaWNrRGlzdGFuY2UsIG5vZGVDbGlja0Rpc3RhbmNlLCBvbkVkZ2VDb250ZXh0TWVudSwgb25FZGdlTW91c2VFbnRlciwgb25FZGdlTW91c2VNb3ZlLCBvbkVkZ2VNb3VzZUxlYXZlLCByZWNvbm5lY3RSYWRpdXMsIG9uUmVjb25uZWN0LCBvblJlY29ubmVjdFN0YXJ0LCBvblJlY29ubmVjdEVuZCwgbm9EcmFnQ2xhc3NOYW1lLCBub1doZWVsQ2xhc3NOYW1lLCBub1BhbkNsYXNzTmFtZSwgZGlzYWJsZUtleWJvYXJkQTExeSwgbm9kZUV4dGVudCwgcmZJZCwgdmlld3BvcnQsIG9uVmlld3BvcnRDaGFuZ2UsIH0pIHtcbiAgICB1c2VOb2RlT3JFZGdlVHlwZXNXYXJuaW5nKG5vZGVUeXBlcyk7XG4gICAgdXNlTm9kZU9yRWRnZVR5cGVzV2FybmluZyhlZGdlVHlwZXMpO1xuICAgIHVzZVN0eWxlc0xvYWRlZFdhcm5pbmcoKTtcbiAgICB1c2VPbkluaXRIYW5kbGVyKG9uSW5pdCk7XG4gICAgdXNlVmlld3BvcnRTeW5jKHZpZXdwb3J0KTtcbiAgICByZXR1cm4gKGpzeChGbG93UmVuZGVyZXIsIHsgb25QYW5lQ2xpY2s6IG9uUGFuZUNsaWNrLCBvblBhbmVNb3VzZUVudGVyOiBvblBhbmVNb3VzZUVudGVyLCBvblBhbmVNb3VzZU1vdmU6IG9uUGFuZU1vdXNlTW92ZSwgb25QYW5lTW91c2VMZWF2ZTogb25QYW5lTW91c2VMZWF2ZSwgb25QYW5lQ29udGV4dE1lbnU6IG9uUGFuZUNvbnRleHRNZW51LCBvblBhbmVTY3JvbGw6IG9uUGFuZVNjcm9sbCwgcGFuZUNsaWNrRGlzdGFuY2U6IHBhbmVDbGlja0Rpc3RhbmNlLCBkZWxldGVLZXlDb2RlOiBkZWxldGVLZXlDb2RlLCBzZWxlY3Rpb25LZXlDb2RlOiBzZWxlY3Rpb25LZXlDb2RlLCBzZWxlY3Rpb25PbkRyYWc6IHNlbGVjdGlvbk9uRHJhZywgc2VsZWN0aW9uTW9kZTogc2VsZWN0aW9uTW9kZSwgb25TZWxlY3Rpb25TdGFydDogb25TZWxlY3Rpb25TdGFydCwgb25TZWxlY3Rpb25FbmQ6IG9uU2VsZWN0aW9uRW5kLCBtdWx0aVNlbGVjdGlvbktleUNvZGU6IG11bHRpU2VsZWN0aW9uS2V5Q29kZSwgcGFuQWN0aXZhdGlvbktleUNvZGU6IHBhbkFjdGl2YXRpb25LZXlDb2RlLCB6b29tQWN0aXZhdGlvbktleUNvZGU6IHpvb21BY3RpdmF0aW9uS2V5Q29kZSwgZWxlbWVudHNTZWxlY3RhYmxlOiBlbGVtZW50c1NlbGVjdGFibGUsIHpvb21PblNjcm9sbDogem9vbU9uU2Nyb2xsLCB6b29tT25QaW5jaDogem9vbU9uUGluY2gsIHpvb21PbkRvdWJsZUNsaWNrOiB6b29tT25Eb3VibGVDbGljaywgcGFuT25TY3JvbGw6IHBhbk9uU2Nyb2xsLCBwYW5PblNjcm9sbFNwZWVkOiBwYW5PblNjcm9sbFNwZWVkLCBwYW5PblNjcm9sbE1vZGU6IHBhbk9uU2Nyb2xsTW9kZSwgcGFuT25EcmFnOiBwYW5PbkRyYWcsIGRlZmF1bHRWaWV3cG9ydDogZGVmYXVsdFZpZXdwb3J0LCB0cmFuc2xhdGVFeHRlbnQ6IHRyYW5zbGF0ZUV4dGVudCwgbWluWm9vbTogbWluWm9vbSwgbWF4Wm9vbTogbWF4Wm9vbSwgb25TZWxlY3Rpb25Db250ZXh0TWVudTogb25TZWxlY3Rpb25Db250ZXh0TWVudSwgcHJldmVudFNjcm9sbGluZzogcHJldmVudFNjcm9sbGluZywgbm9EcmFnQ2xhc3NOYW1lOiBub0RyYWdDbGFzc05hbWUsIG5vV2hlZWxDbGFzc05hbWU6IG5vV2hlZWxDbGFzc05hbWUsIG5vUGFuQ2xhc3NOYW1lOiBub1BhbkNsYXNzTmFtZSwgZGlzYWJsZUtleWJvYXJkQTExeTogZGlzYWJsZUtleWJvYXJkQTExeSwgb25WaWV3cG9ydENoYW5nZTogb25WaWV3cG9ydENoYW5nZSwgaXNDb250cm9sbGVkVmlld3BvcnQ6ICEhdmlld3BvcnQsIGNoaWxkcmVuOiBqc3hzKFZpZXdwb3J0LCB7IGNoaWxkcmVuOiBbanN4KEVkZ2VSZW5kZXJlciwgeyBlZGdlVHlwZXM6IGVkZ2VUeXBlcywgb25FZGdlQ2xpY2s6IG9uRWRnZUNsaWNrLCBvbkVkZ2VEb3VibGVDbGljazogb25FZGdlRG91YmxlQ2xpY2ssIG9uUmVjb25uZWN0OiBvblJlY29ubmVjdCwgb25SZWNvbm5lY3RTdGFydDogb25SZWNvbm5lY3RTdGFydCwgb25SZWNvbm5lY3RFbmQ6IG9uUmVjb25uZWN0RW5kLCBvbmx5UmVuZGVyVmlzaWJsZUVsZW1lbnRzOiBvbmx5UmVuZGVyVmlzaWJsZUVsZW1lbnRzLCBvbkVkZ2VDb250ZXh0TWVudTogb25FZGdlQ29udGV4dE1lbnUsIG9uRWRnZU1vdXNlRW50ZXI6IG9uRWRnZU1vdXNlRW50ZXIsIG9uRWRnZU1vdXNlTW92ZTogb25FZGdlTW91c2VNb3ZlLCBvbkVkZ2VNb3VzZUxlYXZlOiBvbkVkZ2VNb3VzZUxlYXZlLCByZWNvbm5lY3RSYWRpdXM6IHJlY29ubmVjdFJhZGl1cywgZGVmYXVsdE1hcmtlckNvbG9yOiBkZWZhdWx0TWFya2VyQ29sb3IsIG5vUGFuQ2xhc3NOYW1lOiBub1BhbkNsYXNzTmFtZSwgZGlzYWJsZUtleWJvYXJkQTExeTogZGlzYWJsZUtleWJvYXJkQTExeSwgcmZJZDogcmZJZCB9KSwganN4KENvbm5lY3Rpb25MaW5lV3JhcHBlciwgeyBzdHlsZTogY29ubmVjdGlvbkxpbmVTdHlsZSwgdHlwZTogY29ubmVjdGlvbkxpbmVUeXBlLCBjb21wb25lbnQ6IGNvbm5lY3Rpb25MaW5lQ29tcG9uZW50LCBjb250YWluZXJTdHlsZTogY29ubmVjdGlvbkxpbmVDb250YWluZXJTdHlsZSB9KSwganN4KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX2VkZ2VsYWJlbC1yZW5kZXJlclwiIH0pLCBqc3goTm9kZVJlbmRlcmVyLCB7IG5vZGVUeXBlczogbm9kZVR5cGVzLCBvbk5vZGVDbGljazogb25Ob2RlQ2xpY2ssIG9uTm9kZURvdWJsZUNsaWNrOiBvbk5vZGVEb3VibGVDbGljaywgb25Ob2RlTW91c2VFbnRlcjogb25Ob2RlTW91c2VFbnRlciwgb25Ob2RlTW91c2VNb3ZlOiBvbk5vZGVNb3VzZU1vdmUsIG9uTm9kZU1vdXNlTGVhdmU6IG9uTm9kZU1vdXNlTGVhdmUsIG9uTm9kZUNvbnRleHRNZW51OiBvbk5vZGVDb250ZXh0TWVudSwgbm9kZUNsaWNrRGlzdGFuY2U6IG5vZGVDbGlja0Rpc3RhbmNlLCBvbmx5UmVuZGVyVmlzaWJsZUVsZW1lbnRzOiBvbmx5UmVuZGVyVmlzaWJsZUVsZW1lbnRzLCBub1BhbkNsYXNzTmFtZTogbm9QYW5DbGFzc05hbWUsIG5vRHJhZ0NsYXNzTmFtZTogbm9EcmFnQ2xhc3NOYW1lLCBkaXNhYmxlS2V5Ym9hcmRBMTF5OiBkaXNhYmxlS2V5Ym9hcmRBMTF5LCBub2RlRXh0ZW50OiBub2RlRXh0ZW50LCByZklkOiByZklkIH0pLCBqc3goXCJkaXZcIiwgeyBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fdmlld3BvcnQtcG9ydGFsXCIgfSldIH0pIH0pKTtcbn1cbkdyYXBoVmlld0NvbXBvbmVudC5kaXNwbGF5TmFtZSA9ICdHcmFwaFZpZXcnO1xuY29uc3QgR3JhcGhWaWV3ID0gbWVtbyhHcmFwaFZpZXdDb21wb25lbnQpO1xuXG5jb25zdCBnZXRJbml0aWFsU3RhdGUgPSAoeyBub2RlcywgZWRnZXMsIGRlZmF1bHROb2RlcywgZGVmYXVsdEVkZ2VzLCB3aWR0aCwgaGVpZ2h0LCBmaXRWaWV3LCBub2RlT3JpZ2luLCBub2RlRXh0ZW50LCB9ID0ge30pID0+IHtcbiAgICBjb25zdCBub2RlTG9va3VwID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IHBhcmVudExvb2t1cCA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBjb25uZWN0aW9uTG9va3VwID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGVkZ2VMb29rdXAgPSBuZXcgTWFwKCk7XG4gICAgY29uc3Qgc3RvcmVFZGdlcyA9IGRlZmF1bHRFZGdlcyA/PyBlZGdlcyA/PyBbXTtcbiAgICBjb25zdCBzdG9yZU5vZGVzID0gZGVmYXVsdE5vZGVzID8/IG5vZGVzID8/IFtdO1xuICAgIGNvbnN0IHN0b3JlTm9kZU9yaWdpbiA9IG5vZGVPcmlnaW4gPz8gWzAsIDBdO1xuICAgIGNvbnN0IHN0b3JlTm9kZUV4dGVudCA9IG5vZGVFeHRlbnQgPz8gaW5maW5pdGVFeHRlbnQ7XG4gICAgdXBkYXRlQ29ubmVjdGlvbkxvb2t1cChjb25uZWN0aW9uTG9va3VwLCBlZGdlTG9va3VwLCBzdG9yZUVkZ2VzKTtcbiAgICBhZG9wdFVzZXJOb2RlcyhzdG9yZU5vZGVzLCBub2RlTG9va3VwLCBwYXJlbnRMb29rdXAsIHtcbiAgICAgICAgbm9kZU9yaWdpbjogc3RvcmVOb2RlT3JpZ2luLFxuICAgICAgICBub2RlRXh0ZW50OiBzdG9yZU5vZGVFeHRlbnQsXG4gICAgICAgIGVsZXZhdGVOb2Rlc09uU2VsZWN0OiBmYWxzZSxcbiAgICB9KTtcbiAgICBsZXQgdHJhbnNmb3JtID0gWzAsIDAsIDFdO1xuICAgIGlmIChmaXRWaWV3ICYmIHdpZHRoICYmIGhlaWdodCkge1xuICAgICAgICBjb25zdCBib3VuZHMgPSBnZXRJbnRlcm5hbE5vZGVzQm91bmRzKG5vZGVMb29rdXAsIHtcbiAgICAgICAgICAgIGZpbHRlcjogKG5vZGUpID0+ICEhKChub2RlLndpZHRoIHx8IG5vZGUuaW5pdGlhbFdpZHRoKSAmJiAobm9kZS5oZWlnaHQgfHwgbm9kZS5pbml0aWFsSGVpZ2h0KSksXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB7IHgsIHksIHpvb20gfSA9IGdldFZpZXdwb3J0Rm9yQm91bmRzKGJvdW5kcywgd2lkdGgsIGhlaWdodCwgMC41LCAyLCAwLjEpO1xuICAgICAgICB0cmFuc2Zvcm0gPSBbeCwgeSwgem9vbV07XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHJmSWQ6ICcxJyxcbiAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgdHJhbnNmb3JtLFxuICAgICAgICBub2Rlczogc3RvcmVOb2RlcyxcbiAgICAgICAgbm9kZUxvb2t1cCxcbiAgICAgICAgcGFyZW50TG9va3VwLFxuICAgICAgICBlZGdlczogc3RvcmVFZGdlcyxcbiAgICAgICAgZWRnZUxvb2t1cCxcbiAgICAgICAgY29ubmVjdGlvbkxvb2t1cCxcbiAgICAgICAgb25Ob2Rlc0NoYW5nZTogbnVsbCxcbiAgICAgICAgb25FZGdlc0NoYW5nZTogbnVsbCxcbiAgICAgICAgaGFzRGVmYXVsdE5vZGVzOiBkZWZhdWx0Tm9kZXMgIT09IHVuZGVmaW5lZCxcbiAgICAgICAgaGFzRGVmYXVsdEVkZ2VzOiBkZWZhdWx0RWRnZXMgIT09IHVuZGVmaW5lZCxcbiAgICAgICAgcGFuWm9vbTogbnVsbCxcbiAgICAgICAgbWluWm9vbTogMC41LFxuICAgICAgICBtYXhab29tOiAyLFxuICAgICAgICB0cmFuc2xhdGVFeHRlbnQ6IGluZmluaXRlRXh0ZW50LFxuICAgICAgICBub2RlRXh0ZW50OiBzdG9yZU5vZGVFeHRlbnQsXG4gICAgICAgIG5vZGVzU2VsZWN0aW9uQWN0aXZlOiBmYWxzZSxcbiAgICAgICAgdXNlclNlbGVjdGlvbkFjdGl2ZTogZmFsc2UsXG4gICAgICAgIHVzZXJTZWxlY3Rpb25SZWN0OiBudWxsLFxuICAgICAgICBjb25uZWN0aW9uTW9kZTogQ29ubmVjdGlvbk1vZGUuU3RyaWN0LFxuICAgICAgICBkb21Ob2RlOiBudWxsLFxuICAgICAgICBwYW5lRHJhZ2dpbmc6IGZhbHNlLFxuICAgICAgICBub1BhbkNsYXNzTmFtZTogJ25vcGFuJyxcbiAgICAgICAgbm9kZU9yaWdpbjogc3RvcmVOb2RlT3JpZ2luLFxuICAgICAgICBub2RlRHJhZ1RocmVzaG9sZDogMSxcbiAgICAgICAgc25hcEdyaWQ6IFsxNSwgMTVdLFxuICAgICAgICBzbmFwVG9HcmlkOiBmYWxzZSxcbiAgICAgICAgbm9kZXNEcmFnZ2FibGU6IHRydWUsXG4gICAgICAgIG5vZGVzQ29ubmVjdGFibGU6IHRydWUsXG4gICAgICAgIG5vZGVzRm9jdXNhYmxlOiB0cnVlLFxuICAgICAgICBlZGdlc0ZvY3VzYWJsZTogdHJ1ZSxcbiAgICAgICAgZWRnZXNSZWNvbm5lY3RhYmxlOiB0cnVlLFxuICAgICAgICBlbGVtZW50c1NlbGVjdGFibGU6IHRydWUsXG4gICAgICAgIGVsZXZhdGVOb2Rlc09uU2VsZWN0OiB0cnVlLFxuICAgICAgICBlbGV2YXRlRWRnZXNPblNlbGVjdDogZmFsc2UsXG4gICAgICAgIGZpdFZpZXdPbkluaXQ6IGZhbHNlLFxuICAgICAgICBmaXRWaWV3RG9uZTogZmFsc2UsXG4gICAgICAgIGZpdFZpZXdPbkluaXRPcHRpb25zOiB1bmRlZmluZWQsXG4gICAgICAgIHNlbGVjdE5vZGVzT25EcmFnOiB0cnVlLFxuICAgICAgICBtdWx0aVNlbGVjdGlvbkFjdGl2ZTogZmFsc2UsXG4gICAgICAgIGNvbm5lY3Rpb246IHsgLi4uaW5pdGlhbENvbm5lY3Rpb24gfSxcbiAgICAgICAgY29ubmVjdGlvbkNsaWNrU3RhcnRIYW5kbGU6IG51bGwsXG4gICAgICAgIGNvbm5lY3RPbkNsaWNrOiB0cnVlLFxuICAgICAgICBhcmlhTGl2ZU1lc3NhZ2U6ICcnLFxuICAgICAgICBhdXRvUGFuT25Db25uZWN0OiB0cnVlLFxuICAgICAgICBhdXRvUGFuT25Ob2RlRHJhZzogdHJ1ZSxcbiAgICAgICAgYXV0b1BhblNwZWVkOiAxNSxcbiAgICAgICAgY29ubmVjdGlvblJhZGl1czogMjAsXG4gICAgICAgIG9uRXJyb3I6IGRldldhcm4sXG4gICAgICAgIGlzVmFsaWRDb25uZWN0aW9uOiB1bmRlZmluZWQsXG4gICAgICAgIG9uU2VsZWN0aW9uQ2hhbmdlSGFuZGxlcnM6IFtdLFxuICAgICAgICBsaWI6ICdyZWFjdCcsXG4gICAgICAgIGRlYnVnOiBmYWxzZSxcbiAgICB9O1xufTtcblxuY29uc3QgY3JlYXRlU3RvcmUgPSAoeyBub2RlcywgZWRnZXMsIGRlZmF1bHROb2RlcywgZGVmYXVsdEVkZ2VzLCB3aWR0aCwgaGVpZ2h0LCBmaXRWaWV3OiBmaXRWaWV3JDEsIG5vZGVPcmlnaW4sIG5vZGVFeHRlbnQsIH0pID0+IGNyZWF0ZVdpdGhFcXVhbGl0eUZuKChzZXQsIGdldCkgPT4gKHtcbiAgICAuLi5nZXRJbml0aWFsU3RhdGUoeyBub2RlcywgZWRnZXMsIHdpZHRoLCBoZWlnaHQsIGZpdFZpZXc6IGZpdFZpZXckMSwgbm9kZU9yaWdpbiwgbm9kZUV4dGVudCwgZGVmYXVsdE5vZGVzLCBkZWZhdWx0RWRnZXMgfSksXG4gICAgc2V0Tm9kZXM6IChub2RlcykgPT4ge1xuICAgICAgICBjb25zdCB7IG5vZGVMb29rdXAsIHBhcmVudExvb2t1cCwgbm9kZU9yaWdpbiwgZWxldmF0ZU5vZGVzT25TZWxlY3QgfSA9IGdldCgpO1xuICAgICAgICAvKlxuICAgICAgICAgKiBzZXROb2RlcygpIGlzIGNhbGxlZCBleGNsdXNpdmVseSBpbiByZXNwb25zZSB0byB1c2VyIGFjdGlvbnM6XG4gICAgICAgICAqIC0gZWl0aGVyIHdoZW4gdGhlIGA8UmVhY3RGbG93IG5vZGVzPmAgcHJvcCBpcyB1cGRhdGVkIGluIHRoZSBjb250cm9sbGVkIFJlYWN0RmxvdyBzZXR1cCxcbiAgICAgICAgICogLSBvciB3aGVuIHRoZSB1c2VyIGNhbGxzIHNvbWV0aGluZyBsaWtlIGByZWFjdEZsb3dJbnN0YW5jZS5zZXROb2RlcygpYCBpbiBhbiB1bmNvbnRyb2xsZWQgUmVhY3RGbG93IHNldHVwLlxuICAgICAgICAgKlxuICAgICAgICAgKiBXaGVuIHRoaXMgaGFwcGVucywgd2UgdGFrZSB0aGUgbm90ZSBvYmplY3RzIHBhc3NlZCBieSB0aGUgdXNlciBhbmQgZXh0ZW5kIHRoZW0gd2l0aCBmaWVsZHNcbiAgICAgICAgICogcmVsZXZhbnQgZm9yIGludGVybmFsIFJlYWN0IEZsb3cgb3BlcmF0aW9ucy5cbiAgICAgICAgICovXG4gICAgICAgIGFkb3B0VXNlck5vZGVzKG5vZGVzLCBub2RlTG9va3VwLCBwYXJlbnRMb29rdXAsIHtcbiAgICAgICAgICAgIG5vZGVPcmlnaW4sXG4gICAgICAgICAgICBub2RlRXh0ZW50LFxuICAgICAgICAgICAgZWxldmF0ZU5vZGVzT25TZWxlY3QsXG4gICAgICAgICAgICBjaGVja0VxdWFsaXR5OiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgICAgc2V0KHsgbm9kZXMgfSk7XG4gICAgfSxcbiAgICBzZXRFZGdlczogKGVkZ2VzKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgY29ubmVjdGlvbkxvb2t1cCwgZWRnZUxvb2t1cCB9ID0gZ2V0KCk7XG4gICAgICAgIHVwZGF0ZUNvbm5lY3Rpb25Mb29rdXAoY29ubmVjdGlvbkxvb2t1cCwgZWRnZUxvb2t1cCwgZWRnZXMpO1xuICAgICAgICBzZXQoeyBlZGdlcyB9KTtcbiAgICB9LFxuICAgIHNldERlZmF1bHROb2Rlc0FuZEVkZ2VzOiAobm9kZXMsIGVkZ2VzKSA9PiB7XG4gICAgICAgIGlmIChub2Rlcykge1xuICAgICAgICAgICAgY29uc3QgeyBzZXROb2RlcyB9ID0gZ2V0KCk7XG4gICAgICAgICAgICBzZXROb2Rlcyhub2Rlcyk7XG4gICAgICAgICAgICBzZXQoeyBoYXNEZWZhdWx0Tm9kZXM6IHRydWUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVkZ2VzKSB7XG4gICAgICAgICAgICBjb25zdCB7IHNldEVkZ2VzIH0gPSBnZXQoKTtcbiAgICAgICAgICAgIHNldEVkZ2VzKGVkZ2VzKTtcbiAgICAgICAgICAgIHNldCh7IGhhc0RlZmF1bHRFZGdlczogdHJ1ZSB9KTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLypcbiAgICAgKiBFdmVyeSBub2RlIGdldHMgcmVnaXN0ZXJkIGF0IGEgUmVzaXplT2JzZXJ2ZXIuIFdoZW5ldmVyIGEgbm9kZVxuICAgICAqIGNoYW5nZXMgaXRzIGRpbWVuc2lvbnMsIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHRvIG1lYXN1cmUgdGhlXG4gICAgICogbmV3IGRpbWVuc2lvbnMgYW5kIHVwZGF0ZSB0aGUgbm9kZXMuXG4gICAgICovXG4gICAgdXBkYXRlTm9kZUludGVybmFsczogKHVwZGF0ZXMsIHBhcmFtcyA9IHsgdHJpZ2dlckZpdFZpZXc6IHRydWUgfSkgPT4ge1xuICAgICAgICBjb25zdCB7IHRyaWdnZXJOb2RlQ2hhbmdlcywgbm9kZUxvb2t1cCwgcGFyZW50TG9va3VwLCBmaXRWaWV3T25Jbml0LCBmaXRWaWV3RG9uZSwgZml0Vmlld09uSW5pdE9wdGlvbnMsIGRvbU5vZGUsIG5vZGVPcmlnaW4sIG5vZGVFeHRlbnQsIGRlYnVnLCBmaXRWaWV3U3luYywgfSA9IGdldCgpO1xuICAgICAgICBjb25zdCB7IGNoYW5nZXMsIHVwZGF0ZWRJbnRlcm5hbHMgfSA9IHVwZGF0ZU5vZGVJbnRlcm5hbHModXBkYXRlcywgbm9kZUxvb2t1cCwgcGFyZW50TG9va3VwLCBkb21Ob2RlLCBub2RlT3JpZ2luLCBub2RlRXh0ZW50KTtcbiAgICAgICAgaWYgKCF1cGRhdGVkSW50ZXJuYWxzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlQWJzb2x1dGVQb3NpdGlvbnMobm9kZUxvb2t1cCwgcGFyZW50TG9va3VwLCB7IG5vZGVPcmlnaW4sIG5vZGVFeHRlbnQgfSk7XG4gICAgICAgIGlmIChwYXJhbXMudHJpZ2dlckZpdFZpZXcpIHtcbiAgICAgICAgICAgIC8vIHdlIGNhbGwgZml0VmlldyBvbmNlIGluaXRpYWxseSBhZnRlciBhbGwgZGltZW5zaW9ucyBhcmUgc2V0XG4gICAgICAgICAgICBsZXQgbmV4dEZpdFZpZXdEb25lID0gZml0Vmlld0RvbmU7XG4gICAgICAgICAgICBpZiAoIWZpdFZpZXdEb25lICYmIGZpdFZpZXdPbkluaXQpIHtcbiAgICAgICAgICAgICAgICBuZXh0Rml0Vmlld0RvbmUgPSBmaXRWaWV3U3luYyh7XG4gICAgICAgICAgICAgICAgICAgIC4uLmZpdFZpZXdPbkluaXRPcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICBub2RlczogZml0Vmlld09uSW5pdE9wdGlvbnM/Lm5vZGVzLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAqIGhlcmUgd2UgYXJlIGNpcm11bXZlbnRpbmcgdGhlIG9uTm9kZXNDaGFuZ2UgaGFuZGxlclxuICAgICAgICAgICAgICogaW4gb3JkZXIgdG8gYmUgYWJsZSB0byBkaXNwbGF5IG5vZGVzIGV2ZW4gaWYgdGhlIHVzZXJcbiAgICAgICAgICAgICAqIGhhcyBub3QgcHJvdmlkZWQgYW4gb25Ob2Rlc0NoYW5nZSBoYW5kbGVyLlxuICAgICAgICAgICAgICogTm9kZXMgYXJlIG9ubHkgcmVuZGVyZWQgaWYgdGhleSBoYXZlIGEgd2lkdGggYW5kIGhlaWdodFxuICAgICAgICAgICAgICogYXR0cmlidXRlIHdoaWNoIHRoZXkgZ2V0IGZyb20gdGhpcyBoYW5kbGVyLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBzZXQoeyBmaXRWaWV3RG9uZTogbmV4dEZpdFZpZXdEb25lIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gd2UgYWx3YXlzIHdhbnQgdG8gdHJpZ2dlciB1c2VTdG9yZSBjYWxscyB3aGVuZXZlciB1cGRhdGVOb2RlSW50ZXJuYWxzIGlzIGNhbGxlZFxuICAgICAgICAgICAgc2V0KHt9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhbmdlcz8ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaWYgKGRlYnVnKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1JlYWN0IEZsb3c6IHRyaWdnZXIgbm9kZSBjaGFuZ2VzJywgY2hhbmdlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmlnZ2VyTm9kZUNoYW5nZXM/LihjaGFuZ2VzKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgdXBkYXRlTm9kZVBvc2l0aW9uczogKG5vZGVEcmFnSXRlbXMsIGRyYWdnaW5nID0gZmFsc2UpID0+IHtcbiAgICAgICAgY29uc3QgcGFyZW50RXhwYW5kQ2hpbGRyZW4gPSBbXTtcbiAgICAgICAgY29uc3QgY2hhbmdlcyA9IFtdO1xuICAgICAgICBjb25zdCB7IG5vZGVMb29rdXAsIHRyaWdnZXJOb2RlQ2hhbmdlcyB9ID0gZ2V0KCk7XG4gICAgICAgIGZvciAoY29uc3QgW2lkLCBkcmFnSXRlbV0gb2Ygbm9kZURyYWdJdGVtcykge1xuICAgICAgICAgICAgLy8gd2UgYXJlIHVzaW5nIHRoZSBub2RlbG9va3VwIHRvIGJlIHN1cmUgdG8gdXNlIHRoZSBjdXJyZW50IGV4cGFuZFBhcmVudCBhbmQgcGFyZW50SWQgdmFsdWVcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBub2RlTG9va3VwLmdldChpZCk7XG4gICAgICAgICAgICBjb25zdCBleHBhbmRQYXJlbnQgPSAhIShub2RlPy5leHBhbmRQYXJlbnQgJiYgbm9kZT8ucGFyZW50SWQgJiYgZHJhZ0l0ZW0/LnBvc2l0aW9uKTtcbiAgICAgICAgICAgIGNvbnN0IGNoYW5nZSA9IHtcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICB0eXBlOiAncG9zaXRpb24nLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBleHBhbmRQYXJlbnRcbiAgICAgICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBNYXRoLm1heCgwLCBkcmFnSXRlbS5wb3NpdGlvbi54KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHk6IE1hdGgubWF4KDAsIGRyYWdJdGVtLnBvc2l0aW9uLnkpLFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIDogZHJhZ0l0ZW0ucG9zaXRpb24sXG4gICAgICAgICAgICAgICAgZHJhZ2dpbmcsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGV4cGFuZFBhcmVudCAmJiBub2RlLnBhcmVudElkKSB7XG4gICAgICAgICAgICAgICAgcGFyZW50RXhwYW5kQ2hpbGRyZW4ucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgICBwYXJlbnRJZDogbm9kZS5wYXJlbnRJZCxcbiAgICAgICAgICAgICAgICAgICAgcmVjdDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgLi4uZHJhZ0l0ZW0uaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogZHJhZ0l0ZW0ubWVhc3VyZWQud2lkdGggPz8gMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogZHJhZ0l0ZW0ubWVhc3VyZWQuaGVpZ2h0ID8/IDAsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjaGFuZ2VzLnB1c2goY2hhbmdlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyZW50RXhwYW5kQ2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY29uc3QgeyBwYXJlbnRMb29rdXAsIG5vZGVPcmlnaW4gfSA9IGdldCgpO1xuICAgICAgICAgICAgY29uc3QgcGFyZW50RXhwYW5kQ2hhbmdlcyA9IGhhbmRsZUV4cGFuZFBhcmVudChwYXJlbnRFeHBhbmRDaGlsZHJlbiwgbm9kZUxvb2t1cCwgcGFyZW50TG9va3VwLCBub2RlT3JpZ2luKTtcbiAgICAgICAgICAgIGNoYW5nZXMucHVzaCguLi5wYXJlbnRFeHBhbmRDaGFuZ2VzKTtcbiAgICAgICAgfVxuICAgICAgICB0cmlnZ2VyTm9kZUNoYW5nZXMoY2hhbmdlcyk7XG4gICAgfSxcbiAgICB0cmlnZ2VyTm9kZUNoYW5nZXM6IChjaGFuZ2VzKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgb25Ob2Rlc0NoYW5nZSwgc2V0Tm9kZXMsIG5vZGVzLCBoYXNEZWZhdWx0Tm9kZXMsIGRlYnVnIH0gPSBnZXQoKTtcbiAgICAgICAgaWYgKGNoYW5nZXM/Lmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKGhhc0RlZmF1bHROb2Rlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWROb2RlcyA9IGFwcGx5Tm9kZUNoYW5nZXMoY2hhbmdlcywgbm9kZXMpO1xuICAgICAgICAgICAgICAgIHNldE5vZGVzKHVwZGF0ZWROb2Rlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGVidWcpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnUmVhY3QgRmxvdzogdHJpZ2dlciBub2RlIGNoYW5nZXMnLCBjaGFuZ2VzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9uTm9kZXNDaGFuZ2U/LihjaGFuZ2VzKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgdHJpZ2dlckVkZ2VDaGFuZ2VzOiAoY2hhbmdlcykgPT4ge1xuICAgICAgICBjb25zdCB7IG9uRWRnZXNDaGFuZ2UsIHNldEVkZ2VzLCBlZGdlcywgaGFzRGVmYXVsdEVkZ2VzLCBkZWJ1ZyB9ID0gZ2V0KCk7XG4gICAgICAgIGlmIChjaGFuZ2VzPy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChoYXNEZWZhdWx0RWRnZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB1cGRhdGVkRWRnZXMgPSBhcHBseUVkZ2VDaGFuZ2VzKGNoYW5nZXMsIGVkZ2VzKTtcbiAgICAgICAgICAgICAgICBzZXRFZGdlcyh1cGRhdGVkRWRnZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRlYnVnKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ1JlYWN0IEZsb3c6IHRyaWdnZXIgZWRnZSBjaGFuZ2VzJywgY2hhbmdlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvbkVkZ2VzQ2hhbmdlPy4oY2hhbmdlcyk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGFkZFNlbGVjdGVkTm9kZXM6IChzZWxlY3RlZE5vZGVJZHMpID0+IHtcbiAgICAgICAgY29uc3QgeyBtdWx0aVNlbGVjdGlvbkFjdGl2ZSwgZWRnZUxvb2t1cCwgbm9kZUxvb2t1cCwgdHJpZ2dlck5vZGVDaGFuZ2VzLCB0cmlnZ2VyRWRnZUNoYW5nZXMgfSA9IGdldCgpO1xuICAgICAgICBpZiAobXVsdGlTZWxlY3Rpb25BY3RpdmUpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGVDaGFuZ2VzID0gc2VsZWN0ZWROb2RlSWRzLm1hcCgobm9kZUlkKSA9PiBjcmVhdGVTZWxlY3Rpb25DaGFuZ2Uobm9kZUlkLCB0cnVlKSk7XG4gICAgICAgICAgICB0cmlnZ2VyTm9kZUNoYW5nZXMobm9kZUNoYW5nZXMpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRyaWdnZXJOb2RlQ2hhbmdlcyhnZXRTZWxlY3Rpb25DaGFuZ2VzKG5vZGVMb29rdXAsIG5ldyBTZXQoWy4uLnNlbGVjdGVkTm9kZUlkc10pLCB0cnVlKSk7XG4gICAgICAgIHRyaWdnZXJFZGdlQ2hhbmdlcyhnZXRTZWxlY3Rpb25DaGFuZ2VzKGVkZ2VMb29rdXApKTtcbiAgICB9LFxuICAgIGFkZFNlbGVjdGVkRWRnZXM6IChzZWxlY3RlZEVkZ2VJZHMpID0+IHtcbiAgICAgICAgY29uc3QgeyBtdWx0aVNlbGVjdGlvbkFjdGl2ZSwgZWRnZUxvb2t1cCwgbm9kZUxvb2t1cCwgdHJpZ2dlck5vZGVDaGFuZ2VzLCB0cmlnZ2VyRWRnZUNoYW5nZXMgfSA9IGdldCgpO1xuICAgICAgICBpZiAobXVsdGlTZWxlY3Rpb25BY3RpdmUpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoYW5nZWRFZGdlcyA9IHNlbGVjdGVkRWRnZUlkcy5tYXAoKGVkZ2VJZCkgPT4gY3JlYXRlU2VsZWN0aW9uQ2hhbmdlKGVkZ2VJZCwgdHJ1ZSkpO1xuICAgICAgICAgICAgdHJpZ2dlckVkZ2VDaGFuZ2VzKGNoYW5nZWRFZGdlcyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdHJpZ2dlckVkZ2VDaGFuZ2VzKGdldFNlbGVjdGlvbkNoYW5nZXMoZWRnZUxvb2t1cCwgbmV3IFNldChbLi4uc2VsZWN0ZWRFZGdlSWRzXSkpKTtcbiAgICAgICAgdHJpZ2dlck5vZGVDaGFuZ2VzKGdldFNlbGVjdGlvbkNoYW5nZXMobm9kZUxvb2t1cCwgbmV3IFNldCgpLCB0cnVlKSk7XG4gICAgfSxcbiAgICB1bnNlbGVjdE5vZGVzQW5kRWRnZXM6ICh7IG5vZGVzLCBlZGdlcyB9ID0ge30pID0+IHtcbiAgICAgICAgY29uc3QgeyBlZGdlczogc3RvcmVFZGdlcywgbm9kZXM6IHN0b3JlTm9kZXMsIG5vZGVMb29rdXAsIHRyaWdnZXJOb2RlQ2hhbmdlcywgdHJpZ2dlckVkZ2VDaGFuZ2VzIH0gPSBnZXQoKTtcbiAgICAgICAgY29uc3Qgbm9kZXNUb1Vuc2VsZWN0ID0gbm9kZXMgPyBub2RlcyA6IHN0b3JlTm9kZXM7XG4gICAgICAgIGNvbnN0IGVkZ2VzVG9VbnNlbGVjdCA9IGVkZ2VzID8gZWRnZXMgOiBzdG9yZUVkZ2VzO1xuICAgICAgICBjb25zdCBub2RlQ2hhbmdlcyA9IG5vZGVzVG9VbnNlbGVjdC5tYXAoKG4pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGludGVybmFsTm9kZSA9IG5vZGVMb29rdXAuZ2V0KG4uaWQpO1xuICAgICAgICAgICAgaWYgKGludGVybmFsTm9kZSkge1xuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogd2UgbmVlZCB0byB1bnNlbGVjdCB0aGUgaW50ZXJuYWwgbm9kZSB0aGF0IHdhcyBzZWxlY3RlZCBwcmV2aW91c2x5IGJlZm9yZSB3ZVxuICAgICAgICAgICAgICAgICAqIHNlbmQgdGhlIGNoYW5nZSB0byB0aGUgdXNlciB0byBwcmV2ZW50IGl0IHRvIGJlIHNlbGVjdGVkIHdoaWxlIGRyYWdnaW5nIHRoZSBuZXcgbm9kZVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGludGVybmFsTm9kZS5zZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVNlbGVjdGlvbkNoYW5nZShuLmlkLCBmYWxzZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBlZGdlQ2hhbmdlcyA9IGVkZ2VzVG9VbnNlbGVjdC5tYXAoKGVkZ2UpID0+IGNyZWF0ZVNlbGVjdGlvbkNoYW5nZShlZGdlLmlkLCBmYWxzZSkpO1xuICAgICAgICB0cmlnZ2VyTm9kZUNoYW5nZXMobm9kZUNoYW5nZXMpO1xuICAgICAgICB0cmlnZ2VyRWRnZUNoYW5nZXMoZWRnZUNoYW5nZXMpO1xuICAgIH0sXG4gICAgc2V0TWluWm9vbTogKG1pblpvb20pID0+IHtcbiAgICAgICAgY29uc3QgeyBwYW5ab29tLCBtYXhab29tIH0gPSBnZXQoKTtcbiAgICAgICAgcGFuWm9vbT8uc2V0U2NhbGVFeHRlbnQoW21pblpvb20sIG1heFpvb21dKTtcbiAgICAgICAgc2V0KHsgbWluWm9vbSB9KTtcbiAgICB9LFxuICAgIHNldE1heFpvb206IChtYXhab29tKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgcGFuWm9vbSwgbWluWm9vbSB9ID0gZ2V0KCk7XG4gICAgICAgIHBhblpvb20/LnNldFNjYWxlRXh0ZW50KFttaW5ab29tLCBtYXhab29tXSk7XG4gICAgICAgIHNldCh7IG1heFpvb20gfSk7XG4gICAgfSxcbiAgICBzZXRUcmFuc2xhdGVFeHRlbnQ6ICh0cmFuc2xhdGVFeHRlbnQpID0+IHtcbiAgICAgICAgZ2V0KCkucGFuWm9vbT8uc2V0VHJhbnNsYXRlRXh0ZW50KHRyYW5zbGF0ZUV4dGVudCk7XG4gICAgICAgIHNldCh7IHRyYW5zbGF0ZUV4dGVudCB9KTtcbiAgICB9LFxuICAgIHNldFBhbmVDbGlja0Rpc3RhbmNlOiAoY2xpY2tEaXN0YW5jZSkgPT4ge1xuICAgICAgICBnZXQoKS5wYW5ab29tPy5zZXRDbGlja0Rpc3RhbmNlKGNsaWNrRGlzdGFuY2UpO1xuICAgIH0sXG4gICAgcmVzZXRTZWxlY3RlZEVsZW1lbnRzOiAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgZWRnZXMsIG5vZGVzLCB0cmlnZ2VyTm9kZUNoYW5nZXMsIHRyaWdnZXJFZGdlQ2hhbmdlcyB9ID0gZ2V0KCk7XG4gICAgICAgIGNvbnN0IG5vZGVDaGFuZ2VzID0gbm9kZXMucmVkdWNlKChyZXMsIG5vZGUpID0+IChub2RlLnNlbGVjdGVkID8gWy4uLnJlcywgY3JlYXRlU2VsZWN0aW9uQ2hhbmdlKG5vZGUuaWQsIGZhbHNlKV0gOiByZXMpLCBbXSk7XG4gICAgICAgIGNvbnN0IGVkZ2VDaGFuZ2VzID0gZWRnZXMucmVkdWNlKChyZXMsIGVkZ2UpID0+IChlZGdlLnNlbGVjdGVkID8gWy4uLnJlcywgY3JlYXRlU2VsZWN0aW9uQ2hhbmdlKGVkZ2UuaWQsIGZhbHNlKV0gOiByZXMpLCBbXSk7XG4gICAgICAgIHRyaWdnZXJOb2RlQ2hhbmdlcyhub2RlQ2hhbmdlcyk7XG4gICAgICAgIHRyaWdnZXJFZGdlQ2hhbmdlcyhlZGdlQ2hhbmdlcyk7XG4gICAgfSxcbiAgICBzZXROb2RlRXh0ZW50OiAobmV4dE5vZGVFeHRlbnQpID0+IHtcbiAgICAgICAgY29uc3QgeyBub2Rlcywgbm9kZUxvb2t1cCwgcGFyZW50TG9va3VwLCBub2RlT3JpZ2luLCBlbGV2YXRlTm9kZXNPblNlbGVjdCwgbm9kZUV4dGVudCB9ID0gZ2V0KCk7XG4gICAgICAgIGlmIChuZXh0Tm9kZUV4dGVudFswXVswXSA9PT0gbm9kZUV4dGVudFswXVswXSAmJlxuICAgICAgICAgICAgbmV4dE5vZGVFeHRlbnRbMF1bMV0gPT09IG5vZGVFeHRlbnRbMF1bMV0gJiZcbiAgICAgICAgICAgIG5leHROb2RlRXh0ZW50WzFdWzBdID09PSBub2RlRXh0ZW50WzFdWzBdICYmXG4gICAgICAgICAgICBuZXh0Tm9kZUV4dGVudFsxXVsxXSA9PT0gbm9kZUV4dGVudFsxXVsxXSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGFkb3B0VXNlck5vZGVzKG5vZGVzLCBub2RlTG9va3VwLCBwYXJlbnRMb29rdXAsIHtcbiAgICAgICAgICAgIG5vZGVPcmlnaW4sXG4gICAgICAgICAgICBub2RlRXh0ZW50OiBuZXh0Tm9kZUV4dGVudCxcbiAgICAgICAgICAgIGVsZXZhdGVOb2Rlc09uU2VsZWN0LFxuICAgICAgICAgICAgY2hlY2tFcXVhbGl0eTogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgICAgICBzZXQoeyBub2RlRXh0ZW50OiBuZXh0Tm9kZUV4dGVudCB9KTtcbiAgICB9LFxuICAgIHBhbkJ5OiAoZGVsdGEpID0+IHtcbiAgICAgICAgY29uc3QgeyB0cmFuc2Zvcm0sIHdpZHRoLCBoZWlnaHQsIHBhblpvb20sIHRyYW5zbGF0ZUV4dGVudCB9ID0gZ2V0KCk7XG4gICAgICAgIHJldHVybiBwYW5CeSh7IGRlbHRhLCBwYW5ab29tLCB0cmFuc2Zvcm0sIHRyYW5zbGF0ZUV4dGVudCwgd2lkdGgsIGhlaWdodCB9KTtcbiAgICB9LFxuICAgIGZpdFZpZXc6IChvcHRpb25zKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgcGFuWm9vbSwgd2lkdGgsIGhlaWdodCwgbWluWm9vbSwgbWF4Wm9vbSwgbm9kZUxvb2t1cCB9ID0gZ2V0KCk7XG4gICAgICAgIGlmICghcGFuWm9vbSkge1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZml0Vmlld05vZGVzID0gZ2V0Rml0Vmlld05vZGVzKG5vZGVMb29rdXAsIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gZml0Vmlldyh7XG4gICAgICAgICAgICBub2RlczogZml0Vmlld05vZGVzLFxuICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgICBwYW5ab29tLFxuICAgICAgICAgICAgbWluWm9vbSxcbiAgICAgICAgICAgIG1heFpvb20sXG4gICAgICAgIH0sIG9wdGlvbnMpO1xuICAgIH0sXG4gICAgLypcbiAgICAgKiB3ZSBjYW4ndCBjYWxsIGFuIGFzbnljaHJvbm91cyBmdW5jdGlvbiBpbiB1cGRhdGVOb2RlSW50ZXJuYWxzXG4gICAgICogZm9yIHRoYXQgd2UgY3JlYXRlZCB0aGlzIHN5bmMgdmVyc2lvbiBvZiBmaXRWaWV3XG4gICAgICovXG4gICAgZml0Vmlld1N5bmM6IChvcHRpb25zKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgcGFuWm9vbSwgd2lkdGgsIGhlaWdodCwgbWluWm9vbSwgbWF4Wm9vbSwgbm9kZUxvb2t1cCB9ID0gZ2V0KCk7XG4gICAgICAgIGlmICghcGFuWm9vbSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZpdFZpZXdOb2RlcyA9IGdldEZpdFZpZXdOb2Rlcyhub2RlTG9va3VwLCBvcHRpb25zKTtcbiAgICAgICAgZml0Vmlldyh7XG4gICAgICAgICAgICBub2RlczogZml0Vmlld05vZGVzLFxuICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQsXG4gICAgICAgICAgICBwYW5ab29tLFxuICAgICAgICAgICAgbWluWm9vbSxcbiAgICAgICAgICAgIG1heFpvb20sXG4gICAgICAgIH0sIG9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gZml0Vmlld05vZGVzLnNpemUgPiAwO1xuICAgIH0sXG4gICAgY2FuY2VsQ29ubmVjdGlvbjogKCkgPT4ge1xuICAgICAgICBzZXQoe1xuICAgICAgICAgICAgY29ubmVjdGlvbjogeyAuLi5pbml0aWFsQ29ubmVjdGlvbiB9LFxuICAgICAgICB9KTtcbiAgICB9LFxuICAgIHVwZGF0ZUNvbm5lY3Rpb246IChjb25uZWN0aW9uKSA9PiB7XG4gICAgICAgIHNldCh7IGNvbm5lY3Rpb24gfSk7XG4gICAgfSxcbiAgICByZXNldDogKCkgPT4gc2V0KHsgLi4uZ2V0SW5pdGlhbFN0YXRlKCkgfSksXG59KSwgT2JqZWN0LmlzKTtcblxuLyoqXG4gKiBUaGUgYDxSZWFjdEZsb3dQcm92aWRlciAvPmAgY29tcG9uZW50IGlzIGEgW2NvbnRleHQgcHJvdmlkZXJdKGh0dHBzOi8vcmVhY3QuZGV2L2xlYXJuL3Bhc3NpbmctZGF0YS1kZWVwbHktd2l0aC1jb250ZXh0IylcbiAqIHRoYXQgbWFrZXMgaXQgcG9zc2libGUgdG8gYWNjZXNzIGEgZmxvdydzIGludGVybmFsIHN0YXRlIG91dHNpZGUgb2YgdGhlXG4gKiBbYDxSZWFjdEZsb3cgLz5gXSgvYXBpLXJlZmVyZW5jZS9yZWFjdC1mbG93KSBjb21wb25lbnQuIE1hbnkgb2YgdGhlIGhvb2tzIHdlXG4gKiBwcm92aWRlIHJlbHkgb24gdGhpcyBjb21wb25lbnQgdG8gd29yay5cbiAqIEBwdWJsaWNcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHN4XG4gKmltcG9ydCB7IFJlYWN0RmxvdywgUmVhY3RGbG93UHJvdmlkZXIsIHVzZU5vZGVzIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCdcbiAqXG4gKmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEZsb3coKSB7XG4gKiAgcmV0dXJuIChcbiAqICAgIDxSZWFjdEZsb3dQcm92aWRlcj5cbiAqICAgICAgPFJlYWN0RmxvdyBub2Rlcz17Li4ufSBlZGdlcz17Li4ufSAvPlxuICogICAgICA8U2lkZWJhciAvPlxuICogICAgPC9SZWFjdEZsb3dQcm92aWRlcj5cbiAqICApO1xuICp9XG4gKlxuICpmdW5jdGlvbiBTaWRlYmFyKCkge1xuICogIC8vIFRoaXMgaG9vayB3aWxsIG9ubHkgd29yayBpZiB0aGUgY29tcG9uZW50IGl0J3MgdXNlZCBpbiBpcyBhIGNoaWxkIG9mIGFcbiAqICAvLyA8UmVhY3RGbG93UHJvdmlkZXIgLz4uXG4gKiAgY29uc3Qgbm9kZXMgPSB1c2VOb2RlcygpXG4gKlxuICogIHJldHVybiA8YXNpZGU+ZG8gc29tZXRoaW5nIHdpdGggbm9kZXM8L2FzaWRlPjtcbiAqfVxuICpgYGBcbiAqXG4gKiBAcmVtYXJrcyBJZiB5b3UncmUgdXNpbmcgYSByb3V0ZXIgYW5kIHdhbnQgeW91ciBmbG93J3Mgc3RhdGUgdG8gcGVyc2lzdCBhY3Jvc3Mgcm91dGVzLFxuICogaXQncyB2aXRhbCB0aGF0IHlvdSBwbGFjZSB0aGUgYDxSZWFjdEZsb3dQcm92aWRlciAvPmAgY29tcG9uZW50IF9vdXRzaWRlXyBvZlxuICogeW91ciByb3V0ZXIuIElmIHlvdSBoYXZlIG11bHRpcGxlIGZsb3dzIG9uIHRoZSBzYW1lIHBhZ2UgeW91IHdpbGwgbmVlZCB0byB1c2UgYSBzZXBhcmF0ZVxuICogYDxSZWFjdEZsb3dQcm92aWRlciAvPmAgZm9yIGVhY2ggZmxvdy5cbiAqL1xuZnVuY3Rpb24gUmVhY3RGbG93UHJvdmlkZXIoeyBpbml0aWFsTm9kZXM6IG5vZGVzLCBpbml0aWFsRWRnZXM6IGVkZ2VzLCBkZWZhdWx0Tm9kZXMsIGRlZmF1bHRFZGdlcywgaW5pdGlhbFdpZHRoOiB3aWR0aCwgaW5pdGlhbEhlaWdodDogaGVpZ2h0LCBmaXRWaWV3LCBub2RlT3JpZ2luLCBub2RlRXh0ZW50LCBjaGlsZHJlbiwgfSkge1xuICAgIGNvbnN0IFtzdG9yZV0gPSB1c2VTdGF0ZSgoKSA9PiBjcmVhdGVTdG9yZSh7XG4gICAgICAgIG5vZGVzLFxuICAgICAgICBlZGdlcyxcbiAgICAgICAgZGVmYXVsdE5vZGVzLFxuICAgICAgICBkZWZhdWx0RWRnZXMsXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHQsXG4gICAgICAgIGZpdFZpZXcsXG4gICAgICAgIG5vZGVPcmlnaW4sXG4gICAgICAgIG5vZGVFeHRlbnQsXG4gICAgfSkpO1xuICAgIHJldHVybiAoanN4KFByb3ZpZGVyJDEsIHsgdmFsdWU6IHN0b3JlLCBjaGlsZHJlbjoganN4KEJhdGNoUHJvdmlkZXIsIHsgY2hpbGRyZW46IGNoaWxkcmVuIH0pIH0pKTtcbn1cblxuZnVuY3Rpb24gV3JhcHBlcih7IGNoaWxkcmVuLCBub2RlcywgZWRnZXMsIGRlZmF1bHROb2RlcywgZGVmYXVsdEVkZ2VzLCB3aWR0aCwgaGVpZ2h0LCBmaXRWaWV3LCBub2RlT3JpZ2luLCBub2RlRXh0ZW50LCB9KSB7XG4gICAgY29uc3QgaXNXcmFwcGVkID0gdXNlQ29udGV4dChTdG9yZUNvbnRleHQpO1xuICAgIGlmIChpc1dyYXBwZWQpIHtcbiAgICAgICAgLypcbiAgICAgICAgICogd2UgbmVlZCB0byB3cmFwIGl0IHdpdGggYSBmcmFnbWVudCBiZWNhdXNlIGl0J3Mgbm90IGFsbG93ZWQgZm9yIGNoaWxkcmVuIHRvIGJlIGEgUmVhY3ROb2RlXG4gICAgICAgICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9EZWZpbml0ZWx5VHlwZWQvRGVmaW5pdGVseVR5cGVkL2lzc3Vlcy8xODA1MVxuICAgICAgICAgKi9cbiAgICAgICAgcmV0dXJuIGpzeChGcmFnbWVudCwgeyBjaGlsZHJlbjogY2hpbGRyZW4gfSk7XG4gICAgfVxuICAgIHJldHVybiAoanN4KFJlYWN0Rmxvd1Byb3ZpZGVyLCB7IGluaXRpYWxOb2Rlczogbm9kZXMsIGluaXRpYWxFZGdlczogZWRnZXMsIGRlZmF1bHROb2RlczogZGVmYXVsdE5vZGVzLCBkZWZhdWx0RWRnZXM6IGRlZmF1bHRFZGdlcywgaW5pdGlhbFdpZHRoOiB3aWR0aCwgaW5pdGlhbEhlaWdodDogaGVpZ2h0LCBmaXRWaWV3OiBmaXRWaWV3LCBub2RlT3JpZ2luOiBub2RlT3JpZ2luLCBub2RlRXh0ZW50OiBub2RlRXh0ZW50LCBjaGlsZHJlbjogY2hpbGRyZW4gfSkpO1xufVxuXG5jb25zdCB3cmFwcGVyU3R5bGUgPSB7XG4gICAgd2lkdGg6ICcxMDAlJyxcbiAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXG4gICAgekluZGV4OiAwLFxufTtcbmZ1bmN0aW9uIFJlYWN0Rmxvdyh7IG5vZGVzLCBlZGdlcywgZGVmYXVsdE5vZGVzLCBkZWZhdWx0RWRnZXMsIGNsYXNzTmFtZSwgbm9kZVR5cGVzLCBlZGdlVHlwZXMsIG9uTm9kZUNsaWNrLCBvbkVkZ2VDbGljaywgb25Jbml0LCBvbk1vdmUsIG9uTW92ZVN0YXJ0LCBvbk1vdmVFbmQsIG9uQ29ubmVjdCwgb25Db25uZWN0U3RhcnQsIG9uQ29ubmVjdEVuZCwgb25DbGlja0Nvbm5lY3RTdGFydCwgb25DbGlja0Nvbm5lY3RFbmQsIG9uTm9kZU1vdXNlRW50ZXIsIG9uTm9kZU1vdXNlTW92ZSwgb25Ob2RlTW91c2VMZWF2ZSwgb25Ob2RlQ29udGV4dE1lbnUsIG9uTm9kZURvdWJsZUNsaWNrLCBvbk5vZGVEcmFnU3RhcnQsIG9uTm9kZURyYWcsIG9uTm9kZURyYWdTdG9wLCBvbk5vZGVzRGVsZXRlLCBvbkVkZ2VzRGVsZXRlLCBvbkRlbGV0ZSwgb25TZWxlY3Rpb25DaGFuZ2UsIG9uU2VsZWN0aW9uRHJhZ1N0YXJ0LCBvblNlbGVjdGlvbkRyYWcsIG9uU2VsZWN0aW9uRHJhZ1N0b3AsIG9uU2VsZWN0aW9uQ29udGV4dE1lbnUsIG9uU2VsZWN0aW9uU3RhcnQsIG9uU2VsZWN0aW9uRW5kLCBvbkJlZm9yZURlbGV0ZSwgY29ubmVjdGlvbk1vZGUsIGNvbm5lY3Rpb25MaW5lVHlwZSA9IENvbm5lY3Rpb25MaW5lVHlwZS5CZXppZXIsIGNvbm5lY3Rpb25MaW5lU3R5bGUsIGNvbm5lY3Rpb25MaW5lQ29tcG9uZW50LCBjb25uZWN0aW9uTGluZUNvbnRhaW5lclN0eWxlLCBkZWxldGVLZXlDb2RlID0gJ0JhY2tzcGFjZScsIHNlbGVjdGlvbktleUNvZGUgPSAnU2hpZnQnLCBzZWxlY3Rpb25PbkRyYWcgPSBmYWxzZSwgc2VsZWN0aW9uTW9kZSA9IFNlbGVjdGlvbk1vZGUuRnVsbCwgcGFuQWN0aXZhdGlvbktleUNvZGUgPSAnU3BhY2UnLCBtdWx0aVNlbGVjdGlvbktleUNvZGUgPSBpc01hY09zKCkgPyAnTWV0YScgOiAnQ29udHJvbCcsIHpvb21BY3RpdmF0aW9uS2V5Q29kZSA9IGlzTWFjT3MoKSA/ICdNZXRhJyA6ICdDb250cm9sJywgc25hcFRvR3JpZCwgc25hcEdyaWQsIG9ubHlSZW5kZXJWaXNpYmxlRWxlbWVudHMgPSBmYWxzZSwgc2VsZWN0Tm9kZXNPbkRyYWcsIG5vZGVzRHJhZ2dhYmxlLCBub2Rlc0Nvbm5lY3RhYmxlLCBub2Rlc0ZvY3VzYWJsZSwgbm9kZU9yaWdpbiA9IGRlZmF1bHROb2RlT3JpZ2luLCBlZGdlc0ZvY3VzYWJsZSwgZWRnZXNSZWNvbm5lY3RhYmxlLCBlbGVtZW50c1NlbGVjdGFibGUgPSB0cnVlLCBkZWZhdWx0Vmlld3BvcnQ6IGRlZmF1bHRWaWV3cG9ydCQxID0gZGVmYXVsdFZpZXdwb3J0LCBtaW5ab29tID0gMC41LCBtYXhab29tID0gMiwgdHJhbnNsYXRlRXh0ZW50ID0gaW5maW5pdGVFeHRlbnQsIHByZXZlbnRTY3JvbGxpbmcgPSB0cnVlLCBub2RlRXh0ZW50LCBkZWZhdWx0TWFya2VyQ29sb3IgPSAnI2IxYjFiNycsIHpvb21PblNjcm9sbCA9IHRydWUsIHpvb21PblBpbmNoID0gdHJ1ZSwgcGFuT25TY3JvbGwgPSBmYWxzZSwgcGFuT25TY3JvbGxTcGVlZCA9IDAuNSwgcGFuT25TY3JvbGxNb2RlID0gUGFuT25TY3JvbGxNb2RlLkZyZWUsIHpvb21PbkRvdWJsZUNsaWNrID0gdHJ1ZSwgcGFuT25EcmFnID0gdHJ1ZSwgb25QYW5lQ2xpY2ssIG9uUGFuZU1vdXNlRW50ZXIsIG9uUGFuZU1vdXNlTW92ZSwgb25QYW5lTW91c2VMZWF2ZSwgb25QYW5lU2Nyb2xsLCBvblBhbmVDb250ZXh0TWVudSwgcGFuZUNsaWNrRGlzdGFuY2UgPSAwLCBub2RlQ2xpY2tEaXN0YW5jZSA9IDAsIGNoaWxkcmVuLCBvblJlY29ubmVjdCwgb25SZWNvbm5lY3RTdGFydCwgb25SZWNvbm5lY3RFbmQsIG9uRWRnZUNvbnRleHRNZW51LCBvbkVkZ2VEb3VibGVDbGljaywgb25FZGdlTW91c2VFbnRlciwgb25FZGdlTW91c2VNb3ZlLCBvbkVkZ2VNb3VzZUxlYXZlLCByZWNvbm5lY3RSYWRpdXMgPSAxMCwgb25Ob2Rlc0NoYW5nZSwgb25FZGdlc0NoYW5nZSwgbm9EcmFnQ2xhc3NOYW1lID0gJ25vZHJhZycsIG5vV2hlZWxDbGFzc05hbWUgPSAnbm93aGVlbCcsIG5vUGFuQ2xhc3NOYW1lID0gJ25vcGFuJywgZml0VmlldywgZml0Vmlld09wdGlvbnMsIGNvbm5lY3RPbkNsaWNrLCBhdHRyaWJ1dGlvblBvc2l0aW9uLCBwcm9PcHRpb25zLCBkZWZhdWx0RWRnZU9wdGlvbnMsIGVsZXZhdGVOb2Rlc09uU2VsZWN0LCBlbGV2YXRlRWRnZXNPblNlbGVjdCwgZGlzYWJsZUtleWJvYXJkQTExeSA9IGZhbHNlLCBhdXRvUGFuT25Db25uZWN0LCBhdXRvUGFuT25Ob2RlRHJhZywgYXV0b1BhblNwZWVkLCBjb25uZWN0aW9uUmFkaXVzLCBpc1ZhbGlkQ29ubmVjdGlvbiwgb25FcnJvciwgc3R5bGUsIGlkLCBub2RlRHJhZ1RocmVzaG9sZCwgdmlld3BvcnQsIG9uVmlld3BvcnRDaGFuZ2UsIHdpZHRoLCBoZWlnaHQsIGNvbG9yTW9kZSA9ICdsaWdodCcsIGRlYnVnLCBvblNjcm9sbCwgLi4ucmVzdCB9LCByZWYpIHtcbiAgICBjb25zdCByZklkID0gaWQgfHwgJzEnO1xuICAgIGNvbnN0IGNvbG9yTW9kZUNsYXNzTmFtZSA9IHVzZUNvbG9yTW9kZUNsYXNzKGNvbG9yTW9kZSk7XG4gICAgLy8gVW5kbyBzY3JvbGwgZXZlbnRzLCBwcmV2ZW50aW5nIHZpZXdwb3J0IGZyb20gc2hpZnRpbmcgd2hlbiBub2RlcyBvdXRzaWRlIG9mIGl0IGFyZSBmb2N1c2VkXG4gICAgY29uc3Qgd3JhcHBlck9uU2Nyb2xsID0gdXNlQ2FsbGJhY2soKGUpID0+IHtcbiAgICAgICAgZS5jdXJyZW50VGFyZ2V0LnNjcm9sbFRvKHsgdG9wOiAwLCBsZWZ0OiAwLCBiZWhhdmlvcjogJ2luc3RhbnQnIH0pO1xuICAgICAgICBvblNjcm9sbD8uKGUpO1xuICAgIH0sIFtvblNjcm9sbF0pO1xuICAgIHJldHVybiAoanN4KFwiZGl2XCIsIHsgXCJkYXRhLXRlc3RpZFwiOiBcInJmX193cmFwcGVyXCIsIC4uLnJlc3QsIG9uU2Nyb2xsOiB3cmFwcGVyT25TY3JvbGwsIHN0eWxlOiB7IC4uLnN0eWxlLCAuLi53cmFwcGVyU3R5bGUgfSwgcmVmOiByZWYsIGNsYXNzTmFtZTogY2MoWydyZWFjdC1mbG93JywgY2xhc3NOYW1lLCBjb2xvck1vZGVDbGFzc05hbWVdKSwgaWQ6IGlkLCBjaGlsZHJlbjoganN4cyhXcmFwcGVyLCB7IG5vZGVzOiBub2RlcywgZWRnZXM6IGVkZ2VzLCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0LCBmaXRWaWV3OiBmaXRWaWV3LCBub2RlT3JpZ2luOiBub2RlT3JpZ2luLCBub2RlRXh0ZW50OiBub2RlRXh0ZW50LCBjaGlsZHJlbjogW2pzeChHcmFwaFZpZXcsIHsgb25Jbml0OiBvbkluaXQsIG9uTm9kZUNsaWNrOiBvbk5vZGVDbGljaywgb25FZGdlQ2xpY2s6IG9uRWRnZUNsaWNrLCBvbk5vZGVNb3VzZUVudGVyOiBvbk5vZGVNb3VzZUVudGVyLCBvbk5vZGVNb3VzZU1vdmU6IG9uTm9kZU1vdXNlTW92ZSwgb25Ob2RlTW91c2VMZWF2ZTogb25Ob2RlTW91c2VMZWF2ZSwgb25Ob2RlQ29udGV4dE1lbnU6IG9uTm9kZUNvbnRleHRNZW51LCBvbk5vZGVEb3VibGVDbGljazogb25Ob2RlRG91YmxlQ2xpY2ssIG5vZGVUeXBlczogbm9kZVR5cGVzLCBlZGdlVHlwZXM6IGVkZ2VUeXBlcywgY29ubmVjdGlvbkxpbmVUeXBlOiBjb25uZWN0aW9uTGluZVR5cGUsIGNvbm5lY3Rpb25MaW5lU3R5bGU6IGNvbm5lY3Rpb25MaW5lU3R5bGUsIGNvbm5lY3Rpb25MaW5lQ29tcG9uZW50OiBjb25uZWN0aW9uTGluZUNvbXBvbmVudCwgY29ubmVjdGlvbkxpbmVDb250YWluZXJTdHlsZTogY29ubmVjdGlvbkxpbmVDb250YWluZXJTdHlsZSwgc2VsZWN0aW9uS2V5Q29kZTogc2VsZWN0aW9uS2V5Q29kZSwgc2VsZWN0aW9uT25EcmFnOiBzZWxlY3Rpb25PbkRyYWcsIHNlbGVjdGlvbk1vZGU6IHNlbGVjdGlvbk1vZGUsIGRlbGV0ZUtleUNvZGU6IGRlbGV0ZUtleUNvZGUsIG11bHRpU2VsZWN0aW9uS2V5Q29kZTogbXVsdGlTZWxlY3Rpb25LZXlDb2RlLCBwYW5BY3RpdmF0aW9uS2V5Q29kZTogcGFuQWN0aXZhdGlvbktleUNvZGUsIHpvb21BY3RpdmF0aW9uS2V5Q29kZTogem9vbUFjdGl2YXRpb25LZXlDb2RlLCBvbmx5UmVuZGVyVmlzaWJsZUVsZW1lbnRzOiBvbmx5UmVuZGVyVmlzaWJsZUVsZW1lbnRzLCBkZWZhdWx0Vmlld3BvcnQ6IGRlZmF1bHRWaWV3cG9ydCQxLCB0cmFuc2xhdGVFeHRlbnQ6IHRyYW5zbGF0ZUV4dGVudCwgbWluWm9vbTogbWluWm9vbSwgbWF4Wm9vbTogbWF4Wm9vbSwgcHJldmVudFNjcm9sbGluZzogcHJldmVudFNjcm9sbGluZywgem9vbU9uU2Nyb2xsOiB6b29tT25TY3JvbGwsIHpvb21PblBpbmNoOiB6b29tT25QaW5jaCwgem9vbU9uRG91YmxlQ2xpY2s6IHpvb21PbkRvdWJsZUNsaWNrLCBwYW5PblNjcm9sbDogcGFuT25TY3JvbGwsIHBhbk9uU2Nyb2xsU3BlZWQ6IHBhbk9uU2Nyb2xsU3BlZWQsIHBhbk9uU2Nyb2xsTW9kZTogcGFuT25TY3JvbGxNb2RlLCBwYW5PbkRyYWc6IHBhbk9uRHJhZywgb25QYW5lQ2xpY2s6IG9uUGFuZUNsaWNrLCBvblBhbmVNb3VzZUVudGVyOiBvblBhbmVNb3VzZUVudGVyLCBvblBhbmVNb3VzZU1vdmU6IG9uUGFuZU1vdXNlTW92ZSwgb25QYW5lTW91c2VMZWF2ZTogb25QYW5lTW91c2VMZWF2ZSwgb25QYW5lU2Nyb2xsOiBvblBhbmVTY3JvbGwsIG9uUGFuZUNvbnRleHRNZW51OiBvblBhbmVDb250ZXh0TWVudSwgcGFuZUNsaWNrRGlzdGFuY2U6IHBhbmVDbGlja0Rpc3RhbmNlLCBub2RlQ2xpY2tEaXN0YW5jZTogbm9kZUNsaWNrRGlzdGFuY2UsIG9uU2VsZWN0aW9uQ29udGV4dE1lbnU6IG9uU2VsZWN0aW9uQ29udGV4dE1lbnUsIG9uU2VsZWN0aW9uU3RhcnQ6IG9uU2VsZWN0aW9uU3RhcnQsIG9uU2VsZWN0aW9uRW5kOiBvblNlbGVjdGlvbkVuZCwgb25SZWNvbm5lY3Q6IG9uUmVjb25uZWN0LCBvblJlY29ubmVjdFN0YXJ0OiBvblJlY29ubmVjdFN0YXJ0LCBvblJlY29ubmVjdEVuZDogb25SZWNvbm5lY3RFbmQsIG9uRWRnZUNvbnRleHRNZW51OiBvbkVkZ2VDb250ZXh0TWVudSwgb25FZGdlRG91YmxlQ2xpY2s6IG9uRWRnZURvdWJsZUNsaWNrLCBvbkVkZ2VNb3VzZUVudGVyOiBvbkVkZ2VNb3VzZUVudGVyLCBvbkVkZ2VNb3VzZU1vdmU6IG9uRWRnZU1vdXNlTW92ZSwgb25FZGdlTW91c2VMZWF2ZTogb25FZGdlTW91c2VMZWF2ZSwgcmVjb25uZWN0UmFkaXVzOiByZWNvbm5lY3RSYWRpdXMsIGRlZmF1bHRNYXJrZXJDb2xvcjogZGVmYXVsdE1hcmtlckNvbG9yLCBub0RyYWdDbGFzc05hbWU6IG5vRHJhZ0NsYXNzTmFtZSwgbm9XaGVlbENsYXNzTmFtZTogbm9XaGVlbENsYXNzTmFtZSwgbm9QYW5DbGFzc05hbWU6IG5vUGFuQ2xhc3NOYW1lLCByZklkOiByZklkLCBkaXNhYmxlS2V5Ym9hcmRBMTF5OiBkaXNhYmxlS2V5Ym9hcmRBMTF5LCBub2RlRXh0ZW50OiBub2RlRXh0ZW50LCB2aWV3cG9ydDogdmlld3BvcnQsIG9uVmlld3BvcnRDaGFuZ2U6IG9uVmlld3BvcnRDaGFuZ2UgfSksIGpzeChTdG9yZVVwZGF0ZXIsIHsgbm9kZXM6IG5vZGVzLCBlZGdlczogZWRnZXMsIGRlZmF1bHROb2RlczogZGVmYXVsdE5vZGVzLCBkZWZhdWx0RWRnZXM6IGRlZmF1bHRFZGdlcywgb25Db25uZWN0OiBvbkNvbm5lY3QsIG9uQ29ubmVjdFN0YXJ0OiBvbkNvbm5lY3RTdGFydCwgb25Db25uZWN0RW5kOiBvbkNvbm5lY3RFbmQsIG9uQ2xpY2tDb25uZWN0U3RhcnQ6IG9uQ2xpY2tDb25uZWN0U3RhcnQsIG9uQ2xpY2tDb25uZWN0RW5kOiBvbkNsaWNrQ29ubmVjdEVuZCwgbm9kZXNEcmFnZ2FibGU6IG5vZGVzRHJhZ2dhYmxlLCBub2Rlc0Nvbm5lY3RhYmxlOiBub2Rlc0Nvbm5lY3RhYmxlLCBub2Rlc0ZvY3VzYWJsZTogbm9kZXNGb2N1c2FibGUsIGVkZ2VzRm9jdXNhYmxlOiBlZGdlc0ZvY3VzYWJsZSwgZWRnZXNSZWNvbm5lY3RhYmxlOiBlZGdlc1JlY29ubmVjdGFibGUsIGVsZW1lbnRzU2VsZWN0YWJsZTogZWxlbWVudHNTZWxlY3RhYmxlLCBlbGV2YXRlTm9kZXNPblNlbGVjdDogZWxldmF0ZU5vZGVzT25TZWxlY3QsIGVsZXZhdGVFZGdlc09uU2VsZWN0OiBlbGV2YXRlRWRnZXNPblNlbGVjdCwgbWluWm9vbTogbWluWm9vbSwgbWF4Wm9vbTogbWF4Wm9vbSwgbm9kZUV4dGVudDogbm9kZUV4dGVudCwgb25Ob2Rlc0NoYW5nZTogb25Ob2Rlc0NoYW5nZSwgb25FZGdlc0NoYW5nZTogb25FZGdlc0NoYW5nZSwgc25hcFRvR3JpZDogc25hcFRvR3JpZCwgc25hcEdyaWQ6IHNuYXBHcmlkLCBjb25uZWN0aW9uTW9kZTogY29ubmVjdGlvbk1vZGUsIHRyYW5zbGF0ZUV4dGVudDogdHJhbnNsYXRlRXh0ZW50LCBjb25uZWN0T25DbGljazogY29ubmVjdE9uQ2xpY2ssIGRlZmF1bHRFZGdlT3B0aW9uczogZGVmYXVsdEVkZ2VPcHRpb25zLCBmaXRWaWV3OiBmaXRWaWV3LCBmaXRWaWV3T3B0aW9uczogZml0Vmlld09wdGlvbnMsIG9uTm9kZXNEZWxldGU6IG9uTm9kZXNEZWxldGUsIG9uRWRnZXNEZWxldGU6IG9uRWRnZXNEZWxldGUsIG9uRGVsZXRlOiBvbkRlbGV0ZSwgb25Ob2RlRHJhZ1N0YXJ0OiBvbk5vZGVEcmFnU3RhcnQsIG9uTm9kZURyYWc6IG9uTm9kZURyYWcsIG9uTm9kZURyYWdTdG9wOiBvbk5vZGVEcmFnU3RvcCwgb25TZWxlY3Rpb25EcmFnOiBvblNlbGVjdGlvbkRyYWcsIG9uU2VsZWN0aW9uRHJhZ1N0YXJ0OiBvblNlbGVjdGlvbkRyYWdTdGFydCwgb25TZWxlY3Rpb25EcmFnU3RvcDogb25TZWxlY3Rpb25EcmFnU3RvcCwgb25Nb3ZlOiBvbk1vdmUsIG9uTW92ZVN0YXJ0OiBvbk1vdmVTdGFydCwgb25Nb3ZlRW5kOiBvbk1vdmVFbmQsIG5vUGFuQ2xhc3NOYW1lOiBub1BhbkNsYXNzTmFtZSwgbm9kZU9yaWdpbjogbm9kZU9yaWdpbiwgcmZJZDogcmZJZCwgYXV0b1Bhbk9uQ29ubmVjdDogYXV0b1Bhbk9uQ29ubmVjdCwgYXV0b1Bhbk9uTm9kZURyYWc6IGF1dG9QYW5Pbk5vZGVEcmFnLCBhdXRvUGFuU3BlZWQ6IGF1dG9QYW5TcGVlZCwgb25FcnJvcjogb25FcnJvciwgY29ubmVjdGlvblJhZGl1czogY29ubmVjdGlvblJhZGl1cywgaXNWYWxpZENvbm5lY3Rpb246IGlzVmFsaWRDb25uZWN0aW9uLCBzZWxlY3ROb2Rlc09uRHJhZzogc2VsZWN0Tm9kZXNPbkRyYWcsIG5vZGVEcmFnVGhyZXNob2xkOiBub2RlRHJhZ1RocmVzaG9sZCwgb25CZWZvcmVEZWxldGU6IG9uQmVmb3JlRGVsZXRlLCBwYW5lQ2xpY2tEaXN0YW5jZTogcGFuZUNsaWNrRGlzdGFuY2UsIGRlYnVnOiBkZWJ1ZyB9KSwganN4KFNlbGVjdGlvbkxpc3RlbmVyLCB7IG9uU2VsZWN0aW9uQ2hhbmdlOiBvblNlbGVjdGlvbkNoYW5nZSB9KSwgY2hpbGRyZW4sIGpzeChBdHRyaWJ1dGlvbiwgeyBwcm9PcHRpb25zOiBwcm9PcHRpb25zLCBwb3NpdGlvbjogYXR0cmlidXRpb25Qb3NpdGlvbiB9KSwganN4KEExMXlEZXNjcmlwdGlvbnMsIHsgcmZJZDogcmZJZCwgZGlzYWJsZUtleWJvYXJkQTExeTogZGlzYWJsZUtleWJvYXJkQTExeSB9KV0gfSkgfSkpO1xufVxuLyoqXG4gKiBUaGUgYDxSZWFjdEZsb3cgLz5gIGNvbXBvbmVudCBpcyB0aGUgaGVhcnQgb2YgeW91ciBSZWFjdCBGbG93IGFwcGxpY2F0aW9uLlxuICogSXQgcmVuZGVycyB5b3VyIG5vZGVzIGFuZCBlZGdlcyBhbmQgaGFuZGxlcyB1c2VyIGludGVyYWN0aW9uXG4gKlxuICogQHB1YmxpY1xuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c3hcbiAqaW1wb3J0IHsgUmVhY3RGbG93IH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCdcbiAqXG4gKmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEZsb3coKSB7XG4gKiAgcmV0dXJuICg8UmVhY3RGbG93XG4gKiAgICBub2Rlcz17Li4ufVxuICogICAgZWRnZXM9ey4uLn1cbiAqICAgIG9uTm9kZXNDaGFuZ2U9ey4uLn1cbiAqICAgIC4uLlxuICogIC8+KTtcbiAqfVxuICpgYGBcbiAqL1xudmFyIGluZGV4ID0gZml4ZWRGb3J3YXJkUmVmKFJlYWN0Rmxvdyk7XG5cbmNvbnN0IHNlbGVjdG9yJDYgPSAocykgPT4gcy5kb21Ob2RlPy5xdWVyeVNlbGVjdG9yKCcucmVhY3QtZmxvd19fZWRnZWxhYmVsLXJlbmRlcmVyJyk7XG4vKipcbiAqIEVkZ2VzIGFyZSBTVkctYmFzZWQuIElmIHlvdSB3YW50IHRvIHJlbmRlciBtb3JlIGNvbXBsZXggbGFiZWxzIHlvdSBjYW4gdXNlIHRoZVxuICogYDxFZGdlTGFiZWxSZW5kZXJlciAvPmAgY29tcG9uZW50IHRvIGFjY2VzcyBhIGRpdiBiYXNlZCByZW5kZXJlci4gVGhpcyBjb21wb25lbnRcbiAqIGlzIGEgcG9ydGFsIHRoYXQgcmVuZGVycyB0aGUgbGFiZWwgaW4gYSBgPGRpdiAvPmAgdGhhdCBpcyBwb3NpdGlvbmVkIG9uIHRvcCBvZlxuICogdGhlIGVkZ2VzLiBZb3UgY2FuIHNlZSBhbiBleGFtcGxlIHVzYWdlIG9mIHRoZSBjb21wb25lbnQgaW4gdGhlIFtlZGdlIGxhYmVsIHJlbmRlcmVyXSgvZXhhbXBsZXMvZWRnZXMvZWRnZS1sYWJlbC1yZW5kZXJlcikgZXhhbXBsZS5cbiAqIEBwdWJsaWNcbiAqXG4gKiBAZXhhbXBsZVxuICpgYGBqc3hcbiAqaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbiAqaW1wb3J0IHsgZ2V0QmV6aWVyUGF0aCwgRWRnZUxhYmVsUmVuZGVyZXIsIEJhc2VFZGdlIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpleHBvcnQgZnVuY3Rpb24gQ3VzdG9tRWRnZSh7IGlkLCBkYXRhLCAuLi5wcm9wcyB9KSB7XG4gKiAgY29uc3QgW2VkZ2VQYXRoLCBsYWJlbFgsIGxhYmVsWV0gPSBnZXRCZXppZXJQYXRoKHByb3BzKTtcbiAqXG4gKiAgcmV0dXJuIChcbiAqICAgIDw+XG4gKiAgICAgIDxCYXNlRWRnZSBpZD17aWR9IHBhdGg9e2VkZ2VQYXRofSAvPlxuICogICAgICA8RWRnZUxhYmVsUmVuZGVyZXI+XG4gKiAgICAgICAgPGRpdlxuICogICAgICAgICAgc3R5bGU9e3tcbiAqICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gKiAgICAgICAgICAgIHRyYW5zZm9ybTogYHRyYW5zbGF0ZSgtNTAlLCAtNTAlKSB0cmFuc2xhdGUoJHtsYWJlbFh9cHgsJHtsYWJlbFl9cHgpYCxcbiAqICAgICAgICAgICAgYmFja2dyb3VuZDogJyNmZmNjMDAnLFxuICogICAgICAgICAgICBwYWRkaW5nOiAxMCxcbiAqICAgICAgICB9fVxuICogICAgICAgICAgY2xhc3NOYW1lPVwibm9kcmFnIG5vcGFuXCJcbiAqICAgICAgICA+XG4gKiAgICAgICAgIHtkYXRhLmxhYmVsfVxuICogICAgICAgIDwvZGl2PlxuICogICAgICA8L0VkZ2VMYWJlbFJlbmRlcmVyPlxuICogICAgPC8+XG4gKiAgKTtcbiAqfTtcbiAqYGBgXG4gKlxuICogQHJlbWFya3MgVGhlIGA8RWRnZUxhYmVsUmVuZGVyZXIgLz5gIGhhcyBubyBwb2ludGVyIGV2ZW50cyBieSBkZWZhdWx0LiBJZiB5b3Ugd2FudCB0b1xuICogYWRkIG1vdXNlIGludGVyYWN0aW9ucyB5b3UgbmVlZCB0byBzZXQgdGhlIHN0eWxlIGBwb2ludGVyRXZlbnRzOiBhbGxgIGFuZCBhZGRcbiAqIHRoZSBgbm9wYW5gIGNsYXNzIG9uIHRoZSBsYWJlbCBvciB0aGUgZWxlbWVudCB5b3Ugd2FudCB0byBpbnRlcmFjdCB3aXRoLlxuICovXG5mdW5jdGlvbiBFZGdlTGFiZWxSZW5kZXJlcih7IGNoaWxkcmVuIH0pIHtcbiAgICBjb25zdCBlZGdlTGFiZWxSZW5kZXJlciA9IHVzZVN0b3JlKHNlbGVjdG9yJDYpO1xuICAgIGlmICghZWRnZUxhYmVsUmVuZGVyZXIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVQb3J0YWwoY2hpbGRyZW4sIGVkZ2VMYWJlbFJlbmRlcmVyKTtcbn1cblxuY29uc3Qgc2VsZWN0b3IkNSA9IChzKSA9PiBzLmRvbU5vZGU/LnF1ZXJ5U2VsZWN0b3IoJy5yZWFjdC1mbG93X192aWV3cG9ydC1wb3J0YWwnKTtcbi8qKlxuICogVGhlIGA8Vmlld3BvcnRQb3J0YWwgLz5gIGNvbXBvbmVudCBjYW4gYmUgdXNlZCB0byBhZGQgY29tcG9uZW50cyB0byB0aGUgc2FtZSB2aWV3cG9ydFxuICogb2YgdGhlIGZsb3cgd2hlcmUgbm9kZXMgYW5kIGVkZ2VzIGFyZSByZW5kZXJlZC4gVGhpcyBpcyB1c2VmdWwgd2hlbiB5b3Ugd2FudCB0byByZW5kZXJcbiAqIHlvdXIgb3duIGNvbXBvbmVudHMgdGhhdCBhcmUgYWRoZXJlIHRvIHRoZSBzYW1lIGNvb3JkaW5hdGUgc3lzdGVtIGFzIHRoZSBub2RlcyAmIGVkZ2VzXG4gKiBhbmQgYXJlIGFsc28gYWZmZWN0ZWQgYnkgem9vbWluZyBhbmQgcGFubmluZ1xuICogQHB1YmxpY1xuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqc3hcbiAqaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbiAqaW1wb3J0IHsgVmlld3BvcnRQb3J0YWwgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uICgpIHtcbiAqICByZXR1cm4gKFxuICogICAgPFZpZXdwb3J0UG9ydGFsPlxuICogICAgICA8ZGl2XG4gKiAgICAgICAgc3R5bGU9e3sgdHJhbnNmb3JtOiAndHJhbnNsYXRlKDEwMHB4LCAxMDBweCknLCBwb3NpdGlvbjogJ2Fic29sdXRlJyB9fVxuICogICAgICA+XG4gKiAgICAgICAgVGhpcyBkaXYgaXMgcG9zaXRpb25lZCBhdCBbMTAwLCAxMDBdIG9uIHRoZSBmbG93LlxuICogICAgICA8L2Rpdj5cbiAqICAgIDwvVmlld3BvcnRQb3J0YWw+XG4gKiAgKTtcbiAqfVxuICpgYGBcbiAqL1xuZnVuY3Rpb24gVmlld3BvcnRQb3J0YWwoeyBjaGlsZHJlbiB9KSB7XG4gICAgY29uc3Qgdmlld1BvcnRhbERpdiA9IHVzZVN0b3JlKHNlbGVjdG9yJDUpO1xuICAgIGlmICghdmlld1BvcnRhbERpdikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZVBvcnRhbChjaGlsZHJlbiwgdmlld1BvcnRhbERpdik7XG59XG5cbi8qKlxuICogV2hlbiB5b3UgcHJvZ3JhbW1hdGljYWxseSBhZGQgb3IgcmVtb3ZlIGhhbmRsZXMgdG8gYSBub2RlIG9yIHVwZGF0ZSBhIG5vZGUnc1xuICpoYW5kbGUgcG9zaXRpb24sIHlvdSBuZWVkIHRvIGxldCBSZWFjdCBGbG93IGtub3cgYWJvdXQgaXQgdXNpbmcgdGhpcyBob29rLiBUaGlzXG4gKndpbGwgdXBkYXRlIHRoZSBpbnRlcm5hbCBkaW1lbnNpb25zIG9mIHRoZSBub2RlIGFuZCBwcm9wZXJseSByZXBvc2l0aW9uIGhhbmRsZXNcbiAqb24gdGhlIGNhbnZhcyBpZiBuZWNlc3NhcnkuXG4gKlxuICogQHB1YmxpY1xuICogQHJldHVybnMgZnVuY3Rpb24gZm9yIHVwZGF0aW5nIG5vZGUgaW50ZXJuYWxzXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzeFxuICppbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG4gKmltcG9ydCB7IEhhbmRsZSwgdXNlVXBkYXRlTm9kZUludGVybmFscyB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gUmFuZG9tSGFuZGxlTm9kZSh7IGlkIH0pIHtcbiAqICBjb25zdCB1cGRhdGVOb2RlSW50ZXJuYWxzID0gdXNlVXBkYXRlTm9kZUludGVybmFscygpO1xuICogIGNvbnN0IFtoYW5kbGVDb3VudCwgc2V0SGFuZGxlQ291bnRdID0gdXNlU3RhdGUoMCk7XG4gKiAgY29uc3QgcmFuZG9taXplSGFuZGxlQ291bnQgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gKiAgIHNldEhhbmRsZUNvdW50KE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwKSk7XG4gKiAgICB1cGRhdGVOb2RlSW50ZXJuYWxzKGlkKTtcbiAqICB9LCBbaWQsIHVwZGF0ZU5vZGVJbnRlcm5hbHNdKTtcbiAqXG4gKiAgcmV0dXJuIChcbiAqICAgIDw+XG4gKiAgICAgIHtBcnJheS5mcm9tKHsgbGVuZ3RoOiBoYW5kbGVDb3VudCB9KS5tYXAoKF8sIGluZGV4KSA9PiAoXG4gKiAgICAgICAgPEhhbmRsZVxuICogICAgICAgICAga2V5PXtpbmRleH1cbiAqICAgICAgICAgIHR5cGU9XCJ0YXJnZXRcIlxuICogICAgICAgICAgcG9zaXRpb249XCJsZWZ0XCJcbiAqICAgICAgICAgIGlkPXtgaGFuZGxlLSR7aW5kZXh9YH1cbiAqICAgICAgICAvPlxuICogICAgICApKX1cbiAqXG4gKiAgICAgIDxkaXY+XG4gKiAgICAgICAgPGJ1dHRvbiBvbkNsaWNrPXtyYW5kb21pemVIYW5kbGVDb3VudH0+UmFuZG9taXplIGhhbmRsZSBjb3VudDwvYnV0dG9uPlxuICogICAgICAgIDxwPlRoZXJlIGFyZSB7aGFuZGxlQ291bnR9IGhhbmRsZXMgb24gdGhpcyBub2RlLjwvcD5cbiAqICAgICAgPC9kaXY+XG4gKiAgICA8Lz5cbiAqICApO1xuICp9XG4gKmBgYFxuICogQHJlbWFya3MgVGhpcyBob29rIGNhbiBvbmx5IGJlIHVzZWQgaW4gYSBjb21wb25lbnQgdGhhdCBpcyBhIGNoaWxkIG9mIGFcbiAqe0BsaW5rIFJlYWN0Rmxvd1Byb3ZpZGVyfSBvciBhIHtAbGluayBSZWFjdEZsb3d9IGNvbXBvbmVudC5cbiAqL1xuZnVuY3Rpb24gdXNlVXBkYXRlTm9kZUludGVybmFscygpIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgcmV0dXJuIHVzZUNhbGxiYWNrKChpZCkgPT4ge1xuICAgICAgICBjb25zdCB7IGRvbU5vZGUsIHVwZGF0ZU5vZGVJbnRlcm5hbHMgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgIGNvbnN0IHVwZGF0ZUlkcyA9IEFycmF5LmlzQXJyYXkoaWQpID8gaWQgOiBbaWRdO1xuICAgICAgICBjb25zdCB1cGRhdGVzID0gbmV3IE1hcCgpO1xuICAgICAgICB1cGRhdGVJZHMuZm9yRWFjaCgodXBkYXRlSWQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGVFbGVtZW50ID0gZG9tTm9kZT8ucXVlcnlTZWxlY3RvcihgLnJlYWN0LWZsb3dfX25vZGVbZGF0YS1pZD1cIiR7dXBkYXRlSWR9XCJdYCk7XG4gICAgICAgICAgICBpZiAobm9kZUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVzLnNldCh1cGRhdGVJZCwgeyBpZDogdXBkYXRlSWQsIG5vZGVFbGVtZW50LCBmb3JjZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB1cGRhdGVOb2RlSW50ZXJuYWxzKHVwZGF0ZXMsIHsgdHJpZ2dlckZpdFZpZXc6IGZhbHNlIH0pKTtcbiAgICB9LCBbXSk7XG59XG5cbmNvbnN0IG5vZGVzU2VsZWN0b3IgPSAoc3RhdGUpID0+IHN0YXRlLm5vZGVzO1xuLyoqXG4gKiBUaGlzIGhvb2sgcmV0dXJucyBhbiBhcnJheSBvZiB0aGUgY3VycmVudCBub2Rlcy4gQ29tcG9uZW50cyB0aGF0IHVzZSB0aGlzIGhvb2tcbiAqIHdpbGwgcmUtcmVuZGVyICoqd2hlbmV2ZXIgYW55IG5vZGUgY2hhbmdlcyoqLCBpbmNsdWRpbmcgd2hlbiBhIG5vZGUgaXMgc2VsZWN0ZWRcbiAqIG9yIG1vdmVkLlxuICpcbiAqIEBwdWJsaWNcbiAqIEByZXR1cm5zIEFuIGFycmF5IG9mIG5vZGVzXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzeFxuICppbXBvcnQgeyB1c2VOb2RlcyB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24oKSB7XG4gKiAgY29uc3Qgbm9kZXMgPSB1c2VOb2RlcygpO1xuICpcbiAqICByZXR1cm4gPGRpdj5UaGVyZSBhcmUgY3VycmVudGx5IHtub2Rlcy5sZW5ndGh9IG5vZGVzITwvZGl2PjtcbiAqfVxuICpgYGBcbiAqL1xuZnVuY3Rpb24gdXNlTm9kZXMoKSB7XG4gICAgY29uc3Qgbm9kZXMgPSB1c2VTdG9yZShub2Rlc1NlbGVjdG9yLCBzaGFsbG93KTtcbiAgICByZXR1cm4gbm9kZXM7XG59XG5cbmNvbnN0IGVkZ2VzU2VsZWN0b3IgPSAoc3RhdGUpID0+IHN0YXRlLmVkZ2VzO1xuLyoqXG4gKiBUaGlzIGhvb2sgcmV0dXJucyBhbiBhcnJheSBvZiB0aGUgY3VycmVudCBlZGdlcy4gQ29tcG9uZW50cyB0aGF0IHVzZSB0aGlzIGhvb2tcbiAqIHdpbGwgcmUtcmVuZGVyICoqd2hlbmV2ZXIgYW55IGVkZ2UgY2hhbmdlcyoqLlxuICpcbiAqIEBwdWJsaWNcbiAqIEByZXR1cm5zIEFuIGFycmF5IG9mIGVkZ2VzXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzeFxuICppbXBvcnQgeyB1c2VFZGdlcyB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKCkge1xuICogIGNvbnN0IGVkZ2VzID0gdXNlRWRnZXMoKTtcbiAqXG4gKiAgcmV0dXJuIDxkaXY+VGhlcmUgYXJlIGN1cnJlbnRseSB7ZWRnZXMubGVuZ3RofSBlZGdlcyE8L2Rpdj47XG4gKn1cbiAqYGBgXG4gKi9cbmZ1bmN0aW9uIHVzZUVkZ2VzKCkge1xuICAgIGNvbnN0IGVkZ2VzID0gdXNlU3RvcmUoZWRnZXNTZWxlY3Rvciwgc2hhbGxvdyk7XG4gICAgcmV0dXJuIGVkZ2VzO1xufVxuXG5jb25zdCB2aWV3cG9ydFNlbGVjdG9yID0gKHN0YXRlKSA9PiAoe1xuICAgIHg6IHN0YXRlLnRyYW5zZm9ybVswXSxcbiAgICB5OiBzdGF0ZS50cmFuc2Zvcm1bMV0sXG4gICAgem9vbTogc3RhdGUudHJhbnNmb3JtWzJdLFxufSk7XG4vKipcbiAqIFRoZSBgdXNlVmlld3BvcnRgIGhvb2sgaXMgYSBjb252ZW5pZW50IHdheSB0byByZWFkIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZVxuICp7QGxpbmsgVmlld3BvcnR9IGluIGEgY29tcG9uZW50LiBDb21wb25lbnRzIHRoYXQgdXNlIHRoaXMgaG9va1xuICp3aWxsIHJlLXJlbmRlciAqKndoZW5ldmVyIHRoZSB2aWV3cG9ydCBjaGFuZ2VzKiouXG4gKlxuICogQHB1YmxpY1xuICogQHJldHVybnMgVGhlIGN1cnJlbnQgdmlld3BvcnRcbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqYGBganN4XG4gKmltcG9ydCB7IHVzZVZpZXdwb3J0IH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBWaWV3cG9ydERpc3BsYXkoKSB7XG4gKiAgY29uc3QgeyB4LCB5LCB6b29tIH0gPSB1c2VWaWV3cG9ydCgpO1xuICpcbiAqICByZXR1cm4gKFxuICogICAgPGRpdj5cbiAqICAgICAgPHA+XG4gKiAgICAgICAgVGhlIHZpZXdwb3J0IGlzIGN1cnJlbnRseSBhdCAoe3h9LCB7eX0pIGFuZCB6b29tZWQgdG8ge3pvb219LlxuICogICAgICA8L3A+XG4gKiAgICA8L2Rpdj5cbiAqICApO1xuICp9XG4gKmBgYFxuICpcbiAqIEByZW1hcmtzIFRoaXMgaG9vayBjYW4gb25seSBiZSB1c2VkIGluIGEgY29tcG9uZW50IHRoYXQgaXMgYSBjaGlsZCBvZiBhXG4gKntAbGluayBSZWFjdEZsb3dQcm92aWRlcn0gb3IgYSB7QGxpbmsgUmVhY3RGbG93fSBjb21wb25lbnQuXG4gKi9cbmZ1bmN0aW9uIHVzZVZpZXdwb3J0KCkge1xuICAgIGNvbnN0IHZpZXdwb3J0ID0gdXNlU3RvcmUodmlld3BvcnRTZWxlY3Rvciwgc2hhbGxvdyk7XG4gICAgcmV0dXJuIHZpZXdwb3J0O1xufVxuXG4vKipcbiAqIFRoaXMgaG9vayBtYWtlcyBpdCBlYXN5IHRvIHByb3RvdHlwZSBhIGNvbnRyb2xsZWQgZmxvdyB3aGVyZSB5b3UgbWFuYWdlIHRoZVxuICogc3RhdGUgb2Ygbm9kZXMgYW5kIGVkZ2VzIG91dHNpZGUgdGhlIGBSZWFjdEZsb3dJbnN0YW5jZWAuIFlvdSBjYW4gdGhpbmsgb2YgaXRcbiAqIGxpa2UgUmVhY3QncyBgdXNlU3RhdGVgIGhvb2sgd2l0aCBhbiBhZGRpdGlvbmFsIGhlbHBlciBjYWxsYmFjay5cbiAqXG4gKiBAcHVibGljXG4gKiBAcGFyYW0gaW5pdGlhbE5vZGVzXG4gKiBAcmV0dXJucyBhbiBhcnJheSBbbm9kZXMsIHNldE5vZGVzLCBvbk5vZGVzQ2hhbmdlXVxuICogQGV4YW1wbGVcbiAqXG4gKmBgYHRzeFxuICppbXBvcnQgeyBSZWFjdEZsb3csIHVzZU5vZGVzU3RhdGUsIHVzZUVkZ2VzU3RhdGUgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKmNvbnN0IGluaXRpYWxOb2RlcyA9IFtdO1xuICpjb25zdCBpbml0aWFsRWRnZXMgPSBbXTtcbiAqXG4gKmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uICgpIHtcbiAqICBjb25zdCBbbm9kZXMsIHNldE5vZGVzLCBvbk5vZGVzQ2hhbmdlXSA9IHVzZU5vZGVzU3RhdGUoaW5pdGlhbE5vZGVzKTtcbiAqICBjb25zdCBbZWRnZXMsIHNldEVkZ2VzLCBvbkVkZ2VzQ2hhbmdlXSA9IHVzZUVkZ2VzU3RhdGUoaW5pdGlhbEVkZ2VzKTtcbiAqXG4gKiAgcmV0dXJuIChcbiAqICAgIDxSZWFjdEZsb3dcbiAqICAgICAgbm9kZXM9e25vZGVzfVxuICogICAgICBlZGdlcz17ZWRnZXN9XG4gKiAgICAgIG9uTm9kZXNDaGFuZ2U9e29uTm9kZXNDaGFuZ2V9XG4gKiAgICAgIG9uRWRnZXNDaGFuZ2U9e29uRWRnZXNDaGFuZ2V9XG4gKiAgICAvPlxuICogICk7XG4gKn1cbiAqYGBgXG4gKlxuICogQHJlbWFya3MgVGhpcyBob29rIHdhcyBjcmVhdGVkIHRvIG1ha2UgcHJvdG90eXBpbmcgZWFzaWVyIGFuZCBvdXIgZG9jdW1lbnRhdGlvblxuICogZXhhbXBsZXMgY2xlYXJlci4gQWx0aG91Z2ggaXQgaXMgT0sgdG8gdXNlIHRoaXMgaG9vayBpbiBwcm9kdWN0aW9uLCBpblxuICogcHJhY3RpY2UgeW91IG1heSB3YW50IHRvIHVzZSBhIG1vcmUgc29waGlzdGljYXRlZCBzdGF0ZSBtYW5hZ2VtZW50IHNvbHV0aW9uXG4gKiBsaWtlIFp1c3RhbmQge0BsaW5rIGh0dHBzOi8vcmVhY3RmbG93LmRldi9kb2NzL2d1aWRlcy9zdGF0ZS1tYW5hZ2VtZW50L30gaW5zdGVhZC5cbiAqXG4gKi9cbmZ1bmN0aW9uIHVzZU5vZGVzU3RhdGUoaW5pdGlhbE5vZGVzKSB7XG4gICAgY29uc3QgW25vZGVzLCBzZXROb2Rlc10gPSB1c2VTdGF0ZShpbml0aWFsTm9kZXMpO1xuICAgIGNvbnN0IG9uTm9kZXNDaGFuZ2UgPSB1c2VDYWxsYmFjaygoY2hhbmdlcykgPT4gc2V0Tm9kZXMoKG5kcykgPT4gYXBwbHlOb2RlQ2hhbmdlcyhjaGFuZ2VzLCBuZHMpKSwgW10pO1xuICAgIHJldHVybiBbbm9kZXMsIHNldE5vZGVzLCBvbk5vZGVzQ2hhbmdlXTtcbn1cbi8qKlxuICogVGhpcyBob29rIG1ha2VzIGl0IGVhc3kgdG8gcHJvdG90eXBlIGEgY29udHJvbGxlZCBmbG93IHdoZXJlIHlvdSBtYW5hZ2UgdGhlXG4gKiBzdGF0ZSBvZiBub2RlcyBhbmQgZWRnZXMgb3V0c2lkZSB0aGUgYFJlYWN0Rmxvd0luc3RhbmNlYC4gWW91IGNhbiB0aGluayBvZiBpdFxuICogbGlrZSBSZWFjdCdzIGB1c2VTdGF0ZWAgaG9vayB3aXRoIGFuIGFkZGl0aW9uYWwgaGVscGVyIGNhbGxiYWNrLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSBpbml0aWFsRWRnZXNcbiAqIEByZXR1cm5zIGFuIGFycmF5IFtlZGdlcywgc2V0RWRnZXMsIG9uRWRnZXNDaGFuZ2VdXG4gKiBAZXhhbXBsZVxuICpcbiAqYGBgdHN4XG4gKmltcG9ydCB7IFJlYWN0RmxvdywgdXNlTm9kZXNTdGF0ZSwgdXNlRWRnZXNTdGF0ZSB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqY29uc3QgaW5pdGlhbE5vZGVzID0gW107XG4gKmNvbnN0IGluaXRpYWxFZGdlcyA9IFtdO1xuICpcbiAqZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKCkge1xuICogIGNvbnN0IFtub2Rlcywgc2V0Tm9kZXMsIG9uTm9kZXNDaGFuZ2VdID0gdXNlTm9kZXNTdGF0ZShpbml0aWFsTm9kZXMpO1xuICogIGNvbnN0IFtlZGdlcywgc2V0RWRnZXMsIG9uRWRnZXNDaGFuZ2VdID0gdXNlRWRnZXNTdGF0ZShpbml0aWFsRWRnZXMpO1xuICpcbiAqICByZXR1cm4gKFxuICogICAgPFJlYWN0Rmxvd1xuICogICAgICBub2Rlcz17bm9kZXN9XG4gKiAgICAgIGVkZ2VzPXtlZGdlc31cbiAqICAgICAgb25Ob2Rlc0NoYW5nZT17b25Ob2Rlc0NoYW5nZX1cbiAqICAgICAgb25FZGdlc0NoYW5nZT17b25FZGdlc0NoYW5nZX1cbiAqICAgIC8+XG4gKiAgKTtcbiAqfVxuICpgYGBcbiAqXG4gKiBAcmVtYXJrcyBUaGlzIGhvb2sgd2FzIGNyZWF0ZWQgdG8gbWFrZSBwcm90b3R5cGluZyBlYXNpZXIgYW5kIG91ciBkb2N1bWVudGF0aW9uXG4gKiBleGFtcGxlcyBjbGVhcmVyLiBBbHRob3VnaCBpdCBpcyBPSyB0byB1c2UgdGhpcyBob29rIGluIHByb2R1Y3Rpb24sIGluXG4gKiBwcmFjdGljZSB5b3UgbWF5IHdhbnQgdG8gdXNlIGEgbW9yZSBzb3BoaXN0aWNhdGVkIHN0YXRlIG1hbmFnZW1lbnQgc29sdXRpb25cbiAqIGxpa2UgWnVzdGFuZCB7QGxpbmsgaHR0cHM6Ly9yZWFjdGZsb3cuZGV2L2RvY3MvZ3VpZGVzL3N0YXRlLW1hbmFnZW1lbnQvfSBpbnN0ZWFkLlxuICpcbiAqL1xuZnVuY3Rpb24gdXNlRWRnZXNTdGF0ZShpbml0aWFsRWRnZXMpIHtcbiAgICBjb25zdCBbZWRnZXMsIHNldEVkZ2VzXSA9IHVzZVN0YXRlKGluaXRpYWxFZGdlcyk7XG4gICAgY29uc3Qgb25FZGdlc0NoYW5nZSA9IHVzZUNhbGxiYWNrKChjaGFuZ2VzKSA9PiBzZXRFZGdlcygoZWRzKSA9PiBhcHBseUVkZ2VDaGFuZ2VzKGNoYW5nZXMsIGVkcykpLCBbXSk7XG4gICAgcmV0dXJuIFtlZGdlcywgc2V0RWRnZXMsIG9uRWRnZXNDaGFuZ2VdO1xufVxuXG4vKipcbiAqIFRoZSBgdXNlT25WaWV3cG9ydENoYW5nZWAgaG9vayBsZXRzIHlvdSBsaXN0ZW4gZm9yIGNoYW5nZXMgdG8gdGhlIHZpZXdwb3J0IHN1Y2hcbiAqYXMgcGFubmluZyBhbmQgem9vbWluZy4gWW91IGNhbiBwcm92aWRlIGEgY2FsbGJhY2sgZm9yIGVhY2ggcGhhc2Ugb2YgYSB2aWV3cG9ydFxuICpjaGFuZ2U6IGBvblN0YXJ0YCwgYG9uQ2hhbmdlYCwgYW5kIGBvbkVuZGAuXG4gKlxuICogQHB1YmxpY1xuICogQHBhcmFtIHBhcmFtcy5vblN0YXJ0IC0gZ2V0cyBjYWxsZWQgd2hlbiB0aGUgdmlld3BvcnQgc3RhcnRzIGNoYW5naW5nXG4gKiBAcGFyYW0gcGFyYW1zLm9uQ2hhbmdlIC0gZ2V0cyBjYWxsZWQgd2hlbiB0aGUgdmlld3BvcnQgY2hhbmdlc1xuICogQHBhcmFtIHBhcmFtcy5vbkVuZCAtIGdldHMgY2FsbGVkIHdoZW4gdGhlIHZpZXdwb3J0IHN0b3BzIGNoYW5naW5nXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzeFxuICppbXBvcnQgeyB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcbiAqaW1wb3J0IHsgdXNlT25WaWV3cG9ydENoYW5nZSB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqZnVuY3Rpb24gVmlld3BvcnRDaGFuZ2VMb2dnZXIoKSB7XG4gKiAgdXNlT25WaWV3cG9ydENoYW5nZSh7XG4gKiAgICBvblN0YXJ0OiAodmlld3BvcnQ6IFZpZXdwb3J0KSA9PiBjb25zb2xlLmxvZygnc3RhcnQnLCB2aWV3cG9ydCksXG4gKiAgICBvbkNoYW5nZTogKHZpZXdwb3J0OiBWaWV3cG9ydCkgPT4gY29uc29sZS5sb2coJ2NoYW5nZScsIHZpZXdwb3J0KSxcbiAqICAgIG9uRW5kOiAodmlld3BvcnQ6IFZpZXdwb3J0KSA9PiBjb25zb2xlLmxvZygnZW5kJywgdmlld3BvcnQpLFxuICogIH0pO1xuICpcbiAqICByZXR1cm4gbnVsbDtcbiAqfVxuICpgYGBcbiAqL1xuZnVuY3Rpb24gdXNlT25WaWV3cG9ydENoYW5nZSh7IG9uU3RhcnQsIG9uQ2hhbmdlLCBvbkVuZCB9KSB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHN0b3JlLnNldFN0YXRlKHsgb25WaWV3cG9ydENoYW5nZVN0YXJ0OiBvblN0YXJ0IH0pO1xuICAgIH0sIFtvblN0YXJ0XSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgc3RvcmUuc2V0U3RhdGUoeyBvblZpZXdwb3J0Q2hhbmdlOiBvbkNoYW5nZSB9KTtcbiAgICB9LCBbb25DaGFuZ2VdKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7IG9uVmlld3BvcnRDaGFuZ2VFbmQ6IG9uRW5kIH0pO1xuICAgIH0sIFtvbkVuZF0pO1xufVxuXG4vKipcbiAqIFRoaXMgaG9vayBsZXRzIHlvdSBsaXN0ZW4gZm9yIGNoYW5nZXMgdG8gYm90aCBub2RlIGFuZCBlZGdlIHNlbGVjdGlvbi4gQXMgdGhlXG4gKm5hbWUgaW1wbGllcywgdGhlIGNhbGxiYWNrIHlvdSBwcm92aWRlIHdpbGwgYmUgY2FsbGVkIHdoZW5ldmVyIHRoZSBzZWxlY3Rpb24gb2ZcbiAqX2VpdGhlcl8gbm9kZXMgb3IgZWRnZXMgY2hhbmdlcy5cbiAqXG4gKiBAcHVibGljXG4gKiBAcGFyYW0gcGFyYW1zLm9uQ2hhbmdlIC0gVGhlIGhhbmRsZXIgdG8gcmVnaXN0ZXJcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganN4XG4gKmltcG9ydCB7IHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuICppbXBvcnQgeyBSZWFjdEZsb3csIHVzZU9uU2VsZWN0aW9uQ2hhbmdlIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpmdW5jdGlvbiBTZWxlY3Rpb25EaXNwbGF5KCkge1xuICogIGNvbnN0IFtzZWxlY3RlZE5vZGVzLCBzZXRTZWxlY3RlZE5vZGVzXSA9IHVzZVN0YXRlKFtdKTtcbiAqICBjb25zdCBbc2VsZWN0ZWRFZGdlcywgc2V0U2VsZWN0ZWRFZGdlc10gPSB1c2VTdGF0ZShbXSk7XG4gKlxuICogIC8vIHRoZSBwYXNzZWQgaGFuZGxlciBoYXMgdG8gYmUgbWVtb2l6ZWQsIG90aGVyd2lzZSB0aGUgaG9vayB3aWxsIG5vdCB3b3JrIGNvcnJlY3RseVxuICogIGNvbnN0IG9uQ2hhbmdlID0gdXNlQ2FsbGJhY2soKHsgbm9kZXMsIGVkZ2VzIH0pID0+IHtcbiAqICAgIHNldFNlbGVjdGVkTm9kZXMobm9kZXMubWFwKChub2RlKSA9PiBub2RlLmlkKSk7XG4gKiAgICBzZXRTZWxlY3RlZEVkZ2VzKGVkZ2VzLm1hcCgoZWRnZSkgPT4gZWRnZS5pZCkpO1xuICogIH0sIFtdKTtcbiAqXG4gKiAgdXNlT25TZWxlY3Rpb25DaGFuZ2Uoe1xuICogICAgb25DaGFuZ2UsXG4gKiAgfSk7XG4gKlxuICogIHJldHVybiAoXG4gKiAgICA8ZGl2PlxuICogICAgICA8cD5TZWxlY3RlZCBub2Rlczoge3NlbGVjdGVkTm9kZXMuam9pbignLCAnKX08L3A+XG4gKiAgICAgIDxwPlNlbGVjdGVkIGVkZ2VzOiB7c2VsZWN0ZWRFZGdlcy5qb2luKCcsICcpfTwvcD5cbiAqICAgIDwvZGl2PlxuICogICk7XG4gKn1cbiAqYGBgXG4gKlxuICogQHJlbWFya3MgWW91IG5lZWQgdG8gbWVtb2l6ZSB0aGUgcGFzc2VkIGBvbkNoYW5nZWAgaGFuZGxlciwgb3RoZXJ3aXNlIHRoZSBob29rIHdpbGwgbm90IHdvcmsgY29ycmVjdGx5LlxuICovXG5mdW5jdGlvbiB1c2VPblNlbGVjdGlvbkNoYW5nZSh7IG9uQ2hhbmdlLCB9KSB7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IG5leHRPblNlbGVjdGlvbkNoYW5nZUhhbmRsZXJzID0gWy4uLnN0b3JlLmdldFN0YXRlKCkub25TZWxlY3Rpb25DaGFuZ2VIYW5kbGVycywgb25DaGFuZ2VdO1xuICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7IG9uU2VsZWN0aW9uQ2hhbmdlSGFuZGxlcnM6IG5leHRPblNlbGVjdGlvbkNoYW5nZUhhbmRsZXJzIH0pO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmV4dEhhbmRsZXJzID0gc3RvcmUuZ2V0U3RhdGUoKS5vblNlbGVjdGlvbkNoYW5nZUhhbmRsZXJzLmZpbHRlcigoZm4pID0+IGZuICE9PSBvbkNoYW5nZSk7XG4gICAgICAgICAgICBzdG9yZS5zZXRTdGF0ZSh7IG9uU2VsZWN0aW9uQ2hhbmdlSGFuZGxlcnM6IG5leHRIYW5kbGVycyB9KTtcbiAgICAgICAgfTtcbiAgICB9LCBbb25DaGFuZ2VdKTtcbn1cblxuY29uc3Qgc2VsZWN0b3IkNCA9IChvcHRpb25zKSA9PiAocykgPT4ge1xuICAgIGlmIChzLm5vZGVMb29rdXAuc2l6ZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAoY29uc3QgWywgeyBoaWRkZW4sIGludGVybmFscyB9XSBvZiBzLm5vZGVMb29rdXApIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuaW5jbHVkZUhpZGRlbk5vZGVzIHx8ICFoaWRkZW4pIHtcbiAgICAgICAgICAgIGlmIChpbnRlcm5hbHMuaGFuZGxlQm91bmRzID09PSB1bmRlZmluZWQgfHwgIW5vZGVIYXNEaW1lbnNpb25zKGludGVybmFscy51c2VyTm9kZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuLyoqXG4gKiBUaGlzIGhvb2sgdGVsbHMgeW91IHdoZXRoZXIgYWxsIHRoZSBub2RlcyBpbiBhIGZsb3cgaGF2ZSBiZWVuIG1lYXN1cmVkIGFuZCBnaXZlblxuICphIHdpZHRoIGFuZCBoZWlnaHQuIFdoZW4geW91IGFkZCBhIG5vZGUgdG8gdGhlIGZsb3csIHRoaXMgaG9vayB3aWxsIHJldHVyblxuICpgZmFsc2VgIGFuZCB0aGVuIGB0cnVlYCBhZ2FpbiBvbmNlIHRoZSBub2RlIGhhcyBiZWVuIG1lYXN1cmVkLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSBvcHRpb25zLmluY2x1ZGVIaWRkZW5Ob2RlcyAtIGRlZmF1bHRzIHRvIGZhbHNlXG4gKiBAcmV0dXJucyBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciBhbGwgbm9kZXMgYXJlIGluaXRpYWxpemVkXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzeFxuICppbXBvcnQgeyB1c2VSZWFjdEZsb3csIHVzZU5vZGVzSW5pdGlhbGl6ZWQgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbiAqXG4gKmNvbnN0IG9wdGlvbnMgPSB7XG4gKiAgaW5jbHVkZUhpZGRlbk5vZGVzOiBmYWxzZSxcbiAqfTtcbiAqXG4gKmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHVzZUxheW91dCgpIHtcbiAqICBjb25zdCB7IGdldE5vZGVzIH0gPSB1c2VSZWFjdEZsb3coKTtcbiAqICBjb25zdCBub2Rlc0luaXRpYWxpemVkID0gdXNlTm9kZXNJbml0aWFsaXplZChvcHRpb25zKTtcbiAqICBjb25zdCBbbGF5b3V0ZWROb2Rlcywgc2V0TGF5b3V0ZWROb2Rlc10gPSB1c2VTdGF0ZShnZXROb2RlcygpKTtcbiAqXG4gKiAgdXNlRWZmZWN0KCgpID0+IHtcbiAqICAgIGlmIChub2Rlc0luaXRpYWxpemVkKSB7XG4gKiAgICAgIHNldExheW91dGVkTm9kZXMoeW91ckxheW91dGluZ0Z1bmN0aW9uKGdldE5vZGVzKCkpKTtcbiAqICAgIH1cbiAqICB9LCBbbm9kZXNJbml0aWFsaXplZF0pO1xuICpcbiAqICByZXR1cm4gbGF5b3V0ZWROb2RlcztcbiAqfVxuICpgYGBcbiAqL1xuZnVuY3Rpb24gdXNlTm9kZXNJbml0aWFsaXplZChvcHRpb25zID0ge1xuICAgIGluY2x1ZGVIaWRkZW5Ob2RlczogZmFsc2UsXG59KSB7XG4gICAgY29uc3QgaW5pdGlhbGl6ZWQgPSB1c2VTdG9yZShzZWxlY3RvciQ0KG9wdGlvbnMpKTtcbiAgICByZXR1cm4gaW5pdGlhbGl6ZWQ7XG59XG5cbi8qKlxuICogSG9vayB0byBjaGVjayBpZiBhIDxIYW5kbGUgLz4gaXMgY29ubmVjdGVkIHRvIGFub3RoZXIgPEhhbmRsZSAvPiBhbmQgZ2V0IHRoZSBjb25uZWN0aW9ucy5cbiAqXG4gKiBAcHVibGljXG4gKiBAZGVwcmVjYXRlZCBVc2UgYHVzZU5vZGVDb25uZWN0aW9uc2AgaW5zdGVhZC5cbiAqIEBwYXJhbSBwYXJhbS50eXBlIC0gaGFuZGxlIHR5cGUgJ3NvdXJjZScgb3IgJ3RhcmdldCdcbiAqIEBwYXJhbSBwYXJhbS5ub2RlSWQgLSBub2RlIGlkIC0gaWYgbm90IHByb3ZpZGVkLCB0aGUgbm9kZSBpZCBmcm9tIHRoZSBOb2RlSWRDb250ZXh0IGlzIHVzZWRcbiAqIEBwYXJhbSBwYXJhbS5pZCAtIHRoZSBoYW5kbGUgaWQgKHRoaXMgaXMgb25seSBuZWVkZWQgaWYgdGhlIG5vZGUgaGFzIG11bHRpcGxlIGhhbmRsZXMgb2YgdGhlIHNhbWUgdHlwZSlcbiAqIEBwYXJhbSBwYXJhbS5vbkNvbm5lY3QgLSBnZXRzIGNhbGxlZCB3aGVuIGEgY29ubmVjdGlvbiBpcyBlc3RhYmxpc2hlZFxuICogQHBhcmFtIHBhcmFtLm9uRGlzY29ubmVjdCAtIGdldHMgY2FsbGVkIHdoZW4gYSBjb25uZWN0aW9uIGlzIHJlbW92ZWRcbiAqIEByZXR1cm5zIGFuIGFycmF5IHdpdGggaGFuZGxlIGNvbm5lY3Rpb25zXG4gKi9cbmZ1bmN0aW9uIHVzZUhhbmRsZUNvbm5lY3Rpb25zKHsgdHlwZSwgaWQsIG5vZGVJZCwgb25Db25uZWN0LCBvbkRpc2Nvbm5lY3QsIH0pIHtcbiAgICBjb25zb2xlLndhcm4oJ1tERVBSRUNBVEVEXSBgdXNlSGFuZGxlQ29ubmVjdGlvbnNgIGlzIGRlcHJlY2F0ZWQuIEluc3RlYWQgdXNlIGB1c2VOb2RlQ29ubmVjdGlvbnNgIGh0dHBzOi8vcmVhY3RmbG93LmRldi9hcGktcmVmZXJlbmNlL2hvb2tzL3VzZU5vZGVDb25uZWN0aW9ucycpO1xuICAgIGNvbnN0IF9ub2RlSWQgPSB1c2VOb2RlSWQoKTtcbiAgICBjb25zdCBjdXJyZW50Tm9kZUlkID0gbm9kZUlkID8/IF9ub2RlSWQ7XG4gICAgY29uc3QgcHJldkNvbm5lY3Rpb25zID0gdXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IGNvbm5lY3Rpb25zID0gdXNlU3RvcmUoKHN0YXRlKSA9PiBzdGF0ZS5jb25uZWN0aW9uTG9va3VwLmdldChgJHtjdXJyZW50Tm9kZUlkfS0ke3R5cGV9JHtpZCA/IGAtJHtpZH1gIDogJyd9YCksIGFyZUNvbm5lY3Rpb25NYXBzRXF1YWwpO1xuICAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIC8vIEB0b2RvIGRpY3VzcyBpZiBvbkNvbm5lY3Qvb25EaXNjb25uZWN0IHNob3VsZCBiZSBjYWxsZWQgd2hlbiB0aGUgY29tcG9uZW50IG1vdW50cy91bm1vdW50c1xuICAgICAgICBpZiAocHJldkNvbm5lY3Rpb25zLmN1cnJlbnQgJiYgcHJldkNvbm5lY3Rpb25zLmN1cnJlbnQgIT09IGNvbm5lY3Rpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBfY29ubmVjdGlvbnMgPSBjb25uZWN0aW9ucyA/PyBuZXcgTWFwKCk7XG4gICAgICAgICAgICBoYW5kbGVDb25uZWN0aW9uQ2hhbmdlKHByZXZDb25uZWN0aW9ucy5jdXJyZW50LCBfY29ubmVjdGlvbnMsIG9uRGlzY29ubmVjdCk7XG4gICAgICAgICAgICBoYW5kbGVDb25uZWN0aW9uQ2hhbmdlKF9jb25uZWN0aW9ucywgcHJldkNvbm5lY3Rpb25zLmN1cnJlbnQsIG9uQ29ubmVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgcHJldkNvbm5lY3Rpb25zLmN1cnJlbnQgPSBjb25uZWN0aW9ucyA/PyBuZXcgTWFwKCk7XG4gICAgfSwgW2Nvbm5lY3Rpb25zLCBvbkNvbm5lY3QsIG9uRGlzY29ubmVjdF0pO1xuICAgIHJldHVybiB1c2VNZW1vKCgpID0+IEFycmF5LmZyb20oY29ubmVjdGlvbnM/LnZhbHVlcygpID8/IFtdKSwgW2Nvbm5lY3Rpb25zXSk7XG59XG5cbmNvbnN0IGVycm9yMDE0ID0gZXJyb3JNZXNzYWdlc1snZXJyb3IwMTQnXSgpO1xuLyoqXG4gKiBUaGlzIGhvb2sgcmV0dXJucyBhbiBhcnJheSBvZiBjb25uZWN0aW9ucyBvbiBhIHNwZWNpZmljIG5vZGUsIGhhbmRsZSB0eXBlICgnc291cmNlJywgJ3RhcmdldCcpIG9yIGhhbmRsZSBJRC5cbiAqXG4gKiBAcHVibGljXG4gKiBAcGFyYW0gcGFyYW0uaWQgLSBub2RlIGlkIC0gb3B0aW9uYWwgaWYgY2FsbGVkIGluc2lkZSBhIGN1c3RvbSBub2RlXG4gKiBAcGFyYW0gcGFyYW0uaGFuZGxlVHlwZSAtIGZpbHRlciBieSBoYW5kbGUgdHlwZSAnc291cmNlJyBvciAndGFyZ2V0J1xuICogQHBhcmFtIHBhcmFtLmhhbmRsZUlkIC0gZmlsdGVyIGJ5IGhhbmRsZSBpZCAodGhpcyBpcyBvbmx5IG5lZWRlZCBpZiB0aGUgbm9kZSBoYXMgbXVsdGlwbGUgaGFuZGxlcyBvZiB0aGUgc2FtZSB0eXBlKVxuICogQHBhcmFtIHBhcmFtLm9uQ29ubmVjdCAtIGdldHMgY2FsbGVkIHdoZW4gYSBjb25uZWN0aW9uIGlzIGVzdGFibGlzaGVkXG4gKiBAcGFyYW0gcGFyYW0ub25EaXNjb25uZWN0IC0gZ2V0cyBjYWxsZWQgd2hlbiBhIGNvbm5lY3Rpb24gaXMgcmVtb3ZlZFxuICogQHJldHVybnMgYW4gYXJyYXkgd2l0aCBjb25uZWN0aW9uc1xuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc3hcbiAqaW1wb3J0IHsgdXNlTm9kZUNvbm5lY3Rpb25zIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiAoKSB7XG4gKiAgY29uc3QgY29ubmVjdGlvbnMgPSB1c2VOb2RlQ29ubmVjdGlvbnMoe1xuICogICAgaGFuZGxlVHlwZTogJ3RhcmdldCcsXG4gKiAgICBoYW5kbGVJZDogJ215LWhhbmRsZScsXG4gKiAgfSk7XG4gKlxuICogIHJldHVybiAoXG4gKiAgICA8ZGl2PlRoZXJlIGFyZSBjdXJyZW50bHkge2Nvbm5lY3Rpb25zLmxlbmd0aH0gaW5jb21pbmcgY29ubmVjdGlvbnMhPC9kaXY+XG4gKiAgKTtcbiAqfVxuICpgYGBcbiAqL1xuZnVuY3Rpb24gdXNlTm9kZUNvbm5lY3Rpb25zKHsgaWQsIGhhbmRsZVR5cGUsIGhhbmRsZUlkLCBvbkNvbm5lY3QsIG9uRGlzY29ubmVjdCwgfSA9IHt9KSB7XG4gICAgY29uc3Qgbm9kZUlkID0gdXNlTm9kZUlkKCk7XG4gICAgY29uc3QgY3VycmVudE5vZGVJZCA9IGlkID8/IG5vZGVJZDtcbiAgICBpZiAoIWN1cnJlbnROb2RlSWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yMDE0KTtcbiAgICB9XG4gICAgY29uc3QgcHJldkNvbm5lY3Rpb25zID0gdXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IGNvbm5lY3Rpb25zID0gdXNlU3RvcmUoKHN0YXRlKSA9PiBzdGF0ZS5jb25uZWN0aW9uTG9va3VwLmdldChgJHtjdXJyZW50Tm9kZUlkfSR7aGFuZGxlVHlwZSA/IChoYW5kbGVJZCA/IGAtJHtoYW5kbGVUeXBlfS0ke2hhbmRsZUlkfWAgOiBgLSR7aGFuZGxlVHlwZX1gKSA6ICcnfWApLCBhcmVDb25uZWN0aW9uTWFwc0VxdWFsKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICAvLyBAdG9kbyBkaWN1c3MgaWYgb25Db25uZWN0L29uRGlzY29ubmVjdCBzaG91bGQgYmUgY2FsbGVkIHdoZW4gdGhlIGNvbXBvbmVudCBtb3VudHMvdW5tb3VudHNcbiAgICAgICAgaWYgKHByZXZDb25uZWN0aW9ucy5jdXJyZW50ICYmIHByZXZDb25uZWN0aW9ucy5jdXJyZW50ICE9PSBjb25uZWN0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgX2Nvbm5lY3Rpb25zID0gY29ubmVjdGlvbnMgPz8gbmV3IE1hcCgpO1xuICAgICAgICAgICAgaGFuZGxlQ29ubmVjdGlvbkNoYW5nZShwcmV2Q29ubmVjdGlvbnMuY3VycmVudCwgX2Nvbm5lY3Rpb25zLCBvbkRpc2Nvbm5lY3QpO1xuICAgICAgICAgICAgaGFuZGxlQ29ubmVjdGlvbkNoYW5nZShfY29ubmVjdGlvbnMsIHByZXZDb25uZWN0aW9ucy5jdXJyZW50LCBvbkNvbm5lY3QpO1xuICAgICAgICB9XG4gICAgICAgIHByZXZDb25uZWN0aW9ucy5jdXJyZW50ID0gY29ubmVjdGlvbnMgPz8gbmV3IE1hcCgpO1xuICAgIH0sIFtjb25uZWN0aW9ucywgb25Db25uZWN0LCBvbkRpc2Nvbm5lY3RdKTtcbiAgICByZXR1cm4gdXNlTWVtbygoKSA9PiBBcnJheS5mcm9tKGNvbm5lY3Rpb25zPy52YWx1ZXMoKSA/PyBbXSksIFtjb25uZWN0aW9uc10pO1xufVxuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuZnVuY3Rpb24gdXNlTm9kZXNEYXRhKG5vZGVJZHMpIHtcbiAgICBjb25zdCBub2Rlc0RhdGEgPSB1c2VTdG9yZSh1c2VDYWxsYmFjaygocykgPT4ge1xuICAgICAgICBjb25zdCBkYXRhID0gW107XG4gICAgICAgIGNvbnN0IGlzQXJyYXlPZklkcyA9IEFycmF5LmlzQXJyYXkobm9kZUlkcyk7XG4gICAgICAgIGNvbnN0IF9ub2RlSWRzID0gaXNBcnJheU9mSWRzID8gbm9kZUlkcyA6IFtub2RlSWRzXTtcbiAgICAgICAgZm9yIChjb25zdCBub2RlSWQgb2YgX25vZGVJZHMpIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBzLm5vZGVMb29rdXAuZ2V0KG5vZGVJZCk7XG4gICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICAgIGRhdGEucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBub2RlLmlkLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBub2RlLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IG5vZGUuZGF0YSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNBcnJheU9mSWRzID8gZGF0YSA6IGRhdGFbMF0gPz8gbnVsbDtcbiAgICB9LCBbbm9kZUlkc10pLCBzaGFsbG93Tm9kZURhdGEpO1xuICAgIHJldHVybiBub2Rlc0RhdGE7XG59XG5cbi8qKlxuICogVGhpcyBob29rIHJldHVybnMgdGhlIGludGVybmFsIHJlcHJlc2VudGF0aW9uIG9mIGEgc3BlY2lmaWMgbm9kZS5cbiAqIENvbXBvbmVudHMgdGhhdCB1c2UgdGhpcyBob29rIHdpbGwgcmUtcmVuZGVyICoqd2hlbmV2ZXIgdGhlIG5vZGUgY2hhbmdlcyoqLFxuICogaW5jbHVkaW5nIHdoZW4gYSBub2RlIGlzIHNlbGVjdGVkIG9yIG1vdmVkLlxuICpcbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSBpZCAtIGlkIG9mIHRoZSBub2RlXG4gKiBAcmV0dXJucyBhcnJheSB3aXRoIHZpc2libGUgbm9kZSBpZHNcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHN4XG4gKmltcG9ydCB7IHVzZUludGVybmFsTm9kZSB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gKCkge1xuICogIGNvbnN0IGludGVybmFsTm9kZSA9IHVzZUludGVybmFsTm9kZSgnbm9kZS0xJyk7XG4gKiAgY29uc3QgYWJzb2x1dGVQb3NpdGlvbiA9IGludGVybmFsTm9kZS5pbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZTtcbiAqXG4gKiAgcmV0dXJuIChcbiAqICAgIDxkaXY+XG4gKiAgICAgIFRoZSBhYnNvbHV0ZSBwb3NpdGlvbiBvZiB0aGUgbm9kZSBpcyBhdDpcbiAqICAgICAgPHA+eDoge2Fic29sdXRlUG9zaXRpb24ueH08L3A+XG4gKiAgICAgIDxwPnk6IHthYnNvbHV0ZVBvc2l0aW9uLnl9PC9wPlxuICogICAgPC9kaXY+XG4gKiAgKTtcbiAqfVxuICpgYGBcbiAqL1xuZnVuY3Rpb24gdXNlSW50ZXJuYWxOb2RlKGlkKSB7XG4gICAgY29uc3Qgbm9kZSA9IHVzZVN0b3JlKHVzZUNhbGxiYWNrKChzKSA9PiBzLm5vZGVMb29rdXAuZ2V0KGlkKSwgW2lkXSksIHNoYWxsb3cpO1xuICAgIHJldHVybiBub2RlO1xufVxuXG5mdW5jdGlvbiBMaW5lUGF0dGVybih7IGRpbWVuc2lvbnMsIGxpbmVXaWR0aCwgdmFyaWFudCwgY2xhc3NOYW1lIH0pIHtcbiAgICByZXR1cm4gKGpzeChcInBhdGhcIiwgeyBzdHJva2VXaWR0aDogbGluZVdpZHRoLCBkOiBgTSR7ZGltZW5zaW9uc1swXSAvIDJ9IDAgViR7ZGltZW5zaW9uc1sxXX0gTTAgJHtkaW1lbnNpb25zWzFdIC8gMn0gSCR7ZGltZW5zaW9uc1swXX1gLCBjbGFzc05hbWU6IGNjKFsncmVhY3QtZmxvd19fYmFja2dyb3VuZC1wYXR0ZXJuJywgdmFyaWFudCwgY2xhc3NOYW1lXSkgfSkpO1xufVxuZnVuY3Rpb24gRG90UGF0dGVybih7IHJhZGl1cywgY2xhc3NOYW1lIH0pIHtcbiAgICByZXR1cm4gKGpzeChcImNpcmNsZVwiLCB7IGN4OiByYWRpdXMsIGN5OiByYWRpdXMsIHI6IHJhZGl1cywgY2xhc3NOYW1lOiBjYyhbJ3JlYWN0LWZsb3dfX2JhY2tncm91bmQtcGF0dGVybicsICdkb3RzJywgY2xhc3NOYW1lXSkgfSkpO1xufVxuXG4vKipcbiAqIFRoZSB0aHJlZSB2YXJpYW50cyBhcmUgZXhwb3J0ZWQgYXMgYW4gZW51bSBmb3IgY29udmVuaWVuY2UuIFlvdSBjYW4gZWl0aGVyIGltcG9ydFxuICogdGhlIGVudW0gYW5kIHVzZSBpdCBsaWtlIGBCYWNrZ3JvdW5kVmFyaWFudC5MaW5lc2Agb3IgeW91IGNhbiB1c2UgdGhlIHJhdyBzdHJpbmdcbiAqIHZhbHVlIGRpcmVjdGx5LlxuICogQHB1YmxpY1xuICovXG52YXIgQmFja2dyb3VuZFZhcmlhbnQ7XG4oZnVuY3Rpb24gKEJhY2tncm91bmRWYXJpYW50KSB7XG4gICAgQmFja2dyb3VuZFZhcmlhbnRbXCJMaW5lc1wiXSA9IFwibGluZXNcIjtcbiAgICBCYWNrZ3JvdW5kVmFyaWFudFtcIkRvdHNcIl0gPSBcImRvdHNcIjtcbiAgICBCYWNrZ3JvdW5kVmFyaWFudFtcIkNyb3NzXCJdID0gXCJjcm9zc1wiO1xufSkoQmFja2dyb3VuZFZhcmlhbnQgfHwgKEJhY2tncm91bmRWYXJpYW50ID0ge30pKTtcblxuY29uc3QgZGVmYXVsdFNpemUgPSB7XG4gICAgW0JhY2tncm91bmRWYXJpYW50LkRvdHNdOiAxLFxuICAgIFtCYWNrZ3JvdW5kVmFyaWFudC5MaW5lc106IDEsXG4gICAgW0JhY2tncm91bmRWYXJpYW50LkNyb3NzXTogNixcbn07XG5jb25zdCBzZWxlY3RvciQzID0gKHMpID0+ICh7IHRyYW5zZm9ybTogcy50cmFuc2Zvcm0sIHBhdHRlcm5JZDogYHBhdHRlcm4tJHtzLnJmSWR9YCB9KTtcbmZ1bmN0aW9uIEJhY2tncm91bmRDb21wb25lbnQoeyBpZCwgdmFyaWFudCA9IEJhY2tncm91bmRWYXJpYW50LkRvdHMsIFxuLy8gb25seSB1c2VkIGZvciBkb3RzIGFuZCBjcm9zc1xuZ2FwID0gMjAsIFxuLy8gb25seSB1c2VkIGZvciBsaW5lcyBhbmQgY3Jvc3NcbnNpemUsIGxpbmVXaWR0aCA9IDEsIG9mZnNldCA9IDAsIGNvbG9yLCBiZ0NvbG9yLCBzdHlsZSwgY2xhc3NOYW1lLCBwYXR0ZXJuQ2xhc3NOYW1lLCB9KSB7XG4gICAgY29uc3QgcmVmID0gdXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IHsgdHJhbnNmb3JtLCBwYXR0ZXJuSWQgfSA9IHVzZVN0b3JlKHNlbGVjdG9yJDMsIHNoYWxsb3cpO1xuICAgIGNvbnN0IHBhdHRlcm5TaXplID0gc2l6ZSB8fCBkZWZhdWx0U2l6ZVt2YXJpYW50XTtcbiAgICBjb25zdCBpc0RvdHMgPSB2YXJpYW50ID09PSBCYWNrZ3JvdW5kVmFyaWFudC5Eb3RzO1xuICAgIGNvbnN0IGlzQ3Jvc3MgPSB2YXJpYW50ID09PSBCYWNrZ3JvdW5kVmFyaWFudC5Dcm9zcztcbiAgICBjb25zdCBnYXBYWSA9IEFycmF5LmlzQXJyYXkoZ2FwKSA/IGdhcCA6IFtnYXAsIGdhcF07XG4gICAgY29uc3Qgc2NhbGVkR2FwID0gW2dhcFhZWzBdICogdHJhbnNmb3JtWzJdIHx8IDEsIGdhcFhZWzFdICogdHJhbnNmb3JtWzJdIHx8IDFdO1xuICAgIGNvbnN0IHNjYWxlZFNpemUgPSBwYXR0ZXJuU2l6ZSAqIHRyYW5zZm9ybVsyXTtcbiAgICBjb25zdCBvZmZzZXRYWSA9IEFycmF5LmlzQXJyYXkob2Zmc2V0KSA/IG9mZnNldCA6IFtvZmZzZXQsIG9mZnNldF07XG4gICAgY29uc3QgcGF0dGVybkRpbWVuc2lvbnMgPSBpc0Nyb3NzID8gW3NjYWxlZFNpemUsIHNjYWxlZFNpemVdIDogc2NhbGVkR2FwO1xuICAgIGNvbnN0IHNjYWxlZE9mZnNldCA9IFtcbiAgICAgICAgb2Zmc2V0WFlbMF0gKiB0cmFuc2Zvcm1bMl0gfHwgMSArIHBhdHRlcm5EaW1lbnNpb25zWzBdIC8gMixcbiAgICAgICAgb2Zmc2V0WFlbMV0gKiB0cmFuc2Zvcm1bMl0gfHwgMSArIHBhdHRlcm5EaW1lbnNpb25zWzFdIC8gMixcbiAgICBdO1xuICAgIGNvbnN0IF9wYXR0ZXJuSWQgPSBgJHtwYXR0ZXJuSWR9JHtpZCA/IGlkIDogJyd9YDtcbiAgICByZXR1cm4gKGpzeHMoXCJzdmdcIiwgeyBjbGFzc05hbWU6IGNjKFsncmVhY3QtZmxvd19fYmFja2dyb3VuZCcsIGNsYXNzTmFtZV0pLCBzdHlsZToge1xuICAgICAgICAgICAgLi4uc3R5bGUsXG4gICAgICAgICAgICAuLi5jb250YWluZXJTdHlsZSxcbiAgICAgICAgICAgICctLXh5LWJhY2tncm91bmQtY29sb3ItcHJvcHMnOiBiZ0NvbG9yLFxuICAgICAgICAgICAgJy0teHktYmFja2dyb3VuZC1wYXR0ZXJuLWNvbG9yLXByb3BzJzogY29sb3IsXG4gICAgICAgIH0sIHJlZjogcmVmLCBcImRhdGEtdGVzdGlkXCI6IFwicmZfX2JhY2tncm91bmRcIiwgY2hpbGRyZW46IFtqc3goXCJwYXR0ZXJuXCIsIHsgaWQ6IF9wYXR0ZXJuSWQsIHg6IHRyYW5zZm9ybVswXSAlIHNjYWxlZEdhcFswXSwgeTogdHJhbnNmb3JtWzFdICUgc2NhbGVkR2FwWzFdLCB3aWR0aDogc2NhbGVkR2FwWzBdLCBoZWlnaHQ6IHNjYWxlZEdhcFsxXSwgcGF0dGVyblVuaXRzOiBcInVzZXJTcGFjZU9uVXNlXCIsIHBhdHRlcm5UcmFuc2Zvcm06IGB0cmFuc2xhdGUoLSR7c2NhbGVkT2Zmc2V0WzBdfSwtJHtzY2FsZWRPZmZzZXRbMV19KWAsIGNoaWxkcmVuOiBpc0RvdHMgPyAoanN4KERvdFBhdHRlcm4sIHsgcmFkaXVzOiBzY2FsZWRTaXplIC8gMiwgY2xhc3NOYW1lOiBwYXR0ZXJuQ2xhc3NOYW1lIH0pKSA6IChqc3goTGluZVBhdHRlcm4sIHsgZGltZW5zaW9uczogcGF0dGVybkRpbWVuc2lvbnMsIGxpbmVXaWR0aDogbGluZVdpZHRoLCB2YXJpYW50OiB2YXJpYW50LCBjbGFzc05hbWU6IHBhdHRlcm5DbGFzc05hbWUgfSkpIH0pLCBqc3goXCJyZWN0XCIsIHsgeDogXCIwXCIsIHk6IFwiMFwiLCB3aWR0aDogXCIxMDAlXCIsIGhlaWdodDogXCIxMDAlXCIsIGZpbGw6IGB1cmwoIyR7X3BhdHRlcm5JZH0pYCB9KV0gfSkpO1xufVxuQmFja2dyb3VuZENvbXBvbmVudC5kaXNwbGF5TmFtZSA9ICdCYWNrZ3JvdW5kJztcbi8qKlxuICogVGhlIGA8QmFja2dyb3VuZCAvPmAgY29tcG9uZW50IG1ha2VzIGl0IGNvbnZlbmllbnQgdG8gcmVuZGVyIGRpZmZlcmVudCB0eXBlcyBvZiBiYWNrZ3JvdW5kcyBjb21tb24gaW4gbm9kZS1iYXNlZCBVSXMuIEl0IGNvbWVzIHdpdGggdGhyZWUgdmFyaWFudHM6IGxpbmVzLCBkb3RzIGFuZCBjcm9zcy5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIEEgc2ltcGxlIGV4YW1wbGUgb2YgaG93IHRvIHVzZSB0aGUgQmFja2dyb3VuZCBjb21wb25lbnQuXG4gKlxuICogYGBgdHN4XG4gKiBpbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcbiAqIGltcG9ydCB7IFJlYWN0RmxvdywgQmFja2dyb3VuZCwgQmFja2dyb3VuZFZhcmlhbnQgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKiBleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBGbG93KCkge1xuICogICByZXR1cm4gKFxuICogICAgIDxSZWFjdEZsb3cgZGVmYXVsdE5vZGVzPXtbLi4uXX0gZGVmYXVsdEVkZ2VzPXtbLi4uXX0+XG4gKiAgICAgICA8QmFja2dyb3VuZCBjb2xvcj1cIiNjY2NcIiB2YXJpYW50PXtCYWNrZ3JvdW5kVmFyaWFudC5Eb3RzfSAvPlxuICogICAgIDwvUmVhY3RGbG93PlxuICogICApO1xuICogfVxuICogYGBgXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBJbiB0aGlzIGV4YW1wbGUgeW91IGNhbiBzZWUgaG93IHRvIGNvbWJpbmUgbXVsdGlwbGUgYmFja2dyb3VuZHNcbiAqXG4gKiBgYGB0c3hcbiAqIGltcG9ydCB7IFJlYWN0RmxvdywgQmFja2dyb3VuZCwgQmFja2dyb3VuZFZhcmlhbnQgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqIGltcG9ydCAnQHh5Zmxvdy9yZWFjdC9kaXN0L3N0eWxlLmNzcyc7XG4gKlxuICogZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gRmxvdygpIHtcbiAqICAgcmV0dXJuIChcbiAqICAgICA8UmVhY3RGbG93IGRlZmF1bHROb2Rlcz17Wy4uLl19IGRlZmF1bHRFZGdlcz17Wy4uLl19PlxuICogICAgICAgPEJhY2tncm91bmRcbiAqICAgICAgICAgaWQ9XCIxXCJcbiAqICAgICAgICAgZ2FwPXsxMH1cbiAqICAgICAgICAgY29sb3I9XCIjZjFmMWYxXCJcbiAqICAgICAgICAgdmFyaWFudD17QmFja2dyb3VuZFZhcmlhbnQuTGluZXN9XG4gKiAgICAgICAvPlxuICogICAgICAgPEJhY2tncm91bmRcbiAqICAgICAgICAgaWQ9XCIyXCJcbiAqICAgICAgICAgZ2FwPXsxMDB9XG4gKiAgICAgICAgIGNvbG9yPVwiI2NjY1wiXG4gKiAgICAgICAgIHZhcmlhbnQ9e0JhY2tncm91bmRWYXJpYW50LkxpbmVzfVxuICogICAgICAgLz5cbiAqICAgICA8L1JlYWN0Rmxvdz5cbiAqICAgKTtcbiAqIH1cbiAqIGBgYFxuICpcbiAqIEByZW1hcmtzXG4gKlxuICogV2hlbiBjb21iaW5pbmcgbXVsdGlwbGUgPEJhY2tncm91bmQgLz4gY29tcG9uZW50cyBpdOKAmXMgaW1wb3J0YW50IHRvIGdpdmUgZWFjaCBvZiB0aGVtIGEgdW5pcXVlIGlkIHByb3AhXG4gKlxuICovXG5jb25zdCBCYWNrZ3JvdW5kID0gbWVtbyhCYWNrZ3JvdW5kQ29tcG9uZW50KTtcblxuZnVuY3Rpb24gUGx1c0ljb24oKSB7XG4gICAgcmV0dXJuIChqc3goXCJzdmdcIiwgeyB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCB2aWV3Qm94OiBcIjAgMCAzMiAzMlwiLCBjaGlsZHJlbjoganN4KFwicGF0aFwiLCB7IGQ6IFwiTTMyIDE4LjEzM0gxOC4xMzNWMzJoLTQuMjY2VjE4LjEzM0gwdi00LjI2NmgxMy44NjdWMGg0LjI2NnYxMy44NjdIMzJ6XCIgfSkgfSkpO1xufVxuXG5mdW5jdGlvbiBNaW51c0ljb24oKSB7XG4gICAgcmV0dXJuIChqc3goXCJzdmdcIiwgeyB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCB2aWV3Qm94OiBcIjAgMCAzMiA1XCIsIGNoaWxkcmVuOiBqc3goXCJwYXRoXCIsIHsgZDogXCJNMCAwaDMydjQuMkgwelwiIH0pIH0pKTtcbn1cblxuZnVuY3Rpb24gRml0Vmlld0ljb24oKSB7XG4gICAgcmV0dXJuIChqc3goXCJzdmdcIiwgeyB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCB2aWV3Qm94OiBcIjAgMCAzMiAzMFwiLCBjaGlsZHJlbjoganN4KFwicGF0aFwiLCB7IGQ6IFwiTTMuNjkyIDQuNjNjMC0uNTMuNC0uOTM4LjkzOS0uOTM4aDUuMjE1VjBINC43MDhDMi4xMyAwIDAgMi4wNTQgMCA0LjYzdjUuMjE2aDMuNjkyVjQuNjMxek0yNy4zNTQgMGgtNS4ydjMuNjkyaDUuMTdjLjUzIDAgLjk4NC40Ljk4NC45Mzl2NS4yMTVIMzJWNC42MzFBNC42MjQgNC42MjQgMCAwMDI3LjM1NCAwem0uOTU0IDI0LjgzYzAgLjUzMi0uNC45NC0uOTM5Ljk0aC01LjIxNXYzLjc2OGg1LjIxNWMyLjU3NyAwIDQuNjMxLTIuMTMgNC42MzEtNC43MDd2LTUuMTM5aC0zLjY5MnY1LjEzOXptLTIzLjY3Ny45NGMtLjUzMSAwLS45MzktLjQtLjkzOS0uOTR2LTUuMTM4SDB2NS4xMzljMCAyLjU3NyAyLjEzIDQuNzA3IDQuNzA4IDQuNzA3aDUuMTM4VjI1Ljc3SDQuNjMxelwiIH0pIH0pKTtcbn1cblxuZnVuY3Rpb24gTG9ja0ljb24oKSB7XG4gICAgcmV0dXJuIChqc3goXCJzdmdcIiwgeyB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCB2aWV3Qm94OiBcIjAgMCAyNSAzMlwiLCBjaGlsZHJlbjoganN4KFwicGF0aFwiLCB7IGQ6IFwiTTIxLjMzMyAxMC42NjdIMTkuODFWNy42MTlDMTkuODEgMy40MjkgMTYuMzggMCAxMi4xOSAwIDggMCA0LjU3MSAzLjQyOSA0LjU3MSA3LjYxOXYzLjA0OEgzLjA0OEEzLjA1NiAzLjA1NiAwIDAwMCAxMy43MTR2MTUuMjM4QTMuMDU2IDMuMDU2IDAgMDAzLjA0OCAzMmgxOC4yODVhMy4wNTYgMy4wNTYgMCAwMDMuMDQ4LTMuMDQ4VjEzLjcxNGEzLjA1NiAzLjA1NiAwIDAwLTMuMDQ4LTMuMDQ3ek0xMi4xOSAyNC41MzNhMy4wNTYgMy4wNTYgMCAwMS0zLjA0Ny0zLjA0NyAzLjA1NiAzLjA1NiAwIDAxMy4wNDctMy4wNDggMy4wNTYgMy4wNTYgMCAwMTMuMDQ4IDMuMDQ4IDMuMDU2IDMuMDU2IDAgMDEtMy4wNDggMy4wNDd6bTQuNzI0LTEzLjg2Nkg3LjQ2N1Y3LjYxOWMwLTIuNTkgMi4xMzMtNC43MjQgNC43MjMtNC43MjQgMi41OTEgMCA0LjcyNCAyLjEzMyA0LjcyNCA0LjcyNHYzLjA0OHpcIiB9KSB9KSk7XG59XG5cbmZ1bmN0aW9uIFVubG9ja0ljb24oKSB7XG4gICAgcmV0dXJuIChqc3goXCJzdmdcIiwgeyB4bWxuczogXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiLCB2aWV3Qm94OiBcIjAgMCAyNSAzMlwiLCBjaGlsZHJlbjoganN4KFwicGF0aFwiLCB7IGQ6IFwiTTIxLjMzMyAxMC42NjdIMTkuODFWNy42MTlDMTkuODEgMy40MjkgMTYuMzggMCAxMi4xOSAwYy00LjExNCAxLjgyOC0xLjM3IDIuMTMzLjMwNSAyLjQzOCAxLjY3Ni4zMDUgNC40MiAyLjU5IDQuNDIgNS4xODF2My4wNDhIMy4wNDdBMy4wNTYgMy4wNTYgMCAwMDAgMTMuNzE0djE1LjIzOEEzLjA1NiAzLjA1NiAwIDAwMy4wNDggMzJoMTguMjg1YTMuMDU2IDMuMDU2IDAgMDAzLjA0OC0zLjA0OFYxMy43MTRhMy4wNTYgMy4wNTYgMCAwMC0zLjA0OC0zLjA0N3pNMTIuMTkgMjQuNTMzYTMuMDU2IDMuMDU2IDAgMDEtMy4wNDctMy4wNDcgMy4wNTYgMy4wNTYgMCAwMTMuMDQ3LTMuMDQ4IDMuMDU2IDMuMDU2IDAgMDEzLjA0OCAzLjA0OCAzLjA1NiAzLjA1NiAwIDAxLTMuMDQ4IDMuMDQ3elwiIH0pIH0pKTtcbn1cblxuLyoqXG4gKiBZb3UgY2FuIGFkZCBidXR0b25zIHRvIHRoZSBjb250cm9sIHBhbmVsIGJ5IHVzaW5nIHRoZSBgPENvbnRyb2xCdXR0b24gLz5gIGNvbXBvbmVudFxuICogYW5kIHBhc3MgaXQgYXMgYSBjaGlsZCB0byB0aGUgW2A8Q29udHJvbHMgLz5gXSgvYXBpLXJlZmVyZW5jZS9jb21wb25lbnRzL2NvbnRyb2xzKSBjb21wb25lbnQuXG4gKlxuICogQHB1YmxpY1xuICogQGV4YW1wbGVcbiAqYGBganN4XG4gKmltcG9ydCB7IE1hZ2ljV2FuZCB9IGZyb20gJ0ByYWRpeC11aS9yZWFjdC1pY29ucydcbiAqaW1wb3J0IHsgUmVhY3RGbG93LCBDb250cm9scywgQ29udHJvbEJ1dHRvbiB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnXG4gKlxuICpleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBGbG93KCkge1xuICogIHJldHVybiAoXG4gKiAgICA8UmVhY3RGbG93IG5vZGVzPXtbLi4uXX0gZWRnZXM9e1suLi5dfT5cbiAqICAgICAgPENvbnRyb2xzPlxuICogICAgICAgIDxDb250cm9sQnV0dG9uIG9uQ2xpY2s9eygpID0+IGFsZXJ0KCdTb21ldGhpbmcgbWFnaWNhbCBqdXN0IGhhcHBlbmVkLiDinKgnKX0+XG4gKiAgICAgICAgICA8TWFnaWNXYW5kIC8+XG4gKiAgICAgICAgPC9Db250cm9sQnV0dG9uPlxuICogICAgICA8L0NvbnRyb2xzPlxuICogICAgPC9SZWFjdEZsb3c+XG4gKiAgKVxuICp9XG4gKmBgYFxuICovXG5mdW5jdGlvbiBDb250cm9sQnV0dG9uKHsgY2hpbGRyZW4sIGNsYXNzTmFtZSwgLi4ucmVzdCB9KSB7XG4gICAgcmV0dXJuIChqc3goXCJidXR0b25cIiwgeyB0eXBlOiBcImJ1dHRvblwiLCBjbGFzc05hbWU6IGNjKFsncmVhY3QtZmxvd19fY29udHJvbHMtYnV0dG9uJywgY2xhc3NOYW1lXSksIC4uLnJlc3QsIGNoaWxkcmVuOiBjaGlsZHJlbiB9KSk7XG59XG5cbmNvbnN0IHNlbGVjdG9yJDIgPSAocykgPT4gKHtcbiAgICBpc0ludGVyYWN0aXZlOiBzLm5vZGVzRHJhZ2dhYmxlIHx8IHMubm9kZXNDb25uZWN0YWJsZSB8fCBzLmVsZW1lbnRzU2VsZWN0YWJsZSxcbiAgICBtaW5ab29tUmVhY2hlZDogcy50cmFuc2Zvcm1bMl0gPD0gcy5taW5ab29tLFxuICAgIG1heFpvb21SZWFjaGVkOiBzLnRyYW5zZm9ybVsyXSA+PSBzLm1heFpvb20sXG59KTtcbmZ1bmN0aW9uIENvbnRyb2xzQ29tcG9uZW50KHsgc3R5bGUsIHNob3dab29tID0gdHJ1ZSwgc2hvd0ZpdFZpZXcgPSB0cnVlLCBzaG93SW50ZXJhY3RpdmUgPSB0cnVlLCBmaXRWaWV3T3B0aW9ucywgb25ab29tSW4sIG9uWm9vbU91dCwgb25GaXRWaWV3LCBvbkludGVyYWN0aXZlQ2hhbmdlLCBjbGFzc05hbWUsIGNoaWxkcmVuLCBwb3NpdGlvbiA9ICdib3R0b20tbGVmdCcsIG9yaWVudGF0aW9uID0gJ3ZlcnRpY2FsJywgJ2FyaWEtbGFiZWwnOiBhcmlhTGFiZWwgPSAnUmVhY3QgRmxvdyBjb250cm9scycsIH0pIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3QgeyBpc0ludGVyYWN0aXZlLCBtaW5ab29tUmVhY2hlZCwgbWF4Wm9vbVJlYWNoZWQgfSA9IHVzZVN0b3JlKHNlbGVjdG9yJDIsIHNoYWxsb3cpO1xuICAgIGNvbnN0IHsgem9vbUluLCB6b29tT3V0LCBmaXRWaWV3IH0gPSB1c2VSZWFjdEZsb3coKTtcbiAgICBjb25zdCBvblpvb21JbkhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgIHpvb21JbigpO1xuICAgICAgICBvblpvb21Jbj8uKCk7XG4gICAgfTtcbiAgICBjb25zdCBvblpvb21PdXRIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICB6b29tT3V0KCk7XG4gICAgICAgIG9uWm9vbU91dD8uKCk7XG4gICAgfTtcbiAgICBjb25zdCBvbkZpdFZpZXdIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICBmaXRWaWV3KGZpdFZpZXdPcHRpb25zKTtcbiAgICAgICAgb25GaXRWaWV3Py4oKTtcbiAgICB9O1xuICAgIGNvbnN0IG9uVG9nZ2xlSW50ZXJhY3Rpdml0eSA9ICgpID0+IHtcbiAgICAgICAgc3RvcmUuc2V0U3RhdGUoe1xuICAgICAgICAgICAgbm9kZXNEcmFnZ2FibGU6ICFpc0ludGVyYWN0aXZlLFxuICAgICAgICAgICAgbm9kZXNDb25uZWN0YWJsZTogIWlzSW50ZXJhY3RpdmUsXG4gICAgICAgICAgICBlbGVtZW50c1NlbGVjdGFibGU6ICFpc0ludGVyYWN0aXZlLFxuICAgICAgICB9KTtcbiAgICAgICAgb25JbnRlcmFjdGl2ZUNoYW5nZT8uKCFpc0ludGVyYWN0aXZlKTtcbiAgICB9O1xuICAgIGNvbnN0IG9yaWVudGF0aW9uQ2xhc3MgPSBvcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnID8gJ2hvcml6b250YWwnIDogJ3ZlcnRpY2FsJztcbiAgICByZXR1cm4gKGpzeHMoUGFuZWwsIHsgY2xhc3NOYW1lOiBjYyhbJ3JlYWN0LWZsb3dfX2NvbnRyb2xzJywgb3JpZW50YXRpb25DbGFzcywgY2xhc3NOYW1lXSksIHBvc2l0aW9uOiBwb3NpdGlvbiwgc3R5bGU6IHN0eWxlLCBcImRhdGEtdGVzdGlkXCI6IFwicmZfX2NvbnRyb2xzXCIsIFwiYXJpYS1sYWJlbFwiOiBhcmlhTGFiZWwsIGNoaWxkcmVuOiBbc2hvd1pvb20gJiYgKGpzeHMoRnJhZ21lbnQsIHsgY2hpbGRyZW46IFtqc3goQ29udHJvbEJ1dHRvbiwgeyBvbkNsaWNrOiBvblpvb21JbkhhbmRsZXIsIGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19jb250cm9scy16b29taW5cIiwgdGl0bGU6IFwiem9vbSBpblwiLCBcImFyaWEtbGFiZWxcIjogXCJ6b29tIGluXCIsIGRpc2FibGVkOiBtYXhab29tUmVhY2hlZCwgY2hpbGRyZW46IGpzeChQbHVzSWNvbiwge30pIH0pLCBqc3goQ29udHJvbEJ1dHRvbiwgeyBvbkNsaWNrOiBvblpvb21PdXRIYW5kbGVyLCBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fY29udHJvbHMtem9vbW91dFwiLCB0aXRsZTogXCJ6b29tIG91dFwiLCBcImFyaWEtbGFiZWxcIjogXCJ6b29tIG91dFwiLCBkaXNhYmxlZDogbWluWm9vbVJlYWNoZWQsIGNoaWxkcmVuOiBqc3goTWludXNJY29uLCB7fSkgfSldIH0pKSwgc2hvd0ZpdFZpZXcgJiYgKGpzeChDb250cm9sQnV0dG9uLCB7IGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19jb250cm9scy1maXR2aWV3XCIsIG9uQ2xpY2s6IG9uRml0Vmlld0hhbmRsZXIsIHRpdGxlOiBcImZpdCB2aWV3XCIsIFwiYXJpYS1sYWJlbFwiOiBcImZpdCB2aWV3XCIsIGNoaWxkcmVuOiBqc3goRml0Vmlld0ljb24sIHt9KSB9KSksIHNob3dJbnRlcmFjdGl2ZSAmJiAoanN4KENvbnRyb2xCdXR0b24sIHsgY2xhc3NOYW1lOiBcInJlYWN0LWZsb3dfX2NvbnRyb2xzLWludGVyYWN0aXZlXCIsIG9uQ2xpY2s6IG9uVG9nZ2xlSW50ZXJhY3Rpdml0eSwgdGl0bGU6IFwidG9nZ2xlIGludGVyYWN0aXZpdHlcIiwgXCJhcmlhLWxhYmVsXCI6IFwidG9nZ2xlIGludGVyYWN0aXZpdHlcIiwgY2hpbGRyZW46IGlzSW50ZXJhY3RpdmUgPyBqc3goVW5sb2NrSWNvbiwge30pIDoganN4KExvY2tJY29uLCB7fSkgfSkpLCBjaGlsZHJlbl0gfSkpO1xufVxuQ29udHJvbHNDb21wb25lbnQuZGlzcGxheU5hbWUgPSAnQ29udHJvbHMnO1xuLyoqXG4gKiBUaGUgYDxDb250cm9scyAvPmAgY29tcG9uZW50IHJlbmRlcnMgYSBzbWFsbCBwYW5lbCB0aGF0IGNvbnRhaW5zIGNvbnZlbmllbnRcbiAqIGJ1dHRvbnMgdG8gem9vbSBpbiwgem9vbSBvdXQsIGZpdCB0aGUgdmlldywgYW5kIGxvY2sgdGhlIHZpZXdwb3J0LlxuICpcbiAqIEBwdWJsaWNcbiAqIEBleGFtcGxlXG4gKmBgYHRzeFxuICppbXBvcnQgeyBSZWFjdEZsb3csIENvbnRyb2xzIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCdcbiAqXG4gKmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEZsb3coKSB7XG4gKiAgcmV0dXJuIChcbiAqICAgIDxSZWFjdEZsb3cgbm9kZXM9e1suLi5dfSBlZGdlcz17Wy4uLl19PlxuICogICAgICA8Q29udHJvbHMgLz5cbiAqICAgIDwvUmVhY3RGbG93PlxuICogIClcbiAqfVxuICpgYGBcbiAqXG4gKiBAcmVtYXJrcyBUbyBleHRlbmQgb3IgY3VzdG9taXNlIHRoZSBjb250cm9scywgeW91IGNhbiB1c2UgdGhlIFtgPENvbnRyb2xCdXR0b24gLz5gXSgvYXBpLXJlZmVyZW5jZS9jb21wb25lbnRzL2NvbnRyb2wtYnV0dG9uKSBjb21wb25lbnRcbiAqXG4gKi9cbmNvbnN0IENvbnRyb2xzID0gbWVtbyhDb250cm9sc0NvbXBvbmVudCk7XG5cbmZ1bmN0aW9uIE1pbmlNYXBOb2RlQ29tcG9uZW50KHsgaWQsIHgsIHksIHdpZHRoLCBoZWlnaHQsIHN0eWxlLCBjb2xvciwgc3Ryb2tlQ29sb3IsIHN0cm9rZVdpZHRoLCBjbGFzc05hbWUsIGJvcmRlclJhZGl1cywgc2hhcGVSZW5kZXJpbmcsIHNlbGVjdGVkLCBvbkNsaWNrLCB9KSB7XG4gICAgY29uc3QgeyBiYWNrZ3JvdW5kLCBiYWNrZ3JvdW5kQ29sb3IgfSA9IHN0eWxlIHx8IHt9O1xuICAgIGNvbnN0IGZpbGwgPSAoY29sb3IgfHwgYmFja2dyb3VuZCB8fCBiYWNrZ3JvdW5kQ29sb3IpO1xuICAgIHJldHVybiAoanN4KFwicmVjdFwiLCB7IGNsYXNzTmFtZTogY2MoWydyZWFjdC1mbG93X19taW5pbWFwLW5vZGUnLCB7IHNlbGVjdGVkIH0sIGNsYXNzTmFtZV0pLCB4OiB4LCB5OiB5LCByeDogYm9yZGVyUmFkaXVzLCByeTogYm9yZGVyUmFkaXVzLCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0LCBzdHlsZToge1xuICAgICAgICAgICAgZmlsbCxcbiAgICAgICAgICAgIHN0cm9rZTogc3Ryb2tlQ29sb3IsXG4gICAgICAgICAgICBzdHJva2VXaWR0aCxcbiAgICAgICAgfSwgc2hhcGVSZW5kZXJpbmc6IHNoYXBlUmVuZGVyaW5nLCBvbkNsaWNrOiBvbkNsaWNrID8gKGV2ZW50KSA9PiBvbkNsaWNrKGV2ZW50LCBpZCkgOiB1bmRlZmluZWQgfSkpO1xufVxuY29uc3QgTWluaU1hcE5vZGUgPSBtZW1vKE1pbmlNYXBOb2RlQ29tcG9uZW50KTtcblxuY29uc3Qgc2VsZWN0b3JOb2RlSWRzID0gKHMpID0+IHMubm9kZXMubWFwKChub2RlKSA9PiBub2RlLmlkKTtcbmNvbnN0IGdldEF0dHJGdW5jdGlvbiA9IChmdW5jKSA9PiBmdW5jIGluc3RhbmNlb2YgRnVuY3Rpb24gPyBmdW5jIDogKCkgPT4gZnVuYztcbmZ1bmN0aW9uIE1pbmlNYXBOb2Rlcyh7IG5vZGVTdHJva2VDb2xvciwgbm9kZUNvbG9yLCBub2RlQ2xhc3NOYW1lID0gJycsIG5vZGVCb3JkZXJSYWRpdXMgPSA1LCBub2RlU3Ryb2tlV2lkdGgsIFxuLypcbiAqIFdlIG5lZWQgdG8gcmVuYW1lIHRoZSBwcm9wIHRvIGJlIGBDYXBpdGFsQ2FzZWAgc28gdGhhdCBKU1ggd2lsbCByZW5kZXIgaXQgYXNcbiAqIGEgY29tcG9uZW50IHByb3Blcmx5LlxuICovXG5ub2RlQ29tcG9uZW50OiBOb2RlQ29tcG9uZW50ID0gTWluaU1hcE5vZGUsIG9uQ2xpY2ssIH0pIHtcbiAgICBjb25zdCBub2RlSWRzID0gdXNlU3RvcmUoc2VsZWN0b3JOb2RlSWRzLCBzaGFsbG93KTtcbiAgICBjb25zdCBub2RlQ29sb3JGdW5jID0gZ2V0QXR0ckZ1bmN0aW9uKG5vZGVDb2xvcik7XG4gICAgY29uc3Qgbm9kZVN0cm9rZUNvbG9yRnVuYyA9IGdldEF0dHJGdW5jdGlvbihub2RlU3Ryb2tlQ29sb3IpO1xuICAgIGNvbnN0IG5vZGVDbGFzc05hbWVGdW5jID0gZ2V0QXR0ckZ1bmN0aW9uKG5vZGVDbGFzc05hbWUpO1xuICAgIGNvbnN0IHNoYXBlUmVuZGVyaW5nID0gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgfHwgISF3aW5kb3cuY2hyb21lID8gJ2NyaXNwRWRnZXMnIDogJ2dlb21ldHJpY1ByZWNpc2lvbic7XG4gICAgcmV0dXJuIChqc3goRnJhZ21lbnQsIHsgY2hpbGRyZW46IG5vZGVJZHMubWFwKChub2RlSWQpID0+IChcbiAgICAgICAgLypcbiAgICAgICAgICogVGhlIHNwbGl0IG9mIHJlc3BvbnNpYmlsaXRpZXMgYmV0d2VlbiBNaW5pTWFwTm9kZXMgYW5kXG4gICAgICAgICAqIE5vZGVDb21wb25lbnRXcmFwcGVyIG1heSBhcHBlYXIgd2VpcmQuIEhvd2V2ZXIsIGl04oCZcyBkZXNpZ25lZCB0b1xuICAgICAgICAgKiBtaW5pbWl6ZSB0aGUgY29zdCBvZiB1cGRhdGVzIHdoZW4gaW5kaXZpZHVhbCBub2RlcyBjaGFuZ2UuXG4gICAgICAgICAqXG4gICAgICAgICAqIEZvciBtb3JlIGRldGFpbHMsIHNlZSBhIHNpbWlsYXIgY29tbWl0IGluIGBOb2RlUmVuZGVyZXIvaW5kZXgudHN4YC5cbiAgICAgICAgICovXG4gICAgICAgIGpzeChOb2RlQ29tcG9uZW50V3JhcHBlciwgeyBpZDogbm9kZUlkLCBub2RlQ29sb3JGdW5jOiBub2RlQ29sb3JGdW5jLCBub2RlU3Ryb2tlQ29sb3JGdW5jOiBub2RlU3Ryb2tlQ29sb3JGdW5jLCBub2RlQ2xhc3NOYW1lRnVuYzogbm9kZUNsYXNzTmFtZUZ1bmMsIG5vZGVCb3JkZXJSYWRpdXM6IG5vZGVCb3JkZXJSYWRpdXMsIG5vZGVTdHJva2VXaWR0aDogbm9kZVN0cm9rZVdpZHRoLCBOb2RlQ29tcG9uZW50OiBOb2RlQ29tcG9uZW50LCBvbkNsaWNrOiBvbkNsaWNrLCBzaGFwZVJlbmRlcmluZzogc2hhcGVSZW5kZXJpbmcgfSwgbm9kZUlkKSkpIH0pKTtcbn1cbmZ1bmN0aW9uIE5vZGVDb21wb25lbnRXcmFwcGVySW5uZXIoeyBpZCwgbm9kZUNvbG9yRnVuYywgbm9kZVN0cm9rZUNvbG9yRnVuYywgbm9kZUNsYXNzTmFtZUZ1bmMsIG5vZGVCb3JkZXJSYWRpdXMsIG5vZGVTdHJva2VXaWR0aCwgc2hhcGVSZW5kZXJpbmcsIE5vZGVDb21wb25lbnQsIG9uQ2xpY2ssIH0pIHtcbiAgICBjb25zdCB7IG5vZGUsIHgsIHksIHdpZHRoLCBoZWlnaHQgfSA9IHVzZVN0b3JlKChzKSA9PiB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBzLm5vZGVMb29rdXAuZ2V0KGlkKTtcbiAgICAgICAgY29uc3QgeyB4LCB5IH0gPSBub2RlLmludGVybmFscy5wb3NpdGlvbkFic29sdXRlO1xuICAgICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IGdldE5vZGVEaW1lbnNpb25zKG5vZGUpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbm9kZSxcbiAgICAgICAgICAgIHgsXG4gICAgICAgICAgICB5LFxuICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQsXG4gICAgICAgIH07XG4gICAgfSwgc2hhbGxvdyk7XG4gICAgaWYgKCFub2RlIHx8IG5vZGUuaGlkZGVuIHx8ICFub2RlSGFzRGltZW5zaW9ucyhub2RlKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIChqc3goTm9kZUNvbXBvbmVudCwgeyB4OiB4LCB5OiB5LCB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0LCBzdHlsZTogbm9kZS5zdHlsZSwgc2VsZWN0ZWQ6ICEhbm9kZS5zZWxlY3RlZCwgY2xhc3NOYW1lOiBub2RlQ2xhc3NOYW1lRnVuYyhub2RlKSwgY29sb3I6IG5vZGVDb2xvckZ1bmMobm9kZSksIGJvcmRlclJhZGl1czogbm9kZUJvcmRlclJhZGl1cywgc3Ryb2tlQ29sb3I6IG5vZGVTdHJva2VDb2xvckZ1bmMobm9kZSksIHN0cm9rZVdpZHRoOiBub2RlU3Ryb2tlV2lkdGgsIHNoYXBlUmVuZGVyaW5nOiBzaGFwZVJlbmRlcmluZywgb25DbGljazogb25DbGljaywgaWQ6IG5vZGUuaWQgfSkpO1xufVxuY29uc3QgTm9kZUNvbXBvbmVudFdyYXBwZXIgPSBtZW1vKE5vZGVDb21wb25lbnRXcmFwcGVySW5uZXIpO1xudmFyIE1pbmlNYXBOb2RlcyQxID0gbWVtbyhNaW5pTWFwTm9kZXMpO1xuXG5jb25zdCBkZWZhdWx0V2lkdGggPSAyMDA7XG5jb25zdCBkZWZhdWx0SGVpZ2h0ID0gMTUwO1xuY29uc3Qgc2VsZWN0b3IkMSA9IChzKSA9PiB7XG4gICAgY29uc3Qgdmlld0JCID0ge1xuICAgICAgICB4OiAtcy50cmFuc2Zvcm1bMF0gLyBzLnRyYW5zZm9ybVsyXSxcbiAgICAgICAgeTogLXMudHJhbnNmb3JtWzFdIC8gcy50cmFuc2Zvcm1bMl0sXG4gICAgICAgIHdpZHRoOiBzLndpZHRoIC8gcy50cmFuc2Zvcm1bMl0sXG4gICAgICAgIGhlaWdodDogcy5oZWlnaHQgLyBzLnRyYW5zZm9ybVsyXSxcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIHZpZXdCQixcbiAgICAgICAgYm91bmRpbmdSZWN0OiBzLm5vZGVMb29rdXAuc2l6ZSA+IDAgPyBnZXRCb3VuZHNPZlJlY3RzKGdldEludGVybmFsTm9kZXNCb3VuZHMocy5ub2RlTG9va3VwKSwgdmlld0JCKSA6IHZpZXdCQixcbiAgICAgICAgcmZJZDogcy5yZklkLFxuICAgICAgICBwYW5ab29tOiBzLnBhblpvb20sXG4gICAgICAgIHRyYW5zbGF0ZUV4dGVudDogcy50cmFuc2xhdGVFeHRlbnQsXG4gICAgICAgIGZsb3dXaWR0aDogcy53aWR0aCxcbiAgICAgICAgZmxvd0hlaWdodDogcy5oZWlnaHQsXG4gICAgfTtcbn07XG5jb25zdCBBUklBX0xBQkVMX0tFWSA9ICdyZWFjdC1mbG93X19taW5pbWFwLWRlc2MnO1xuZnVuY3Rpb24gTWluaU1hcENvbXBvbmVudCh7IHN0eWxlLCBjbGFzc05hbWUsIG5vZGVTdHJva2VDb2xvciwgbm9kZUNvbG9yLCBub2RlQ2xhc3NOYW1lID0gJycsIG5vZGVCb3JkZXJSYWRpdXMgPSA1LCBub2RlU3Ryb2tlV2lkdGgsIFxuLypcbiAqIFdlIG5lZWQgdG8gcmVuYW1lIHRoZSBwcm9wIHRvIGJlIGBDYXBpdGFsQ2FzZWAgc28gdGhhdCBKU1ggd2lsbCByZW5kZXIgaXQgYXNcbiAqIGEgY29tcG9uZW50IHByb3Blcmx5LlxuICovXG5ub2RlQ29tcG9uZW50LCBiZ0NvbG9yLCBtYXNrQ29sb3IsIG1hc2tTdHJva2VDb2xvciwgbWFza1N0cm9rZVdpZHRoLCBwb3NpdGlvbiA9ICdib3R0b20tcmlnaHQnLCBvbkNsaWNrLCBvbk5vZGVDbGljaywgcGFubmFibGUgPSBmYWxzZSwgem9vbWFibGUgPSBmYWxzZSwgYXJpYUxhYmVsID0gJ1JlYWN0IEZsb3cgbWluaSBtYXAnLCBpbnZlcnNlUGFuLCB6b29tU3RlcCA9IDEwLCBvZmZzZXRTY2FsZSA9IDUsIH0pIHtcbiAgICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlQXBpKCk7XG4gICAgY29uc3Qgc3ZnID0gdXNlUmVmKG51bGwpO1xuICAgIGNvbnN0IHsgYm91bmRpbmdSZWN0LCB2aWV3QkIsIHJmSWQsIHBhblpvb20sIHRyYW5zbGF0ZUV4dGVudCwgZmxvd1dpZHRoLCBmbG93SGVpZ2h0IH0gPSB1c2VTdG9yZShzZWxlY3RvciQxLCBzaGFsbG93KTtcbiAgICBjb25zdCBlbGVtZW50V2lkdGggPSBzdHlsZT8ud2lkdGggPz8gZGVmYXVsdFdpZHRoO1xuICAgIGNvbnN0IGVsZW1lbnRIZWlnaHQgPSBzdHlsZT8uaGVpZ2h0ID8/IGRlZmF1bHRIZWlnaHQ7XG4gICAgY29uc3Qgc2NhbGVkV2lkdGggPSBib3VuZGluZ1JlY3Qud2lkdGggLyBlbGVtZW50V2lkdGg7XG4gICAgY29uc3Qgc2NhbGVkSGVpZ2h0ID0gYm91bmRpbmdSZWN0LmhlaWdodCAvIGVsZW1lbnRIZWlnaHQ7XG4gICAgY29uc3Qgdmlld1NjYWxlID0gTWF0aC5tYXgoc2NhbGVkV2lkdGgsIHNjYWxlZEhlaWdodCk7XG4gICAgY29uc3Qgdmlld1dpZHRoID0gdmlld1NjYWxlICogZWxlbWVudFdpZHRoO1xuICAgIGNvbnN0IHZpZXdIZWlnaHQgPSB2aWV3U2NhbGUgKiBlbGVtZW50SGVpZ2h0O1xuICAgIGNvbnN0IG9mZnNldCA9IG9mZnNldFNjYWxlICogdmlld1NjYWxlO1xuICAgIGNvbnN0IHggPSBib3VuZGluZ1JlY3QueCAtICh2aWV3V2lkdGggLSBib3VuZGluZ1JlY3Qud2lkdGgpIC8gMiAtIG9mZnNldDtcbiAgICBjb25zdCB5ID0gYm91bmRpbmdSZWN0LnkgLSAodmlld0hlaWdodCAtIGJvdW5kaW5nUmVjdC5oZWlnaHQpIC8gMiAtIG9mZnNldDtcbiAgICBjb25zdCB3aWR0aCA9IHZpZXdXaWR0aCArIG9mZnNldCAqIDI7XG4gICAgY29uc3QgaGVpZ2h0ID0gdmlld0hlaWdodCArIG9mZnNldCAqIDI7XG4gICAgY29uc3QgbGFiZWxsZWRCeSA9IGAke0FSSUFfTEFCRUxfS0VZfS0ke3JmSWR9YDtcbiAgICBjb25zdCB2aWV3U2NhbGVSZWYgPSB1c2VSZWYoMCk7XG4gICAgY29uc3QgbWluaW1hcEluc3RhbmNlID0gdXNlUmVmKCk7XG4gICAgdmlld1NjYWxlUmVmLmN1cnJlbnQgPSB2aWV3U2NhbGU7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKHN2Zy5jdXJyZW50ICYmIHBhblpvb20pIHtcbiAgICAgICAgICAgIG1pbmltYXBJbnN0YW5jZS5jdXJyZW50ID0gWFlNaW5pbWFwKHtcbiAgICAgICAgICAgICAgICBkb21Ob2RlOiBzdmcuY3VycmVudCxcbiAgICAgICAgICAgICAgICBwYW5ab29tLFxuICAgICAgICAgICAgICAgIGdldFRyYW5zZm9ybTogKCkgPT4gc3RvcmUuZ2V0U3RhdGUoKS50cmFuc2Zvcm0sXG4gICAgICAgICAgICAgICAgZ2V0Vmlld1NjYWxlOiAoKSA9PiB2aWV3U2NhbGVSZWYuY3VycmVudCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICBtaW5pbWFwSW5zdGFuY2UuY3VycmVudD8uZGVzdHJveSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH0sIFtwYW5ab29tXSk7XG4gICAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgbWluaW1hcEluc3RhbmNlLmN1cnJlbnQ/LnVwZGF0ZSh7XG4gICAgICAgICAgICB0cmFuc2xhdGVFeHRlbnQsXG4gICAgICAgICAgICB3aWR0aDogZmxvd1dpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBmbG93SGVpZ2h0LFxuICAgICAgICAgICAgaW52ZXJzZVBhbixcbiAgICAgICAgICAgIHBhbm5hYmxlLFxuICAgICAgICAgICAgem9vbVN0ZXAsXG4gICAgICAgICAgICB6b29tYWJsZSxcbiAgICAgICAgfSk7XG4gICAgfSwgW3Bhbm5hYmxlLCB6b29tYWJsZSwgaW52ZXJzZVBhbiwgem9vbVN0ZXAsIHRyYW5zbGF0ZUV4dGVudCwgZmxvd1dpZHRoLCBmbG93SGVpZ2h0XSk7XG4gICAgY29uc3Qgb25TdmdDbGljayA9IG9uQ2xpY2tcbiAgICAgICAgPyAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IFt4LCB5XSA9IG1pbmltYXBJbnN0YW5jZS5jdXJyZW50Py5wb2ludGVyKGV2ZW50KSB8fCBbMCwgMF07XG4gICAgICAgICAgICBvbkNsaWNrKGV2ZW50LCB7IHgsIHkgfSk7XG4gICAgICAgIH1cbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgY29uc3Qgb25TdmdOb2RlQ2xpY2sgPSBvbk5vZGVDbGlja1xuICAgICAgICA/IHVzZUNhbGxiYWNrKChldmVudCwgbm9kZUlkKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gc3RvcmUuZ2V0U3RhdGUoKS5ub2RlTG9va3VwLmdldChub2RlSWQpO1xuICAgICAgICAgICAgb25Ob2RlQ2xpY2soZXZlbnQsIG5vZGUpO1xuICAgICAgICB9LCBbXSlcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIChqc3goUGFuZWwsIHsgcG9zaXRpb246IHBvc2l0aW9uLCBzdHlsZToge1xuICAgICAgICAgICAgLi4uc3R5bGUsXG4gICAgICAgICAgICAnLS14eS1taW5pbWFwLWJhY2tncm91bmQtY29sb3ItcHJvcHMnOiB0eXBlb2YgYmdDb2xvciA9PT0gJ3N0cmluZycgPyBiZ0NvbG9yIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgJy0teHktbWluaW1hcC1tYXNrLWJhY2tncm91bmQtY29sb3ItcHJvcHMnOiB0eXBlb2YgbWFza0NvbG9yID09PSAnc3RyaW5nJyA/IG1hc2tDb2xvciA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICctLXh5LW1pbmltYXAtbWFzay1zdHJva2UtY29sb3ItcHJvcHMnOiB0eXBlb2YgbWFza1N0cm9rZUNvbG9yID09PSAnc3RyaW5nJyA/IG1hc2tTdHJva2VDb2xvciA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICctLXh5LW1pbmltYXAtbWFzay1zdHJva2Utd2lkdGgtcHJvcHMnOiB0eXBlb2YgbWFza1N0cm9rZVdpZHRoID09PSAnbnVtYmVyJyA/IG1hc2tTdHJva2VXaWR0aCAqIHZpZXdTY2FsZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICctLXh5LW1pbmltYXAtbm9kZS1iYWNrZ3JvdW5kLWNvbG9yLXByb3BzJzogdHlwZW9mIG5vZGVDb2xvciA9PT0gJ3N0cmluZycgPyBub2RlQ29sb3IgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnLS14eS1taW5pbWFwLW5vZGUtc3Ryb2tlLWNvbG9yLXByb3BzJzogdHlwZW9mIG5vZGVTdHJva2VDb2xvciA9PT0gJ3N0cmluZycgPyBub2RlU3Ryb2tlQ29sb3IgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAnLS14eS1taW5pbWFwLW5vZGUtc3Ryb2tlLXdpZHRoLXByb3BzJzogdHlwZW9mIG5vZGVTdHJva2VXaWR0aCA9PT0gJ3N0cmluZycgPyBub2RlU3Ryb2tlV2lkdGggOiB1bmRlZmluZWQsXG4gICAgICAgIH0sIGNsYXNzTmFtZTogY2MoWydyZWFjdC1mbG93X19taW5pbWFwJywgY2xhc3NOYW1lXSksIFwiZGF0YS10ZXN0aWRcIjogXCJyZl9fbWluaW1hcFwiLCBjaGlsZHJlbjoganN4cyhcInN2Z1wiLCB7IHdpZHRoOiBlbGVtZW50V2lkdGgsIGhlaWdodDogZWxlbWVudEhlaWdodCwgdmlld0JveDogYCR7eH0gJHt5fSAke3dpZHRofSAke2hlaWdodH1gLCBjbGFzc05hbWU6IFwicmVhY3QtZmxvd19fbWluaW1hcC1zdmdcIiwgcm9sZTogXCJpbWdcIiwgXCJhcmlhLWxhYmVsbGVkYnlcIjogbGFiZWxsZWRCeSwgcmVmOiBzdmcsIG9uQ2xpY2s6IG9uU3ZnQ2xpY2ssIGNoaWxkcmVuOiBbYXJpYUxhYmVsICYmIGpzeChcInRpdGxlXCIsIHsgaWQ6IGxhYmVsbGVkQnksIGNoaWxkcmVuOiBhcmlhTGFiZWwgfSksIGpzeChNaW5pTWFwTm9kZXMkMSwgeyBvbkNsaWNrOiBvblN2Z05vZGVDbGljaywgbm9kZUNvbG9yOiBub2RlQ29sb3IsIG5vZGVTdHJva2VDb2xvcjogbm9kZVN0cm9rZUNvbG9yLCBub2RlQm9yZGVyUmFkaXVzOiBub2RlQm9yZGVyUmFkaXVzLCBub2RlQ2xhc3NOYW1lOiBub2RlQ2xhc3NOYW1lLCBub2RlU3Ryb2tlV2lkdGg6IG5vZGVTdHJva2VXaWR0aCwgbm9kZUNvbXBvbmVudDogbm9kZUNvbXBvbmVudCB9KSwganN4KFwicGF0aFwiLCB7IGNsYXNzTmFtZTogXCJyZWFjdC1mbG93X19taW5pbWFwLW1hc2tcIiwgZDogYE0ke3ggLSBvZmZzZXR9LCR7eSAtIG9mZnNldH1oJHt3aWR0aCArIG9mZnNldCAqIDJ9diR7aGVpZ2h0ICsgb2Zmc2V0ICogMn1oJHstd2lkdGggLSBvZmZzZXQgKiAyfXpcbiAgICAgICAgTSR7dmlld0JCLnh9LCR7dmlld0JCLnl9aCR7dmlld0JCLndpZHRofXYke3ZpZXdCQi5oZWlnaHR9aCR7LXZpZXdCQi53aWR0aH16YCwgZmlsbFJ1bGU6IFwiZXZlbm9kZFwiLCBwb2ludGVyRXZlbnRzOiBcIm5vbmVcIiB9KV0gfSkgfSkpO1xufVxuTWluaU1hcENvbXBvbmVudC5kaXNwbGF5TmFtZSA9ICdNaW5pTWFwJztcbi8qKlxuICogVGhlIGA8TWluaU1hcCAvPmAgY29tcG9uZW50IGNhbiBiZSB1c2VkIHRvIHJlbmRlciBhbiBvdmVydmlldyBvZiB5b3VyIGZsb3cuIEl0XG4gKiByZW5kZXJzIGVhY2ggbm9kZSBhcyBhbiBTVkcgZWxlbWVudCBhbmQgdmlzdWFsaXplcyB3aGVyZSB0aGUgY3VycmVudCB2aWV3cG9ydCBpc1xuICogaW4gcmVsYXRpb24gdG8gdGhlIHJlc3Qgb2YgdGhlIGZsb3cuXG4gKlxuICogQHB1YmxpY1xuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBqc3hcbiAqaW1wb3J0IHsgUmVhY3RGbG93LCBNaW5pTWFwIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBGbG93KCkge1xuICogIHJldHVybiAoXG4gKiAgICA8UmVhY3RGbG93IG5vZGVzPXtbLi4uXV19IGVkZ2VzPXtbLi4uXV19PlxuICogICAgICA8TWluaU1hcCBub2RlU3Ryb2tlV2lkdGg9ezN9IC8+XG4gKiAgICA8L1JlYWN0Rmxvdz5cbiAqICApO1xuICp9XG4gKmBgYFxuICovXG5jb25zdCBNaW5pTWFwID0gbWVtbyhNaW5pTWFwQ29tcG9uZW50KTtcblxuZnVuY3Rpb24gUmVzaXplQ29udHJvbCh7IG5vZGVJZCwgcG9zaXRpb24sIHZhcmlhbnQgPSBSZXNpemVDb250cm9sVmFyaWFudC5IYW5kbGUsIGNsYXNzTmFtZSwgc3R5bGUgPSB7fSwgY2hpbGRyZW4sIGNvbG9yLCBtaW5XaWR0aCA9IDEwLCBtaW5IZWlnaHQgPSAxMCwgbWF4V2lkdGggPSBOdW1iZXIuTUFYX1ZBTFVFLCBtYXhIZWlnaHQgPSBOdW1iZXIuTUFYX1ZBTFVFLCBrZWVwQXNwZWN0UmF0aW8gPSBmYWxzZSwgc2hvdWxkUmVzaXplLCBvblJlc2l6ZVN0YXJ0LCBvblJlc2l6ZSwgb25SZXNpemVFbmQsIH0pIHtcbiAgICBjb25zdCBjb250ZXh0Tm9kZUlkID0gdXNlTm9kZUlkKCk7XG4gICAgY29uc3QgaWQgPSB0eXBlb2Ygbm9kZUlkID09PSAnc3RyaW5nJyA/IG5vZGVJZCA6IGNvbnRleHROb2RlSWQ7XG4gICAgY29uc3Qgc3RvcmUgPSB1c2VTdG9yZUFwaSgpO1xuICAgIGNvbnN0IHJlc2l6ZUNvbnRyb2xSZWYgPSB1c2VSZWYobnVsbCk7XG4gICAgY29uc3QgZGVmYXVsdFBvc2l0aW9uID0gdmFyaWFudCA9PT0gUmVzaXplQ29udHJvbFZhcmlhbnQuTGluZSA/ICdyaWdodCcgOiAnYm90dG9tLXJpZ2h0JztcbiAgICBjb25zdCBjb250cm9sUG9zaXRpb24gPSBwb3NpdGlvbiA/PyBkZWZhdWx0UG9zaXRpb247XG4gICAgY29uc3QgcmVzaXplciA9IHVzZVJlZihudWxsKTtcbiAgICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIXJlc2l6ZUNvbnRyb2xSZWYuY3VycmVudCB8fCAhaWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXJlc2l6ZXIuY3VycmVudCkge1xuICAgICAgICAgICAgcmVzaXplci5jdXJyZW50ID0gWFlSZXNpemVyKHtcbiAgICAgICAgICAgICAgICBkb21Ob2RlOiByZXNpemVDb250cm9sUmVmLmN1cnJlbnQsXG4gICAgICAgICAgICAgICAgbm9kZUlkOiBpZCxcbiAgICAgICAgICAgICAgICBnZXRTdG9yZUl0ZW1zOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgbm9kZUxvb2t1cCwgdHJhbnNmb3JtLCBzbmFwR3JpZCwgc25hcFRvR3JpZCwgbm9kZU9yaWdpbiwgZG9tTm9kZSB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVMb29rdXAsXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2Zvcm0sXG4gICAgICAgICAgICAgICAgICAgICAgICBzbmFwR3JpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNuYXBUb0dyaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlT3JpZ2luLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFuZURvbU5vZGU6IGRvbU5vZGUsXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvbkNoYW5nZTogKGNoYW5nZSwgY2hpbGRDaGFuZ2VzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgdHJpZ2dlck5vZGVDaGFuZ2VzLCBub2RlTG9va3VwLCBwYXJlbnRMb29rdXAsIG5vZGVPcmlnaW4gfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoYW5nZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV4dFBvc2l0aW9uID0geyB4OiBjaGFuZ2UueCwgeTogY2hhbmdlLnkgfTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVMb29rdXAuZ2V0KGlkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUgJiYgbm9kZS5leHBhbmRQYXJlbnQgJiYgbm9kZS5wYXJlbnRJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb3JpZ2luID0gbm9kZS5vcmlnaW4gPz8gbm9kZU9yaWdpbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gY2hhbmdlLndpZHRoID8/IG5vZGUubWVhc3VyZWQud2lkdGggPz8gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGhlaWdodCA9IGNoYW5nZS5oZWlnaHQgPz8gbm9kZS5tZWFzdXJlZC5oZWlnaHQgPz8gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoaWxkID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBub2RlLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudElkOiBub2RlLnBhcmVudElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY3Q6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uZXZhbHVhdGVBYnNvbHV0ZVBvc2l0aW9uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHg6IGNoYW5nZS54ID8/IG5vZGUucG9zaXRpb24ueCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IGNoYW5nZS55ID8/IG5vZGUucG9zaXRpb24ueSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgeyB3aWR0aCwgaGVpZ2h0IH0sIG5vZGUucGFyZW50SWQsIG5vZGVMb29rdXAsIG9yaWdpbiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRFeHBhbmRDaGFuZ2VzID0gaGFuZGxlRXhwYW5kUGFyZW50KFtjaGlsZF0sIG5vZGVMb29rdXAsIHBhcmVudExvb2t1cCwgbm9kZU9yaWdpbik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VzLnB1c2goLi4ucGFyZW50RXhwYW5kQ2hhbmdlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogd2hlbiB0aGUgcGFyZW50IHdhcyBleHBhbmRlZCBieSB0aGUgY2hpbGQgbm9kZSwgaXRzIHBvc2l0aW9uIHdpbGwgYmUgY2xhbXBlZCBhdFxuICAgICAgICAgICAgICAgICAgICAgICAgICogMCwwIHdoZW4gbm9kZSBvcmlnaW4gaXMgMCwwIGFuZCB0byB3aWR0aCwgaGVpZ2h0IGlmIGl0J3MgMSwxXG4gICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIG5leHRQb3NpdGlvbi54ID0gY2hhbmdlLnggPyBNYXRoLm1heChvcmlnaW5bMF0gKiB3aWR0aCwgY2hhbmdlLngpIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dFBvc2l0aW9uLnkgPSBjaGFuZ2UueSA/IE1hdGgubWF4KG9yaWdpblsxXSAqIGhlaWdodCwgY2hhbmdlLnkpIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0UG9zaXRpb24ueCAhPT0gdW5kZWZpbmVkICYmIG5leHRQb3NpdGlvbi55ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uQ2hhbmdlID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdwb3NpdGlvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHsgLi4ubmV4dFBvc2l0aW9uIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHBvc2l0aW9uQ2hhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhbmdlLndpZHRoICE9PSB1bmRlZmluZWQgJiYgY2hhbmdlLmhlaWdodCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkaW1lbnNpb25DaGFuZ2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2RpbWVuc2lvbnMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc2l6aW5nOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldEF0dHJpYnV0ZXM6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGltZW5zaW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogY2hhbmdlLndpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGNoYW5nZS5oZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VzLnB1c2goZGltZW5zaW9uQ2hhbmdlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNoaWxkQ2hhbmdlIG9mIGNoaWxkQ2hhbmdlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcG9zaXRpb25DaGFuZ2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uY2hpbGRDaGFuZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3Bvc2l0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VzLnB1c2gocG9zaXRpb25DaGFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXJOb2RlQ2hhbmdlcyhjaGFuZ2VzKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9uRW5kOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpbWVuc2lvbkNoYW5nZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdkaW1lbnNpb25zJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc2l6aW5nOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgc3RvcmUuZ2V0U3RhdGUoKS50cmlnZ2VyTm9kZUNoYW5nZXMoW2RpbWVuc2lvbkNoYW5nZV0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXNpemVyLmN1cnJlbnQudXBkYXRlKHtcbiAgICAgICAgICAgIGNvbnRyb2xQb3NpdGlvbixcbiAgICAgICAgICAgIGJvdW5kYXJpZXM6IHtcbiAgICAgICAgICAgICAgICBtaW5XaWR0aCxcbiAgICAgICAgICAgICAgICBtaW5IZWlnaHQsXG4gICAgICAgICAgICAgICAgbWF4V2lkdGgsXG4gICAgICAgICAgICAgICAgbWF4SGVpZ2h0LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGtlZXBBc3BlY3RSYXRpbyxcbiAgICAgICAgICAgIG9uUmVzaXplU3RhcnQsXG4gICAgICAgICAgICBvblJlc2l6ZSxcbiAgICAgICAgICAgIG9uUmVzaXplRW5kLFxuICAgICAgICAgICAgc2hvdWxkUmVzaXplLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHJlc2l6ZXIuY3VycmVudD8uZGVzdHJveSgpO1xuICAgICAgICB9O1xuICAgIH0sIFtcbiAgICAgICAgY29udHJvbFBvc2l0aW9uLFxuICAgICAgICBtaW5XaWR0aCxcbiAgICAgICAgbWluSGVpZ2h0LFxuICAgICAgICBtYXhXaWR0aCxcbiAgICAgICAgbWF4SGVpZ2h0LFxuICAgICAgICBrZWVwQXNwZWN0UmF0aW8sXG4gICAgICAgIG9uUmVzaXplU3RhcnQsXG4gICAgICAgIG9uUmVzaXplLFxuICAgICAgICBvblJlc2l6ZUVuZCxcbiAgICAgICAgc2hvdWxkUmVzaXplLFxuICAgIF0pO1xuICAgIGNvbnN0IHBvc2l0aW9uQ2xhc3NOYW1lcyA9IGNvbnRyb2xQb3NpdGlvbi5zcGxpdCgnLScpO1xuICAgIGNvbnN0IGNvbG9yU3R5bGVQcm9wID0gdmFyaWFudCA9PT0gUmVzaXplQ29udHJvbFZhcmlhbnQuTGluZSA/ICdib3JkZXJDb2xvcicgOiAnYmFja2dyb3VuZENvbG9yJztcbiAgICBjb25zdCBjb250cm9sU3R5bGUgPSBjb2xvciA/IHsgLi4uc3R5bGUsIFtjb2xvclN0eWxlUHJvcF06IGNvbG9yIH0gOiBzdHlsZTtcbiAgICByZXR1cm4gKGpzeChcImRpdlwiLCB7IGNsYXNzTmFtZTogY2MoWydyZWFjdC1mbG93X19yZXNpemUtY29udHJvbCcsICdub2RyYWcnLCAuLi5wb3NpdGlvbkNsYXNzTmFtZXMsIHZhcmlhbnQsIGNsYXNzTmFtZV0pLCByZWY6IHJlc2l6ZUNvbnRyb2xSZWYsIHN0eWxlOiBjb250cm9sU3R5bGUsIGNoaWxkcmVuOiBjaGlsZHJlbiB9KSk7XG59XG4vKipcbiAqIFRvIGNyZWF0ZSB5b3VyIG93biByZXNpemluZyBVSSwgeW91IGNhbiB1c2UgdGhlIGBOb2RlUmVzaXplQ29udHJvbGAgY29tcG9uZW50IHdoZXJlIHlvdSBjYW4gcGFzcyBjaGlsZHJlbiAoc3VjaCBhcyBpY29ucykuXG4gKiBAcHVibGljXG4gKlxuICovXG5jb25zdCBOb2RlUmVzaXplQ29udHJvbCA9IG1lbW8oUmVzaXplQ29udHJvbCk7XG5cbi8qKlxuICogVGhlIGA8Tm9kZVJlc2l6ZXIgLz5gIGNvbXBvbmVudCBjYW4gYmUgdXNlZCB0byBhZGQgYSByZXNpemUgZnVuY3Rpb25hbGl0eSB0byB5b3VyXG4gKiBub2Rlcy4gSXQgcmVuZGVycyBkcmFnZ2FibGUgY29udHJvbHMgYXJvdW5kIHRoZSBub2RlIHRvIHJlc2l6ZSBpbiBhbGwgZGlyZWN0aW9ucy5cbiAqIEBwdWJsaWNcbiAqXG4gKiBAZXhhbXBsZVxuICpgYGBqc3hcbiAqaW1wb3J0IHsgbWVtbyB9IGZyb20gJ3JlYWN0JztcbiAqaW1wb3J0IHsgSGFuZGxlLCBQb3NpdGlvbiwgTm9kZVJlc2l6ZXIgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKmZ1bmN0aW9uIFJlc2l6YWJsZU5vZGUoeyBkYXRhIH0pIHtcbiAqICByZXR1cm4gKFxuICogICAgPD5cbiAqICAgICAgPE5vZGVSZXNpemVyIG1pbldpZHRoPXsxMDB9IG1pbkhlaWdodD17MzB9IC8+XG4gKiAgICAgIDxIYW5kbGUgdHlwZT1cInRhcmdldFwiIHBvc2l0aW9uPXtQb3NpdGlvbi5MZWZ0fSAvPlxuICogICAgICA8ZGl2IHN0eWxlPXt7IHBhZGRpbmc6IDEwIH19PntkYXRhLmxhYmVsfTwvZGl2PlxuICogICAgICA8SGFuZGxlIHR5cGU9XCJzb3VyY2VcIiBwb3NpdGlvbj17UG9zaXRpb24uUmlnaHR9IC8+XG4gKiAgICA8Lz5cbiAqICApO1xuICp9O1xuICpcbiAqZXhwb3J0IGRlZmF1bHQgbWVtbyhSZXNpemFibGVOb2RlKTtcbiAqYGBgXG4gKi9cbmZ1bmN0aW9uIE5vZGVSZXNpemVyKHsgbm9kZUlkLCBpc1Zpc2libGUgPSB0cnVlLCBoYW5kbGVDbGFzc05hbWUsIGhhbmRsZVN0eWxlLCBsaW5lQ2xhc3NOYW1lLCBsaW5lU3R5bGUsIGNvbG9yLCBtaW5XaWR0aCA9IDEwLCBtaW5IZWlnaHQgPSAxMCwgbWF4V2lkdGggPSBOdW1iZXIuTUFYX1ZBTFVFLCBtYXhIZWlnaHQgPSBOdW1iZXIuTUFYX1ZBTFVFLCBrZWVwQXNwZWN0UmF0aW8gPSBmYWxzZSwgc2hvdWxkUmVzaXplLCBvblJlc2l6ZVN0YXJ0LCBvblJlc2l6ZSwgb25SZXNpemVFbmQsIH0pIHtcbiAgICBpZiAoIWlzVmlzaWJsZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIChqc3hzKEZyYWdtZW50LCB7IGNoaWxkcmVuOiBbWFlfUkVTSVpFUl9MSU5FX1BPU0lUSU9OUy5tYXAoKHBvc2l0aW9uKSA9PiAoanN4KE5vZGVSZXNpemVDb250cm9sLCB7IGNsYXNzTmFtZTogbGluZUNsYXNzTmFtZSwgc3R5bGU6IGxpbmVTdHlsZSwgbm9kZUlkOiBub2RlSWQsIHBvc2l0aW9uOiBwb3NpdGlvbiwgdmFyaWFudDogUmVzaXplQ29udHJvbFZhcmlhbnQuTGluZSwgY29sb3I6IGNvbG9yLCBtaW5XaWR0aDogbWluV2lkdGgsIG1pbkhlaWdodDogbWluSGVpZ2h0LCBtYXhXaWR0aDogbWF4V2lkdGgsIG1heEhlaWdodDogbWF4SGVpZ2h0LCBvblJlc2l6ZVN0YXJ0OiBvblJlc2l6ZVN0YXJ0LCBrZWVwQXNwZWN0UmF0aW86IGtlZXBBc3BlY3RSYXRpbywgc2hvdWxkUmVzaXplOiBzaG91bGRSZXNpemUsIG9uUmVzaXplOiBvblJlc2l6ZSwgb25SZXNpemVFbmQ6IG9uUmVzaXplRW5kIH0sIHBvc2l0aW9uKSkpLCBYWV9SRVNJWkVSX0hBTkRMRV9QT1NJVElPTlMubWFwKChwb3NpdGlvbikgPT4gKGpzeChOb2RlUmVzaXplQ29udHJvbCwgeyBjbGFzc05hbWU6IGhhbmRsZUNsYXNzTmFtZSwgc3R5bGU6IGhhbmRsZVN0eWxlLCBub2RlSWQ6IG5vZGVJZCwgcG9zaXRpb246IHBvc2l0aW9uLCBjb2xvcjogY29sb3IsIG1pbldpZHRoOiBtaW5XaWR0aCwgbWluSGVpZ2h0OiBtaW5IZWlnaHQsIG1heFdpZHRoOiBtYXhXaWR0aCwgbWF4SGVpZ2h0OiBtYXhIZWlnaHQsIG9uUmVzaXplU3RhcnQ6IG9uUmVzaXplU3RhcnQsIGtlZXBBc3BlY3RSYXRpbzoga2VlcEFzcGVjdFJhdGlvLCBzaG91bGRSZXNpemU6IHNob3VsZFJlc2l6ZSwgb25SZXNpemU6IG9uUmVzaXplLCBvblJlc2l6ZUVuZDogb25SZXNpemVFbmQgfSwgcG9zaXRpb24pKSldIH0pKTtcbn1cblxuY29uc3Qgc2VsZWN0b3IgPSAoc3RhdGUpID0+IHN0YXRlLmRvbU5vZGU/LnF1ZXJ5U2VsZWN0b3IoJy5yZWFjdC1mbG93X19yZW5kZXJlcicpO1xuZnVuY3Rpb24gTm9kZVRvb2xiYXJQb3J0YWwoeyBjaGlsZHJlbiB9KSB7XG4gICAgY29uc3Qgd3JhcHBlclJlZiA9IHVzZVN0b3JlKHNlbGVjdG9yKTtcbiAgICBpZiAoIXdyYXBwZXJSZWYpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVQb3J0YWwoY2hpbGRyZW4sIHdyYXBwZXJSZWYpO1xufVxuXG5jb25zdCBub2RlRXF1YWxpdHlGbiA9IChhLCBiKSA9PiBhPy5pbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZS54ICE9PSBiPy5pbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZS54IHx8XG4gICAgYT8uaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUueSAhPT0gYj8uaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUueSB8fFxuICAgIGE/Lm1lYXN1cmVkLndpZHRoICE9PSBiPy5tZWFzdXJlZC53aWR0aCB8fFxuICAgIGE/Lm1lYXN1cmVkLmhlaWdodCAhPT0gYj8ubWVhc3VyZWQuaGVpZ2h0IHx8XG4gICAgYT8uc2VsZWN0ZWQgIT09IGI/LnNlbGVjdGVkIHx8XG4gICAgYT8uaW50ZXJuYWxzLnogIT09IGI/LmludGVybmFscy56O1xuY29uc3Qgbm9kZXNFcXVhbGl0eUZuID0gKGEsIGIpID0+IHtcbiAgICBpZiAoYS5zaXplICE9PSBiLnNpemUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtrZXksIG5vZGVdIG9mIGEpIHtcbiAgICAgICAgaWYgKG5vZGVFcXVhbGl0eUZuKG5vZGUsIGIuZ2V0KGtleSkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuY29uc3Qgc3RvcmVTZWxlY3RvciA9IChzdGF0ZSkgPT4gKHtcbiAgICB4OiBzdGF0ZS50cmFuc2Zvcm1bMF0sXG4gICAgeTogc3RhdGUudHJhbnNmb3JtWzFdLFxuICAgIHpvb206IHN0YXRlLnRyYW5zZm9ybVsyXSxcbiAgICBzZWxlY3RlZE5vZGVzQ291bnQ6IHN0YXRlLm5vZGVzLmZpbHRlcigobm9kZSkgPT4gbm9kZS5zZWxlY3RlZCkubGVuZ3RoLFxufSk7XG4vKipcbiAqIFRoaXMgY29tcG9uZW50IGNhbiByZW5kZXIgYSB0b29sYmFyIG9yIHRvb2x0aXAgdG8gb25lIHNpZGUgb2YgYSBjdXN0b20gbm9kZS4gVGhpc1xuICogdG9vbGJhciBkb2Vzbid0IHNjYWxlIHdpdGggdGhlIHZpZXdwb3J0IHNvIHRoYXQgdGhlIGNvbnRlbnQgaXMgYWx3YXlzIHZpc2libGUuXG4gKlxuICogQHB1YmxpY1xuICogQGV4YW1wbGVcbiAqIGBgYGpzeFxuICppbXBvcnQgeyBtZW1vIH0gZnJvbSAncmVhY3QnO1xuICppbXBvcnQgeyBIYW5kbGUsIFBvc2l0aW9uLCBOb2RlVG9vbGJhciB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqZnVuY3Rpb24gQ3VzdG9tTm9kZSh7IGRhdGEgfSkge1xuICogIHJldHVybiAoXG4gKiAgICA8PlxuICogICAgICA8Tm9kZVRvb2xiYXIgaXNWaXNpYmxlPXtkYXRhLnRvb2xiYXJWaXNpYmxlfSBwb3NpdGlvbj17ZGF0YS50b29sYmFyUG9zaXRpb259PlxuICogICAgICAgIDxidXR0b24+ZGVsZXRlPC9idXR0b24+XG4gKiAgICAgICAgPGJ1dHRvbj5jb3B5PC9idXR0b24+XG4gKiAgICAgICAgPGJ1dHRvbj5leHBhbmQ8L2J1dHRvbj5cbiAqICAgICAgPC9Ob2RlVG9vbGJhcj5cbiAqXG4gKiAgICAgIDxkaXYgc3R5bGU9e3sgcGFkZGluZzogJzEwcHggMjBweCcgfX0+XG4gKiAgICAgICAge2RhdGEubGFiZWx9XG4gKiAgICAgIDwvZGl2PlxuICpcbiAqICAgICAgPEhhbmRsZSB0eXBlPVwidGFyZ2V0XCIgcG9zaXRpb249e1Bvc2l0aW9uLkxlZnR9IC8+XG4gKiAgICAgIDxIYW5kbGUgdHlwZT1cInNvdXJjZVwiIHBvc2l0aW9uPXtQb3NpdGlvbi5SaWdodH0gLz5cbiAqICAgIDwvPlxuICogICk7XG4gKn07XG4gKlxuICpleHBvcnQgZGVmYXVsdCBtZW1vKEN1c3RvbU5vZGUpO1xuICpgYGBcbiAqIEByZW1hcmtzIEJ5IGRlZmF1bHQsIHRoZSB0b29sYmFyIGlzIG9ubHkgdmlzaWJsZSB3aGVuIGEgbm9kZSBpcyBzZWxlY3RlZC4gSWYgbXVsdGlwbGVcbiAqIG5vZGVzIGFyZSBzZWxlY3RlZCBpdCB3aWxsIG5vdCBiZSB2aXNpYmxlIHRvIHByZXZlbnQgb3ZlcmxhcHBpbmcgdG9vbGJhcnMgb3JcbiAqIGNsdXR0ZXIuIFlvdSBjYW4gb3ZlcnJpZGUgdGhpcyBiZWhhdmlvciBieSBzZXR0aW5nIHRoZSBgaXNWaXNpYmxlYCBwcm9wIHRvIGB0cnVlYC5cbiAqL1xuZnVuY3Rpb24gTm9kZVRvb2xiYXIoeyBub2RlSWQsIGNoaWxkcmVuLCBjbGFzc05hbWUsIHN0eWxlLCBpc1Zpc2libGUsIHBvc2l0aW9uID0gUG9zaXRpb24uVG9wLCBvZmZzZXQgPSAxMCwgYWxpZ24gPSAnY2VudGVyJywgLi4ucmVzdCB9KSB7XG4gICAgY29uc3QgY29udGV4dE5vZGVJZCA9IHVzZU5vZGVJZCgpO1xuICAgIGNvbnN0IG5vZGVzU2VsZWN0b3IgPSB1c2VDYWxsYmFjaygoc3RhdGUpID0+IHtcbiAgICAgICAgY29uc3Qgbm9kZUlkcyA9IEFycmF5LmlzQXJyYXkobm9kZUlkKSA/IG5vZGVJZCA6IFtub2RlSWQgfHwgY29udGV4dE5vZGVJZCB8fCAnJ107XG4gICAgICAgIGNvbnN0IGludGVybmFsTm9kZXMgPSBub2RlSWRzLnJlZHVjZSgocmVzLCBpZCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHN0YXRlLm5vZGVMb29rdXAuZ2V0KGlkKTtcbiAgICAgICAgICAgIGlmIChub2RlKSB7XG4gICAgICAgICAgICAgICAgcmVzLnNldChub2RlLmlkLCBub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0sIG5ldyBNYXAoKSk7XG4gICAgICAgIHJldHVybiBpbnRlcm5hbE5vZGVzO1xuICAgIH0sIFtub2RlSWQsIGNvbnRleHROb2RlSWRdKTtcbiAgICBjb25zdCBub2RlcyA9IHVzZVN0b3JlKG5vZGVzU2VsZWN0b3IsIG5vZGVzRXF1YWxpdHlGbik7XG4gICAgY29uc3QgeyB4LCB5LCB6b29tLCBzZWxlY3RlZE5vZGVzQ291bnQgfSA9IHVzZVN0b3JlKHN0b3JlU2VsZWN0b3IsIHNoYWxsb3cpO1xuICAgIC8vIGlmIGlzVmlzaWJsZSBpcyBub3Qgc2V0LCB3ZSBzaG93IHRoZSB0b29sYmFyIG9ubHkgaWYgaXRzIG5vZGUgaXMgc2VsZWN0ZWQgYW5kIG5vIG90aGVyIG5vZGUgaXMgc2VsZWN0ZWRcbiAgICBjb25zdCBpc0FjdGl2ZSA9IHR5cGVvZiBpc1Zpc2libGUgPT09ICdib29sZWFuJ1xuICAgICAgICA/IGlzVmlzaWJsZVxuICAgICAgICA6IG5vZGVzLnNpemUgPT09IDEgJiYgbm9kZXMudmFsdWVzKCkubmV4dCgpLnZhbHVlPy5zZWxlY3RlZCAmJiBzZWxlY3RlZE5vZGVzQ291bnQgPT09IDE7XG4gICAgaWYgKCFpc0FjdGl2ZSB8fCAhbm9kZXMuc2l6ZSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qgbm9kZVJlY3QgPSBnZXRJbnRlcm5hbE5vZGVzQm91bmRzKG5vZGVzKTtcbiAgICBjb25zdCBub2Rlc0FycmF5ID0gQXJyYXkuZnJvbShub2Rlcy52YWx1ZXMoKSk7XG4gICAgY29uc3QgekluZGV4ID0gTWF0aC5tYXgoLi4ubm9kZXNBcnJheS5tYXAoKG5vZGUpID0+IG5vZGUuaW50ZXJuYWxzLnogKyAxKSk7XG4gICAgY29uc3Qgd3JhcHBlclN0eWxlID0ge1xuICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgICAgdHJhbnNmb3JtOiBnZXROb2RlVG9vbGJhclRyYW5zZm9ybShub2RlUmVjdCwgeyB4LCB5LCB6b29tIH0sIHBvc2l0aW9uLCBvZmZzZXQsIGFsaWduKSxcbiAgICAgICAgekluZGV4LFxuICAgICAgICAuLi5zdHlsZSxcbiAgICB9O1xuICAgIHJldHVybiAoanN4KE5vZGVUb29sYmFyUG9ydGFsLCB7IGNoaWxkcmVuOiBqc3goXCJkaXZcIiwgeyBzdHlsZTogd3JhcHBlclN0eWxlLCBjbGFzc05hbWU6IGNjKFsncmVhY3QtZmxvd19fbm9kZS10b29sYmFyJywgY2xhc3NOYW1lXSksIC4uLnJlc3QsIFwiZGF0YS1pZFwiOiBub2Rlc0FycmF5LnJlZHVjZSgoYWNjLCBub2RlKSA9PiBgJHthY2N9JHtub2RlLmlkfSBgLCAnJykudHJpbSgpLCBjaGlsZHJlbjogY2hpbGRyZW4gfSkgfSkpO1xufVxuXG5leHBvcnQgeyBCYWNrZ3JvdW5kLCBCYWNrZ3JvdW5kVmFyaWFudCwgQmFzZUVkZ2UsIEJlemllckVkZ2UsIENvbnRyb2xCdXR0b24sIENvbnRyb2xzLCBFZGdlTGFiZWxSZW5kZXJlciwgRWRnZVRleHQsIEhhbmRsZSwgTWluaU1hcCwgTm9kZVJlc2l6ZUNvbnRyb2wsIE5vZGVSZXNpemVyLCBOb2RlVG9vbGJhciwgUGFuZWwsIGluZGV4IGFzIFJlYWN0RmxvdywgUmVhY3RGbG93UHJvdmlkZXIsIFNpbXBsZUJlemllckVkZ2UsIFNtb290aFN0ZXBFZGdlLCBTdGVwRWRnZSwgU3RyYWlnaHRFZGdlLCBWaWV3cG9ydFBvcnRhbCwgYXBwbHlFZGdlQ2hhbmdlcywgYXBwbHlOb2RlQ2hhbmdlcywgZ2V0U2ltcGxlQmV6aWVyUGF0aCwgaXNFZGdlLCBpc05vZGUsIHVzZUNvbm5lY3Rpb24sIHVzZUVkZ2VzLCB1c2VFZGdlc1N0YXRlLCB1c2VIYW5kbGVDb25uZWN0aW9ucywgdXNlSW50ZXJuYWxOb2RlLCB1c2VLZXlQcmVzcywgdXNlTm9kZUNvbm5lY3Rpb25zLCB1c2VOb2RlSWQsIHVzZU5vZGVzLCB1c2VOb2Rlc0RhdGEsIHVzZU5vZGVzSW5pdGlhbGl6ZWQsIHVzZU5vZGVzU3RhdGUsIHVzZU9uU2VsZWN0aW9uQ2hhbmdlLCB1c2VPblZpZXdwb3J0Q2hhbmdlLCB1c2VSZWFjdEZsb3csIHVzZVN0b3JlLCB1c2VTdG9yZUFwaSwgdXNlVXBkYXRlTm9kZUludGVybmFscywgdXNlVmlld3BvcnQgfTtcbiJdLCJuYW1lcyI6WyJqc3hzIiwiRnJhZ21lbnQiLCJqc3giLCJjcmVhdGVDb250ZXh0IiwidXNlQ29udGV4dCIsInVzZU1lbW8iLCJmb3J3YXJkUmVmIiwidXNlRWZmZWN0IiwidXNlUmVmIiwidXNlU3RhdGUiLCJ1c2VMYXlvdXRFZmZlY3QiLCJ1c2VDYWxsYmFjayIsIm1lbW8iLCJjYyIsImVycm9yTWVzc2FnZXMiLCJpbmZpbml0ZUV4dGVudCIsImlzSW5wdXRET01Ob2RlIiwiZ2V0Rml0Vmlld05vZGVzIiwiZ2V0RGltZW5zaW9ucyIsImZpdFZpZXciLCJnZXRWaWV3cG9ydEZvckJvdW5kcyIsInBvaW50VG9SZW5kZXJlclBvaW50IiwicmVuZGVyZXJQb2ludFRvUG9pbnQiLCJpc05vZGVCYXNlIiwiaXNFZGdlQmFzZSIsImdldEVsZW1lbnRzVG9SZW1vdmUiLCJpc1JlY3RPYmplY3QiLCJub2RlVG9SZWN0IiwiZ2V0T3ZlcmxhcHBpbmdBcmVhIiwiZ2V0Tm9kZXNCb3VuZHMiLCJldmFsdWF0ZUFic29sdXRlUG9zaXRpb24iLCJYWVBhblpvb20iLCJQYW5PblNjcm9sbE1vZGUiLCJTZWxlY3Rpb25Nb2RlIiwiZ2V0RXZlbnRQb3NpdGlvbiIsImdldE5vZGVzSW5zaWRlIiwiYXJlU2V0c0VxdWFsIiwiWFlEcmFnIiwic25hcFBvc2l0aW9uIiwiY2FsY3VsYXRlTm9kZVBvc2l0aW9uIiwiUG9zaXRpb24iLCJDb25uZWN0aW9uTW9kZSIsImlzTW91c2VFdmVudCIsIlhZSGFuZGxlIiwiZ2V0SG9zdEZvckVsZW1lbnQiLCJhZGRFZGdlIiwiZ2V0SW50ZXJuYWxOb2Rlc0JvdW5kcyIsImlzTnVtZXJpYyIsIm5vZGVIYXNEaW1lbnNpb25zIiwiZ2V0Tm9kZURpbWVuc2lvbnMiLCJlbGVtZW50U2VsZWN0aW9uS2V5cyIsImlzRWRnZVZpc2libGUiLCJNYXJrZXJUeXBlIiwiY3JlYXRlTWFya2VySWRzIiwiZ2V0QmV6aWVyRWRnZUNlbnRlciIsImdldFNtb290aFN0ZXBQYXRoIiwiZ2V0U3RyYWlnaHRQYXRoIiwiZ2V0QmV6aWVyUGF0aCIsImdldEVkZ2VQb3NpdGlvbiIsImdldEVsZXZhdGVkRWRnZVpJbmRleCIsImdldE1hcmtlcklkIiwiZ2V0Q29ubmVjdGlvblN0YXR1cyIsIkNvbm5lY3Rpb25MaW5lVHlwZSIsInVwZGF0ZUNvbm5lY3Rpb25Mb29rdXAiLCJhZG9wdFVzZXJOb2RlcyIsImluaXRpYWxDb25uZWN0aW9uIiwiZGV2V2FybiIsInVwZGF0ZU5vZGVJbnRlcm5hbHMiLCJ1cGRhdGVBYnNvbHV0ZVBvc2l0aW9ucyIsImhhbmRsZUV4cGFuZFBhcmVudCIsInBhbkJ5IiwiaXNNYWNPcyIsImFyZUNvbm5lY3Rpb25NYXBzRXF1YWwiLCJoYW5kbGVDb25uZWN0aW9uQ2hhbmdlIiwic2hhbGxvd05vZGVEYXRhIiwiWFlNaW5pbWFwIiwiZ2V0Qm91bmRzT2ZSZWN0cyIsIlJlc2l6ZUNvbnRyb2xWYXJpYW50IiwiWFlSZXNpemVyIiwiWFlfUkVTSVpFUl9MSU5FX1BPU0lUSU9OUyIsIlhZX1JFU0laRVJfSEFORExFX1BPU0lUSU9OUyIsImdldE5vZGVUb29sYmFyVHJhbnNmb3JtIiwiZ2V0Q29ubmVjdGVkRWRnZXMiLCJnZXRFZGdlQ2VudGVyIiwiZ2V0SW5jb21lcnMiLCJnZXRPdXRnb2VycyIsInJlY29ubmVjdEVkZ2UiLCJ1c2VTdG9yZVdpdGhFcXVhbGl0eUZuIiwiY3JlYXRlV2l0aEVxdWFsaXR5Rm4iLCJzaGFsbG93IiwiY3JlYXRlUG9ydGFsIiwiU3RvcmVDb250ZXh0IiwiUHJvdmlkZXIkMSIsIlByb3ZpZGVyIiwienVzdGFuZEVycm9yTWVzc2FnZSIsInVzZVN0b3JlIiwic2VsZWN0b3IiLCJlcXVhbGl0eUZuIiwic3RvcmUiLCJFcnJvciIsInVzZVN0b3JlQXBpIiwiZ2V0U3RhdGUiLCJzZXRTdGF0ZSIsInN1YnNjcmliZSIsInN0eWxlIiwiZGlzcGxheSIsImFyaWFMaXZlU3R5bGUiLCJwb3NpdGlvbiIsIndpZHRoIiwiaGVpZ2h0IiwibWFyZ2luIiwiYm9yZGVyIiwicGFkZGluZyIsIm92ZXJmbG93IiwiY2xpcCIsImNsaXBQYXRoIiwiQVJJQV9OT0RFX0RFU0NfS0VZIiwiQVJJQV9FREdFX0RFU0NfS0VZIiwiQVJJQV9MSVZFX01FU1NBR0UiLCJzZWxlY3RvciRvIiwicyIsImFyaWFMaXZlTWVzc2FnZSIsIkFyaWFMaXZlTWVzc2FnZSIsInJmSWQiLCJpZCIsImNoaWxkcmVuIiwiQTExeURlc2NyaXB0aW9ucyIsImRpc2FibGVLZXlib2FyZEExMXkiLCJzZWxlY3RvciRuIiwidXNlclNlbGVjdGlvbkFjdGl2ZSIsIlBhbmVsIiwiY2xhc3NOYW1lIiwicmVzdCIsInJlZiIsInBvaW50ZXJFdmVudHMiLCJwb3NpdGlvbkNsYXNzZXMiLCJzcGxpdCIsImRpc3BsYXlOYW1lIiwiQXR0cmlidXRpb24iLCJwcm9PcHRpb25zIiwiaGlkZUF0dHJpYnV0aW9uIiwiaHJlZiIsInRhcmdldCIsInJlbCIsInNlbGVjdG9yJG0iLCJzZWxlY3RlZE5vZGVzIiwic2VsZWN0ZWRFZGdlcyIsIm5vZGUiLCJub2RlTG9va3VwIiwic2VsZWN0ZWQiLCJwdXNoIiwiaW50ZXJuYWxzIiwidXNlck5vZGUiLCJlZGdlIiwiZWRnZUxvb2t1cCIsInNlbGVjdElkIiwib2JqIiwiYXJlRXF1YWwiLCJhIiwiYiIsIm1hcCIsIlNlbGVjdGlvbkxpc3RlbmVySW5uZXIiLCJvblNlbGVjdGlvbkNoYW5nZSIsInBhcmFtcyIsIm5vZGVzIiwiZWRnZXMiLCJvblNlbGVjdGlvbkNoYW5nZUhhbmRsZXJzIiwiZm9yRWFjaCIsImZuIiwiY2hhbmdlU2VsZWN0b3IiLCJTZWxlY3Rpb25MaXN0ZW5lciIsInN0b3JlSGFzU2VsZWN0aW9uQ2hhbmdlSGFuZGxlcnMiLCJkZWZhdWx0Tm9kZU9yaWdpbiIsImRlZmF1bHRWaWV3cG9ydCIsIngiLCJ5Iiwiem9vbSIsInJlYWN0Rmxvd0ZpZWxkc1RvVHJhY2siLCJmaWVsZHNUb1RyYWNrIiwic2VsZWN0b3IkbCIsInNldE5vZGVzIiwic2V0RWRnZXMiLCJzZXRNaW5ab29tIiwic2V0TWF4Wm9vbSIsInNldFRyYW5zbGF0ZUV4dGVudCIsInNldE5vZGVFeHRlbnQiLCJyZXNldCIsInNldERlZmF1bHROb2Rlc0FuZEVkZ2VzIiwic2V0UGFuZUNsaWNrRGlzdGFuY2UiLCJpbml0UHJldlZhbHVlcyIsInRyYW5zbGF0ZUV4dGVudCIsIm5vZGVPcmlnaW4iLCJtaW5ab29tIiwibWF4Wm9vbSIsImVsZW1lbnRzU2VsZWN0YWJsZSIsIm5vUGFuQ2xhc3NOYW1lIiwicGFuZUNsaWNrRGlzdGFuY2UiLCJTdG9yZVVwZGF0ZXIiLCJwcm9wcyIsImRlZmF1bHROb2RlcyIsImRlZmF1bHRFZGdlcyIsInByZXZpb3VzRmllbGRzIiwiY3VycmVudCIsImZpZWxkTmFtZSIsImZpZWxkVmFsdWUiLCJwcmV2aW91c0ZpZWxkVmFsdWUiLCJmaXRWaWV3T25Jbml0IiwiZml0Vmlld09uSW5pdE9wdGlvbnMiLCJnZXRNZWRpYVF1ZXJ5Iiwid2luZG93IiwibWF0Y2hNZWRpYSIsInVzZUNvbG9yTW9kZUNsYXNzIiwiY29sb3JNb2RlIiwiY29sb3JNb2RlQ2xhc3MiLCJzZXRDb2xvck1vZGVDbGFzcyIsIm1lZGlhUXVlcnkiLCJ1cGRhdGVDb2xvck1vZGVDbGFzcyIsIm1hdGNoZXMiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImRlZmF1bHREb2MiLCJkb2N1bWVudCIsInVzZUtleVByZXNzIiwia2V5Q29kZSIsIm9wdGlvbnMiLCJhY3RJbnNpZGVJbnB1dFdpdGhNb2RpZmllciIsImtleVByZXNzZWQiLCJzZXRLZXlQcmVzc2VkIiwibW9kaWZpZXJQcmVzc2VkIiwicHJlc3NlZEtleXMiLCJTZXQiLCJrZXlDb2RlcyIsImtleXNUb1dhdGNoIiwia2V5Q29kZUFyciIsIkFycmF5IiwiaXNBcnJheSIsImtleXMiLCJmaWx0ZXIiLCJrYyIsInJlcGxhY2UiLCJrZXlzRmxhdCIsInJlZHVjZSIsInJlcyIsIml0ZW0iLCJjb25jYXQiLCJkb3duSGFuZGxlciIsImV2ZW50IiwiY3RybEtleSIsIm1ldGFLZXkiLCJzaGlmdEtleSIsInByZXZlbnRBY3Rpb24iLCJrZXlPckNvZGUiLCJ1c2VLZXlPckNvZGUiLCJjb2RlIiwiYWRkIiwiaXNNYXRjaGluZ0tleSIsInByZXZlbnREZWZhdWx0IiwidXBIYW5kbGVyIiwiY2xlYXIiLCJkZWxldGUiLCJrZXkiLCJyZXNldEhhbmRsZXIiLCJpc1VwIiwibGVuZ3RoIiwic2l6ZSIsInNvbWUiLCJldmVyeSIsImsiLCJoYXMiLCJldmVudENvZGUiLCJpbmNsdWRlcyIsInVzZVZpZXdwb3J0SGVscGVyIiwiem9vbUluIiwicGFuWm9vbSIsInNjYWxlQnkiLCJkdXJhdGlvbiIsIlByb21pc2UiLCJyZXNvbHZlIiwiem9vbU91dCIsInpvb21UbyIsInpvb21MZXZlbCIsInNjYWxlVG8iLCJnZXRab29tIiwidHJhbnNmb3JtIiwic2V0Vmlld3BvcnQiLCJ2aWV3cG9ydCIsInRYIiwidFkiLCJ0Wm9vbSIsImdldFZpZXdwb3J0IiwiZG9tTm9kZSIsImZpdFZpZXdOb2RlcyIsInNldENlbnRlciIsIm5leHRab29tIiwiY2VudGVyWCIsImNlbnRlclkiLCJmaXRCb3VuZHMiLCJib3VuZHMiLCJzY3JlZW5Ub0Zsb3dQb3NpdGlvbiIsImNsaWVudFBvc2l0aW9uIiwic25hcEdyaWQiLCJzbmFwVG9HcmlkIiwiZG9tWCIsImRvbVkiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJjb3JyZWN0ZWRQb3NpdGlvbiIsIl9zbmFwR3JpZCIsIl9zbmFwVG9HcmlkIiwiZmxvd1RvU2NyZWVuUG9zaXRpb24iLCJmbG93UG9zaXRpb24iLCJyZW5kZXJlclBvc2l0aW9uIiwiYXBwbHlDaGFuZ2VzIiwiY2hhbmdlcyIsImVsZW1lbnRzIiwidXBkYXRlZEVsZW1lbnRzIiwiY2hhbmdlc01hcCIsIk1hcCIsImFkZEl0ZW1DaGFuZ2VzIiwiY2hhbmdlIiwidHlwZSIsInNldCIsImVsZW1lbnRDaGFuZ2VzIiwiZ2V0IiwiZWxlbWVudCIsInVwZGF0ZWRFbGVtZW50IiwiYXBwbHlDaGFuZ2UiLCJpbmRleCIsInVuZGVmaW5lZCIsInNwbGljZSIsImRyYWdnaW5nIiwiZGltZW5zaW9ucyIsIm1lYXN1cmVkIiwic2V0QXR0cmlidXRlcyIsInJlc2l6aW5nIiwiYXBwbHlOb2RlQ2hhbmdlcyIsImFwcGx5RWRnZUNoYW5nZXMiLCJjcmVhdGVTZWxlY3Rpb25DaGFuZ2UiLCJnZXRTZWxlY3Rpb25DaGFuZ2VzIiwiaXRlbXMiLCJzZWxlY3RlZElkcyIsIm11dGF0ZUl0ZW0iLCJ3aWxsQmVTZWxlY3RlZCIsImdldEVsZW1lbnRzRGlmZkNoYW5nZXMiLCJsb29rdXAiLCJpdGVtc0xvb2t1cCIsImVudHJpZXMiLCJsb29rdXBJdGVtIiwic3RvcmVJdGVtIiwibmV4dE5vZGUiLCJlbGVtZW50VG9SZW1vdmVDaGFuZ2UiLCJpc05vZGUiLCJpc0VkZ2UiLCJmaXhlZEZvcndhcmRSZWYiLCJyZW5kZXIiLCJ1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0IiwidXNlUXVldWUiLCJydW5RdWV1ZSIsInNlcmlhbCIsInNldFNlcmlhbCIsIkJpZ0ludCIsInF1ZXVlIiwiY3JlYXRlUXVldWUiLCJuIiwicXVldWVJdGVtcyIsImNiIiwiQmF0Y2hDb250ZXh0IiwiQmF0Y2hQcm92aWRlciIsIm5vZGVRdWV1ZUhhbmRsZXIiLCJoYXNEZWZhdWx0Tm9kZXMiLCJvbk5vZGVzQ2hhbmdlIiwibmV4dCIsInBheWxvYWQiLCJub2RlUXVldWUiLCJlZGdlUXVldWVIYW5kbGVyIiwiaGFzRGVmYXVsdEVkZ2VzIiwib25FZGdlc0NoYW5nZSIsImVkZ2VRdWV1ZSIsInZhbHVlIiwidXNlQmF0Y2hDb250ZXh0IiwiYmF0Y2hDb250ZXh0Iiwic2VsZWN0b3IkayIsInVzZVJlYWN0RmxvdyIsInZpZXdwb3J0SGVscGVyIiwidmlld3BvcnRJbml0aWFsaXplZCIsImdlbmVyYWxIZWxwZXIiLCJnZXRJbnRlcm5hbE5vZGUiLCJnZXROb2RlUmVjdCIsIm5vZGVUb1VzZSIsInBhcmVudElkIiwibm9kZVdpdGhQb3NpdGlvbiIsInVwZGF0ZU5vZGUiLCJub2RlVXBkYXRlIiwicHJldk5vZGVzIiwidXBkYXRlRWRnZSIsImVkZ2VVcGRhdGUiLCJwcmV2RWRnZXMiLCJuZXh0RWRnZSIsImdldE5vZGVzIiwiZ2V0Tm9kZSIsImdldEVkZ2VzIiwiZSIsImdldEVkZ2UiLCJhZGROb2RlcyIsIm5ld05vZGVzIiwiYWRkRWRnZXMiLCJuZXdFZGdlcyIsInRvT2JqZWN0IiwiZGVsZXRlRWxlbWVudHMiLCJub2Rlc1RvUmVtb3ZlIiwiZWRnZXNUb1JlbW92ZSIsIm9uTm9kZXNEZWxldGUiLCJvbkVkZ2VzRGVsZXRlIiwidHJpZ2dlck5vZGVDaGFuZ2VzIiwidHJpZ2dlckVkZ2VDaGFuZ2VzIiwib25EZWxldGUiLCJvbkJlZm9yZURlbGV0ZSIsIm1hdGNoaW5nTm9kZXMiLCJtYXRjaGluZ0VkZ2VzIiwiaGFzTWF0Y2hpbmdFZGdlcyIsImhhc01hdGNoaW5nTm9kZXMiLCJlZGdlQ2hhbmdlcyIsIm5vZGVDaGFuZ2VzIiwiZGVsZXRlZE5vZGVzIiwiZGVsZXRlZEVkZ2VzIiwiZ2V0SW50ZXJzZWN0aW5nTm9kZXMiLCJub2RlT3JSZWN0IiwicGFydGlhbGx5IiwiaXNSZWN0Iiwibm9kZVJlY3QiLCJoYXNOb2Rlc09wdGlvbiIsImludGVybmFsTm9kZSIsInBvc2l0aW9uQWJzb2x1dGUiLCJjdXJyTm9kZVJlY3QiLCJvdmVybGFwcGluZ0FyZWEiLCJwYXJ0aWFsbHlWaXNpYmxlIiwiaXNOb2RlSW50ZXJzZWN0aW5nIiwiYXJlYSIsInVwZGF0ZU5vZGVEYXRhIiwiZGF0YVVwZGF0ZSIsIm5leHREYXRhIiwiZGF0YSIsInVwZGF0ZUVkZ2VEYXRhIiwiZ2V0SGFuZGxlQ29ubmVjdGlvbnMiLCJub2RlSWQiLCJmcm9tIiwiY29ubmVjdGlvbkxvb2t1cCIsInZhbHVlcyIsImdldE5vZGVDb25uZWN0aW9ucyIsImhhbmRsZUlkIiwiZGVsZXRlS2V5T3B0aW9ucyIsIndpbiQxIiwidXNlR2xvYmFsS2V5SGFuZGxlciIsImRlbGV0ZUtleUNvZGUiLCJtdWx0aVNlbGVjdGlvbktleUNvZGUiLCJkZWxldGVLZXlQcmVzc2VkIiwibXVsdGlTZWxlY3Rpb25LZXlQcmVzc2VkIiwibm9kZXNTZWxlY3Rpb25BY3RpdmUiLCJtdWx0aVNlbGVjdGlvbkFjdGl2ZSIsInVzZVJlc2l6ZUhhbmRsZXIiLCJ1cGRhdGVEaW1lbnNpb25zIiwib25FcnJvciIsInJlc2l6ZU9ic2VydmVyIiwiUmVzaXplT2JzZXJ2ZXIiLCJvYnNlcnZlIiwidW5vYnNlcnZlIiwiY29udGFpbmVyU3R5bGUiLCJ0b3AiLCJsZWZ0Iiwic2VsZWN0b3IkaiIsImxpYiIsIlpvb21QYW5lIiwib25QYW5lQ29udGV4dE1lbnUiLCJ6b29tT25TY3JvbGwiLCJ6b29tT25QaW5jaCIsInBhbk9uU2Nyb2xsIiwicGFuT25TY3JvbGxTcGVlZCIsInBhbk9uU2Nyb2xsTW9kZSIsIkZyZWUiLCJ6b29tT25Eb3VibGVDbGljayIsInBhbk9uRHJhZyIsInpvb21BY3RpdmF0aW9uS2V5Q29kZSIsInByZXZlbnRTY3JvbGxpbmciLCJub1doZWVsQ2xhc3NOYW1lIiwib25WaWV3cG9ydENoYW5nZSIsImlzQ29udHJvbGxlZFZpZXdwb3J0Iiwiem9vbVBhbmUiLCJ6b29tQWN0aXZhdGlvbktleVByZXNzZWQiLCJvblRyYW5zZm9ybUNoYW5nZSIsIm9uRHJhZ2dpbmdDaGFuZ2UiLCJwYW5lRHJhZ2dpbmciLCJvblBhblpvb21TdGFydCIsInZwIiwib25WaWV3cG9ydENoYW5nZVN0YXJ0Iiwib25Nb3ZlU3RhcnQiLCJvblBhblpvb20iLCJvbk1vdmUiLCJvblBhblpvb21FbmQiLCJvblZpZXdwb3J0Q2hhbmdlRW5kIiwib25Nb3ZlRW5kIiwiY2xvc2VzdCIsImRlc3Ryb3kiLCJ1cGRhdGUiLCJzZWxlY3RvciRpIiwidXNlclNlbGVjdGlvblJlY3QiLCJVc2VyU2VsZWN0aW9uIiwiaXNBY3RpdmUiLCJ3cmFwSGFuZGxlciIsImhhbmRsZXIiLCJjb250YWluZXJSZWYiLCJzZWxlY3RvciRoIiwiUGFuZSIsImlzU2VsZWN0aW5nIiwic2VsZWN0aW9uS2V5UHJlc3NlZCIsInNlbGVjdGlvbk1vZGUiLCJGdWxsIiwic2VsZWN0aW9uT25EcmFnIiwib25TZWxlY3Rpb25TdGFydCIsIm9uU2VsZWN0aW9uRW5kIiwib25QYW5lQ2xpY2siLCJvblBhbmVTY3JvbGwiLCJvblBhbmVNb3VzZUVudGVyIiwib25QYW5lTW91c2VNb3ZlIiwib25QYW5lTW91c2VMZWF2ZSIsImhhc0FjdGl2ZVNlbGVjdGlvbiIsImNvbnRhaW5lciIsImNvbnRhaW5lckJvdW5kcyIsInNlbGVjdGVkTm9kZUlkcyIsInNlbGVjdGVkRWRnZUlkcyIsInNlbGVjdGlvbkluUHJvZ3Jlc3MiLCJzZWxlY3Rpb25TdGFydGVkIiwib25DbGljayIsInJlc2V0U2VsZWN0ZWRFbGVtZW50cyIsIm9uQ29udGV4dE1lbnUiLCJvbldoZWVsIiwib25Qb2ludGVyRG93biIsImJ1dHRvbiIsInNldFBvaW50ZXJDYXB0dXJlIiwicG9pbnRlcklkIiwibmF0aXZlRXZlbnQiLCJzdGFydFgiLCJzdGFydFkiLCJvblBvaW50ZXJNb3ZlIiwiZGVmYXVsdEVkZ2VPcHRpb25zIiwibW91c2VYIiwibW91c2VZIiwibmV4dFVzZXJTZWxlY3RSZWN0IiwiTWF0aCIsImFicyIsInByZXZTZWxlY3RlZE5vZGVJZHMiLCJwcmV2U2VsZWN0ZWRFZGdlSWRzIiwiUGFydGlhbCIsImVkZ2VzU2VsZWN0YWJsZSIsInNlbGVjdGFibGUiLCJjb25uZWN0aW9ucyIsImVkZ2VJZCIsIm9uUG9pbnRlclVwIiwicmVsZWFzZVBvaW50ZXJDYXB0dXJlIiwiZHJhZ2dhYmxlIiwic2VsZWN0aW9uIiwib25Qb2ludGVyRW50ZXIiLCJvblBvaW50ZXJMZWF2ZSIsImhhbmRsZU5vZGVDbGljayIsInVuc2VsZWN0Iiwibm9kZVJlZiIsImFkZFNlbGVjdGVkTm9kZXMiLCJ1bnNlbGVjdE5vZGVzQW5kRWRnZXMiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJibHVyIiwidXNlRHJhZyIsImRpc2FibGVkIiwibm9EcmFnQ2xhc3NOYW1lIiwiaGFuZGxlU2VsZWN0b3IiLCJpc1NlbGVjdGFibGUiLCJub2RlQ2xpY2tEaXN0YW5jZSIsInNldERyYWdnaW5nIiwieHlEcmFnIiwiZ2V0U3RvcmVJdGVtcyIsIm9uTm9kZU1vdXNlRG93biIsIm9uRHJhZ1N0YXJ0Iiwib25EcmFnU3RvcCIsInNlbGVjdGVkQW5kRHJhZ2dhYmxlIiwibm9kZXNEcmFnZ2FibGUiLCJ1c2VNb3ZlU2VsZWN0ZWROb2RlcyIsIm1vdmVTZWxlY3RlZE5vZGVzIiwibm9kZUV4dGVudCIsInVwZGF0ZU5vZGVQb3NpdGlvbnMiLCJub2RlVXBkYXRlcyIsImlzU2VsZWN0ZWQiLCJ4VmVsbyIsInlWZWxvIiwieERpZmYiLCJkaXJlY3Rpb24iLCJmYWN0b3IiLCJ5RGlmZiIsIm5leHRQb3NpdGlvbiIsIk5vZGVJZENvbnRleHQiLCJDb25zdW1lciIsInVzZU5vZGVJZCIsInNlbGVjdG9yJGciLCJjb25uZWN0T25DbGljayIsImNvbm5lY3RpbmdTZWxlY3RvciIsInN0YXRlIiwiY29ubmVjdGlvbkNsaWNrU3RhcnRIYW5kbGUiLCJjbGlja0hhbmRsZSIsImNvbm5lY3Rpb25Nb2RlIiwiY29ubmVjdGlvbiIsImZyb21IYW5kbGUiLCJ0b0hhbmRsZSIsImlzVmFsaWQiLCJjb25uZWN0aW5nVG8iLCJjb25uZWN0aW5nRnJvbSIsImNsaWNrQ29ubmVjdGluZyIsImlzUG9zc2libGVFbmRIYW5kbGUiLCJTdHJpY3QiLCJjb25uZWN0aW9uSW5Qcm9jZXNzIiwiY2xpY2tDb25uZWN0aW9uSW5Qcm9jZXNzIiwidmFsaWQiLCJIYW5kbGVDb21wb25lbnQiLCJUb3AiLCJpc1ZhbGlkQ29ubmVjdGlvbiIsImlzQ29ubmVjdGFibGUiLCJpc0Nvbm5lY3RhYmxlU3RhcnQiLCJpc0Nvbm5lY3RhYmxlRW5kIiwib25Db25uZWN0Iiwib25Nb3VzZURvd24iLCJvblRvdWNoU3RhcnQiLCJpc1RhcmdldCIsIm9uQ29ubmVjdEV4dGVuZGVkIiwib25Db25uZWN0QWN0aW9uIiwiZWRnZVBhcmFtcyIsImlzTW91c2VUcmlnZ2VyZWQiLCJjdXJyZW50U3RvcmUiLCJhdXRvUGFuT25Db25uZWN0IiwiY29ubmVjdGlvblJhZGl1cyIsImZsb3dJZCIsImNhbmNlbENvbm5lY3Rpb24iLCJvbkNvbm5lY3RTdGFydCIsIm9uQ29ubmVjdEVuZCIsInVwZGF0ZUNvbm5lY3Rpb24iLCJnZXRUcmFuc2Zvcm0iLCJnZXRGcm9tSGFuZGxlIiwiYXV0b1BhblNwZWVkIiwib25DbGlja0Nvbm5lY3RTdGFydCIsIm9uQ2xpY2tDb25uZWN0RW5kIiwiaXNWYWxpZENvbm5lY3Rpb25TdG9yZSIsImNvbm5lY3Rpb25TdGF0ZSIsImhhbmRsZVR5cGUiLCJkb2MiLCJpc1ZhbGlkQ29ubmVjdGlvbkhhbmRsZXIiLCJoYW5kbGUiLCJmcm9tTm9kZUlkIiwiZnJvbUhhbmRsZUlkIiwiZnJvbVR5cGUiLCJjb25uZWN0aW9uQ2xvbmUiLCJzdHJ1Y3R1cmVkQ2xvbmUiLCJpblByb2dyZXNzIiwidG9Qb3NpdGlvbiIsInNvdXJjZSIsImNvbm5lY3RhYmxlIiwiY29ubmVjdGFibGVzdGFydCIsImNvbm5lY3RhYmxlZW5kIiwiY2xpY2tjb25uZWN0aW5nIiwiY29ubmVjdGluZ2Zyb20iLCJjb25uZWN0aW5ndG8iLCJjb25uZWN0aW9uaW5kaWNhdG9yIiwiSGFuZGxlIiwiSW5wdXROb2RlIiwic291cmNlUG9zaXRpb24iLCJCb3R0b20iLCJsYWJlbCIsIkRlZmF1bHROb2RlIiwidGFyZ2V0UG9zaXRpb24iLCJHcm91cE5vZGUiLCJPdXRwdXROb2RlIiwiYXJyb3dLZXlEaWZmcyIsIkFycm93VXAiLCJBcnJvd0Rvd24iLCJBcnJvd0xlZnQiLCJBcnJvd1JpZ2h0IiwiYnVpbHRpbk5vZGVUeXBlcyIsImlucHV0IiwiZGVmYXVsdCIsIm91dHB1dCIsImdyb3VwIiwiZ2V0Tm9kZUlubGluZVN0eWxlRGltZW5zaW9ucyIsImhhbmRsZUJvdW5kcyIsImluaXRpYWxXaWR0aCIsImluaXRpYWxIZWlnaHQiLCJzZWxlY3RvciRmIiwidHJhbnNmb3JtU3RyaW5nIiwiTm9kZXNTZWxlY3Rpb24iLCJvblNlbGVjdGlvbkNvbnRleHRNZW51IiwiZm9jdXMiLCJwcmV2ZW50U2Nyb2xsIiwib25LZXlEb3duIiwiT2JqZWN0IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwidGFiSW5kZXgiLCJ3aW4iLCJzZWxlY3RvciRlIiwiRmxvd1JlbmRlcmVyQ29tcG9uZW50Iiwic2VsZWN0aW9uS2V5Q29kZSIsInBhbkFjdGl2YXRpb25LZXlDb2RlIiwiX3Bhbk9uU2Nyb2xsIiwiX3Bhbk9uRHJhZyIsInBhbkFjdGl2YXRpb25LZXlQcmVzc2VkIiwiX3NlbGVjdGlvbk9uRHJhZyIsIkZsb3dSZW5kZXJlciIsInNlbGVjdG9yJGQiLCJvbmx5UmVuZGVyVmlzaWJsZSIsInVzZVZpc2libGVOb2RlSWRzIiwibm9kZUlkcyIsInNlbGVjdG9yJGMiLCJ1c2VSZXNpemVPYnNlcnZlciIsInVwZGF0ZXMiLCJlbnRyeSIsImdldEF0dHJpYnV0ZSIsIm5vZGVFbGVtZW50IiwiZm9yY2UiLCJkaXNjb25uZWN0IiwidXNlTm9kZU9ic2VydmVyIiwibm9kZVR5cGUiLCJoYXNEaW1lbnNpb25zIiwib2JzZXJ2ZWROb2RlIiwicHJldlNvdXJjZVBvc2l0aW9uIiwicHJldlRhcmdldFBvc2l0aW9uIiwicHJldlR5cGUiLCJpc0luaXRpYWxpemVkIiwiaGlkZGVuIiwidHlwZUNoYW5nZWQiLCJzb3VyY2VQb3NDaGFuZ2VkIiwidGFyZ2V0UG9zQ2hhbmdlZCIsIk5vZGVXcmFwcGVyIiwib25Nb3VzZUVudGVyIiwib25Nb3VzZU1vdmUiLCJvbk1vdXNlTGVhdmUiLCJvbkRvdWJsZUNsaWNrIiwibm9kZXNDb25uZWN0YWJsZSIsIm5vZGVzRm9jdXNhYmxlIiwibm9kZVR5cGVzIiwiaXNQYXJlbnQiLCJwYXJlbnRMb29rdXAiLCJOb2RlQ29tcG9uZW50IiwiaXNEcmFnZ2FibGUiLCJpc0ZvY3VzYWJsZSIsImZvY3VzYWJsZSIsImRyYWdIYW5kbGUiLCJub2RlRGltZW5zaW9ucyIsImlubGluZURpbWVuc2lvbnMiLCJoYXNQb2ludGVyRXZlbnRzIiwib25Nb3VzZUVudGVySGFuZGxlciIsIm9uTW91c2VNb3ZlSGFuZGxlciIsIm9uTW91c2VMZWF2ZUhhbmRsZXIiLCJvbkNvbnRleHRNZW51SGFuZGxlciIsIm9uRG91YmxlQ2xpY2tIYW5kbGVyIiwib25TZWxlY3ROb2RlSGFuZGxlciIsInNlbGVjdE5vZGVzT25EcmFnIiwibm9kZURyYWdUaHJlc2hvbGQiLCJ0b0xvd2VyQ2FzZSIsInBhcmVudCIsInpJbmRleCIsInoiLCJ2aXNpYmlsaXR5Iiwicm9sZSIsImFyaWFMYWJlbCIsInBvc2l0aW9uQWJzb2x1dGVYIiwicG9zaXRpb25BYnNvbHV0ZVkiLCJkZWxldGFibGUiLCJzZWxlY3RvciRiIiwiTm9kZVJlbmRlcmVyQ29tcG9uZW50Iiwib25seVJlbmRlclZpc2libGVFbGVtZW50cyIsIm9uTm9kZUNsaWNrIiwib25Ob2RlTW91c2VFbnRlciIsIm9uTm9kZU1vdXNlTW92ZSIsIm9uTm9kZU1vdXNlTGVhdmUiLCJvbk5vZGVDb250ZXh0TWVudSIsIm9uTm9kZURvdWJsZUNsaWNrIiwiTm9kZVJlbmRlcmVyIiwidXNlVmlzaWJsZUVkZ2VJZHMiLCJlZGdlSWRzIiwidmlzaWJsZUVkZ2VJZHMiLCJzb3VyY2VOb2RlIiwidGFyZ2V0Tm9kZSIsIkFycm93U3ltYm9sIiwiY29sb3IiLCJzdHJva2VXaWR0aCIsInN0cm9rZSIsInN0cm9rZUxpbmVjYXAiLCJzdHJva2VMaW5lam9pbiIsImZpbGwiLCJwb2ludHMiLCJBcnJvd0Nsb3NlZFN5bWJvbCIsIk1hcmtlclN5bWJvbHMiLCJBcnJvdyIsIkFycm93Q2xvc2VkIiwidXNlTWFya2VyU3ltYm9sIiwic3ltYm9sIiwic3ltYm9sRXhpc3RzIiwiTWFya2VyIiwibWFya2VyVW5pdHMiLCJvcmllbnQiLCJTeW1ib2wiLCJtYXJrZXJXaWR0aCIsIm1hcmtlckhlaWdodCIsInZpZXdCb3giLCJyZWZYIiwicmVmWSIsIk1hcmtlckRlZmluaXRpb25zIiwiZGVmYXVsdENvbG9yIiwibWFya2VycyIsImRlZmF1bHRNYXJrZXJTdGFydCIsIm1hcmtlclN0YXJ0IiwiZGVmYXVsdE1hcmtlckVuZCIsIm1hcmtlckVuZCIsIm1hcmtlciIsIk1hcmtlckRlZmluaXRpb25zJDEiLCJFZGdlVGV4dENvbXBvbmVudCIsImxhYmVsU3R5bGUiLCJsYWJlbFNob3dCZyIsImxhYmVsQmdTdHlsZSIsImxhYmVsQmdQYWRkaW5nIiwibGFiZWxCZ0JvcmRlclJhZGl1cyIsImVkZ2VUZXh0QmJveCIsInNldEVkZ2VUZXh0QmJveCIsImVkZ2VUZXh0Q2xhc3NlcyIsImVkZ2VUZXh0UmVmIiwidGV4dEJib3giLCJnZXRCQm94IiwicngiLCJyeSIsImR5IiwiRWRnZVRleHQiLCJCYXNlRWRnZSIsInBhdGgiLCJsYWJlbFgiLCJsYWJlbFkiLCJpbnRlcmFjdGlvbldpZHRoIiwiZCIsInN0cm9rZU9wYWNpdHkiLCJnZXRDb250cm9sIiwicG9zIiwieDEiLCJ5MSIsIngyIiwieTIiLCJMZWZ0IiwiUmlnaHQiLCJnZXRTaW1wbGVCZXppZXJQYXRoIiwic291cmNlWCIsInNvdXJjZVkiLCJ0YXJnZXRYIiwidGFyZ2V0WSIsInNvdXJjZUNvbnRyb2xYIiwic291cmNlQ29udHJvbFkiLCJ0YXJnZXRDb250cm9sWCIsInRhcmdldENvbnRyb2xZIiwib2Zmc2V0WCIsIm9mZnNldFkiLCJjcmVhdGVTaW1wbGVCZXppZXJFZGdlIiwiX2lkIiwiaXNJbnRlcm5hbCIsIlNpbXBsZUJlemllckVkZ2UiLCJTaW1wbGVCZXppZXJFZGdlSW50ZXJuYWwiLCJjcmVhdGVTbW9vdGhTdGVwRWRnZSIsInBhdGhPcHRpb25zIiwiYm9yZGVyUmFkaXVzIiwib2Zmc2V0IiwiU21vb3RoU3RlcEVkZ2UiLCJTbW9vdGhTdGVwRWRnZUludGVybmFsIiwiY3JlYXRlU3RlcEVkZ2UiLCJTdGVwRWRnZSIsIlN0ZXBFZGdlSW50ZXJuYWwiLCJjcmVhdGVTdHJhaWdodEVkZ2UiLCJTdHJhaWdodEVkZ2UiLCJTdHJhaWdodEVkZ2VJbnRlcm5hbCIsImNyZWF0ZUJlemllckVkZ2UiLCJjdXJ2YXR1cmUiLCJCZXppZXJFZGdlIiwiQmV6aWVyRWRnZUludGVybmFsIiwiYnVpbHRpbkVkZ2VUeXBlcyIsInN0cmFpZ2h0Iiwic3RlcCIsInNtb290aHN0ZXAiLCJzaW1wbGViZXppZXIiLCJudWxsUG9zaXRpb24iLCJzaGlmdFgiLCJzaGlmdCIsInNoaWZ0WSIsIkVkZ2VVcGRhdGVyQ2xhc3NOYW1lIiwiRWRnZUFuY2hvciIsInJhZGl1cyIsIm9uTW91c2VPdXQiLCJjeCIsImN5IiwiciIsIkVkZ2VVcGRhdGVBbmNob3JzIiwiaXNSZWNvbm5lY3RhYmxlIiwicmVjb25uZWN0UmFkaXVzIiwib25SZWNvbm5lY3QiLCJvblJlY29ubmVjdFN0YXJ0Iiwib25SZWNvbm5lY3RFbmQiLCJzZXRSZWNvbm5lY3RpbmciLCJzZXRVcGRhdGVIb3ZlciIsImhhbmRsZUVkZ2VVcGRhdGVyIiwib3Bwb3NpdGVIYW5kbGUiLCJfb25SZWNvbm5lY3RFbmQiLCJldnQiLCJvbkNvbm5lY3RFZGdlIiwiZWRnZVVwZGF0ZXJUeXBlIiwib25SZWNvbm5lY3RTb3VyY2VNb3VzZURvd24iLCJ0YXJnZXRIYW5kbGUiLCJvblJlY29ubmVjdFRhcmdldE1vdXNlRG93biIsInNvdXJjZUhhbmRsZSIsIm9uUmVjb25uZWN0TW91c2VFbnRlciIsIm9uUmVjb25uZWN0TW91c2VPdXQiLCJFZGdlV3JhcHBlciIsImVkZ2VzRm9jdXNhYmxlIiwiZWRnZXNSZWNvbm5lY3RhYmxlIiwiZWRnZVR5cGVzIiwiZWRnZVR5cGUiLCJFZGdlQ29tcG9uZW50IiwicmVjb25uZWN0YWJsZSIsImVkZ2VSZWYiLCJ1cGRhdGVIb3ZlciIsInJlY29ubmVjdGluZyIsImVkZ2VQb3NpdGlvbiIsImVsZXZhdGVPblNlbGVjdCIsImVsZXZhdGVFZGdlc09uU2VsZWN0IiwibWFya2VyU3RhcnRVcmwiLCJtYXJrZXJFbmRVcmwiLCJvbkVkZ2VDbGljayIsImFkZFNlbGVjdGVkRWRnZXMiLCJvbkVkZ2VEb3VibGVDbGljayIsIm9uRWRnZUNvbnRleHRNZW51Iiwib25FZGdlTW91c2VFbnRlciIsIm9uRWRnZU1vdXNlTW92ZSIsIm9uRWRnZU1vdXNlTGVhdmUiLCJhbmltYXRlZCIsImluYWN0aXZlIiwidXBkYXRpbmciLCJzb3VyY2VIYW5kbGVJZCIsInRhcmdldEhhbmRsZUlkIiwic2VsZWN0b3IkYSIsIkVkZ2VSZW5kZXJlckNvbXBvbmVudCIsImRlZmF1bHRNYXJrZXJDb2xvciIsIkVkZ2VSZW5kZXJlciIsInNlbGVjdG9yJDkiLCJWaWV3cG9ydCIsInVzZU9uSW5pdEhhbmRsZXIiLCJvbkluaXQiLCJyZkluc3RhbmNlIiwic2V0VGltZW91dCIsInNlbGVjdG9yJDgiLCJzeW5jVmlld3BvcnQiLCJ1c2VWaWV3cG9ydFN5bmMiLCJzdG9yZVNlbGVjdG9yJDEiLCJ0byIsImdldFNlbGVjdG9yIiwiY29ubmVjdGlvblNlbGVjdG9yIiwiY29tYmluZWRTZWxlY3RvciIsInVzZUNvbm5lY3Rpb24iLCJzZWxlY3RvciQ3IiwiQ29ubmVjdGlvbkxpbmVXcmFwcGVyIiwiY29tcG9uZW50IiwicmVuZGVyQ29ubmVjdGlvbiIsIkNvbm5lY3Rpb25MaW5lIiwiQ3VzdG9tQ29tcG9uZW50IiwiQmV6aWVyIiwiZnJvbU5vZGUiLCJmcm9tUG9zaXRpb24iLCJ0b05vZGUiLCJjb25uZWN0aW9uTGluZVR5cGUiLCJjb25uZWN0aW9uTGluZVN0eWxlIiwiZnJvbVgiLCJmcm9tWSIsInRvWCIsInRvWSIsImNvbm5lY3Rpb25TdGF0dXMiLCJwYXRoUGFyYW1zIiwiU2ltcGxlQmV6aWVyIiwiU3RlcCIsIlNtb290aFN0ZXAiLCJlbXB0eVR5cGVzIiwidXNlTm9kZU9yRWRnZVR5cGVzV2FybmluZyIsIm5vZGVPckVkZ2VUeXBlcyIsInR5cGVzUmVmIiwicHJvY2VzcyIsInVzZWRLZXlzIiwidXNlU3R5bGVzTG9hZGVkV2FybmluZyIsImNoZWNrZWQiLCJwYW5lIiwicXVlcnlTZWxlY3RvciIsImdldENvbXB1dGVkU3R5bGUiLCJHcmFwaFZpZXdDb21wb25lbnQiLCJjb25uZWN0aW9uTGluZUNvbXBvbmVudCIsImNvbm5lY3Rpb25MaW5lQ29udGFpbmVyU3R5bGUiLCJHcmFwaFZpZXciLCJnZXRJbml0aWFsU3RhdGUiLCJzdG9yZUVkZ2VzIiwic3RvcmVOb2RlcyIsInN0b3JlTm9kZU9yaWdpbiIsInN0b3JlTm9kZUV4dGVudCIsImVsZXZhdGVOb2Rlc09uU2VsZWN0IiwiZml0Vmlld0RvbmUiLCJhdXRvUGFuT25Ob2RlRHJhZyIsImRlYnVnIiwiY3JlYXRlU3RvcmUiLCJmaXRWaWV3JDEiLCJjaGVja0VxdWFsaXR5IiwidHJpZ2dlckZpdFZpZXciLCJmaXRWaWV3U3luYyIsInVwZGF0ZWRJbnRlcm5hbHMiLCJuZXh0Rml0Vmlld0RvbmUiLCJjb25zb2xlIiwibG9nIiwibm9kZURyYWdJdGVtcyIsInBhcmVudEV4cGFuZENoaWxkcmVuIiwiZHJhZ0l0ZW0iLCJleHBhbmRQYXJlbnQiLCJtYXgiLCJyZWN0IiwicGFyZW50RXhwYW5kQ2hhbmdlcyIsInVwZGF0ZWROb2RlcyIsInVwZGF0ZWRFZGdlcyIsImNoYW5nZWRFZGdlcyIsIm5vZGVzVG9VbnNlbGVjdCIsImVkZ2VzVG9VbnNlbGVjdCIsInNldFNjYWxlRXh0ZW50IiwiY2xpY2tEaXN0YW5jZSIsInNldENsaWNrRGlzdGFuY2UiLCJuZXh0Tm9kZUV4dGVudCIsImRlbHRhIiwiaXMiLCJSZWFjdEZsb3dQcm92aWRlciIsImluaXRpYWxOb2RlcyIsImluaXRpYWxFZGdlcyIsIldyYXBwZXIiLCJpc1dyYXBwZWQiLCJ3cmFwcGVyU3R5bGUiLCJSZWFjdEZsb3ciLCJvbk5vZGVEcmFnU3RhcnQiLCJvbk5vZGVEcmFnIiwib25Ob2RlRHJhZ1N0b3AiLCJvblNlbGVjdGlvbkRyYWdTdGFydCIsIm9uU2VsZWN0aW9uRHJhZyIsIm9uU2VsZWN0aW9uRHJhZ1N0b3AiLCJkZWZhdWx0Vmlld3BvcnQkMSIsImZpdFZpZXdPcHRpb25zIiwiYXR0cmlidXRpb25Qb3NpdGlvbiIsIm9uU2Nyb2xsIiwiY29sb3JNb2RlQ2xhc3NOYW1lIiwid3JhcHBlck9uU2Nyb2xsIiwiY3VycmVudFRhcmdldCIsInNjcm9sbFRvIiwiYmVoYXZpb3IiLCJzZWxlY3RvciQ2IiwiRWRnZUxhYmVsUmVuZGVyZXIiLCJlZGdlTGFiZWxSZW5kZXJlciIsInNlbGVjdG9yJDUiLCJWaWV3cG9ydFBvcnRhbCIsInZpZXdQb3J0YWxEaXYiLCJ1c2VVcGRhdGVOb2RlSW50ZXJuYWxzIiwidXBkYXRlSWRzIiwidXBkYXRlSWQiLCJub2Rlc1NlbGVjdG9yIiwidXNlTm9kZXMiLCJlZGdlc1NlbGVjdG9yIiwidXNlRWRnZXMiLCJ2aWV3cG9ydFNlbGVjdG9yIiwidXNlVmlld3BvcnQiLCJ1c2VOb2Rlc1N0YXRlIiwibmRzIiwidXNlRWRnZXNTdGF0ZSIsImVkcyIsInVzZU9uVmlld3BvcnRDaGFuZ2UiLCJvblN0YXJ0Iiwib25DaGFuZ2UiLCJvbkVuZCIsInVzZU9uU2VsZWN0aW9uQ2hhbmdlIiwibmV4dE9uU2VsZWN0aW9uQ2hhbmdlSGFuZGxlcnMiLCJuZXh0SGFuZGxlcnMiLCJzZWxlY3RvciQ0IiwiaW5jbHVkZUhpZGRlbk5vZGVzIiwidXNlTm9kZXNJbml0aWFsaXplZCIsImluaXRpYWxpemVkIiwidXNlSGFuZGxlQ29ubmVjdGlvbnMiLCJvbkRpc2Nvbm5lY3QiLCJ3YXJuIiwiX25vZGVJZCIsImN1cnJlbnROb2RlSWQiLCJwcmV2Q29ubmVjdGlvbnMiLCJfY29ubmVjdGlvbnMiLCJlcnJvcjAxNCIsInVzZU5vZGVDb25uZWN0aW9ucyIsInVzZU5vZGVzRGF0YSIsIm5vZGVzRGF0YSIsImlzQXJyYXlPZklkcyIsIl9ub2RlSWRzIiwidXNlSW50ZXJuYWxOb2RlIiwiTGluZVBhdHRlcm4iLCJsaW5lV2lkdGgiLCJ2YXJpYW50IiwiRG90UGF0dGVybiIsIkJhY2tncm91bmRWYXJpYW50IiwiZGVmYXVsdFNpemUiLCJEb3RzIiwiTGluZXMiLCJDcm9zcyIsInNlbGVjdG9yJDMiLCJwYXR0ZXJuSWQiLCJCYWNrZ3JvdW5kQ29tcG9uZW50IiwiZ2FwIiwiYmdDb2xvciIsInBhdHRlcm5DbGFzc05hbWUiLCJwYXR0ZXJuU2l6ZSIsImlzRG90cyIsImlzQ3Jvc3MiLCJnYXBYWSIsInNjYWxlZEdhcCIsInNjYWxlZFNpemUiLCJvZmZzZXRYWSIsInBhdHRlcm5EaW1lbnNpb25zIiwic2NhbGVkT2Zmc2V0IiwiX3BhdHRlcm5JZCIsInBhdHRlcm5Vbml0cyIsInBhdHRlcm5UcmFuc2Zvcm0iLCJCYWNrZ3JvdW5kIiwiUGx1c0ljb24iLCJ4bWxucyIsIk1pbnVzSWNvbiIsIkZpdFZpZXdJY29uIiwiTG9ja0ljb24iLCJVbmxvY2tJY29uIiwiQ29udHJvbEJ1dHRvbiIsInNlbGVjdG9yJDIiLCJpc0ludGVyYWN0aXZlIiwibWluWm9vbVJlYWNoZWQiLCJtYXhab29tUmVhY2hlZCIsIkNvbnRyb2xzQ29tcG9uZW50Iiwic2hvd1pvb20iLCJzaG93Rml0VmlldyIsInNob3dJbnRlcmFjdGl2ZSIsIm9uWm9vbUluIiwib25ab29tT3V0Iiwib25GaXRWaWV3Iiwib25JbnRlcmFjdGl2ZUNoYW5nZSIsIm9yaWVudGF0aW9uIiwib25ab29tSW5IYW5kbGVyIiwib25ab29tT3V0SGFuZGxlciIsIm9uRml0Vmlld0hhbmRsZXIiLCJvblRvZ2dsZUludGVyYWN0aXZpdHkiLCJvcmllbnRhdGlvbkNsYXNzIiwidGl0bGUiLCJDb250cm9scyIsIk1pbmlNYXBOb2RlQ29tcG9uZW50Iiwic3Ryb2tlQ29sb3IiLCJzaGFwZVJlbmRlcmluZyIsImJhY2tncm91bmQiLCJiYWNrZ3JvdW5kQ29sb3IiLCJNaW5pTWFwTm9kZSIsInNlbGVjdG9yTm9kZUlkcyIsImdldEF0dHJGdW5jdGlvbiIsImZ1bmMiLCJGdW5jdGlvbiIsIk1pbmlNYXBOb2RlcyIsIm5vZGVTdHJva2VDb2xvciIsIm5vZGVDb2xvciIsIm5vZGVDbGFzc05hbWUiLCJub2RlQm9yZGVyUmFkaXVzIiwibm9kZVN0cm9rZVdpZHRoIiwibm9kZUNvbXBvbmVudCIsIm5vZGVDb2xvckZ1bmMiLCJub2RlU3Ryb2tlQ29sb3JGdW5jIiwibm9kZUNsYXNzTmFtZUZ1bmMiLCJjaHJvbWUiLCJOb2RlQ29tcG9uZW50V3JhcHBlciIsIk5vZGVDb21wb25lbnRXcmFwcGVySW5uZXIiLCJNaW5pTWFwTm9kZXMkMSIsImRlZmF1bHRXaWR0aCIsImRlZmF1bHRIZWlnaHQiLCJzZWxlY3RvciQxIiwidmlld0JCIiwiYm91bmRpbmdSZWN0IiwiZmxvd1dpZHRoIiwiZmxvd0hlaWdodCIsIkFSSUFfTEFCRUxfS0VZIiwiTWluaU1hcENvbXBvbmVudCIsIm1hc2tDb2xvciIsIm1hc2tTdHJva2VDb2xvciIsIm1hc2tTdHJva2VXaWR0aCIsInBhbm5hYmxlIiwiem9vbWFibGUiLCJpbnZlcnNlUGFuIiwiem9vbVN0ZXAiLCJvZmZzZXRTY2FsZSIsInN2ZyIsImVsZW1lbnRXaWR0aCIsImVsZW1lbnRIZWlnaHQiLCJzY2FsZWRXaWR0aCIsInNjYWxlZEhlaWdodCIsInZpZXdTY2FsZSIsInZpZXdXaWR0aCIsInZpZXdIZWlnaHQiLCJsYWJlbGxlZEJ5Iiwidmlld1NjYWxlUmVmIiwibWluaW1hcEluc3RhbmNlIiwiZ2V0Vmlld1NjYWxlIiwib25TdmdDbGljayIsInBvaW50ZXIiLCJvblN2Z05vZGVDbGljayIsImZpbGxSdWxlIiwiTWluaU1hcCIsIlJlc2l6ZUNvbnRyb2wiLCJtaW5XaWR0aCIsIm1pbkhlaWdodCIsIm1heFdpZHRoIiwiTnVtYmVyIiwiTUFYX1ZBTFVFIiwibWF4SGVpZ2h0Iiwia2VlcEFzcGVjdFJhdGlvIiwic2hvdWxkUmVzaXplIiwib25SZXNpemVTdGFydCIsIm9uUmVzaXplIiwib25SZXNpemVFbmQiLCJjb250ZXh0Tm9kZUlkIiwicmVzaXplQ29udHJvbFJlZiIsImRlZmF1bHRQb3NpdGlvbiIsIkxpbmUiLCJjb250cm9sUG9zaXRpb24iLCJyZXNpemVyIiwicGFuZURvbU5vZGUiLCJjaGlsZENoYW5nZXMiLCJvcmlnaW4iLCJjaGlsZCIsInBvc2l0aW9uQ2hhbmdlIiwiZGltZW5zaW9uQ2hhbmdlIiwiY2hpbGRDaGFuZ2UiLCJib3VuZGFyaWVzIiwicG9zaXRpb25DbGFzc05hbWVzIiwiY29sb3JTdHlsZVByb3AiLCJjb250cm9sU3R5bGUiLCJOb2RlUmVzaXplQ29udHJvbCIsIk5vZGVSZXNpemVyIiwiaXNWaXNpYmxlIiwiaGFuZGxlQ2xhc3NOYW1lIiwiaGFuZGxlU3R5bGUiLCJsaW5lQ2xhc3NOYW1lIiwibGluZVN0eWxlIiwiTm9kZVRvb2xiYXJQb3J0YWwiLCJ3cmFwcGVyUmVmIiwibm9kZUVxdWFsaXR5Rm4iLCJub2Rlc0VxdWFsaXR5Rm4iLCJzdG9yZVNlbGVjdG9yIiwic2VsZWN0ZWROb2Rlc0NvdW50IiwiTm9kZVRvb2xiYXIiLCJhbGlnbiIsImludGVybmFsTm9kZXMiLCJub2Rlc0FycmF5IiwiYWNjIiwidHJpbSJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xyflow/react/dist/esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xyflow/react/dist/style.css":
/*!***************************************************!*\
  !*** ./node_modules/@xyflow/react/dist/style.css ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"869ef40efae5\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHh5Zmxvdy9yZWFjdC9kaXN0L3N0eWxlLmNzcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsaUVBQWUsY0FBYztBQUM3QixJQUFJLEtBQVUsRUFBRSxFQUF1QiIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxzdXJ5YVxcRG93bmxvYWRzXFxGaWxlc1xcVlNjb2RlXFxzdXBlcnZhaXNvcl90YXNrXFxub2RlX21vZHVsZXNcXEB4eWZsb3dcXHJlYWN0XFxkaXN0XFxzdHlsZS5jc3MiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCI4NjllZjQwZWZhZTVcIlxuaWYgKG1vZHVsZS5ob3QpIHsgbW9kdWxlLmhvdC5hY2NlcHQoKSB9XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xyflow/react/dist/style.css\n");

/***/ }),

/***/ "(ssr)/./node_modules/@xyflow/system/dist/esm/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/@xyflow/system/dist/esm/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ConnectionLineType: () => (/* binding */ ConnectionLineType),\n/* harmony export */   ConnectionMode: () => (/* binding */ ConnectionMode),\n/* harmony export */   MarkerType: () => (/* binding */ MarkerType),\n/* harmony export */   PanOnScrollMode: () => (/* binding */ PanOnScrollMode),\n/* harmony export */   Position: () => (/* binding */ Position),\n/* harmony export */   ResizeControlVariant: () => (/* binding */ ResizeControlVariant),\n/* harmony export */   SelectionMode: () => (/* binding */ SelectionMode),\n/* harmony export */   XYDrag: () => (/* binding */ XYDrag),\n/* harmony export */   XYHandle: () => (/* binding */ XYHandle),\n/* harmony export */   XYMinimap: () => (/* binding */ XYMinimap),\n/* harmony export */   XYPanZoom: () => (/* binding */ XYPanZoom),\n/* harmony export */   XYResizer: () => (/* binding */ XYResizer),\n/* harmony export */   XY_RESIZER_HANDLE_POSITIONS: () => (/* binding */ XY_RESIZER_HANDLE_POSITIONS),\n/* harmony export */   XY_RESIZER_LINE_POSITIONS: () => (/* binding */ XY_RESIZER_LINE_POSITIONS),\n/* harmony export */   addEdge: () => (/* binding */ addEdge),\n/* harmony export */   adoptUserNodes: () => (/* binding */ adoptUserNodes),\n/* harmony export */   areConnectionMapsEqual: () => (/* binding */ areConnectionMapsEqual),\n/* harmony export */   areSetsEqual: () => (/* binding */ areSetsEqual),\n/* harmony export */   boxToRect: () => (/* binding */ boxToRect),\n/* harmony export */   calcAutoPan: () => (/* binding */ calcAutoPan),\n/* harmony export */   calculateNodePosition: () => (/* binding */ calculateNodePosition),\n/* harmony export */   clamp: () => (/* binding */ clamp),\n/* harmony export */   clampPosition: () => (/* binding */ clampPosition),\n/* harmony export */   clampPositionToParent: () => (/* binding */ clampPositionToParent),\n/* harmony export */   createMarkerIds: () => (/* binding */ createMarkerIds),\n/* harmony export */   devWarn: () => (/* binding */ devWarn),\n/* harmony export */   elementSelectionKeys: () => (/* binding */ elementSelectionKeys),\n/* harmony export */   errorMessages: () => (/* binding */ errorMessages),\n/* harmony export */   evaluateAbsolutePosition: () => (/* binding */ evaluateAbsolutePosition),\n/* harmony export */   fitView: () => (/* binding */ fitView),\n/* harmony export */   getBezierEdgeCenter: () => (/* binding */ getBezierEdgeCenter),\n/* harmony export */   getBezierPath: () => (/* binding */ getBezierPath),\n/* harmony export */   getBoundsOfBoxes: () => (/* binding */ getBoundsOfBoxes),\n/* harmony export */   getBoundsOfRects: () => (/* binding */ getBoundsOfRects),\n/* harmony export */   getConnectedEdges: () => (/* binding */ getConnectedEdges),\n/* harmony export */   getConnectionStatus: () => (/* binding */ getConnectionStatus),\n/* harmony export */   getDimensions: () => (/* binding */ getDimensions),\n/* harmony export */   getEdgeCenter: () => (/* binding */ getEdgeCenter),\n/* harmony export */   getEdgePosition: () => (/* binding */ getEdgePosition),\n/* harmony export */   getElementsToRemove: () => (/* binding */ getElementsToRemove),\n/* harmony export */   getElevatedEdgeZIndex: () => (/* binding */ getElevatedEdgeZIndex),\n/* harmony export */   getEventPosition: () => (/* binding */ getEventPosition),\n/* harmony export */   getFitViewNodes: () => (/* binding */ getFitViewNodes),\n/* harmony export */   getHandleBounds: () => (/* binding */ getHandleBounds),\n/* harmony export */   getHandlePosition: () => (/* binding */ getHandlePosition),\n/* harmony export */   getHostForElement: () => (/* binding */ getHostForElement),\n/* harmony export */   getIncomers: () => (/* binding */ getIncomers),\n/* harmony export */   getInternalNodesBounds: () => (/* binding */ getInternalNodesBounds),\n/* harmony export */   getMarkerId: () => (/* binding */ getMarkerId),\n/* harmony export */   getNodeDimensions: () => (/* binding */ getNodeDimensions),\n/* harmony export */   getNodePositionWithOrigin: () => (/* binding */ getNodePositionWithOrigin),\n/* harmony export */   getNodeToolbarTransform: () => (/* binding */ getNodeToolbarTransform),\n/* harmony export */   getNodesBounds: () => (/* binding */ getNodesBounds),\n/* harmony export */   getNodesInside: () => (/* binding */ getNodesInside),\n/* harmony export */   getOutgoers: () => (/* binding */ getOutgoers),\n/* harmony export */   getOverlappingArea: () => (/* binding */ getOverlappingArea),\n/* harmony export */   getPointerPosition: () => (/* binding */ getPointerPosition),\n/* harmony export */   getSmoothStepPath: () => (/* binding */ getSmoothStepPath),\n/* harmony export */   getStraightPath: () => (/* binding */ getStraightPath),\n/* harmony export */   getViewportForBounds: () => (/* binding */ getViewportForBounds),\n/* harmony export */   handleConnectionChange: () => (/* binding */ handleConnectionChange),\n/* harmony export */   handleExpandParent: () => (/* binding */ handleExpandParent),\n/* harmony export */   infiniteExtent: () => (/* binding */ infiniteExtent),\n/* harmony export */   initialConnection: () => (/* binding */ initialConnection),\n/* harmony export */   isCoordinateExtent: () => (/* binding */ isCoordinateExtent),\n/* harmony export */   isEdgeBase: () => (/* binding */ isEdgeBase),\n/* harmony export */   isEdgeVisible: () => (/* binding */ isEdgeVisible),\n/* harmony export */   isInputDOMNode: () => (/* binding */ isInputDOMNode),\n/* harmony export */   isInternalNodeBase: () => (/* binding */ isInternalNodeBase),\n/* harmony export */   isMacOs: () => (/* binding */ isMacOs),\n/* harmony export */   isMouseEvent: () => (/* binding */ isMouseEvent),\n/* harmony export */   isNodeBase: () => (/* binding */ isNodeBase),\n/* harmony export */   isNumeric: () => (/* binding */ isNumeric),\n/* harmony export */   isRectObject: () => (/* binding */ isRectObject),\n/* harmony export */   nodeHasDimensions: () => (/* binding */ nodeHasDimensions),\n/* harmony export */   nodeToBox: () => (/* binding */ nodeToBox),\n/* harmony export */   nodeToRect: () => (/* binding */ nodeToRect),\n/* harmony export */   oppositePosition: () => (/* binding */ oppositePosition),\n/* harmony export */   panBy: () => (/* binding */ panBy),\n/* harmony export */   pointToRendererPoint: () => (/* binding */ pointToRendererPoint),\n/* harmony export */   reconnectEdge: () => (/* binding */ reconnectEdge),\n/* harmony export */   rectToBox: () => (/* binding */ rectToBox),\n/* harmony export */   rendererPointToPoint: () => (/* binding */ rendererPointToPoint),\n/* harmony export */   shallowNodeData: () => (/* binding */ shallowNodeData),\n/* harmony export */   snapPosition: () => (/* binding */ snapPosition),\n/* harmony export */   updateAbsolutePositions: () => (/* binding */ updateAbsolutePositions),\n/* harmony export */   updateConnectionLookup: () => (/* binding */ updateConnectionLookup),\n/* harmony export */   updateNodeInternals: () => (/* binding */ updateNodeInternals)\n/* harmony export */ });\n/* harmony import */ var d3_drag__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! d3-drag */ \"(ssr)/./node_modules/d3-drag/src/drag.js\");\n/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! d3-selection */ \"(ssr)/./node_modules/d3-selection/src/select.js\");\n/* harmony import */ var d3_selection__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! d3-selection */ \"(ssr)/./node_modules/d3-selection/src/pointer.js\");\n/* harmony import */ var d3_zoom__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! d3-zoom */ \"(ssr)/./node_modules/d3-zoom/src/index.js\");\n\n\n\n\nconst errorMessages = {\n    error001: () => '[React Flow]: Seems like you have not used zustand provider as an ancestor. Help: https://reactflow.dev/error#001',\n    error002: () => \"It looks like you've created a new nodeTypes or edgeTypes object. If this wasn't on purpose please define the nodeTypes/edgeTypes outside of the component or memoize them.\",\n    error003: (nodeType) => `Node type \"${nodeType}\" not found. Using fallback type \"default\".`,\n    error004: () => 'The React Flow parent container needs a width and a height to render the graph.',\n    error005: () => 'Only child nodes can use a parent extent.',\n    error006: () => \"Can't create edge. An edge needs a source and a target.\",\n    error007: (id) => `The old edge with id=${id} does not exist.`,\n    error009: (type) => `Marker type \"${type}\" doesn't exist.`,\n    error008: (handleType, { id, sourceHandle, targetHandle }) => `Couldn't create edge for ${handleType} handle id: \"${handleType === 'source' ? sourceHandle : targetHandle}\", edge id: ${id}.`,\n    error010: () => 'Handle: No node id found. Make sure to only use a Handle inside a custom Node.',\n    error011: (edgeType) => `Edge type \"${edgeType}\" not found. Using fallback type \"default\".`,\n    error012: (id) => `Node with id \"${id}\" does not exist, it may have been removed. This can happen when a node is deleted before the \"onNodeClick\" handler is called.`,\n    error013: (lib = 'react') => `It seems that you haven't loaded the styles. Please import '@xyflow/${lib}/dist/style.css' or base.css to make sure everything is working properly.`,\n    error014: () => 'useNodeConnections: No node ID found. Call useNodeConnections inside a custom Node or provide a node ID.',\n    error015: () => 'It seems that you are trying to drag a node that is not initialized. Please use onNodesChange as explained in the docs.',\n};\nconst infiniteExtent = [\n    [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY],\n    [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY],\n];\nconst elementSelectionKeys = ['Enter', ' ', 'Escape'];\n\n/**\n * The `ConnectionMode` is used to set the mode of connection between nodes.\n * The `Strict` mode is the default one and only allows source to target edges.\n * `Loose` mode allows source to source and target to target edges as well.\n *\n * @public\n */\nvar ConnectionMode;\n(function (ConnectionMode) {\n    ConnectionMode[\"Strict\"] = \"strict\";\n    ConnectionMode[\"Loose\"] = \"loose\";\n})(ConnectionMode || (ConnectionMode = {}));\n/**\n * This enum is used to set the different modes of panning the viewport when the\n * user scrolls. The `Free` mode allows the user to pan in any direction by scrolling\n * with a device like a trackpad. The `Vertical` and `Horizontal` modes restrict\n * scroll panning to only the vertical or horizontal axis, respectively.\n *\n * @public\n */\nvar PanOnScrollMode;\n(function (PanOnScrollMode) {\n    PanOnScrollMode[\"Free\"] = \"free\";\n    PanOnScrollMode[\"Vertical\"] = \"vertical\";\n    PanOnScrollMode[\"Horizontal\"] = \"horizontal\";\n})(PanOnScrollMode || (PanOnScrollMode = {}));\nvar SelectionMode;\n(function (SelectionMode) {\n    SelectionMode[\"Partial\"] = \"partial\";\n    SelectionMode[\"Full\"] = \"full\";\n})(SelectionMode || (SelectionMode = {}));\nconst initialConnection = {\n    inProgress: false,\n    isValid: null,\n    from: null,\n    fromHandle: null,\n    fromPosition: null,\n    fromNode: null,\n    to: null,\n    toHandle: null,\n    toPosition: null,\n    toNode: null,\n};\n\n/**\n * If you set the `connectionLineType` prop on your [`<ReactFlow />`](/api-reference/react-flow#connection-connectionLineType)\n *component, it will dictate the style of connection line rendered when creating\n *new edges.\n *\n * @public\n *\n * @remarks If you choose to render a custom connection line component, this value will be\n *passed to your component as part of its [`ConnectionLineComponentProps`](/api-reference/types/connection-line-component-props).\n */\nvar ConnectionLineType;\n(function (ConnectionLineType) {\n    ConnectionLineType[\"Bezier\"] = \"default\";\n    ConnectionLineType[\"Straight\"] = \"straight\";\n    ConnectionLineType[\"Step\"] = \"step\";\n    ConnectionLineType[\"SmoothStep\"] = \"smoothstep\";\n    ConnectionLineType[\"SimpleBezier\"] = \"simplebezier\";\n})(ConnectionLineType || (ConnectionLineType = {}));\n/**\n * Edges may optionally have a marker on either end. The MarkerType type enumerates\n * the options available to you when configuring a given marker.\n *\n * @public\n */\nvar MarkerType;\n(function (MarkerType) {\n    MarkerType[\"Arrow\"] = \"arrow\";\n    MarkerType[\"ArrowClosed\"] = \"arrowclosed\";\n})(MarkerType || (MarkerType = {}));\n\n/**\n * While [`PanelPosition`](/api-reference/types/panel-position) can be used to place a\n * component in the corners of a container, the `Position` enum is less precise and used\n * primarily in relation to edges and handles.\n *\n * @public\n */\nvar Position;\n(function (Position) {\n    Position[\"Left\"] = \"left\";\n    Position[\"Top\"] = \"top\";\n    Position[\"Right\"] = \"right\";\n    Position[\"Bottom\"] = \"bottom\";\n})(Position || (Position = {}));\nconst oppositePosition = {\n    [Position.Left]: Position.Right,\n    [Position.Right]: Position.Left,\n    [Position.Top]: Position.Bottom,\n    [Position.Bottom]: Position.Top,\n};\n\n/**\n * @internal\n */\nfunction areConnectionMapsEqual(a, b) {\n    if (!a && !b) {\n        return true;\n    }\n    if (!a || !b || a.size !== b.size) {\n        return false;\n    }\n    if (!a.size && !b.size) {\n        return true;\n    }\n    for (const key of a.keys()) {\n        if (!b.has(key)) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * We call the callback for all connections in a that are not in b\n *\n * @internal\n */\nfunction handleConnectionChange(a, b, cb) {\n    if (!cb) {\n        return;\n    }\n    const diff = [];\n    a.forEach((connection, key) => {\n        if (!b?.has(key)) {\n            diff.push(connection);\n        }\n    });\n    if (diff.length) {\n        cb(diff);\n    }\n}\nfunction getConnectionStatus(isValid) {\n    return isValid === null ? null : isValid ? 'valid' : 'invalid';\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/**\n * Test whether an object is useable as an Edge\n * @public\n * @remarks In TypeScript this is a type guard that will narrow the type of whatever you pass in to Edge if it returns true\n * @param element - The element to test\n * @returns A boolean indicating whether the element is an Edge\n */\nconst isEdgeBase = (element) => 'id' in element && 'source' in element && 'target' in element;\n/**\n * Test whether an object is useable as a Node\n * @public\n * @remarks In TypeScript this is a type guard that will narrow the type of whatever you pass in to Node if it returns true\n * @param element - The element to test\n * @returns A boolean indicating whether the element is an Node\n */\nconst isNodeBase = (element) => 'id' in element && 'position' in element && !('source' in element) && !('target' in element);\nconst isInternalNodeBase = (element) => 'id' in element && 'internals' in element && !('source' in element) && !('target' in element);\n/**\n * This util is used to tell you what nodes, if any, are connected to the given node\n * as the _target_ of an edge.\n * @public\n * @param node - The node to get the connected nodes from\n * @param nodes - The array of all nodes\n * @param edges - The array of all edges\n * @returns An array of nodes that are connected over eges where the source is the given node\n *\n * @example\n * ```ts\n *import { getOutgoers } from '@xyflow/react';\n *\n *const nodes = [];\n *const edges = [];\n *\n *const outgoers = getOutgoers(\n *  { id: '1', position: { x: 0, y: 0 }, data: { label: 'node' } },\n *  nodes,\n *  edges,\n *);\n *```\n */\nconst getOutgoers = (node, nodes, edges) => {\n    if (!node.id) {\n        return [];\n    }\n    const outgoerIds = new Set();\n    edges.forEach((edge) => {\n        if (edge.source === node.id) {\n            outgoerIds.add(edge.target);\n        }\n    });\n    return nodes.filter((n) => outgoerIds.has(n.id));\n};\n/**\n * This util is used to tell you what nodes, if any, are connected to the given node\n * as the _source_ of an edge.\n * @public\n * @param node - The node to get the connected nodes from\n * @param nodes - The array of all nodes\n * @param edges - The array of all edges\n * @returns An array of nodes that are connected over eges where the target is the given node\n *\n * @example\n * ```ts\n *import { getIncomers } from '@xyflow/react';\n *\n *const nodes = [];\n *const edges = [];\n *\n *const incomers = getIncomers(\n *  { id: '1', position: { x: 0, y: 0 }, data: { label: 'node' } },\n *  nodes,\n *  edges,\n *);\n *```\n */\nconst getIncomers = (node, nodes, edges) => {\n    if (!node.id) {\n        return [];\n    }\n    const incomersIds = new Set();\n    edges.forEach((edge) => {\n        if (edge.target === node.id) {\n            incomersIds.add(edge.source);\n        }\n    });\n    return nodes.filter((n) => incomersIds.has(n.id));\n};\nconst getNodePositionWithOrigin = (node, nodeOrigin = [0, 0]) => {\n    const { width, height } = getNodeDimensions(node);\n    const origin = node.origin ?? nodeOrigin;\n    const offsetX = width * origin[0];\n    const offsetY = height * origin[1];\n    return {\n        x: node.position.x - offsetX,\n        y: node.position.y - offsetY,\n    };\n};\n/**\n * Returns the bounding box that contains all the given nodes in an array. This can\n * be useful when combined with [`getViewportForBounds`](/api-reference/utils/get-viewport-for-bounds)\n * to calculate the correct transform to fit the given nodes in a viewport.\n * @public\n * @remarks Useful when combined with {@link getViewportForBounds} to calculate the correct transform to fit the given nodes in a viewport.\n * @param nodes - Nodes to calculate the bounds for\n * @param params.nodeOrigin - Origin of the nodes: [0, 0] - top left, [0.5, 0.5] - center\n * @returns Bounding box enclosing all nodes\n *\n * @remarks This function was previously called `getRectOfNodes`\n *\n * @example\n * ```js\n *import { getNodesBounds } from '@xyflow/react';\n *\n *const nodes = [\n *  {\n *    id: 'a',\n *    position: { x: 0, y: 0 },\n *    data: { label: 'a' },\n *    width: 50,\n *    height: 25,\n *  },\n *  {\n *    id: 'b',\n *    position: { x: 100, y: 100 },\n *    data: { label: 'b' },\n *    width: 50,\n *    height: 25,\n *  },\n *];\n *\n *const bounds = getNodesBounds(nodes);\n *```\n */\nconst getNodesBounds = (nodes, params = { nodeOrigin: [0, 0], nodeLookup: undefined }) => {\n    if ( true && !params.nodeLookup) {\n        console.warn('Please use `getNodesBounds` from `useReactFlow`/`useSvelteFlow` hook to ensure correct values for sub flows. If not possible, you have to provide a nodeLookup to support sub flows.');\n    }\n    if (nodes.length === 0) {\n        return { x: 0, y: 0, width: 0, height: 0 };\n    }\n    const box = nodes.reduce((currBox, nodeOrId) => {\n        const isId = typeof nodeOrId === 'string';\n        let currentNode = !params.nodeLookup && !isId ? nodeOrId : undefined;\n        if (params.nodeLookup) {\n            currentNode = isId\n                ? params.nodeLookup.get(nodeOrId)\n                : !isInternalNodeBase(nodeOrId)\n                    ? params.nodeLookup.get(nodeOrId.id)\n                    : nodeOrId;\n        }\n        const nodeBox = currentNode ? nodeToBox(currentNode, params.nodeOrigin) : { x: 0, y: 0, x2: 0, y2: 0 };\n        return getBoundsOfBoxes(currBox, nodeBox);\n    }, { x: Infinity, y: Infinity, x2: -Infinity, y2: -Infinity });\n    return boxToRect(box);\n};\n/**\n * Determines a bounding box that contains all given nodes in an array\n * @internal\n */\nconst getInternalNodesBounds = (nodeLookup, params = {}) => {\n    if (nodeLookup.size === 0) {\n        return { x: 0, y: 0, width: 0, height: 0 };\n    }\n    let box = { x: Infinity, y: Infinity, x2: -Infinity, y2: -Infinity };\n    nodeLookup.forEach((node) => {\n        if (params.filter === undefined || params.filter(node)) {\n            const nodeBox = nodeToBox(node);\n            box = getBoundsOfBoxes(box, nodeBox);\n        }\n    });\n    return boxToRect(box);\n};\nconst getNodesInside = (nodes, rect, [tx, ty, tScale] = [0, 0, 1], partially = false, \n// set excludeNonSelectableNodes if you want to pay attention to the nodes \"selectable\" attribute\nexcludeNonSelectableNodes = false) => {\n    const paneRect = {\n        ...pointToRendererPoint(rect, [tx, ty, tScale]),\n        width: rect.width / tScale,\n        height: rect.height / tScale,\n    };\n    const visibleNodes = [];\n    for (const node of nodes.values()) {\n        const { measured, selectable = true, hidden = false } = node;\n        if ((excludeNonSelectableNodes && !selectable) || hidden) {\n            continue;\n        }\n        const width = measured.width ?? node.width ?? node.initialWidth ?? null;\n        const height = measured.height ?? node.height ?? node.initialHeight ?? null;\n        const overlappingArea = getOverlappingArea(paneRect, nodeToRect(node));\n        const area = (width ?? 0) * (height ?? 0);\n        const partiallyVisible = partially && overlappingArea > 0;\n        const forceInitialRender = !node.internals.handleBounds;\n        const isVisible = forceInitialRender || partiallyVisible || overlappingArea >= area;\n        if (isVisible || node.dragging) {\n            visibleNodes.push(node);\n        }\n    }\n    return visibleNodes;\n};\n/**\n * This utility filters an array of edges, keeping only those where either the source or target\n * node is present in the given array of nodes.\n * @public\n * @param nodes - Nodes you want to get the connected edges for\n * @param edges - All edges\n * @returns Array of edges that connect any of the given nodes with each other\n *\n * @example\n * ```js\n *import { getConnectedEdges } from '@xyflow/react';\n *\n *const nodes = [\n *  { id: 'a', position: { x: 0, y: 0 } },\n *  { id: 'b', position: { x: 100, y: 0 } },\n *];\n *\n *const edges = [\n *  { id: 'a->c', source: 'a', target: 'c' },\n *  { id: 'c->d', source: 'c', target: 'd' },\n *];\n *\n *const connectedEdges = getConnectedEdges(nodes, edges);\n * // => [{ id: 'a->c', source: 'a', target: 'c' }]\n *```\n */\nconst getConnectedEdges = (nodes, edges) => {\n    const nodeIds = new Set();\n    nodes.forEach((node) => {\n        nodeIds.add(node.id);\n    });\n    return edges.filter((edge) => nodeIds.has(edge.source) || nodeIds.has(edge.target));\n};\nfunction getFitViewNodes(nodeLookup, options) {\n    const fitViewNodes = new Map();\n    const optionNodeIds = options?.nodes ? new Set(options.nodes.map((node) => node.id)) : null;\n    nodeLookup.forEach((n) => {\n        const isVisible = n.measured.width && n.measured.height && (options?.includeHiddenNodes || !n.hidden);\n        if (isVisible && (!optionNodeIds || optionNodeIds.has(n.id))) {\n            fitViewNodes.set(n.id, n);\n        }\n    });\n    return fitViewNodes;\n}\nasync function fitView({ nodes, width, height, panZoom, minZoom, maxZoom }, options) {\n    if (nodes.size === 0) {\n        return Promise.resolve(false);\n    }\n    const bounds = getInternalNodesBounds(nodes);\n    const viewport = getViewportForBounds(bounds, width, height, options?.minZoom ?? minZoom, options?.maxZoom ?? maxZoom, options?.padding ?? 0.1);\n    await panZoom.setViewport(viewport, { duration: options?.duration });\n    return Promise.resolve(true);\n}\n/**\n * This function calculates the next position of a node, taking into account the node's extent, parent node, and origin.\n *\n * @internal\n * @returns position, positionAbsolute\n */\nfunction calculateNodePosition({ nodeId, nextPosition, nodeLookup, nodeOrigin = [0, 0], nodeExtent, onError, }) {\n    const node = nodeLookup.get(nodeId);\n    const parentNode = node.parentId ? nodeLookup.get(node.parentId) : undefined;\n    const { x: parentX, y: parentY } = parentNode ? parentNode.internals.positionAbsolute : { x: 0, y: 0 };\n    const origin = node.origin ?? nodeOrigin;\n    let extent = nodeExtent;\n    if (node.extent === 'parent' && !node.expandParent) {\n        if (!parentNode) {\n            onError?.('005', errorMessages['error005']());\n        }\n        else {\n            const parentWidth = parentNode.measured.width;\n            const parentHeight = parentNode.measured.height;\n            if (parentWidth && parentHeight) {\n                extent = [\n                    [parentX, parentY],\n                    [parentX + parentWidth, parentY + parentHeight],\n                ];\n            }\n        }\n    }\n    else if (parentNode && isCoordinateExtent(node.extent)) {\n        extent = [\n            [node.extent[0][0] + parentX, node.extent[0][1] + parentY],\n            [node.extent[1][0] + parentX, node.extent[1][1] + parentY],\n        ];\n    }\n    const positionAbsolute = isCoordinateExtent(extent)\n        ? clampPosition(nextPosition, extent, node.measured)\n        : nextPosition;\n    if (node.measured.width === undefined || node.measured.height === undefined) {\n        onError?.('015', errorMessages['error015']());\n    }\n    return {\n        position: {\n            x: positionAbsolute.x - parentX + (node.measured.width ?? 0) * origin[0],\n            y: positionAbsolute.y - parentY + (node.measured.height ?? 0) * origin[1],\n        },\n        positionAbsolute,\n    };\n}\n/**\n * Pass in nodes & edges to delete, get arrays of nodes and edges that actually can be deleted\n * @internal\n * @param param.nodesToRemove - The nodes to remove\n * @param param.edgesToRemove - The edges to remove\n * @param param.nodes - All nodes\n * @param param.edges - All edges\n * @param param.onBeforeDelete - Callback to check which nodes and edges can be deleted\n * @returns nodes: nodes that can be deleted, edges: edges that can be deleted\n */\nasync function getElementsToRemove({ nodesToRemove = [], edgesToRemove = [], nodes, edges, onBeforeDelete, }) {\n    const nodeIds = new Set(nodesToRemove.map((node) => node.id));\n    const matchingNodes = [];\n    for (const node of nodes) {\n        if (node.deletable === false) {\n            continue;\n        }\n        const isIncluded = nodeIds.has(node.id);\n        const parentHit = !isIncluded && node.parentId && matchingNodes.find((n) => n.id === node.parentId);\n        if (isIncluded || parentHit) {\n            matchingNodes.push(node);\n        }\n    }\n    const edgeIds = new Set(edgesToRemove.map((edge) => edge.id));\n    const deletableEdges = edges.filter((edge) => edge.deletable !== false);\n    const connectedEdges = getConnectedEdges(matchingNodes, deletableEdges);\n    const matchingEdges = connectedEdges;\n    for (const edge of deletableEdges) {\n        const isIncluded = edgeIds.has(edge.id);\n        if (isIncluded && !matchingEdges.find((e) => e.id === edge.id)) {\n            matchingEdges.push(edge);\n        }\n    }\n    if (!onBeforeDelete) {\n        return {\n            edges: matchingEdges,\n            nodes: matchingNodes,\n        };\n    }\n    const onBeforeDeleteResult = await onBeforeDelete({\n        nodes: matchingNodes,\n        edges: matchingEdges,\n    });\n    if (typeof onBeforeDeleteResult === 'boolean') {\n        return onBeforeDeleteResult ? { edges: matchingEdges, nodes: matchingNodes } : { edges: [], nodes: [] };\n    }\n    return onBeforeDeleteResult;\n}\n\nconst clamp = (val, min = 0, max = 1) => Math.min(Math.max(val, min), max);\nconst clampPosition = (position = { x: 0, y: 0 }, extent, dimensions) => ({\n    x: clamp(position.x, extent[0][0], extent[1][0] - (dimensions?.width ?? 0)),\n    y: clamp(position.y, extent[0][1], extent[1][1] - (dimensions?.height ?? 0)),\n});\nfunction clampPositionToParent(childPosition, childDimensions, parent) {\n    const { width: parentWidth, height: parentHeight } = getNodeDimensions(parent);\n    const { x: parentX, y: parentY } = parent.internals.positionAbsolute;\n    return clampPosition(childPosition, [\n        [parentX, parentY],\n        [parentX + parentWidth, parentY + parentHeight],\n    ], childDimensions);\n}\n/**\n * Calculates the velocity of panning when the mouse is close to the edge of the canvas\n * @internal\n * @param value - One dimensional poition of the mouse (x or y)\n * @param min - Minimal position on canvas before panning starts\n * @param max - Maximal position on canvas before panning starts\n * @returns - A number between 0 and 1 that represents the velocity of panning\n */\nconst calcAutoPanVelocity = (value, min, max) => {\n    if (value < min) {\n        return clamp(Math.abs(value - min), 1, min) / min;\n    }\n    else if (value > max) {\n        return -clamp(Math.abs(value - max), 1, min) / min;\n    }\n    return 0;\n};\nconst calcAutoPan = (pos, bounds, speed = 15, distance = 40) => {\n    const xMovement = calcAutoPanVelocity(pos.x, distance, bounds.width - distance) * speed;\n    const yMovement = calcAutoPanVelocity(pos.y, distance, bounds.height - distance) * speed;\n    return [xMovement, yMovement];\n};\nconst getBoundsOfBoxes = (box1, box2) => ({\n    x: Math.min(box1.x, box2.x),\n    y: Math.min(box1.y, box2.y),\n    x2: Math.max(box1.x2, box2.x2),\n    y2: Math.max(box1.y2, box2.y2),\n});\nconst rectToBox = ({ x, y, width, height }) => ({\n    x,\n    y,\n    x2: x + width,\n    y2: y + height,\n});\nconst boxToRect = ({ x, y, x2, y2 }) => ({\n    x,\n    y,\n    width: x2 - x,\n    height: y2 - y,\n});\nconst nodeToRect = (node, nodeOrigin = [0, 0]) => {\n    const { x, y } = isInternalNodeBase(node)\n        ? node.internals.positionAbsolute\n        : getNodePositionWithOrigin(node, nodeOrigin);\n    return {\n        x,\n        y,\n        width: node.measured?.width ?? node.width ?? node.initialWidth ?? 0,\n        height: node.measured?.height ?? node.height ?? node.initialHeight ?? 0,\n    };\n};\nconst nodeToBox = (node, nodeOrigin = [0, 0]) => {\n    const { x, y } = isInternalNodeBase(node)\n        ? node.internals.positionAbsolute\n        : getNodePositionWithOrigin(node, nodeOrigin);\n    return {\n        x,\n        y,\n        x2: x + (node.measured?.width ?? node.width ?? node.initialWidth ?? 0),\n        y2: y + (node.measured?.height ?? node.height ?? node.initialHeight ?? 0),\n    };\n};\nconst getBoundsOfRects = (rect1, rect2) => boxToRect(getBoundsOfBoxes(rectToBox(rect1), rectToBox(rect2)));\nconst getOverlappingArea = (rectA, rectB) => {\n    const xOverlap = Math.max(0, Math.min(rectA.x + rectA.width, rectB.x + rectB.width) - Math.max(rectA.x, rectB.x));\n    const yOverlap = Math.max(0, Math.min(rectA.y + rectA.height, rectB.y + rectB.height) - Math.max(rectA.y, rectB.y));\n    return Math.ceil(xOverlap * yOverlap);\n};\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst isRectObject = (obj) => isNumeric(obj.width) && isNumeric(obj.height) && isNumeric(obj.x) && isNumeric(obj.y);\n/* eslint-disable-next-line @typescript-eslint/no-explicit-any */\nconst isNumeric = (n) => !isNaN(n) && isFinite(n);\n// used for a11y key board controls for nodes and edges\nconst devWarn = (id, message) => {\n    if (true) {\n        console.warn(`[React Flow]: ${message} Help: https://reactflow.dev/error#${id}`);\n    }\n};\nconst snapPosition = (position, snapGrid = [1, 1]) => {\n    return {\n        x: snapGrid[0] * Math.round(position.x / snapGrid[0]),\n        y: snapGrid[1] * Math.round(position.y / snapGrid[1]),\n    };\n};\nconst pointToRendererPoint = ({ x, y }, [tx, ty, tScale], snapToGrid = false, snapGrid = [1, 1]) => {\n    const position = {\n        x: (x - tx) / tScale,\n        y: (y - ty) / tScale,\n    };\n    return snapToGrid ? snapPosition(position, snapGrid) : position;\n};\nconst rendererPointToPoint = ({ x, y }, [tx, ty, tScale]) => {\n    return {\n        x: x * tScale + tx,\n        y: y * tScale + ty,\n    };\n};\n/**\n * Returns a viewport that encloses the given bounds with optional padding.\n * @public\n * @remarks You can determine bounds of nodes with {@link getNodesBounds} and {@link getBoundsOfRects}\n * @param bounds - Bounds to fit inside viewport\n * @param width - Width of the viewport\n * @param height  - Height of the viewport\n * @param minZoom - Minimum zoom level of the resulting viewport\n * @param maxZoom - Maximum zoom level of the resulting viewport\n * @param padding - Optional padding around the bounds\n * @returns A transforned {@link Viewport} that encloses the given bounds which you can pass to e.g. {@link setViewport}\n * @example\n * const { x, y, zoom } = getViewportForBounds(\n *{ x: 0, y: 0, width: 100, height: 100},\n *1200, 800, 0.5, 2);\n */\nconst getViewportForBounds = (bounds, width, height, minZoom, maxZoom, padding) => {\n    const xZoom = width / (bounds.width * (1 + padding));\n    const yZoom = height / (bounds.height * (1 + padding));\n    const zoom = Math.min(xZoom, yZoom);\n    const clampedZoom = clamp(zoom, minZoom, maxZoom);\n    const boundsCenterX = bounds.x + bounds.width / 2;\n    const boundsCenterY = bounds.y + bounds.height / 2;\n    const x = width / 2 - boundsCenterX * clampedZoom;\n    const y = height / 2 - boundsCenterY * clampedZoom;\n    return { x, y, zoom: clampedZoom };\n};\nconst isMacOs = () => typeof navigator !== 'undefined' && navigator?.userAgent?.indexOf('Mac') >= 0;\nfunction isCoordinateExtent(extent) {\n    return extent !== undefined && extent !== 'parent';\n}\nfunction getNodeDimensions(node) {\n    return {\n        width: node.measured?.width ?? node.width ?? node.initialWidth ?? 0,\n        height: node.measured?.height ?? node.height ?? node.initialHeight ?? 0,\n    };\n}\nfunction nodeHasDimensions(node) {\n    return ((node.measured?.width ?? node.width ?? node.initialWidth) !== undefined &&\n        (node.measured?.height ?? node.height ?? node.initialHeight) !== undefined);\n}\n/**\n * Convert child position to aboslute position\n *\n * @internal\n * @param position\n * @param parentId\n * @param nodeLookup\n * @param nodeOrigin\n * @returns an internal node with an absolute position\n */\nfunction evaluateAbsolutePosition(position, dimensions = { width: 0, height: 0 }, parentId, nodeLookup, nodeOrigin) {\n    const positionAbsolute = { ...position };\n    const parent = nodeLookup.get(parentId);\n    if (parent) {\n        const origin = parent.origin || nodeOrigin;\n        positionAbsolute.x += parent.internals.positionAbsolute.x - (dimensions.width ?? 0) * origin[0];\n        positionAbsolute.y += parent.internals.positionAbsolute.y - (dimensions.height ?? 0) * origin[1];\n    }\n    return positionAbsolute;\n}\nfunction areSetsEqual(a, b) {\n    if (a.size !== b.size) {\n        return false;\n    }\n    for (const item of a) {\n        if (!b.has(item)) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction getPointerPosition(event, { snapGrid = [0, 0], snapToGrid = false, transform, containerBounds }) {\n    const { x, y } = getEventPosition(event);\n    const pointerPos = pointToRendererPoint({ x: x - (containerBounds?.left ?? 0), y: y - (containerBounds?.top ?? 0) }, transform);\n    const { x: xSnapped, y: ySnapped } = snapToGrid ? snapPosition(pointerPos, snapGrid) : pointerPos;\n    // we need the snapped position in order to be able to skip unnecessary drag events\n    return {\n        xSnapped,\n        ySnapped,\n        ...pointerPos,\n    };\n}\nconst getDimensions = (node) => ({\n    width: node.offsetWidth,\n    height: node.offsetHeight,\n});\nconst getHostForElement = (element) => element?.getRootNode?.() || window?.document;\nconst inputTags = ['INPUT', 'SELECT', 'TEXTAREA'];\nfunction isInputDOMNode(event) {\n    // using composed path for handling shadow dom\n    const target = (event.composedPath?.()?.[0] || event.target);\n    if (target?.nodeType !== 1 /* Node.ELEMENT_NODE */)\n        return false;\n    const isInput = inputTags.includes(target.nodeName) || target.hasAttribute('contenteditable');\n    // when an input field is focused we don't want to trigger deletion or movement of nodes\n    return isInput || !!target.closest('.nokey');\n}\nconst isMouseEvent = (event) => 'clientX' in event;\nconst getEventPosition = (event, bounds) => {\n    const isMouse = isMouseEvent(event);\n    const evtX = isMouse ? event.clientX : event.touches?.[0].clientX;\n    const evtY = isMouse ? event.clientY : event.touches?.[0].clientY;\n    return {\n        x: evtX - (bounds?.left ?? 0),\n        y: evtY - (bounds?.top ?? 0),\n    };\n};\n/*\n * The handle bounds are calculated relative to the node element.\n * We store them in the internals object of the node in order to avoid\n * unnecessary recalculations.\n */\nconst getHandleBounds = (type, nodeElement, nodeBounds, zoom, nodeId) => {\n    const handles = nodeElement.querySelectorAll(`.${type}`);\n    if (!handles || !handles.length) {\n        return null;\n    }\n    return Array.from(handles).map((handle) => {\n        const handleBounds = handle.getBoundingClientRect();\n        return {\n            id: handle.getAttribute('data-handleid'),\n            type,\n            nodeId,\n            position: handle.getAttribute('data-handlepos'),\n            x: (handleBounds.left - nodeBounds.left) / zoom,\n            y: (handleBounds.top - nodeBounds.top) / zoom,\n            ...getDimensions(handle),\n        };\n    });\n};\n\nfunction getBezierEdgeCenter({ sourceX, sourceY, targetX, targetY, sourceControlX, sourceControlY, targetControlX, targetControlY, }) {\n    /*\n     * cubic bezier t=0.5 mid point, not the actual mid point, but easy to calculate\n     * https://stackoverflow.com/questions/67516101/how-to-find-distance-mid-point-of-bezier-curve\n     */\n    const centerX = sourceX * 0.125 + sourceControlX * 0.375 + targetControlX * 0.375 + targetX * 0.125;\n    const centerY = sourceY * 0.125 + sourceControlY * 0.375 + targetControlY * 0.375 + targetY * 0.125;\n    const offsetX = Math.abs(centerX - sourceX);\n    const offsetY = Math.abs(centerY - sourceY);\n    return [centerX, centerY, offsetX, offsetY];\n}\nfunction calculateControlOffset(distance, curvature) {\n    if (distance >= 0) {\n        return 0.5 * distance;\n    }\n    return curvature * 25 * Math.sqrt(-distance);\n}\nfunction getControlWithCurvature({ pos, x1, y1, x2, y2, c }) {\n    switch (pos) {\n        case Position.Left:\n            return [x1 - calculateControlOffset(x1 - x2, c), y1];\n        case Position.Right:\n            return [x1 + calculateControlOffset(x2 - x1, c), y1];\n        case Position.Top:\n            return [x1, y1 - calculateControlOffset(y1 - y2, c)];\n        case Position.Bottom:\n            return [x1, y1 + calculateControlOffset(y2 - y1, c)];\n    }\n}\n/**\n * The `getBezierPath` util returns everything you need to render a bezier edge\n *between two nodes.\n * @public\n * @param params.sourceX - The x position of the source handle\n * @param params.sourceY - The y position of the source handle\n * @param params.sourcePosition - The position of the source handle (default: Position.Bottom)\n * @param params.targetX - The x position of the target handle\n * @param params.targetY - The y position of the target handle\n * @param params.targetPosition - The position of the target handle (default: Position.Top)\n * @param params.curvature - The curvature of the bezier edge\n * @returns A path string you can use in an SVG, the labelX and labelY position (center of path) and offsetX, offsetY between source handle and label\n * @example\n * ```js\n *  const source = { x: 0, y: 20 };\n *  const target = { x: 150, y: 100 };\n *\n *  const [path, labelX, labelY, offsetX, offsetY] = getBezierPath({\n *    sourceX: source.x,\n *    sourceY: source.y,\n *    sourcePosition: Position.Right,\n *    targetX: target.x,\n *    targetY: target.y,\n *    targetPosition: Position.Left,\n *});\n *```\n *\n * @remarks This function returns a tuple (aka a fixed-size array) to make it easier to\n *work with multiple edge paths at once.\n */\nfunction getBezierPath({ sourceX, sourceY, sourcePosition = Position.Bottom, targetX, targetY, targetPosition = Position.Top, curvature = 0.25, }) {\n    const [sourceControlX, sourceControlY] = getControlWithCurvature({\n        pos: sourcePosition,\n        x1: sourceX,\n        y1: sourceY,\n        x2: targetX,\n        y2: targetY,\n        c: curvature,\n    });\n    const [targetControlX, targetControlY] = getControlWithCurvature({\n        pos: targetPosition,\n        x1: targetX,\n        y1: targetY,\n        x2: sourceX,\n        y2: sourceY,\n        c: curvature,\n    });\n    const [labelX, labelY, offsetX, offsetY] = getBezierEdgeCenter({\n        sourceX,\n        sourceY,\n        targetX,\n        targetY,\n        sourceControlX,\n        sourceControlY,\n        targetControlX,\n        targetControlY,\n    });\n    return [\n        `M${sourceX},${sourceY} C${sourceControlX},${sourceControlY} ${targetControlX},${targetControlY} ${targetX},${targetY}`,\n        labelX,\n        labelY,\n        offsetX,\n        offsetY,\n    ];\n}\n\n// this is used for straight edges and simple smoothstep edges (LTR, RTL, BTT, TTB)\nfunction getEdgeCenter({ sourceX, sourceY, targetX, targetY, }) {\n    const xOffset = Math.abs(targetX - sourceX) / 2;\n    const centerX = targetX < sourceX ? targetX + xOffset : targetX - xOffset;\n    const yOffset = Math.abs(targetY - sourceY) / 2;\n    const centerY = targetY < sourceY ? targetY + yOffset : targetY - yOffset;\n    return [centerX, centerY, xOffset, yOffset];\n}\nfunction getElevatedEdgeZIndex({ sourceNode, targetNode, selected = false, zIndex = 0, elevateOnSelect = false, }) {\n    if (!elevateOnSelect) {\n        return zIndex;\n    }\n    const edgeOrConnectedNodeSelected = selected || targetNode.selected || sourceNode.selected;\n    const selectedZIndex = Math.max(sourceNode.internals.z || 0, targetNode.internals.z || 0, 1000);\n    return zIndex + (edgeOrConnectedNodeSelected ? selectedZIndex : 0);\n}\nfunction isEdgeVisible({ sourceNode, targetNode, width, height, transform }) {\n    const edgeBox = getBoundsOfBoxes(nodeToBox(sourceNode), nodeToBox(targetNode));\n    if (edgeBox.x === edgeBox.x2) {\n        edgeBox.x2 += 1;\n    }\n    if (edgeBox.y === edgeBox.y2) {\n        edgeBox.y2 += 1;\n    }\n    const viewRect = {\n        x: -transform[0] / transform[2],\n        y: -transform[1] / transform[2],\n        width: width / transform[2],\n        height: height / transform[2],\n    };\n    return getOverlappingArea(viewRect, boxToRect(edgeBox)) > 0;\n}\nconst getEdgeId = ({ source, sourceHandle, target, targetHandle }) => `xy-edge__${source}${sourceHandle || ''}-${target}${targetHandle || ''}`;\nconst connectionExists = (edge, edges) => {\n    return edges.some((el) => el.source === edge.source &&\n        el.target === edge.target &&\n        (el.sourceHandle === edge.sourceHandle || (!el.sourceHandle && !edge.sourceHandle)) &&\n        (el.targetHandle === edge.targetHandle || (!el.targetHandle && !edge.targetHandle)));\n};\n/**\n * This util is a convenience function to add a new Edge to an array of edges. It also performs some validation to make sure you don't add an invalid edge or duplicate an existing one.\n * @public\n * @param edgeParams - Either an Edge or a Connection you want to add\n * @param edges -  The array of all current edges\n * @returns A new array of edges with the new edge added\n *\n * @remarks If an edge with the same `target` and `source` already exists (and the same\n *`targetHandle` and `sourceHandle` if those are set), then this util won't add\n *a new edge even if the `id` property is different.\n *\n */\nconst addEdge = (edgeParams, edges) => {\n    if (!edgeParams.source || !edgeParams.target) {\n        devWarn('006', errorMessages['error006']());\n        return edges;\n    }\n    let edge;\n    if (isEdgeBase(edgeParams)) {\n        edge = { ...edgeParams };\n    }\n    else {\n        edge = {\n            ...edgeParams,\n            id: getEdgeId(edgeParams),\n        };\n    }\n    if (connectionExists(edge, edges)) {\n        return edges;\n    }\n    if (edge.sourceHandle === null) {\n        delete edge.sourceHandle;\n    }\n    if (edge.targetHandle === null) {\n        delete edge.targetHandle;\n    }\n    return edges.concat(edge);\n};\n/**\n * A handy utility to update an existing [`Edge`](/api-reference/types/edge) with new properties.\n *This searches your edge array for an edge with a matching `id` and updates its\n *properties with the connection you provide.\n * @public\n * @param oldEdge - The edge you want to update\n * @param newConnection - The new connection you want to update the edge with\n * @param edges - The array of all current edges\n * @param options.shouldReplaceId - should the id of the old edge be replaced with the new connection id\n * @returns the updated edges array\n *\n * @example\n * ```js\n *const onReconnect = useCallback(\n *  (oldEdge: Edge, newConnection: Connection) => setEdges((els) => reconnectEdge(oldEdge, newConnection, els)),[]);\n *```\n */\nconst reconnectEdge = (oldEdge, newConnection, edges, options = { shouldReplaceId: true }) => {\n    const { id: oldEdgeId, ...rest } = oldEdge;\n    if (!newConnection.source || !newConnection.target) {\n        devWarn('006', errorMessages['error006']());\n        return edges;\n    }\n    const foundEdge = edges.find((e) => e.id === oldEdge.id);\n    if (!foundEdge) {\n        devWarn('007', errorMessages['error007'](oldEdgeId));\n        return edges;\n    }\n    // Remove old edge and create the new edge with parameters of old edge.\n    const edge = {\n        ...rest,\n        id: options.shouldReplaceId ? getEdgeId(newConnection) : oldEdgeId,\n        source: newConnection.source,\n        target: newConnection.target,\n        sourceHandle: newConnection.sourceHandle,\n        targetHandle: newConnection.targetHandle,\n    };\n    return edges.filter((e) => e.id !== oldEdgeId).concat(edge);\n};\n\n/**\n * Calculates the straight line path between two points.\n * @public\n * @param params.sourceX - The x position of the source handle\n * @param params.sourceY - The y position of the source handle\n * @param params.targetX - The x position of the target handle\n * @param params.targetY - The y position of the target handle\n * @returns A path string you can use in an SVG, the labelX and labelY position (center of path) and offsetX, offsetY between source handle and label\n * @example\n * ```js\n *  const source = { x: 0, y: 20 };\n *  const target = { x: 150, y: 100 };\n *\n *  const [path, labelX, labelY, offsetX, offsetY] = getStraightPath({\n *    sourceX: source.x,\n *    sourceY: source.y,\n *    sourcePosition: Position.Right,\n *    targetX: target.x,\n *    targetY: target.y,\n *    targetPosition: Position.Left,\n *  });\n * ```\n * @remarks This function returns a tuple (aka a fixed-size array) to make it easier to work with multiple edge paths at once.\n */\nfunction getStraightPath({ sourceX, sourceY, targetX, targetY, }) {\n    const [labelX, labelY, offsetX, offsetY] = getEdgeCenter({\n        sourceX,\n        sourceY,\n        targetX,\n        targetY,\n    });\n    return [`M ${sourceX},${sourceY}L ${targetX},${targetY}`, labelX, labelY, offsetX, offsetY];\n}\n\nconst handleDirections = {\n    [Position.Left]: { x: -1, y: 0 },\n    [Position.Right]: { x: 1, y: 0 },\n    [Position.Top]: { x: 0, y: -1 },\n    [Position.Bottom]: { x: 0, y: 1 },\n};\nconst getDirection = ({ source, sourcePosition = Position.Bottom, target, }) => {\n    if (sourcePosition === Position.Left || sourcePosition === Position.Right) {\n        return source.x < target.x ? { x: 1, y: 0 } : { x: -1, y: 0 };\n    }\n    return source.y < target.y ? { x: 0, y: 1 } : { x: 0, y: -1 };\n};\nconst distance = (a, b) => Math.sqrt(Math.pow(b.x - a.x, 2) + Math.pow(b.y - a.y, 2));\n/*\n * ith this function we try to mimic a orthogonal edge routing behaviour\n * It's not as good as a real orthogonal edge routing but it's faster and good enough as a default for step and smooth step edges\n */\nfunction getPoints({ source, sourcePosition = Position.Bottom, target, targetPosition = Position.Top, center, offset, }) {\n    const sourceDir = handleDirections[sourcePosition];\n    const targetDir = handleDirections[targetPosition];\n    const sourceGapped = { x: source.x + sourceDir.x * offset, y: source.y + sourceDir.y * offset };\n    const targetGapped = { x: target.x + targetDir.x * offset, y: target.y + targetDir.y * offset };\n    const dir = getDirection({\n        source: sourceGapped,\n        sourcePosition,\n        target: targetGapped,\n    });\n    const dirAccessor = dir.x !== 0 ? 'x' : 'y';\n    const currDir = dir[dirAccessor];\n    let points = [];\n    let centerX, centerY;\n    const sourceGapOffset = { x: 0, y: 0 };\n    const targetGapOffset = { x: 0, y: 0 };\n    const [defaultCenterX, defaultCenterY, defaultOffsetX, defaultOffsetY] = getEdgeCenter({\n        sourceX: source.x,\n        sourceY: source.y,\n        targetX: target.x,\n        targetY: target.y,\n    });\n    // opposite handle positions, default case\n    if (sourceDir[dirAccessor] * targetDir[dirAccessor] === -1) {\n        centerX = center.x ?? defaultCenterX;\n        centerY = center.y ?? defaultCenterY;\n        /*\n         *    --->\n         *    |\n         * >---\n         */\n        const verticalSplit = [\n            { x: centerX, y: sourceGapped.y },\n            { x: centerX, y: targetGapped.y },\n        ];\n        /*\n         *    |\n         *  ---\n         *  |\n         */\n        const horizontalSplit = [\n            { x: sourceGapped.x, y: centerY },\n            { x: targetGapped.x, y: centerY },\n        ];\n        if (sourceDir[dirAccessor] === currDir) {\n            points = dirAccessor === 'x' ? verticalSplit : horizontalSplit;\n        }\n        else {\n            points = dirAccessor === 'x' ? horizontalSplit : verticalSplit;\n        }\n    }\n    else {\n        // sourceTarget means we take x from source and y from target, targetSource is the opposite\n        const sourceTarget = [{ x: sourceGapped.x, y: targetGapped.y }];\n        const targetSource = [{ x: targetGapped.x, y: sourceGapped.y }];\n        // this handles edges with same handle positions\n        if (dirAccessor === 'x') {\n            points = sourceDir.x === currDir ? targetSource : sourceTarget;\n        }\n        else {\n            points = sourceDir.y === currDir ? sourceTarget : targetSource;\n        }\n        if (sourcePosition === targetPosition) {\n            const diff = Math.abs(source[dirAccessor] - target[dirAccessor]);\n            // if an edge goes from right to right for example (sourcePosition === targetPosition) and the distance between source.x and target.x is less than the offset, the added point and the gapped source/target will overlap. This leads to a weird edge path. To avoid this we add a gapOffset to the source/target\n            if (diff <= offset) {\n                const gapOffset = Math.min(offset - 1, offset - diff);\n                if (sourceDir[dirAccessor] === currDir) {\n                    sourceGapOffset[dirAccessor] = (sourceGapped[dirAccessor] > source[dirAccessor] ? -1 : 1) * gapOffset;\n                }\n                else {\n                    targetGapOffset[dirAccessor] = (targetGapped[dirAccessor] > target[dirAccessor] ? -1 : 1) * gapOffset;\n                }\n            }\n        }\n        // these are conditions for handling mixed handle positions like Right -> Bottom for example\n        if (sourcePosition !== targetPosition) {\n            const dirAccessorOpposite = dirAccessor === 'x' ? 'y' : 'x';\n            const isSameDir = sourceDir[dirAccessor] === targetDir[dirAccessorOpposite];\n            const sourceGtTargetOppo = sourceGapped[dirAccessorOpposite] > targetGapped[dirAccessorOpposite];\n            const sourceLtTargetOppo = sourceGapped[dirAccessorOpposite] < targetGapped[dirAccessorOpposite];\n            const flipSourceTarget = (sourceDir[dirAccessor] === 1 && ((!isSameDir && sourceGtTargetOppo) || (isSameDir && sourceLtTargetOppo))) ||\n                (sourceDir[dirAccessor] !== 1 && ((!isSameDir && sourceLtTargetOppo) || (isSameDir && sourceGtTargetOppo)));\n            if (flipSourceTarget) {\n                points = dirAccessor === 'x' ? sourceTarget : targetSource;\n            }\n        }\n        const sourceGapPoint = { x: sourceGapped.x + sourceGapOffset.x, y: sourceGapped.y + sourceGapOffset.y };\n        const targetGapPoint = { x: targetGapped.x + targetGapOffset.x, y: targetGapped.y + targetGapOffset.y };\n        const maxXDistance = Math.max(Math.abs(sourceGapPoint.x - points[0].x), Math.abs(targetGapPoint.x - points[0].x));\n        const maxYDistance = Math.max(Math.abs(sourceGapPoint.y - points[0].y), Math.abs(targetGapPoint.y - points[0].y));\n        // we want to place the label on the longest segment of the edge\n        if (maxXDistance >= maxYDistance) {\n            centerX = (sourceGapPoint.x + targetGapPoint.x) / 2;\n            centerY = points[0].y;\n        }\n        else {\n            centerX = points[0].x;\n            centerY = (sourceGapPoint.y + targetGapPoint.y) / 2;\n        }\n    }\n    const pathPoints = [\n        source,\n        { x: sourceGapped.x + sourceGapOffset.x, y: sourceGapped.y + sourceGapOffset.y },\n        ...points,\n        { x: targetGapped.x + targetGapOffset.x, y: targetGapped.y + targetGapOffset.y },\n        target,\n    ];\n    return [pathPoints, centerX, centerY, defaultOffsetX, defaultOffsetY];\n}\nfunction getBend(a, b, c, size) {\n    const bendSize = Math.min(distance(a, b) / 2, distance(b, c) / 2, size);\n    const { x, y } = b;\n    // no bend\n    if ((a.x === x && x === c.x) || (a.y === y && y === c.y)) {\n        return `L${x} ${y}`;\n    }\n    // first segment is horizontal\n    if (a.y === y) {\n        const xDir = a.x < c.x ? -1 : 1;\n        const yDir = a.y < c.y ? 1 : -1;\n        return `L ${x + bendSize * xDir},${y}Q ${x},${y} ${x},${y + bendSize * yDir}`;\n    }\n    const xDir = a.x < c.x ? 1 : -1;\n    const yDir = a.y < c.y ? -1 : 1;\n    return `L ${x},${y + bendSize * yDir}Q ${x},${y} ${x + bendSize * xDir},${y}`;\n}\n/**\n * The `getSmoothStepPath` util returns everything you need to render a stepped path\n *between two nodes. The `borderRadius` property can be used to choose how rounded\n *the corners of those steps are.\n * @public\n * @param params.sourceX - The x position of the source handle\n * @param params.sourceY - The y position of the source handle\n * @param params.sourcePosition - The position of the source handle (default: Position.Bottom)\n * @param params.targetX - The x position of the target handle\n * @param params.targetY - The y position of the target handle\n * @param params.targetPosition - The position of the target handle (default: Position.Top)\n * @returns A path string you can use in an SVG, the labelX and labelY position (center of path) and offsetX, offsetY between source handle and label\n * @example\n * ```js\n *  const source = { x: 0, y: 20 };\n *  const target = { x: 150, y: 100 };\n *\n *  const [path, labelX, labelY, offsetX, offsetY] = getSmoothStepPath({\n *    sourceX: source.x,\n *    sourceY: source.y,\n *    sourcePosition: Position.Right,\n *    targetX: target.x,\n *    targetY: target.y,\n *    targetPosition: Position.Left,\n *  });\n * ```\n * @remarks This function returns a tuple (aka a fixed-size array) to make it easier to work with multiple edge paths at once.\n */\nfunction getSmoothStepPath({ sourceX, sourceY, sourcePosition = Position.Bottom, targetX, targetY, targetPosition = Position.Top, borderRadius = 5, centerX, centerY, offset = 20, }) {\n    const [points, labelX, labelY, offsetX, offsetY] = getPoints({\n        source: { x: sourceX, y: sourceY },\n        sourcePosition,\n        target: { x: targetX, y: targetY },\n        targetPosition,\n        center: { x: centerX, y: centerY },\n        offset,\n    });\n    const path = points.reduce((res, p, i) => {\n        let segment = '';\n        if (i > 0 && i < points.length - 1) {\n            segment = getBend(points[i - 1], p, points[i + 1], borderRadius);\n        }\n        else {\n            segment = `${i === 0 ? 'M' : 'L'}${p.x} ${p.y}`;\n        }\n        res += segment;\n        return res;\n    }, '');\n    return [path, labelX, labelY, offsetX, offsetY];\n}\n\nfunction isNodeInitialized(node) {\n    return (node &&\n        !!(node.internals.handleBounds || node.handles?.length) &&\n        !!(node.measured.width || node.width || node.initialWidth));\n}\nfunction getEdgePosition(params) {\n    const { sourceNode, targetNode } = params;\n    if (!isNodeInitialized(sourceNode) || !isNodeInitialized(targetNode)) {\n        return null;\n    }\n    const sourceHandleBounds = sourceNode.internals.handleBounds || toHandleBounds(sourceNode.handles);\n    const targetHandleBounds = targetNode.internals.handleBounds || toHandleBounds(targetNode.handles);\n    const sourceHandle = getHandle$1(sourceHandleBounds?.source ?? [], params.sourceHandle);\n    const targetHandle = getHandle$1(\n    // when connection type is loose we can define all handles as sources and connect source -> source\n    params.connectionMode === ConnectionMode.Strict\n        ? targetHandleBounds?.target ?? []\n        : (targetHandleBounds?.target ?? []).concat(targetHandleBounds?.source ?? []), params.targetHandle);\n    if (!sourceHandle || !targetHandle) {\n        params.onError?.('008', errorMessages['error008'](!sourceHandle ? 'source' : 'target', {\n            id: params.id,\n            sourceHandle: params.sourceHandle,\n            targetHandle: params.targetHandle,\n        }));\n        return null;\n    }\n    const sourcePosition = sourceHandle?.position || Position.Bottom;\n    const targetPosition = targetHandle?.position || Position.Top;\n    const source = getHandlePosition(sourceNode, sourceHandle, sourcePosition);\n    const target = getHandlePosition(targetNode, targetHandle, targetPosition);\n    return {\n        sourceX: source.x,\n        sourceY: source.y,\n        targetX: target.x,\n        targetY: target.y,\n        sourcePosition,\n        targetPosition,\n    };\n}\nfunction toHandleBounds(handles) {\n    if (!handles) {\n        return null;\n    }\n    const source = [];\n    const target = [];\n    for (const handle of handles) {\n        handle.width = handle.width ?? 1;\n        handle.height = handle.height ?? 1;\n        if (handle.type === 'source') {\n            source.push(handle);\n        }\n        else if (handle.type === 'target') {\n            target.push(handle);\n        }\n    }\n    return {\n        source,\n        target,\n    };\n}\nfunction getHandlePosition(node, handle, fallbackPosition = Position.Left, center = false) {\n    const x = (handle?.x ?? 0) + node.internals.positionAbsolute.x;\n    const y = (handle?.y ?? 0) + node.internals.positionAbsolute.y;\n    const { width, height } = handle ?? getNodeDimensions(node);\n    if (center) {\n        return { x: x + width / 2, y: y + height / 2 };\n    }\n    const position = handle?.position ?? fallbackPosition;\n    switch (position) {\n        case Position.Top:\n            return { x: x + width / 2, y };\n        case Position.Right:\n            return { x: x + width, y: y + height / 2 };\n        case Position.Bottom:\n            return { x: x + width / 2, y: y + height };\n        case Position.Left:\n            return { x, y: y + height / 2 };\n    }\n}\nfunction getHandle$1(bounds, handleId) {\n    if (!bounds) {\n        return null;\n    }\n    // if no handleId is given, we use the first handle, otherwise we check for the id\n    return (!handleId ? bounds[0] : bounds.find((d) => d.id === handleId)) || null;\n}\n\nfunction getMarkerId(marker, id) {\n    if (!marker) {\n        return '';\n    }\n    if (typeof marker === 'string') {\n        return marker;\n    }\n    const idPrefix = id ? `${id}__` : '';\n    return `${idPrefix}${Object.keys(marker)\n        .sort()\n        .map((key) => `${key}=${marker[key]}`)\n        .join('&')}`;\n}\nfunction createMarkerIds(edges, { id, defaultColor, defaultMarkerStart, defaultMarkerEnd, }) {\n    const ids = new Set();\n    return edges\n        .reduce((markers, edge) => {\n        [edge.markerStart || defaultMarkerStart, edge.markerEnd || defaultMarkerEnd].forEach((marker) => {\n            if (marker && typeof marker === 'object') {\n                const markerId = getMarkerId(marker, id);\n                if (!ids.has(markerId)) {\n                    markers.push({ id: markerId, color: marker.color || defaultColor, ...marker });\n                    ids.add(markerId);\n                }\n            }\n        });\n        return markers;\n    }, [])\n        .sort((a, b) => a.id.localeCompare(b.id));\n}\n\nfunction getNodeToolbarTransform(nodeRect, viewport, position, offset, align) {\n    let alignmentOffset = 0.5;\n    if (align === 'start') {\n        alignmentOffset = 0;\n    }\n    else if (align === 'end') {\n        alignmentOffset = 1;\n    }\n    /*\n     * position === Position.Top\n     * we set the x any y position of the toolbar based on the nodes position\n     */\n    let pos = [\n        (nodeRect.x + nodeRect.width * alignmentOffset) * viewport.zoom + viewport.x,\n        nodeRect.y * viewport.zoom + viewport.y - offset,\n    ];\n    // and than shift it based on the alignment. The shift values are in %.\n    let shift = [-100 * alignmentOffset, -100];\n    switch (position) {\n        case Position.Right:\n            pos = [\n                (nodeRect.x + nodeRect.width) * viewport.zoom + viewport.x + offset,\n                (nodeRect.y + nodeRect.height * alignmentOffset) * viewport.zoom + viewport.y,\n            ];\n            shift = [0, -100 * alignmentOffset];\n            break;\n        case Position.Bottom:\n            pos[1] = (nodeRect.y + nodeRect.height) * viewport.zoom + viewport.y + offset;\n            shift[1] = 0;\n            break;\n        case Position.Left:\n            pos = [\n                nodeRect.x * viewport.zoom + viewport.x - offset,\n                (nodeRect.y + nodeRect.height * alignmentOffset) * viewport.zoom + viewport.y,\n            ];\n            shift = [-100, -100 * alignmentOffset];\n            break;\n    }\n    return `translate(${pos[0]}px, ${pos[1]}px) translate(${shift[0]}%, ${shift[1]}%)`;\n}\n\nconst defaultOptions = {\n    nodeOrigin: [0, 0],\n    nodeExtent: infiniteExtent,\n    elevateNodesOnSelect: true,\n    defaults: {},\n};\nconst adoptUserNodesDefaultOptions = {\n    ...defaultOptions,\n    checkEquality: true,\n};\nfunction mergeObjects(base, incoming) {\n    const result = { ...base };\n    for (const key in incoming) {\n        if (incoming[key] !== undefined) {\n            // typecast is safe here, because we check for undefined\n            result[key] = incoming[key];\n        }\n    }\n    return result;\n}\nfunction updateAbsolutePositions(nodeLookup, parentLookup, options) {\n    const _options = mergeObjects(defaultOptions, options);\n    for (const node of nodeLookup.values()) {\n        if (node.parentId) {\n            updateChildNode(node, nodeLookup, parentLookup, _options);\n        }\n        else {\n            const positionWithOrigin = getNodePositionWithOrigin(node, _options.nodeOrigin);\n            const extent = isCoordinateExtent(node.extent) ? node.extent : _options.nodeExtent;\n            const clampedPosition = clampPosition(positionWithOrigin, extent, getNodeDimensions(node));\n            node.internals.positionAbsolute = clampedPosition;\n        }\n    }\n}\nfunction adoptUserNodes(nodes, nodeLookup, parentLookup, options) {\n    const _options = mergeObjects(adoptUserNodesDefaultOptions, options);\n    const tmpLookup = new Map(nodeLookup);\n    const selectedNodeZ = _options?.elevateNodesOnSelect ? 1000 : 0;\n    nodeLookup.clear();\n    parentLookup.clear();\n    for (const userNode of nodes) {\n        let internalNode = tmpLookup.get(userNode.id);\n        if (_options.checkEquality && userNode === internalNode?.internals.userNode) {\n            nodeLookup.set(userNode.id, internalNode);\n        }\n        else {\n            const positionWithOrigin = getNodePositionWithOrigin(userNode, _options.nodeOrigin);\n            const extent = isCoordinateExtent(userNode.extent) ? userNode.extent : _options.nodeExtent;\n            const clampedPosition = clampPosition(positionWithOrigin, extent, getNodeDimensions(userNode));\n            internalNode = {\n                ..._options.defaults,\n                ...userNode,\n                measured: {\n                    width: userNode.measured?.width,\n                    height: userNode.measured?.height,\n                },\n                internals: {\n                    positionAbsolute: clampedPosition,\n                    // if user re-initializes the node or removes `measured` for whatever reason, we reset the handleBounds so that the node gets re-measured\n                    handleBounds: !userNode.measured ? undefined : internalNode?.internals.handleBounds,\n                    z: calculateZ(userNode, selectedNodeZ),\n                    userNode,\n                },\n            };\n            nodeLookup.set(userNode.id, internalNode);\n        }\n        if (userNode.parentId) {\n            updateChildNode(internalNode, nodeLookup, parentLookup, options);\n        }\n    }\n}\nfunction updateParentLookup(node, parentLookup) {\n    if (!node.parentId) {\n        return;\n    }\n    const childNodes = parentLookup.get(node.parentId);\n    if (childNodes) {\n        childNodes.set(node.id, node);\n    }\n    else {\n        parentLookup.set(node.parentId, new Map([[node.id, node]]));\n    }\n}\n/**\n * Updates positionAbsolute and zIndex of a child node and the parentLookup.\n */\nfunction updateChildNode(node, nodeLookup, parentLookup, options) {\n    const { elevateNodesOnSelect, nodeOrigin, nodeExtent } = mergeObjects(defaultOptions, options);\n    const parentId = node.parentId;\n    const parentNode = nodeLookup.get(parentId);\n    if (!parentNode) {\n        console.warn(`Parent node ${parentId} not found. Please make sure that parent nodes are in front of their child nodes in the nodes array.`);\n        return;\n    }\n    updateParentLookup(node, parentLookup);\n    const selectedNodeZ = elevateNodesOnSelect ? 1000 : 0;\n    const { x, y, z } = calculateChildXYZ(node, parentNode, nodeOrigin, nodeExtent, selectedNodeZ);\n    const { positionAbsolute } = node.internals;\n    const positionChanged = x !== positionAbsolute.x || y !== positionAbsolute.y;\n    if (positionChanged || z !== node.internals.z) {\n        // we create a new object to mark the node as updated\n        nodeLookup.set(node.id, {\n            ...node,\n            internals: {\n                ...node.internals,\n                positionAbsolute: positionChanged ? { x, y } : positionAbsolute,\n                z,\n            },\n        });\n    }\n}\nfunction calculateZ(node, selectedNodeZ) {\n    return (isNumeric(node.zIndex) ? node.zIndex : 0) + (node.selected ? selectedNodeZ : 0);\n}\nfunction calculateChildXYZ(childNode, parentNode, nodeOrigin, nodeExtent, selectedNodeZ) {\n    const { x: parentX, y: parentY } = parentNode.internals.positionAbsolute;\n    const childDimensions = getNodeDimensions(childNode);\n    const positionWithOrigin = getNodePositionWithOrigin(childNode, nodeOrigin);\n    const clampedPosition = isCoordinateExtent(childNode.extent)\n        ? clampPosition(positionWithOrigin, childNode.extent, childDimensions)\n        : positionWithOrigin;\n    let absolutePosition = clampPosition({ x: parentX + clampedPosition.x, y: parentY + clampedPosition.y }, nodeExtent, childDimensions);\n    if (childNode.extent === 'parent') {\n        absolutePosition = clampPositionToParent(absolutePosition, childDimensions, parentNode);\n    }\n    const childZ = calculateZ(childNode, selectedNodeZ);\n    const parentZ = parentNode.internals.z ?? 0;\n    return {\n        x: absolutePosition.x,\n        y: absolutePosition.y,\n        z: parentZ > childZ ? parentZ : childZ,\n    };\n}\nfunction handleExpandParent(children, nodeLookup, parentLookup, nodeOrigin = [0, 0]) {\n    const changes = [];\n    const parentExpansions = new Map();\n    // determine the expanded rectangle the child nodes would take for each parent\n    for (const child of children) {\n        const parent = nodeLookup.get(child.parentId);\n        if (!parent) {\n            continue;\n        }\n        const parentRect = parentExpansions.get(child.parentId)?.expandedRect ?? nodeToRect(parent);\n        const expandedRect = getBoundsOfRects(parentRect, child.rect);\n        parentExpansions.set(child.parentId, { expandedRect, parent });\n    }\n    if (parentExpansions.size > 0) {\n        parentExpansions.forEach(({ expandedRect, parent }, parentId) => {\n            // determine the position & dimensions of the parent\n            const positionAbsolute = parent.internals.positionAbsolute;\n            const dimensions = getNodeDimensions(parent);\n            const origin = parent.origin ?? nodeOrigin;\n            // determine how much the parent expands in width and position\n            const xChange = expandedRect.x < positionAbsolute.x ? Math.round(Math.abs(positionAbsolute.x - expandedRect.x)) : 0;\n            const yChange = expandedRect.y < positionAbsolute.y ? Math.round(Math.abs(positionAbsolute.y - expandedRect.y)) : 0;\n            const newWidth = Math.max(dimensions.width, Math.round(expandedRect.width));\n            const newHeight = Math.max(dimensions.height, Math.round(expandedRect.height));\n            const widthChange = (newWidth - dimensions.width) * origin[0];\n            const heightChange = (newHeight - dimensions.height) * origin[1];\n            // We need to correct the position of the parent node if the origin is not [0,0]\n            if (xChange > 0 || yChange > 0 || widthChange || heightChange) {\n                changes.push({\n                    id: parentId,\n                    type: 'position',\n                    position: {\n                        x: parent.position.x - xChange + widthChange,\n                        y: parent.position.y - yChange + heightChange,\n                    },\n                });\n                /*\n                 * We move all child nodes in the oppsite direction\n                 * so the x,y changes of the parent do not move the children\n                 */\n                parentLookup.get(parentId)?.forEach((childNode) => {\n                    if (!children.some((child) => child.id === childNode.id)) {\n                        changes.push({\n                            id: childNode.id,\n                            type: 'position',\n                            position: {\n                                x: childNode.position.x + xChange,\n                                y: childNode.position.y + yChange,\n                            },\n                        });\n                    }\n                });\n            }\n            // We need to correct the dimensions of the parent node if the origin is not [0,0]\n            if (dimensions.width < expandedRect.width || dimensions.height < expandedRect.height || xChange || yChange) {\n                changes.push({\n                    id: parentId,\n                    type: 'dimensions',\n                    setAttributes: true,\n                    dimensions: {\n                        width: newWidth + (xChange ? origin[0] * xChange - widthChange : 0),\n                        height: newHeight + (yChange ? origin[1] * yChange - heightChange : 0),\n                    },\n                });\n            }\n        });\n    }\n    return changes;\n}\nfunction updateNodeInternals(updates, nodeLookup, parentLookup, domNode, nodeOrigin, nodeExtent) {\n    const viewportNode = domNode?.querySelector('.xyflow__viewport');\n    let updatedInternals = false;\n    if (!viewportNode) {\n        return { changes: [], updatedInternals };\n    }\n    const changes = [];\n    const style = window.getComputedStyle(viewportNode);\n    const { m22: zoom } = new window.DOMMatrixReadOnly(style.transform);\n    // in this array we collect nodes, that might trigger changes (like expanding parent)\n    const parentExpandChildren = [];\n    for (const update of updates.values()) {\n        const node = nodeLookup.get(update.id);\n        if (!node) {\n            continue;\n        }\n        if (node.hidden) {\n            nodeLookup.set(node.id, {\n                ...node,\n                internals: {\n                    ...node.internals,\n                    handleBounds: undefined,\n                },\n            });\n            updatedInternals = true;\n            continue;\n        }\n        const dimensions = getDimensions(update.nodeElement);\n        const dimensionChanged = node.measured.width !== dimensions.width || node.measured.height !== dimensions.height;\n        const doUpdate = !!(dimensions.width &&\n            dimensions.height &&\n            (dimensionChanged || !node.internals.handleBounds || update.force));\n        if (doUpdate) {\n            const nodeBounds = update.nodeElement.getBoundingClientRect();\n            const extent = isCoordinateExtent(node.extent) ? node.extent : nodeExtent;\n            let { positionAbsolute } = node.internals;\n            if (node.parentId && node.extent === 'parent') {\n                positionAbsolute = clampPositionToParent(positionAbsolute, dimensions, nodeLookup.get(node.parentId));\n            }\n            else if (extent) {\n                positionAbsolute = clampPosition(positionAbsolute, extent, dimensions);\n            }\n            const newNode = {\n                ...node,\n                measured: dimensions,\n                internals: {\n                    ...node.internals,\n                    positionAbsolute,\n                    handleBounds: {\n                        source: getHandleBounds('source', update.nodeElement, nodeBounds, zoom, node.id),\n                        target: getHandleBounds('target', update.nodeElement, nodeBounds, zoom, node.id),\n                    },\n                },\n            };\n            nodeLookup.set(node.id, newNode);\n            if (node.parentId) {\n                updateChildNode(newNode, nodeLookup, parentLookup, { nodeOrigin });\n            }\n            updatedInternals = true;\n            if (dimensionChanged) {\n                changes.push({\n                    id: node.id,\n                    type: 'dimensions',\n                    dimensions,\n                });\n                if (node.expandParent && node.parentId) {\n                    parentExpandChildren.push({\n                        id: node.id,\n                        parentId: node.parentId,\n                        rect: nodeToRect(newNode, nodeOrigin),\n                    });\n                }\n            }\n        }\n    }\n    if (parentExpandChildren.length > 0) {\n        const parentExpandChanges = handleExpandParent(parentExpandChildren, nodeLookup, parentLookup, nodeOrigin);\n        changes.push(...parentExpandChanges);\n    }\n    return { changes, updatedInternals };\n}\nasync function panBy({ delta, panZoom, transform, translateExtent, width, height, }) {\n    if (!panZoom || (!delta.x && !delta.y)) {\n        return Promise.resolve(false);\n    }\n    const nextViewport = await panZoom.setViewportConstrained({\n        x: transform[0] + delta.x,\n        y: transform[1] + delta.y,\n        zoom: transform[2],\n    }, [\n        [0, 0],\n        [width, height],\n    ], translateExtent);\n    const transformChanged = !!nextViewport &&\n        (nextViewport.x !== transform[0] || nextViewport.y !== transform[1] || nextViewport.k !== transform[2]);\n    return Promise.resolve(transformChanged);\n}\n/**\n * this function adds the connection to the connectionLookup\n * at the following keys: nodeId-type-handleId, nodeId-type and nodeId\n * @param type type of the connection\n * @param connection connection that should be added to the lookup\n * @param connectionKey at which key the connection should be added\n * @param connectionLookup reference to the connection lookup\n * @param nodeId nodeId of the connection\n * @param handleId handleId of the conneciton\n */\nfunction addConnectionToLookup(type, connection, connectionKey, connectionLookup, nodeId, handleId) {\n    /*\n     * We add the connection to the connectionLookup at the following keys\n     * 1. nodeId, 2. nodeId-type, 3. nodeId-type-handleId\n     * If the key already exists, we add the connection to the existing map\n     */\n    let key = nodeId;\n    const nodeMap = connectionLookup.get(key) || new Map();\n    connectionLookup.set(key, nodeMap.set(connectionKey, connection));\n    key = `${nodeId}-${type}`;\n    const typeMap = connectionLookup.get(key) || new Map();\n    connectionLookup.set(key, typeMap.set(connectionKey, connection));\n    if (handleId) {\n        key = `${nodeId}-${type}-${handleId}`;\n        const handleMap = connectionLookup.get(key) || new Map();\n        connectionLookup.set(key, handleMap.set(connectionKey, connection));\n    }\n}\nfunction updateConnectionLookup(connectionLookup, edgeLookup, edges) {\n    connectionLookup.clear();\n    edgeLookup.clear();\n    for (const edge of edges) {\n        const { source: sourceNode, target: targetNode, sourceHandle = null, targetHandle = null } = edge;\n        const connection = { edgeId: edge.id, source: sourceNode, target: targetNode, sourceHandle, targetHandle };\n        const sourceKey = `${sourceNode}-${sourceHandle}--${targetNode}-${targetHandle}`;\n        const targetKey = `${targetNode}-${targetHandle}--${sourceNode}-${sourceHandle}`;\n        addConnectionToLookup('source', connection, targetKey, connectionLookup, sourceNode, sourceHandle);\n        addConnectionToLookup('target', connection, sourceKey, connectionLookup, targetNode, targetHandle);\n        edgeLookup.set(edge.id, edge);\n    }\n}\n\nfunction shallowNodeData(a, b) {\n    if (a === null || b === null) {\n        return false;\n    }\n    const _a = Array.isArray(a) ? a : [a];\n    const _b = Array.isArray(b) ? b : [b];\n    if (_a.length !== _b.length) {\n        return false;\n    }\n    for (let i = 0; i < _a.length; i++) {\n        if (_a[i].id !== _b[i].id || _a[i].type !== _b[i].type || !Object.is(_a[i].data, _b[i].data)) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction isParentSelected(node, nodeLookup) {\n    if (!node.parentId) {\n        return false;\n    }\n    const parentNode = nodeLookup.get(node.parentId);\n    if (!parentNode) {\n        return false;\n    }\n    if (parentNode.selected) {\n        return true;\n    }\n    return isParentSelected(parentNode, nodeLookup);\n}\nfunction hasSelector(target, selector, domNode) {\n    let current = target;\n    do {\n        if (current?.matches?.(selector))\n            return true;\n        if (current === domNode)\n            return false;\n        current = current?.parentElement;\n    } while (current);\n    return false;\n}\n// looks for all selected nodes and created a NodeDragItem for each of them\nfunction getDragItems(nodeLookup, nodesDraggable, mousePos, nodeId) {\n    const dragItems = new Map();\n    for (const [id, node] of nodeLookup) {\n        if ((node.selected || node.id === nodeId) &&\n            (!node.parentId || !isParentSelected(node, nodeLookup)) &&\n            (node.draggable || (nodesDraggable && typeof node.draggable === 'undefined'))) {\n            const internalNode = nodeLookup.get(id);\n            if (internalNode) {\n                dragItems.set(id, {\n                    id,\n                    position: internalNode.position || { x: 0, y: 0 },\n                    distance: {\n                        x: mousePos.x - internalNode.internals.positionAbsolute.x,\n                        y: mousePos.y - internalNode.internals.positionAbsolute.y,\n                    },\n                    extent: internalNode.extent,\n                    parentId: internalNode.parentId,\n                    origin: internalNode.origin,\n                    expandParent: internalNode.expandParent,\n                    internals: {\n                        positionAbsolute: internalNode.internals.positionAbsolute || { x: 0, y: 0 },\n                    },\n                    measured: {\n                        width: internalNode.measured.width ?? 0,\n                        height: internalNode.measured.height ?? 0,\n                    },\n                });\n            }\n        }\n    }\n    return dragItems;\n}\n/*\n * returns two params:\n * 1. the dragged node (or the first of the list, if we are dragging a node selection)\n * 2. array of selected nodes (for multi selections)\n */\nfunction getEventHandlerParams({ nodeId, dragItems, nodeLookup, dragging = true, }) {\n    const nodesFromDragItems = [];\n    for (const [id, dragItem] of dragItems) {\n        const node = nodeLookup.get(id)?.internals.userNode;\n        if (node) {\n            nodesFromDragItems.push({\n                ...node,\n                position: dragItem.position,\n                dragging,\n            });\n        }\n    }\n    if (!nodeId) {\n        return [nodesFromDragItems[0], nodesFromDragItems];\n    }\n    const node = nodeLookup.get(nodeId)?.internals.userNode;\n    return [\n        !node\n            ? nodesFromDragItems[0]\n            : {\n                ...node,\n                position: dragItems.get(nodeId)?.position || node.position,\n                dragging,\n            },\n        nodesFromDragItems,\n    ];\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction XYDrag({ onNodeMouseDown, getStoreItems, onDragStart, onDrag, onDragStop, }) {\n    let lastPos = { x: null, y: null };\n    let autoPanId = 0;\n    let dragItems = new Map();\n    let autoPanStarted = false;\n    let mousePosition = { x: 0, y: 0 };\n    let containerBounds = null;\n    let dragStarted = false;\n    let d3Selection = null;\n    let abortDrag = false; // prevents unintentional dragging on multitouch\n    // public functions\n    function update({ noDragClassName, handleSelector, domNode, isSelectable, nodeId, nodeClickDistance = 0, }) {\n        d3Selection = (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(domNode);\n        function updateNodes({ x, y }, dragEvent) {\n            const { nodeLookup, nodeExtent, snapGrid, snapToGrid, nodeOrigin, onNodeDrag, onSelectionDrag, onError, updateNodePositions, } = getStoreItems();\n            lastPos = { x, y };\n            let hasChange = false;\n            let nodesBox = { x: 0, y: 0, x2: 0, y2: 0 };\n            if (dragItems.size > 1 && nodeExtent) {\n                const rect = getInternalNodesBounds(dragItems);\n                nodesBox = rectToBox(rect);\n            }\n            for (const [id, dragItem] of dragItems) {\n                if (!nodeLookup.has(id)) {\n                    /*\n                     * if the node is not in the nodeLookup anymore, it was probably deleted while dragging\n                     * and we don't need to update it anymore\n                     */\n                    continue;\n                }\n                let nextPosition = { x: x - dragItem.distance.x, y: y - dragItem.distance.y };\n                if (snapToGrid) {\n                    nextPosition = snapPosition(nextPosition, snapGrid);\n                }\n                /*\n                 * if there is selection with multiple nodes and a node extent is set, we need to adjust the node extent for each node\n                 * based on its position so that the node stays at it's position relative to the selection.\n                 */\n                let adjustedNodeExtent = [\n                    [nodeExtent[0][0], nodeExtent[0][1]],\n                    [nodeExtent[1][0], nodeExtent[1][1]],\n                ];\n                if (dragItems.size > 1 && nodeExtent && !dragItem.extent) {\n                    const { positionAbsolute } = dragItem.internals;\n                    const x1 = positionAbsolute.x - nodesBox.x + nodeExtent[0][0];\n                    const x2 = positionAbsolute.x + dragItem.measured.width - nodesBox.x2 + nodeExtent[1][0];\n                    const y1 = positionAbsolute.y - nodesBox.y + nodeExtent[0][1];\n                    const y2 = positionAbsolute.y + dragItem.measured.height - nodesBox.y2 + nodeExtent[1][1];\n                    adjustedNodeExtent = [\n                        [x1, y1],\n                        [x2, y2],\n                    ];\n                }\n                const { position, positionAbsolute } = calculateNodePosition({\n                    nodeId: id,\n                    nextPosition,\n                    nodeLookup,\n                    nodeExtent: adjustedNodeExtent,\n                    nodeOrigin,\n                    onError,\n                });\n                // we want to make sure that we only fire a change event when there is a change\n                hasChange = hasChange || dragItem.position.x !== position.x || dragItem.position.y !== position.y;\n                dragItem.position = position;\n                dragItem.internals.positionAbsolute = positionAbsolute;\n            }\n            if (!hasChange) {\n                return;\n            }\n            updateNodePositions(dragItems, true);\n            if (dragEvent && (onDrag || onNodeDrag || (!nodeId && onSelectionDrag))) {\n                const [currentNode, currentNodes] = getEventHandlerParams({\n                    nodeId,\n                    dragItems,\n                    nodeLookup,\n                });\n                onDrag?.(dragEvent, dragItems, currentNode, currentNodes);\n                onNodeDrag?.(dragEvent, currentNode, currentNodes);\n                if (!nodeId) {\n                    onSelectionDrag?.(dragEvent, currentNodes);\n                }\n            }\n        }\n        async function autoPan() {\n            if (!containerBounds) {\n                return;\n            }\n            const { transform, panBy, autoPanSpeed, autoPanOnNodeDrag } = getStoreItems();\n            if (!autoPanOnNodeDrag) {\n                autoPanStarted = false;\n                cancelAnimationFrame(autoPanId);\n                return;\n            }\n            const [xMovement, yMovement] = calcAutoPan(mousePosition, containerBounds, autoPanSpeed);\n            if (xMovement !== 0 || yMovement !== 0) {\n                lastPos.x = (lastPos.x ?? 0) - xMovement / transform[2];\n                lastPos.y = (lastPos.y ?? 0) - yMovement / transform[2];\n                if (await panBy({ x: xMovement, y: yMovement })) {\n                    updateNodes(lastPos, null);\n                }\n            }\n            autoPanId = requestAnimationFrame(autoPan);\n        }\n        function startDrag(event) {\n            const { nodeLookup, multiSelectionActive, nodesDraggable, transform, snapGrid, snapToGrid, selectNodesOnDrag, onNodeDragStart, onSelectionDragStart, unselectNodesAndEdges, } = getStoreItems();\n            dragStarted = true;\n            if ((!selectNodesOnDrag || !isSelectable) && !multiSelectionActive && nodeId) {\n                if (!nodeLookup.get(nodeId)?.selected) {\n                    // we need to reset selected nodes when selectNodesOnDrag=false\n                    unselectNodesAndEdges();\n                }\n            }\n            if (isSelectable && selectNodesOnDrag && nodeId) {\n                onNodeMouseDown?.(nodeId);\n            }\n            const pointerPos = getPointerPosition(event.sourceEvent, { transform, snapGrid, snapToGrid, containerBounds });\n            lastPos = pointerPos;\n            dragItems = getDragItems(nodeLookup, nodesDraggable, pointerPos, nodeId);\n            if (dragItems.size > 0 && (onDragStart || onNodeDragStart || (!nodeId && onSelectionDragStart))) {\n                const [currentNode, currentNodes] = getEventHandlerParams({\n                    nodeId,\n                    dragItems,\n                    nodeLookup,\n                });\n                onDragStart?.(event.sourceEvent, dragItems, currentNode, currentNodes);\n                onNodeDragStart?.(event.sourceEvent, currentNode, currentNodes);\n                if (!nodeId) {\n                    onSelectionDragStart?.(event.sourceEvent, currentNodes);\n                }\n            }\n        }\n        const d3DragInstance = (0,d3_drag__WEBPACK_IMPORTED_MODULE_2__[\"default\"])()\n            .clickDistance(nodeClickDistance)\n            .on('start', (event) => {\n            const { domNode, nodeDragThreshold, transform, snapGrid, snapToGrid } = getStoreItems();\n            containerBounds = domNode?.getBoundingClientRect() || null;\n            abortDrag = false;\n            if (nodeDragThreshold === 0) {\n                startDrag(event);\n            }\n            const pointerPos = getPointerPosition(event.sourceEvent, { transform, snapGrid, snapToGrid, containerBounds });\n            lastPos = pointerPos;\n            mousePosition = getEventPosition(event.sourceEvent, containerBounds);\n        })\n            .on('drag', (event) => {\n            const { autoPanOnNodeDrag, transform, snapGrid, snapToGrid, nodeDragThreshold, nodeLookup } = getStoreItems();\n            const pointerPos = getPointerPosition(event.sourceEvent, { transform, snapGrid, snapToGrid, containerBounds });\n            if ((event.sourceEvent.type === 'touchmove' && event.sourceEvent.touches.length > 1) ||\n                // if user deletes a node while dragging, we need to abort the drag to prevent errors\n                (nodeId && !nodeLookup.has(nodeId))) {\n                abortDrag = true;\n            }\n            if (abortDrag) {\n                return;\n            }\n            if (!autoPanStarted && autoPanOnNodeDrag && dragStarted) {\n                autoPanStarted = true;\n                autoPan();\n            }\n            if (!dragStarted) {\n                const x = pointerPos.xSnapped - (lastPos.x ?? 0);\n                const y = pointerPos.ySnapped - (lastPos.y ?? 0);\n                const distance = Math.sqrt(x * x + y * y);\n                if (distance > nodeDragThreshold) {\n                    startDrag(event);\n                }\n            }\n            // skip events without movement\n            if ((lastPos.x !== pointerPos.xSnapped || lastPos.y !== pointerPos.ySnapped) && dragItems && dragStarted) {\n                // dragEvent = event.sourceEvent as MouseEvent;\n                mousePosition = getEventPosition(event.sourceEvent, containerBounds);\n                updateNodes(pointerPos, event.sourceEvent);\n            }\n        })\n            .on('end', (event) => {\n            if (!dragStarted || abortDrag) {\n                return;\n            }\n            autoPanStarted = false;\n            dragStarted = false;\n            cancelAnimationFrame(autoPanId);\n            if (dragItems.size > 0) {\n                const { nodeLookup, updateNodePositions, onNodeDragStop, onSelectionDragStop } = getStoreItems();\n                updateNodePositions(dragItems, false);\n                if (onDragStop || onNodeDragStop || (!nodeId && onSelectionDragStop)) {\n                    const [currentNode, currentNodes] = getEventHandlerParams({\n                        nodeId,\n                        dragItems,\n                        nodeLookup,\n                        dragging: false,\n                    });\n                    onDragStop?.(event.sourceEvent, dragItems, currentNode, currentNodes);\n                    onNodeDragStop?.(event.sourceEvent, currentNode, currentNodes);\n                    if (!nodeId) {\n                        onSelectionDragStop?.(event.sourceEvent, currentNodes);\n                    }\n                }\n            }\n        })\n            .filter((event) => {\n            const target = event.target;\n            const isDraggable = !event.button &&\n                (!noDragClassName || !hasSelector(target, `.${noDragClassName}`, domNode)) &&\n                (!handleSelector || hasSelector(target, handleSelector, domNode));\n            return isDraggable;\n        });\n        d3Selection.call(d3DragInstance);\n    }\n    function destroy() {\n        d3Selection?.on('.drag', null);\n    }\n    return {\n        update,\n        destroy,\n    };\n}\n\nfunction getNodesWithinDistance(position, nodeLookup, distance) {\n    const nodes = [];\n    const rect = {\n        x: position.x - distance,\n        y: position.y - distance,\n        width: distance * 2,\n        height: distance * 2,\n    };\n    for (const node of nodeLookup.values()) {\n        if (getOverlappingArea(rect, nodeToRect(node)) > 0) {\n            nodes.push(node);\n        }\n    }\n    return nodes;\n}\n/*\n * this distance is used for the area around the user pointer\n * while doing a connection for finding the closest nodes\n */\nconst ADDITIONAL_DISTANCE = 250;\nfunction getClosestHandle(position, connectionRadius, nodeLookup, fromHandle) {\n    let closestHandles = [];\n    let minDistance = Infinity;\n    const closeNodes = getNodesWithinDistance(position, nodeLookup, connectionRadius + ADDITIONAL_DISTANCE);\n    for (const node of closeNodes) {\n        const allHandles = [...(node.internals.handleBounds?.source ?? []), ...(node.internals.handleBounds?.target ?? [])];\n        for (const handle of allHandles) {\n            // if the handle is the same as the fromHandle we skip it\n            if (fromHandle.nodeId === handle.nodeId && fromHandle.type === handle.type && fromHandle.id === handle.id) {\n                continue;\n            }\n            // determine absolute position of the handle\n            const { x, y } = getHandlePosition(node, handle, handle.position, true);\n            const distance = Math.sqrt(Math.pow(x - position.x, 2) + Math.pow(y - position.y, 2));\n            if (distance > connectionRadius) {\n                continue;\n            }\n            if (distance < minDistance) {\n                closestHandles = [{ ...handle, x, y }];\n                minDistance = distance;\n            }\n            else if (distance === minDistance) {\n                // when multiple handles are on the same distance we collect all of them\n                closestHandles.push({ ...handle, x, y });\n            }\n        }\n    }\n    if (!closestHandles.length) {\n        return null;\n    }\n    // when multiple handles overlay each other we prefer the opposite handle\n    if (closestHandles.length > 1) {\n        const oppositeHandleType = fromHandle.type === 'source' ? 'target' : 'source';\n        return closestHandles.find((handle) => handle.type === oppositeHandleType) ?? closestHandles[0];\n    }\n    return closestHandles[0];\n}\nfunction getHandle(nodeId, handleType, handleId, nodeLookup, connectionMode, withAbsolutePosition = false) {\n    const node = nodeLookup.get(nodeId);\n    if (!node) {\n        return null;\n    }\n    const handles = connectionMode === 'strict'\n        ? node.internals.handleBounds?.[handleType]\n        : [...(node.internals.handleBounds?.source ?? []), ...(node.internals.handleBounds?.target ?? [])];\n    const handle = (handleId ? handles?.find((h) => h.id === handleId) : handles?.[0]) ?? null;\n    return handle && withAbsolutePosition\n        ? { ...handle, ...getHandlePosition(node, handle, handle.position, true) }\n        : handle;\n}\nfunction getHandleType(edgeUpdaterType, handleDomNode) {\n    if (edgeUpdaterType) {\n        return edgeUpdaterType;\n    }\n    else if (handleDomNode?.classList.contains('target')) {\n        return 'target';\n    }\n    else if (handleDomNode?.classList.contains('source')) {\n        return 'source';\n    }\n    return null;\n}\nfunction isConnectionValid(isInsideConnectionRadius, isHandleValid) {\n    let isValid = null;\n    if (isHandleValid) {\n        isValid = true;\n    }\n    else if (isInsideConnectionRadius && !isHandleValid) {\n        isValid = false;\n    }\n    return isValid;\n}\n\nconst alwaysValid = () => true;\nfunction onPointerDown(event, { connectionMode, connectionRadius, handleId, nodeId, edgeUpdaterType, isTarget, domNode, nodeLookup, lib, autoPanOnConnect, flowId, panBy, cancelConnection, onConnectStart, onConnect, onConnectEnd, isValidConnection = alwaysValid, onReconnectEnd, updateConnection, getTransform, getFromHandle, autoPanSpeed, }) {\n    // when xyflow is used inside a shadow root we can't use document\n    const doc = getHostForElement(event.target);\n    let autoPanId = 0;\n    let closestHandle;\n    const { x, y } = getEventPosition(event);\n    const clickedHandle = doc?.elementFromPoint(x, y);\n    const handleType = getHandleType(edgeUpdaterType, clickedHandle);\n    const containerBounds = domNode?.getBoundingClientRect();\n    if (!containerBounds || !handleType) {\n        return;\n    }\n    const fromHandleInternal = getHandle(nodeId, handleType, handleId, nodeLookup, connectionMode);\n    if (!fromHandleInternal) {\n        return;\n    }\n    let position = getEventPosition(event, containerBounds);\n    let autoPanStarted = false;\n    let connection = null;\n    let isValid = false;\n    let handleDomNode = null;\n    // when the user is moving the mouse close to the edge of the canvas while connecting we move the canvas\n    function autoPan() {\n        if (!autoPanOnConnect || !containerBounds) {\n            return;\n        }\n        const [x, y] = calcAutoPan(position, containerBounds, autoPanSpeed);\n        panBy({ x, y });\n        autoPanId = requestAnimationFrame(autoPan);\n    }\n    // Stays the same for all consecutive pointermove events\n    const fromHandle = {\n        ...fromHandleInternal,\n        nodeId,\n        type: handleType,\n        position: fromHandleInternal.position,\n    };\n    const fromNodeInternal = nodeLookup.get(nodeId);\n    const from = getHandlePosition(fromNodeInternal, fromHandle, Position.Left, true);\n    const newConnection = {\n        inProgress: true,\n        isValid: null,\n        from,\n        fromHandle,\n        fromPosition: fromHandle.position,\n        fromNode: fromNodeInternal,\n        to: position,\n        toHandle: null,\n        toPosition: oppositePosition[fromHandle.position],\n        toNode: null,\n    };\n    updateConnection(newConnection);\n    let previousConnection = newConnection;\n    onConnectStart?.(event, { nodeId, handleId, handleType });\n    function onPointerMove(event) {\n        if (!getFromHandle() || !fromHandle) {\n            onPointerUp(event);\n            return;\n        }\n        const transform = getTransform();\n        position = getEventPosition(event, containerBounds);\n        closestHandle = getClosestHandle(pointToRendererPoint(position, transform, false, [1, 1]), connectionRadius, nodeLookup, fromHandle);\n        if (!autoPanStarted) {\n            autoPan();\n            autoPanStarted = true;\n        }\n        const result = isValidHandle(event, {\n            handle: closestHandle,\n            connectionMode,\n            fromNodeId: nodeId,\n            fromHandleId: handleId,\n            fromType: isTarget ? 'target' : 'source',\n            isValidConnection,\n            doc,\n            lib,\n            flowId,\n            nodeLookup,\n        });\n        handleDomNode = result.handleDomNode;\n        connection = result.connection;\n        isValid = isConnectionValid(!!closestHandle, result.isValid);\n        const newConnection = {\n            // from stays the same\n            ...previousConnection,\n            isValid,\n            to: closestHandle && isValid\n                ? rendererPointToPoint({ x: closestHandle.x, y: closestHandle.y }, transform)\n                : position,\n            toHandle: result.toHandle,\n            toPosition: isValid && result.toHandle ? result.toHandle.position : oppositePosition[fromHandle.position],\n            toNode: result.toHandle ? nodeLookup.get(result.toHandle.nodeId) : null,\n        };\n        /*\n         * we don't want to trigger an update when the connection\n         * is snapped to the same handle as before\n         */\n        if (isValid &&\n            closestHandle &&\n            previousConnection.toHandle &&\n            newConnection.toHandle &&\n            previousConnection.toHandle.type === newConnection.toHandle.type &&\n            previousConnection.toHandle.nodeId === newConnection.toHandle.nodeId &&\n            previousConnection.toHandle.id === newConnection.toHandle.id &&\n            previousConnection.to.x === newConnection.to.x &&\n            previousConnection.to.y === newConnection.to.y) {\n            return;\n        }\n        updateConnection(newConnection);\n        previousConnection = newConnection;\n    }\n    function onPointerUp(event) {\n        if ((closestHandle || handleDomNode) && connection && isValid) {\n            onConnect?.(connection);\n        }\n        /*\n         * it's important to get a fresh reference from the store here\n         * in order to get the latest state of onConnectEnd\n         */\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        const { inProgress, ...connectionState } = previousConnection;\n        const finalConnectionState = {\n            ...connectionState,\n            toPosition: previousConnection.toHandle ? previousConnection.toPosition : null,\n        };\n        onConnectEnd?.(event, finalConnectionState);\n        if (edgeUpdaterType) {\n            onReconnectEnd?.(event, finalConnectionState);\n        }\n        cancelConnection();\n        cancelAnimationFrame(autoPanId);\n        autoPanStarted = false;\n        isValid = false;\n        connection = null;\n        handleDomNode = null;\n        doc.removeEventListener('mousemove', onPointerMove);\n        doc.removeEventListener('mouseup', onPointerUp);\n        doc.removeEventListener('touchmove', onPointerMove);\n        doc.removeEventListener('touchend', onPointerUp);\n    }\n    doc.addEventListener('mousemove', onPointerMove);\n    doc.addEventListener('mouseup', onPointerUp);\n    doc.addEventListener('touchmove', onPointerMove);\n    doc.addEventListener('touchend', onPointerUp);\n}\n// checks if  and returns connection in fom of an object { source: 123, target: 312 }\nfunction isValidHandle(event, { handle, connectionMode, fromNodeId, fromHandleId, fromType, doc, lib, flowId, isValidConnection = alwaysValid, nodeLookup, }) {\n    const isTarget = fromType === 'target';\n    const handleDomNode = handle\n        ? doc.querySelector(`.${lib}-flow__handle[data-id=\"${flowId}-${handle?.nodeId}-${handle?.id}-${handle?.type}\"]`)\n        : null;\n    const { x, y } = getEventPosition(event);\n    const handleBelow = doc.elementFromPoint(x, y);\n    /*\n     * we always want to prioritize the handle below the mouse cursor over the closest distance handle,\n     * because it could be that the center of another handle is closer to the mouse pointer than the handle below the cursor\n     */\n    const handleToCheck = handleBelow?.classList.contains(`${lib}-flow__handle`) ? handleBelow : handleDomNode;\n    const result = {\n        handleDomNode: handleToCheck,\n        isValid: false,\n        connection: null,\n        toHandle: null,\n    };\n    if (handleToCheck) {\n        const handleType = getHandleType(undefined, handleToCheck);\n        const handleNodeId = handleToCheck.getAttribute('data-nodeid');\n        const handleId = handleToCheck.getAttribute('data-handleid');\n        const connectable = handleToCheck.classList.contains('connectable');\n        const connectableEnd = handleToCheck.classList.contains('connectableend');\n        if (!handleNodeId || !handleType) {\n            return result;\n        }\n        const connection = {\n            source: isTarget ? handleNodeId : fromNodeId,\n            sourceHandle: isTarget ? handleId : fromHandleId,\n            target: isTarget ? fromNodeId : handleNodeId,\n            targetHandle: isTarget ? fromHandleId : handleId,\n        };\n        result.connection = connection;\n        const isConnectable = connectable && connectableEnd;\n        // in strict mode we don't allow target to target or source to source connections\n        const isValid = isConnectable &&\n            (connectionMode === ConnectionMode.Strict\n                ? (isTarget && handleType === 'source') || (!isTarget && handleType === 'target')\n                : handleNodeId !== fromNodeId || handleId !== fromHandleId);\n        result.isValid = isValid && isValidConnection(connection);\n        result.toHandle = getHandle(handleNodeId, handleType, handleId, nodeLookup, connectionMode, false);\n    }\n    return result;\n}\nconst XYHandle = {\n    onPointerDown,\n    isValid: isValidHandle,\n};\n\nfunction XYMinimap({ domNode, panZoom, getTransform, getViewScale }) {\n    const selection = (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(domNode);\n    function update({ translateExtent, width, height, zoomStep = 10, pannable = true, zoomable = true, inversePan = false, }) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const zoomHandler = (event) => {\n            const transform = getTransform();\n            if (event.sourceEvent.type !== 'wheel' || !panZoom) {\n                return;\n            }\n            const pinchDelta = -event.sourceEvent.deltaY *\n                (event.sourceEvent.deltaMode === 1 ? 0.05 : event.sourceEvent.deltaMode ? 1 : 0.002) *\n                zoomStep;\n            const nextZoom = transform[2] * Math.pow(2, pinchDelta);\n            panZoom.scaleTo(nextZoom);\n        };\n        let panStart = [0, 0];\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const panStartHandler = (event) => {\n            if (event.sourceEvent.type === 'mousedown' || event.sourceEvent.type === 'touchstart') {\n                panStart = [\n                    event.sourceEvent.clientX ?? event.sourceEvent.touches[0].clientX,\n                    event.sourceEvent.clientY ?? event.sourceEvent.touches[0].clientY,\n                ];\n            }\n        };\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const panHandler = (event) => {\n            const transform = getTransform();\n            if ((event.sourceEvent.type !== 'mousemove' && event.sourceEvent.type !== 'touchmove') || !panZoom) {\n                return;\n            }\n            const panCurrent = [\n                event.sourceEvent.clientX ?? event.sourceEvent.touches[0].clientX,\n                event.sourceEvent.clientY ?? event.sourceEvent.touches[0].clientY,\n            ];\n            const panDelta = [panCurrent[0] - panStart[0], panCurrent[1] - panStart[1]];\n            panStart = panCurrent;\n            const moveScale = getViewScale() * Math.max(transform[2], Math.log(transform[2])) * (inversePan ? -1 : 1);\n            const position = {\n                x: transform[0] - panDelta[0] * moveScale,\n                y: transform[1] - panDelta[1] * moveScale,\n            };\n            const extent = [\n                [0, 0],\n                [width, height],\n            ];\n            panZoom.setViewportConstrained({\n                x: position.x,\n                y: position.y,\n                zoom: transform[2],\n            }, extent, translateExtent);\n        };\n        const zoomAndPanHandler = (0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoom)()\n            .on('start', panStartHandler)\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore\n            .on('zoom', pannable ? panHandler : null)\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            // @ts-ignore\n            .on('zoom.wheel', zoomable ? zoomHandler : null);\n        selection.call(zoomAndPanHandler, {});\n    }\n    function destroy() {\n        selection.on('zoom', null);\n    }\n    return {\n        update,\n        destroy,\n        pointer: d3_selection__WEBPACK_IMPORTED_MODULE_3__[\"default\"],\n    };\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\nconst viewChanged = (prevViewport, eventViewport) => prevViewport.x !== eventViewport.x || prevViewport.y !== eventViewport.y || prevViewport.zoom !== eventViewport.k;\nconst transformToViewport = (transform) => ({\n    x: transform.x,\n    y: transform.y,\n    zoom: transform.k,\n});\nconst viewportToTransform = ({ x, y, zoom }) => d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoomIdentity.translate(x, y).scale(zoom);\nconst isWrappedWithClass = (event, className) => event.target.closest(`.${className}`);\nconst isRightClickPan = (panOnDrag, usedButton) => usedButton === 2 && Array.isArray(panOnDrag) && panOnDrag.includes(2);\nconst getD3Transition = (selection, duration = 0, onEnd = () => { }) => {\n    const hasDuration = typeof duration === 'number' && duration > 0;\n    if (!hasDuration) {\n        onEnd();\n    }\n    return hasDuration ? selection.transition().duration(duration).on('end', onEnd) : selection;\n};\nconst wheelDelta = (event) => {\n    const factor = event.ctrlKey && isMacOs() ? 10 : 1;\n    return -event.deltaY * (event.deltaMode === 1 ? 0.05 : event.deltaMode ? 1 : 0.002) * factor;\n};\n\nfunction createPanOnScrollHandler({ zoomPanValues, noWheelClassName, d3Selection, d3Zoom, panOnScrollMode, panOnScrollSpeed, zoomOnPinch, onPanZoomStart, onPanZoom, onPanZoomEnd, }) {\n    return (event) => {\n        if (isWrappedWithClass(event, noWheelClassName)) {\n            return false;\n        }\n        event.preventDefault();\n        event.stopImmediatePropagation();\n        const currentZoom = d3Selection.property('__zoom').k || 1;\n        // macos sets ctrlKey=true for pinch gesture on a trackpad\n        if (event.ctrlKey && zoomOnPinch) {\n            const point = (0,d3_selection__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(event);\n            const pinchDelta = wheelDelta(event);\n            const zoom = currentZoom * Math.pow(2, pinchDelta);\n            // @ts-ignore\n            d3Zoom.scaleTo(d3Selection, zoom, point, event);\n            return;\n        }\n        /*\n         * increase scroll speed in firefox\n         * firefox: deltaMode === 1; chrome: deltaMode === 0\n         */\n        const deltaNormalize = event.deltaMode === 1 ? 20 : 1;\n        let deltaX = panOnScrollMode === PanOnScrollMode.Vertical ? 0 : event.deltaX * deltaNormalize;\n        let deltaY = panOnScrollMode === PanOnScrollMode.Horizontal ? 0 : event.deltaY * deltaNormalize;\n        // this enables vertical scrolling with shift + scroll on windows\n        if (!isMacOs() && event.shiftKey && panOnScrollMode !== PanOnScrollMode.Vertical) {\n            deltaX = event.deltaY * deltaNormalize;\n            deltaY = 0;\n        }\n        d3Zoom.translateBy(d3Selection, -(deltaX / currentZoom) * panOnScrollSpeed, -(deltaY / currentZoom) * panOnScrollSpeed, \n        // @ts-ignore\n        { internal: true });\n        const nextViewport = transformToViewport(d3Selection.property('__zoom'));\n        clearTimeout(zoomPanValues.panScrollTimeout);\n        /*\n         * for pan on scroll we need to handle the event calls on our own\n         * we can't use the start, zoom and end events from d3-zoom\n         * because start and move gets called on every scroll event and not once at the beginning\n         */\n        if (!zoomPanValues.isPanScrolling) {\n            zoomPanValues.isPanScrolling = true;\n            onPanZoomStart?.(event, nextViewport);\n        }\n        if (zoomPanValues.isPanScrolling) {\n            onPanZoom?.(event, nextViewport);\n            zoomPanValues.panScrollTimeout = setTimeout(() => {\n                onPanZoomEnd?.(event, nextViewport);\n                zoomPanValues.isPanScrolling = false;\n            }, 150);\n        }\n    };\n}\nfunction createZoomOnScrollHandler({ noWheelClassName, preventScrolling, d3ZoomHandler }) {\n    return function (event, d) {\n        // we still want to enable pinch zooming even if preventScrolling is set to false\n        const preventZoom = !preventScrolling && event.type === 'wheel' && !event.ctrlKey;\n        if (preventZoom || isWrappedWithClass(event, noWheelClassName)) {\n            return null;\n        }\n        event.preventDefault();\n        d3ZoomHandler.call(this, event, d);\n    };\n}\nfunction createPanZoomStartHandler({ zoomPanValues, onDraggingChange, onPanZoomStart }) {\n    return (event) => {\n        if (event.sourceEvent?.internal) {\n            return;\n        }\n        const viewport = transformToViewport(event.transform);\n        // we need to remember it here, because it's always 0 in the \"zoom\" event\n        zoomPanValues.mouseButton = event.sourceEvent?.button || 0;\n        zoomPanValues.isZoomingOrPanning = true;\n        zoomPanValues.prevViewport = viewport;\n        if (event.sourceEvent?.type === 'mousedown') {\n            onDraggingChange(true);\n        }\n        if (onPanZoomStart) {\n            onPanZoomStart?.(event.sourceEvent, viewport);\n        }\n    };\n}\nfunction createPanZoomHandler({ zoomPanValues, panOnDrag, onPaneContextMenu, onTransformChange, onPanZoom, }) {\n    return (event) => {\n        zoomPanValues.usedRightMouseButton = !!(onPaneContextMenu && isRightClickPan(panOnDrag, zoomPanValues.mouseButton ?? 0));\n        if (!event.sourceEvent?.sync) {\n            onTransformChange([event.transform.x, event.transform.y, event.transform.k]);\n        }\n        if (onPanZoom && !event.sourceEvent?.internal) {\n            onPanZoom?.(event.sourceEvent, transformToViewport(event.transform));\n        }\n    };\n}\nfunction createPanZoomEndHandler({ zoomPanValues, panOnDrag, panOnScroll, onDraggingChange, onPanZoomEnd, onPaneContextMenu, }) {\n    return (event) => {\n        if (event.sourceEvent?.internal) {\n            return;\n        }\n        zoomPanValues.isZoomingOrPanning = false;\n        if (onPaneContextMenu &&\n            isRightClickPan(panOnDrag, zoomPanValues.mouseButton ?? 0) &&\n            !zoomPanValues.usedRightMouseButton &&\n            event.sourceEvent) {\n            onPaneContextMenu(event.sourceEvent);\n        }\n        zoomPanValues.usedRightMouseButton = false;\n        onDraggingChange(false);\n        if (onPanZoomEnd && viewChanged(zoomPanValues.prevViewport, event.transform)) {\n            const viewport = transformToViewport(event.transform);\n            zoomPanValues.prevViewport = viewport;\n            clearTimeout(zoomPanValues.timerId);\n            zoomPanValues.timerId = setTimeout(() => {\n                onPanZoomEnd?.(event.sourceEvent, viewport);\n            }, \n            // we need a setTimeout for panOnScroll to supress multiple end events fired during scroll\n            panOnScroll ? 150 : 0);\n        }\n    };\n}\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\nfunction createFilter({ zoomActivationKeyPressed, zoomOnScroll, zoomOnPinch, panOnDrag, panOnScroll, zoomOnDoubleClick, userSelectionActive, noWheelClassName, noPanClassName, lib, }) {\n    return (event) => {\n        const zoomScroll = zoomActivationKeyPressed || zoomOnScroll;\n        const pinchZoom = zoomOnPinch && event.ctrlKey;\n        if (event.button === 1 &&\n            event.type === 'mousedown' &&\n            (isWrappedWithClass(event, `${lib}-flow__node`) || isWrappedWithClass(event, `${lib}-flow__edge`))) {\n            return true;\n        }\n        // if all interactions are disabled, we prevent all zoom events\n        if (!panOnDrag && !zoomScroll && !panOnScroll && !zoomOnDoubleClick && !zoomOnPinch) {\n            return false;\n        }\n        // during a selection we prevent all other interactions\n        if (userSelectionActive) {\n            return false;\n        }\n        // if the target element is inside an element with the nowheel class, we prevent zooming\n        if (isWrappedWithClass(event, noWheelClassName) && event.type === 'wheel') {\n            return false;\n        }\n        // if the target element is inside an element with the nopan class, we prevent panning\n        if (isWrappedWithClass(event, noPanClassName) &&\n            (event.type !== 'wheel' || (panOnScroll && event.type === 'wheel' && !zoomActivationKeyPressed))) {\n            return false;\n        }\n        if (!zoomOnPinch && event.ctrlKey && event.type === 'wheel') {\n            return false;\n        }\n        if (!zoomOnPinch && event.type === 'touchstart' && event.touches?.length > 1) {\n            event.preventDefault(); // if you manage to start with 2 touches, we prevent native zoom\n            return false;\n        }\n        // when there is no scroll handling enabled, we prevent all wheel events\n        if (!zoomScroll && !panOnScroll && !pinchZoom && event.type === 'wheel') {\n            return false;\n        }\n        // if the pane is not movable, we prevent dragging it with mousestart or touchstart\n        if (!panOnDrag && (event.type === 'mousedown' || event.type === 'touchstart')) {\n            return false;\n        }\n        // if the pane is only movable using allowed clicks\n        if (Array.isArray(panOnDrag) && !panOnDrag.includes(event.button) && event.type === 'mousedown') {\n            return false;\n        }\n        // We only allow right clicks if pan on drag is set to right click\n        const buttonAllowed = (Array.isArray(panOnDrag) && panOnDrag.includes(event.button)) || !event.button || event.button <= 1;\n        // default filter for d3-zoom\n        return (!event.ctrlKey || event.type === 'wheel') && buttonAllowed;\n    };\n}\n\nfunction XYPanZoom({ domNode, minZoom, maxZoom, paneClickDistance, translateExtent, viewport, onPanZoom, onPanZoomStart, onPanZoomEnd, onDraggingChange, }) {\n    const zoomPanValues = {\n        isZoomingOrPanning: false,\n        usedRightMouseButton: false,\n        prevViewport: { x: 0, y: 0, zoom: 0 },\n        mouseButton: 0,\n        timerId: undefined,\n        panScrollTimeout: undefined,\n        isPanScrolling: false,\n    };\n    const bbox = domNode.getBoundingClientRect();\n    const d3ZoomInstance = (0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoom)()\n        .clickDistance(!isNumeric(paneClickDistance) || paneClickDistance < 0 ? 0 : paneClickDistance)\n        .scaleExtent([minZoom, maxZoom])\n        .translateExtent(translateExtent);\n    const d3Selection = (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(domNode).call(d3ZoomInstance);\n    setViewportConstrained({\n        x: viewport.x,\n        y: viewport.y,\n        zoom: clamp(viewport.zoom, minZoom, maxZoom),\n    }, [\n        [0, 0],\n        [bbox.width, bbox.height],\n    ], translateExtent);\n    const d3ZoomHandler = d3Selection.on('wheel.zoom');\n    const d3DblClickZoomHandler = d3Selection.on('dblclick.zoom');\n    d3ZoomInstance.wheelDelta(wheelDelta);\n    function setTransform(transform, options) {\n        if (d3Selection) {\n            return new Promise((resolve) => {\n                d3ZoomInstance?.transform(getD3Transition(d3Selection, options?.duration, () => resolve(true)), transform);\n            });\n        }\n        return Promise.resolve(false);\n    }\n    // public functions\n    function update({ noWheelClassName, noPanClassName, onPaneContextMenu, userSelectionActive, panOnScroll, panOnDrag, panOnScrollMode, panOnScrollSpeed, preventScrolling, zoomOnPinch, zoomOnScroll, zoomOnDoubleClick, zoomActivationKeyPressed, lib, onTransformChange, }) {\n        if (userSelectionActive && !zoomPanValues.isZoomingOrPanning) {\n            destroy();\n        }\n        const isPanOnScroll = panOnScroll && !zoomActivationKeyPressed && !userSelectionActive;\n        const wheelHandler = isPanOnScroll\n            ? createPanOnScrollHandler({\n                zoomPanValues,\n                noWheelClassName,\n                d3Selection,\n                d3Zoom: d3ZoomInstance,\n                panOnScrollMode,\n                panOnScrollSpeed,\n                zoomOnPinch,\n                onPanZoomStart,\n                onPanZoom,\n                onPanZoomEnd,\n            })\n            : createZoomOnScrollHandler({\n                noWheelClassName,\n                preventScrolling,\n                d3ZoomHandler,\n            });\n        d3Selection.on('wheel.zoom', wheelHandler, { passive: false });\n        if (!userSelectionActive) {\n            // pan zoom start\n            const startHandler = createPanZoomStartHandler({\n                zoomPanValues,\n                onDraggingChange,\n                onPanZoomStart,\n            });\n            d3ZoomInstance.on('start', startHandler);\n            // pan zoom\n            const panZoomHandler = createPanZoomHandler({\n                zoomPanValues,\n                panOnDrag,\n                onPaneContextMenu: !!onPaneContextMenu,\n                onPanZoom,\n                onTransformChange,\n            });\n            d3ZoomInstance.on('zoom', panZoomHandler);\n            // pan zoom end\n            const panZoomEndHandler = createPanZoomEndHandler({\n                zoomPanValues,\n                panOnDrag,\n                panOnScroll,\n                onPaneContextMenu,\n                onPanZoomEnd,\n                onDraggingChange,\n            });\n            d3ZoomInstance.on('end', panZoomEndHandler);\n        }\n        const filter = createFilter({\n            zoomActivationKeyPressed,\n            panOnDrag,\n            zoomOnScroll,\n            panOnScroll,\n            zoomOnDoubleClick,\n            zoomOnPinch,\n            userSelectionActive,\n            noPanClassName,\n            noWheelClassName,\n            lib,\n        });\n        d3ZoomInstance.filter(filter);\n        /*\n         * We cannot add zoomOnDoubleClick to the filter above because\n         * double tapping on touch screens circumvents the filter and\n         * dblclick.zoom is fired on the selection directly\n         */\n        if (zoomOnDoubleClick) {\n            d3Selection.on('dblclick.zoom', d3DblClickZoomHandler);\n        }\n        else {\n            d3Selection.on('dblclick.zoom', null);\n        }\n    }\n    function destroy() {\n        d3ZoomInstance.on('zoom', null);\n    }\n    async function setViewportConstrained(viewport, extent, translateExtent) {\n        const nextTransform = viewportToTransform(viewport);\n        const contrainedTransform = d3ZoomInstance?.constrain()(nextTransform, extent, translateExtent);\n        if (contrainedTransform) {\n            await setTransform(contrainedTransform);\n        }\n        return new Promise((resolve) => resolve(contrainedTransform));\n    }\n    async function setViewport(viewport, options) {\n        const nextTransform = viewportToTransform(viewport);\n        await setTransform(nextTransform, options);\n        return new Promise((resolve) => resolve(nextTransform));\n    }\n    function syncViewport(viewport) {\n        if (d3Selection) {\n            const nextTransform = viewportToTransform(viewport);\n            const currentTransform = d3Selection.property('__zoom');\n            if (currentTransform.k !== viewport.zoom ||\n                currentTransform.x !== viewport.x ||\n                currentTransform.y !== viewport.y) {\n                // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                // @ts-ignore\n                d3ZoomInstance?.transform(d3Selection, nextTransform, null, { sync: true });\n            }\n        }\n    }\n    function getViewport() {\n        const transform = d3Selection ? (0,d3_zoom__WEBPACK_IMPORTED_MODULE_0__.zoomTransform)(d3Selection.node()) : { x: 0, y: 0, k: 1 };\n        return { x: transform.x, y: transform.y, zoom: transform.k };\n    }\n    function scaleTo(zoom, options) {\n        if (d3Selection) {\n            return new Promise((resolve) => {\n                d3ZoomInstance?.scaleTo(getD3Transition(d3Selection, options?.duration, () => resolve(true)), zoom);\n            });\n        }\n        return Promise.resolve(false);\n    }\n    function scaleBy(factor, options) {\n        if (d3Selection) {\n            return new Promise((resolve) => {\n                d3ZoomInstance?.scaleBy(getD3Transition(d3Selection, options?.duration, () => resolve(true)), factor);\n            });\n        }\n        return Promise.resolve(false);\n    }\n    function setScaleExtent(scaleExtent) {\n        d3ZoomInstance?.scaleExtent(scaleExtent);\n    }\n    function setTranslateExtent(translateExtent) {\n        d3ZoomInstance?.translateExtent(translateExtent);\n    }\n    function setClickDistance(distance) {\n        const validDistance = !isNumeric(distance) || distance < 0 ? 0 : distance;\n        d3ZoomInstance?.clickDistance(validDistance);\n    }\n    return {\n        update,\n        destroy,\n        setViewport,\n        setViewportConstrained,\n        getViewport,\n        scaleTo,\n        scaleBy,\n        setScaleExtent,\n        setTranslateExtent,\n        syncViewport,\n        setClickDistance,\n    };\n}\n\n/**\n * Used to determine the variant of the resize control\n *\n * @public\n */\nvar ResizeControlVariant;\n(function (ResizeControlVariant) {\n    ResizeControlVariant[\"Line\"] = \"line\";\n    ResizeControlVariant[\"Handle\"] = \"handle\";\n})(ResizeControlVariant || (ResizeControlVariant = {}));\nconst XY_RESIZER_HANDLE_POSITIONS = ['top-left', 'top-right', 'bottom-left', 'bottom-right'];\nconst XY_RESIZER_LINE_POSITIONS = ['top', 'right', 'bottom', 'left'];\n\n/**\n * Get all connecting edges for a given set of nodes\n * @param width - new width of the node\n * @param prevWidth - previous width of the node\n * @param height - new height of the node\n * @param prevHeight - previous height of the node\n * @param affectsX - whether to invert the resize direction for the x axis\n * @param affectsY - whether to invert the resize direction for the y axis\n * @returns array of two numbers representing the direction of the resize for each axis, 0 = no change, 1 = increase, -1 = decrease\n */\nfunction getResizeDirection({ width, prevWidth, height, prevHeight, affectsX, affectsY, }) {\n    const deltaWidth = width - prevWidth;\n    const deltaHeight = height - prevHeight;\n    const direction = [deltaWidth > 0 ? 1 : deltaWidth < 0 ? -1 : 0, deltaHeight > 0 ? 1 : deltaHeight < 0 ? -1 : 0];\n    if (deltaWidth && affectsX) {\n        direction[0] = direction[0] * -1;\n    }\n    if (deltaHeight && affectsY) {\n        direction[1] = direction[1] * -1;\n    }\n    return direction;\n}\n/**\n * Parses the control position that is being dragged to dimensions that are being resized\n * @param controlPosition - position of the control that is being dragged\n * @returns isHorizontal, isVertical, affectsX, affectsY,\n */\nfunction getControlDirection(controlPosition) {\n    const isHorizontal = controlPosition.includes('right') || controlPosition.includes('left');\n    const isVertical = controlPosition.includes('bottom') || controlPosition.includes('top');\n    const affectsX = controlPosition.includes('left');\n    const affectsY = controlPosition.includes('top');\n    return {\n        isHorizontal,\n        isVertical,\n        affectsX,\n        affectsY,\n    };\n}\nfunction getLowerExtentClamp(lowerExtent, lowerBound) {\n    return Math.max(0, lowerBound - lowerExtent);\n}\nfunction getUpperExtentClamp(upperExtent, upperBound) {\n    return Math.max(0, upperExtent - upperBound);\n}\nfunction getSizeClamp(size, minSize, maxSize) {\n    return Math.max(0, minSize - size, size - maxSize);\n}\nfunction xor(a, b) {\n    return a ? !b : b;\n}\n/**\n * Calculates new width & height and x & y of node after resize based on pointer position\n * @description - Buckle up, this is a chunky one... If you want to determine the new dimensions of a node after a resize,\n * you have to account for all possible restrictions: min/max width/height of the node, the maximum extent the node is allowed\n * to move in (in this case: resize into) determined by the parent node, the minimal extent determined by child nodes\n * with expandParent or extent: 'parent' set and oh yeah, these things also have to work with keepAspectRatio!\n * The way this is done is by determining how much each of these restricting actually restricts the resize and then applying the\n * strongest restriction. Because the resize affects x, y and width, height and width, height of a opposing side with keepAspectRatio,\n * the resize amount is always kept in distX & distY amount (the distance in mouse movement)\n * Instead of clamping each value, we first calculate the biggest 'clamp' (for the lack of a better name) and then apply it to all values.\n * To complicate things nodeOrigin has to be taken into account as well. This is done by offsetting the nodes as if their origin is [0, 0],\n * then calculating the restrictions as usual\n * @param startValues - starting values of resize\n * @param controlDirection - dimensions affected by the resize\n * @param pointerPosition - the current pointer position corrected for snapping\n * @param boundaries - minimum and maximum dimensions of the node\n * @param keepAspectRatio - prevent changes of asprect ratio\n * @returns x, y, width and height of the node after resize\n */\nfunction getDimensionsAfterResize(startValues, controlDirection, pointerPosition, boundaries, keepAspectRatio, nodeOrigin, extent, childExtent) {\n    let { affectsX, affectsY } = controlDirection;\n    const { isHorizontal, isVertical } = controlDirection;\n    const isDiagonal = isHorizontal && isVertical;\n    const { xSnapped, ySnapped } = pointerPosition;\n    const { minWidth, maxWidth, minHeight, maxHeight } = boundaries;\n    const { x: startX, y: startY, width: startWidth, height: startHeight, aspectRatio } = startValues;\n    let distX = Math.floor(isHorizontal ? xSnapped - startValues.pointerX : 0);\n    let distY = Math.floor(isVertical ? ySnapped - startValues.pointerY : 0);\n    const newWidth = startWidth + (affectsX ? -distX : distX);\n    const newHeight = startHeight + (affectsY ? -distY : distY);\n    const originOffsetX = -nodeOrigin[0] * startWidth;\n    const originOffsetY = -nodeOrigin[1] * startHeight;\n    // Check if maxWidth, minWWidth, maxHeight, minHeight are restricting the resize\n    let clampX = getSizeClamp(newWidth, minWidth, maxWidth);\n    let clampY = getSizeClamp(newHeight, minHeight, maxHeight);\n    // Check if extent is restricting the resize\n    if (extent) {\n        let xExtentClamp = 0;\n        let yExtentClamp = 0;\n        if (affectsX && distX < 0) {\n            xExtentClamp = getLowerExtentClamp(startX + distX + originOffsetX, extent[0][0]);\n        }\n        else if (!affectsX && distX > 0) {\n            xExtentClamp = getUpperExtentClamp(startX + newWidth + originOffsetX, extent[1][0]);\n        }\n        if (affectsY && distY < 0) {\n            yExtentClamp = getLowerExtentClamp(startY + distY + originOffsetY, extent[0][1]);\n        }\n        else if (!affectsY && distY > 0) {\n            yExtentClamp = getUpperExtentClamp(startY + newHeight + originOffsetY, extent[1][1]);\n        }\n        clampX = Math.max(clampX, xExtentClamp);\n        clampY = Math.max(clampY, yExtentClamp);\n    }\n    // Check if the child extent is restricting the resize\n    if (childExtent) {\n        let xExtentClamp = 0;\n        let yExtentClamp = 0;\n        if (affectsX && distX > 0) {\n            xExtentClamp = getUpperExtentClamp(startX + distX, childExtent[0][0]);\n        }\n        else if (!affectsX && distX < 0) {\n            xExtentClamp = getLowerExtentClamp(startX + newWidth, childExtent[1][0]);\n        }\n        if (affectsY && distY > 0) {\n            yExtentClamp = getUpperExtentClamp(startY + distY, childExtent[0][1]);\n        }\n        else if (!affectsY && distY < 0) {\n            yExtentClamp = getLowerExtentClamp(startY + newHeight, childExtent[1][1]);\n        }\n        clampX = Math.max(clampX, xExtentClamp);\n        clampY = Math.max(clampY, yExtentClamp);\n    }\n    // Check if the aspect ratio resizing of the other side is restricting the resize\n    if (keepAspectRatio) {\n        if (isHorizontal) {\n            // Check if the max dimensions might be restricting the resize\n            const aspectHeightClamp = getSizeClamp(newWidth / aspectRatio, minHeight, maxHeight) * aspectRatio;\n            clampX = Math.max(clampX, aspectHeightClamp);\n            // Check if the extent is restricting the resize\n            if (extent) {\n                let aspectExtentClamp = 0;\n                if ((!affectsX && !affectsY) || (affectsX && !affectsY && isDiagonal)) {\n                    aspectExtentClamp =\n                        getUpperExtentClamp(startY + originOffsetY + newWidth / aspectRatio, extent[1][1]) * aspectRatio;\n                }\n                else {\n                    aspectExtentClamp =\n                        getLowerExtentClamp(startY + originOffsetY + (affectsX ? distX : -distX) / aspectRatio, extent[0][1]) *\n                            aspectRatio;\n                }\n                clampX = Math.max(clampX, aspectExtentClamp);\n            }\n            // Check if the child extent is restricting the resize\n            if (childExtent) {\n                let aspectExtentClamp = 0;\n                if ((!affectsX && !affectsY) || (affectsX && !affectsY && isDiagonal)) {\n                    aspectExtentClamp = getLowerExtentClamp(startY + newWidth / aspectRatio, childExtent[1][1]) * aspectRatio;\n                }\n                else {\n                    aspectExtentClamp =\n                        getUpperExtentClamp(startY + (affectsX ? distX : -distX) / aspectRatio, childExtent[0][1]) * aspectRatio;\n                }\n                clampX = Math.max(clampX, aspectExtentClamp);\n            }\n        }\n        // Do the same thing for vertical resizing\n        if (isVertical) {\n            const aspectWidthClamp = getSizeClamp(newHeight * aspectRatio, minWidth, maxWidth) / aspectRatio;\n            clampY = Math.max(clampY, aspectWidthClamp);\n            if (extent) {\n                let aspectExtentClamp = 0;\n                if ((!affectsX && !affectsY) || (affectsY && !affectsX && isDiagonal)) {\n                    aspectExtentClamp =\n                        getUpperExtentClamp(startX + newHeight * aspectRatio + originOffsetX, extent[1][0]) / aspectRatio;\n                }\n                else {\n                    aspectExtentClamp =\n                        getLowerExtentClamp(startX + (affectsY ? distY : -distY) * aspectRatio + originOffsetX, extent[0][0]) /\n                            aspectRatio;\n                }\n                clampY = Math.max(clampY, aspectExtentClamp);\n            }\n            if (childExtent) {\n                let aspectExtentClamp = 0;\n                if ((!affectsX && !affectsY) || (affectsY && !affectsX && isDiagonal)) {\n                    aspectExtentClamp = getLowerExtentClamp(startX + newHeight * aspectRatio, childExtent[1][0]) / aspectRatio;\n                }\n                else {\n                    aspectExtentClamp =\n                        getUpperExtentClamp(startX + (affectsY ? distY : -distY) * aspectRatio, childExtent[0][0]) / aspectRatio;\n                }\n                clampY = Math.max(clampY, aspectExtentClamp);\n            }\n        }\n    }\n    distY = distY + (distY < 0 ? clampY : -clampY);\n    distX = distX + (distX < 0 ? clampX : -clampX);\n    if (keepAspectRatio) {\n        if (isDiagonal) {\n            if (newWidth > newHeight * aspectRatio) {\n                distY = (xor(affectsX, affectsY) ? -distX : distX) / aspectRatio;\n            }\n            else {\n                distX = (xor(affectsX, affectsY) ? -distY : distY) * aspectRatio;\n            }\n        }\n        else {\n            if (isHorizontal) {\n                distY = distX / aspectRatio;\n                affectsY = affectsX;\n            }\n            else {\n                distX = distY * aspectRatio;\n                affectsX = affectsY;\n            }\n        }\n    }\n    const x = affectsX ? startX + distX : startX;\n    const y = affectsY ? startY + distY : startY;\n    return {\n        width: startWidth + (affectsX ? -distX : distX),\n        height: startHeight + (affectsY ? -distY : distY),\n        x: nodeOrigin[0] * distX * (!affectsX ? 1 : -1) + x,\n        y: nodeOrigin[1] * distY * (!affectsY ? 1 : -1) + y,\n    };\n}\n\nconst initPrevValues = { width: 0, height: 0, x: 0, y: 0 };\nconst initStartValues = {\n    ...initPrevValues,\n    pointerX: 0,\n    pointerY: 0,\n    aspectRatio: 1,\n};\nfunction nodeToParentExtent(node) {\n    return [\n        [0, 0],\n        [node.measured.width, node.measured.height],\n    ];\n}\nfunction nodeToChildExtent(child, parent, nodeOrigin) {\n    const x = parent.position.x + child.position.x;\n    const y = parent.position.y + child.position.y;\n    const width = child.measured.width ?? 0;\n    const height = child.measured.height ?? 0;\n    const originOffsetX = nodeOrigin[0] * width;\n    const originOffsetY = nodeOrigin[1] * height;\n    return [\n        [x - originOffsetX, y - originOffsetY],\n        [x + width - originOffsetX, y + height - originOffsetY],\n    ];\n}\nfunction XYResizer({ domNode, nodeId, getStoreItems, onChange, onEnd }) {\n    const selection = (0,d3_selection__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(domNode);\n    function update({ controlPosition, boundaries, keepAspectRatio, onResizeStart, onResize, onResizeEnd, shouldResize, }) {\n        let prevValues = { ...initPrevValues };\n        let startValues = { ...initStartValues };\n        const controlDirection = getControlDirection(controlPosition);\n        let node = undefined;\n        let containerBounds = null;\n        let childNodes = [];\n        let parentNode = undefined; // Needed to fix expandParent\n        let parentExtent = undefined;\n        let childExtent = undefined;\n        const dragHandler = (0,d3_drag__WEBPACK_IMPORTED_MODULE_2__[\"default\"])()\n            .on('start', (event) => {\n            const { nodeLookup, transform, snapGrid, snapToGrid, nodeOrigin, paneDomNode } = getStoreItems();\n            node = nodeLookup.get(nodeId);\n            if (!node) {\n                return;\n            }\n            containerBounds = paneDomNode?.getBoundingClientRect() ?? null;\n            const { xSnapped, ySnapped } = getPointerPosition(event.sourceEvent, {\n                transform,\n                snapGrid,\n                snapToGrid,\n                containerBounds,\n            });\n            prevValues = {\n                width: node.measured.width ?? 0,\n                height: node.measured.height ?? 0,\n                x: node.position.x ?? 0,\n                y: node.position.y ?? 0,\n            };\n            startValues = {\n                ...prevValues,\n                pointerX: xSnapped,\n                pointerY: ySnapped,\n                aspectRatio: prevValues.width / prevValues.height,\n            };\n            parentNode = undefined;\n            if (node.parentId && (node.extent === 'parent' || node.expandParent)) {\n                parentNode = nodeLookup.get(node.parentId);\n                parentExtent = parentNode && node.extent === 'parent' ? nodeToParentExtent(parentNode) : undefined;\n            }\n            /*\n             * Collect all child nodes to correct their relative positions when top/left changes\n             * Determine largest minimal extent the parent node is allowed to resize to\n             */\n            childNodes = [];\n            childExtent = undefined;\n            for (const [childId, child] of nodeLookup) {\n                if (child.parentId === nodeId) {\n                    childNodes.push({\n                        id: childId,\n                        position: { ...child.position },\n                        extent: child.extent,\n                    });\n                    if (child.extent === 'parent' || child.expandParent) {\n                        const extent = nodeToChildExtent(child, node, child.origin ?? nodeOrigin);\n                        if (childExtent) {\n                            childExtent = [\n                                [Math.min(extent[0][0], childExtent[0][0]), Math.min(extent[0][1], childExtent[0][1])],\n                                [Math.max(extent[1][0], childExtent[1][0]), Math.max(extent[1][1], childExtent[1][1])],\n                            ];\n                        }\n                        else {\n                            childExtent = extent;\n                        }\n                    }\n                }\n            }\n            onResizeStart?.(event, { ...prevValues });\n        })\n            .on('drag', (event) => {\n            const { transform, snapGrid, snapToGrid, nodeOrigin: storeNodeOrigin } = getStoreItems();\n            const pointerPosition = getPointerPosition(event.sourceEvent, {\n                transform,\n                snapGrid,\n                snapToGrid,\n                containerBounds,\n            });\n            const childChanges = [];\n            if (!node) {\n                return;\n            }\n            const { x: prevX, y: prevY, width: prevWidth, height: prevHeight } = prevValues;\n            const change = {};\n            const nodeOrigin = node.origin ?? storeNodeOrigin;\n            const { width, height, x, y } = getDimensionsAfterResize(startValues, controlDirection, pointerPosition, boundaries, keepAspectRatio, nodeOrigin, parentExtent, childExtent);\n            const isWidthChange = width !== prevWidth;\n            const isHeightChange = height !== prevHeight;\n            const isXPosChange = x !== prevX && isWidthChange;\n            const isYPosChange = y !== prevY && isHeightChange;\n            if (!isXPosChange && !isYPosChange && !isWidthChange && !isHeightChange) {\n                return;\n            }\n            if (isXPosChange || isYPosChange || nodeOrigin[0] === 1 || nodeOrigin[1] === 1) {\n                change.x = isXPosChange ? x : prevValues.x;\n                change.y = isYPosChange ? y : prevValues.y;\n                prevValues.x = change.x;\n                prevValues.y = change.y;\n                /*\n                 * when top/left changes, correct the relative positions of child nodes\n                 * so that they stay in the same position\n                 */\n                if (childNodes.length > 0) {\n                    const xChange = x - prevX;\n                    const yChange = y - prevY;\n                    for (const childNode of childNodes) {\n                        childNode.position = {\n                            x: childNode.position.x - xChange + nodeOrigin[0] * (width - prevWidth),\n                            y: childNode.position.y - yChange + nodeOrigin[1] * (height - prevHeight),\n                        };\n                        childChanges.push(childNode);\n                    }\n                }\n            }\n            if (isWidthChange || isHeightChange) {\n                change.width = isWidthChange ? width : prevValues.width;\n                change.height = isHeightChange ? height : prevValues.height;\n                prevValues.width = change.width;\n                prevValues.height = change.height;\n            }\n            // Fix expandParent when resizing from top/left\n            if (parentNode && node.expandParent) {\n                const xLimit = nodeOrigin[0] * (change.width ?? 0);\n                if (change.x && change.x < xLimit) {\n                    prevValues.x = xLimit;\n                    startValues.x = startValues.x - (change.x - xLimit);\n                }\n                const yLimit = nodeOrigin[1] * (change.height ?? 0);\n                if (change.y && change.y < yLimit) {\n                    prevValues.y = yLimit;\n                    startValues.y = startValues.y - (change.y - yLimit);\n                }\n            }\n            const direction = getResizeDirection({\n                width: prevValues.width,\n                prevWidth,\n                height: prevValues.height,\n                prevHeight,\n                affectsX: controlDirection.affectsX,\n                affectsY: controlDirection.affectsY,\n            });\n            const nextValues = { ...prevValues, direction };\n            const callResize = shouldResize?.(event, nextValues);\n            if (callResize === false) {\n                return;\n            }\n            onResize?.(event, nextValues);\n            onChange(change, childChanges);\n        })\n            .on('end', (event) => {\n            onResizeEnd?.(event, { ...prevValues });\n            onEnd?.();\n        });\n        selection.call(dragHandler);\n    }\n    function destroy() {\n        selection.on('.drag', null);\n    }\n    return {\n        update,\n        destroy,\n    };\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHh5Zmxvdy9zeXN0ZW0vZGlzdC9lc20vaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBK0I7QUFDZ0I7QUFDYTs7QUFFNUQ7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFNBQVM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsOENBQThDLElBQUk7QUFDbEQsd0NBQXdDLEtBQUs7QUFDN0MsNkJBQTZCLGdDQUFnQyxpQ0FBaUMsWUFBWSxjQUFjLHNEQUFzRCxjQUFjLEdBQUc7QUFDL0w7QUFDQSwwQ0FBMEMsU0FBUztBQUNuRCx1Q0FBdUMsR0FBRztBQUMxQyx3R0FBd0csSUFBSTtBQUM1RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdDQUF3QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMENBQTBDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzQ0FBc0M7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdEQUFnRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0NBQWdDOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUscUJBQXFCO0FBQy9CLFlBQVksMkJBQTJCO0FBQ3ZDO0FBQ0EsWUFBWSxxQkFBcUI7QUFDakMsWUFBWSwyQ0FBMkM7QUFDdkQsWUFBWSw0RUFBNEU7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsaURBQWlEO0FBQ3RFLHNCQUFzQix3REFBTTtBQUM1QixzQkFBc0IsbUdBQW1HO0FBQ3pILDJCQUEyQjtBQUMzQiw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBLDRCQUE0QixtREFBSTtBQUNoQztBQUNBLG9CQUFvQix1RUFBdUU7QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixxQkFBcUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLG1CQUFtQjtBQUN2RDtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGVBQWU7QUFDcEQsU0FBUztBQUNUO0FBQ0Esb0JBQW9CLCtEQUErRDtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLDJEQUEyRDtBQUMvRTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLG1DQUFtQyxlQUFlO0FBQ2xEO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUUyOUMiLCJzb3VyY2VzIjpbIkM6XFxVc2Vyc1xcc3VyeWFcXERvd25sb2Fkc1xcRmlsZXNcXFZTY29kZVxcc3VwZXJ2YWlzb3JfdGFza1xcbm9kZV9tb2R1bGVzXFxAeHlmbG93XFxzeXN0ZW1cXGRpc3RcXGVzbVxcaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZHJhZyB9IGZyb20gJ2QzLWRyYWcnO1xuaW1wb3J0IHsgc2VsZWN0LCBwb2ludGVyIH0gZnJvbSAnZDMtc2VsZWN0aW9uJztcbmltcG9ydCB7IHpvb20sIHpvb21JZGVudGl0eSwgem9vbVRyYW5zZm9ybSB9IGZyb20gJ2QzLXpvb20nO1xuXG5jb25zdCBlcnJvck1lc3NhZ2VzID0ge1xuICAgIGVycm9yMDAxOiAoKSA9PiAnW1JlYWN0IEZsb3ddOiBTZWVtcyBsaWtlIHlvdSBoYXZlIG5vdCB1c2VkIHp1c3RhbmQgcHJvdmlkZXIgYXMgYW4gYW5jZXN0b3IuIEhlbHA6IGh0dHBzOi8vcmVhY3RmbG93LmRldi9lcnJvciMwMDEnLFxuICAgIGVycm9yMDAyOiAoKSA9PiBcIkl0IGxvb2tzIGxpa2UgeW91J3ZlIGNyZWF0ZWQgYSBuZXcgbm9kZVR5cGVzIG9yIGVkZ2VUeXBlcyBvYmplY3QuIElmIHRoaXMgd2Fzbid0IG9uIHB1cnBvc2UgcGxlYXNlIGRlZmluZSB0aGUgbm9kZVR5cGVzL2VkZ2VUeXBlcyBvdXRzaWRlIG9mIHRoZSBjb21wb25lbnQgb3IgbWVtb2l6ZSB0aGVtLlwiLFxuICAgIGVycm9yMDAzOiAobm9kZVR5cGUpID0+IGBOb2RlIHR5cGUgXCIke25vZGVUeXBlfVwiIG5vdCBmb3VuZC4gVXNpbmcgZmFsbGJhY2sgdHlwZSBcImRlZmF1bHRcIi5gLFxuICAgIGVycm9yMDA0OiAoKSA9PiAnVGhlIFJlYWN0IEZsb3cgcGFyZW50IGNvbnRhaW5lciBuZWVkcyBhIHdpZHRoIGFuZCBhIGhlaWdodCB0byByZW5kZXIgdGhlIGdyYXBoLicsXG4gICAgZXJyb3IwMDU6ICgpID0+ICdPbmx5IGNoaWxkIG5vZGVzIGNhbiB1c2UgYSBwYXJlbnQgZXh0ZW50LicsXG4gICAgZXJyb3IwMDY6ICgpID0+IFwiQ2FuJ3QgY3JlYXRlIGVkZ2UuIEFuIGVkZ2UgbmVlZHMgYSBzb3VyY2UgYW5kIGEgdGFyZ2V0LlwiLFxuICAgIGVycm9yMDA3OiAoaWQpID0+IGBUaGUgb2xkIGVkZ2Ugd2l0aCBpZD0ke2lkfSBkb2VzIG5vdCBleGlzdC5gLFxuICAgIGVycm9yMDA5OiAodHlwZSkgPT4gYE1hcmtlciB0eXBlIFwiJHt0eXBlfVwiIGRvZXNuJ3QgZXhpc3QuYCxcbiAgICBlcnJvcjAwODogKGhhbmRsZVR5cGUsIHsgaWQsIHNvdXJjZUhhbmRsZSwgdGFyZ2V0SGFuZGxlIH0pID0+IGBDb3VsZG4ndCBjcmVhdGUgZWRnZSBmb3IgJHtoYW5kbGVUeXBlfSBoYW5kbGUgaWQ6IFwiJHtoYW5kbGVUeXBlID09PSAnc291cmNlJyA/IHNvdXJjZUhhbmRsZSA6IHRhcmdldEhhbmRsZX1cIiwgZWRnZSBpZDogJHtpZH0uYCxcbiAgICBlcnJvcjAxMDogKCkgPT4gJ0hhbmRsZTogTm8gbm9kZSBpZCBmb3VuZC4gTWFrZSBzdXJlIHRvIG9ubHkgdXNlIGEgSGFuZGxlIGluc2lkZSBhIGN1c3RvbSBOb2RlLicsXG4gICAgZXJyb3IwMTE6IChlZGdlVHlwZSkgPT4gYEVkZ2UgdHlwZSBcIiR7ZWRnZVR5cGV9XCIgbm90IGZvdW5kLiBVc2luZyBmYWxsYmFjayB0eXBlIFwiZGVmYXVsdFwiLmAsXG4gICAgZXJyb3IwMTI6IChpZCkgPT4gYE5vZGUgd2l0aCBpZCBcIiR7aWR9XCIgZG9lcyBub3QgZXhpc3QsIGl0IG1heSBoYXZlIGJlZW4gcmVtb3ZlZC4gVGhpcyBjYW4gaGFwcGVuIHdoZW4gYSBub2RlIGlzIGRlbGV0ZWQgYmVmb3JlIHRoZSBcIm9uTm9kZUNsaWNrXCIgaGFuZGxlciBpcyBjYWxsZWQuYCxcbiAgICBlcnJvcjAxMzogKGxpYiA9ICdyZWFjdCcpID0+IGBJdCBzZWVtcyB0aGF0IHlvdSBoYXZlbid0IGxvYWRlZCB0aGUgc3R5bGVzLiBQbGVhc2UgaW1wb3J0ICdAeHlmbG93LyR7bGlifS9kaXN0L3N0eWxlLmNzcycgb3IgYmFzZS5jc3MgdG8gbWFrZSBzdXJlIGV2ZXJ5dGhpbmcgaXMgd29ya2luZyBwcm9wZXJseS5gLFxuICAgIGVycm9yMDE0OiAoKSA9PiAndXNlTm9kZUNvbm5lY3Rpb25zOiBObyBub2RlIElEIGZvdW5kLiBDYWxsIHVzZU5vZGVDb25uZWN0aW9ucyBpbnNpZGUgYSBjdXN0b20gTm9kZSBvciBwcm92aWRlIGEgbm9kZSBJRC4nLFxuICAgIGVycm9yMDE1OiAoKSA9PiAnSXQgc2VlbXMgdGhhdCB5b3UgYXJlIHRyeWluZyB0byBkcmFnIGEgbm9kZSB0aGF0IGlzIG5vdCBpbml0aWFsaXplZC4gUGxlYXNlIHVzZSBvbk5vZGVzQ2hhbmdlIGFzIGV4cGxhaW5lZCBpbiB0aGUgZG9jcy4nLFxufTtcbmNvbnN0IGluZmluaXRlRXh0ZW50ID0gW1xuICAgIFtOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFksIE51bWJlci5ORUdBVElWRV9JTkZJTklUWV0sXG4gICAgW051bWJlci5QT1NJVElWRV9JTkZJTklUWSwgTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZXSxcbl07XG5jb25zdCBlbGVtZW50U2VsZWN0aW9uS2V5cyA9IFsnRW50ZXInLCAnICcsICdFc2NhcGUnXTtcblxuLyoqXG4gKiBUaGUgYENvbm5lY3Rpb25Nb2RlYCBpcyB1c2VkIHRvIHNldCB0aGUgbW9kZSBvZiBjb25uZWN0aW9uIGJldHdlZW4gbm9kZXMuXG4gKiBUaGUgYFN0cmljdGAgbW9kZSBpcyB0aGUgZGVmYXVsdCBvbmUgYW5kIG9ubHkgYWxsb3dzIHNvdXJjZSB0byB0YXJnZXQgZWRnZXMuXG4gKiBgTG9vc2VgIG1vZGUgYWxsb3dzIHNvdXJjZSB0byBzb3VyY2UgYW5kIHRhcmdldCB0byB0YXJnZXQgZWRnZXMgYXMgd2VsbC5cbiAqXG4gKiBAcHVibGljXG4gKi9cbnZhciBDb25uZWN0aW9uTW9kZTtcbihmdW5jdGlvbiAoQ29ubmVjdGlvbk1vZGUpIHtcbiAgICBDb25uZWN0aW9uTW9kZVtcIlN0cmljdFwiXSA9IFwic3RyaWN0XCI7XG4gICAgQ29ubmVjdGlvbk1vZGVbXCJMb29zZVwiXSA9IFwibG9vc2VcIjtcbn0pKENvbm5lY3Rpb25Nb2RlIHx8IChDb25uZWN0aW9uTW9kZSA9IHt9KSk7XG4vKipcbiAqIFRoaXMgZW51bSBpcyB1c2VkIHRvIHNldCB0aGUgZGlmZmVyZW50IG1vZGVzIG9mIHBhbm5pbmcgdGhlIHZpZXdwb3J0IHdoZW4gdGhlXG4gKiB1c2VyIHNjcm9sbHMuIFRoZSBgRnJlZWAgbW9kZSBhbGxvd3MgdGhlIHVzZXIgdG8gcGFuIGluIGFueSBkaXJlY3Rpb24gYnkgc2Nyb2xsaW5nXG4gKiB3aXRoIGEgZGV2aWNlIGxpa2UgYSB0cmFja3BhZC4gVGhlIGBWZXJ0aWNhbGAgYW5kIGBIb3Jpem9udGFsYCBtb2RlcyByZXN0cmljdFxuICogc2Nyb2xsIHBhbm5pbmcgdG8gb25seSB0aGUgdmVydGljYWwgb3IgaG9yaXpvbnRhbCBheGlzLCByZXNwZWN0aXZlbHkuXG4gKlxuICogQHB1YmxpY1xuICovXG52YXIgUGFuT25TY3JvbGxNb2RlO1xuKGZ1bmN0aW9uIChQYW5PblNjcm9sbE1vZGUpIHtcbiAgICBQYW5PblNjcm9sbE1vZGVbXCJGcmVlXCJdID0gXCJmcmVlXCI7XG4gICAgUGFuT25TY3JvbGxNb2RlW1wiVmVydGljYWxcIl0gPSBcInZlcnRpY2FsXCI7XG4gICAgUGFuT25TY3JvbGxNb2RlW1wiSG9yaXpvbnRhbFwiXSA9IFwiaG9yaXpvbnRhbFwiO1xufSkoUGFuT25TY3JvbGxNb2RlIHx8IChQYW5PblNjcm9sbE1vZGUgPSB7fSkpO1xudmFyIFNlbGVjdGlvbk1vZGU7XG4oZnVuY3Rpb24gKFNlbGVjdGlvbk1vZGUpIHtcbiAgICBTZWxlY3Rpb25Nb2RlW1wiUGFydGlhbFwiXSA9IFwicGFydGlhbFwiO1xuICAgIFNlbGVjdGlvbk1vZGVbXCJGdWxsXCJdID0gXCJmdWxsXCI7XG59KShTZWxlY3Rpb25Nb2RlIHx8IChTZWxlY3Rpb25Nb2RlID0ge30pKTtcbmNvbnN0IGluaXRpYWxDb25uZWN0aW9uID0ge1xuICAgIGluUHJvZ3Jlc3M6IGZhbHNlLFxuICAgIGlzVmFsaWQ6IG51bGwsXG4gICAgZnJvbTogbnVsbCxcbiAgICBmcm9tSGFuZGxlOiBudWxsLFxuICAgIGZyb21Qb3NpdGlvbjogbnVsbCxcbiAgICBmcm9tTm9kZTogbnVsbCxcbiAgICB0bzogbnVsbCxcbiAgICB0b0hhbmRsZTogbnVsbCxcbiAgICB0b1Bvc2l0aW9uOiBudWxsLFxuICAgIHRvTm9kZTogbnVsbCxcbn07XG5cbi8qKlxuICogSWYgeW91IHNldCB0aGUgYGNvbm5lY3Rpb25MaW5lVHlwZWAgcHJvcCBvbiB5b3VyIFtgPFJlYWN0RmxvdyAvPmBdKC9hcGktcmVmZXJlbmNlL3JlYWN0LWZsb3cjY29ubmVjdGlvbi1jb25uZWN0aW9uTGluZVR5cGUpXG4gKmNvbXBvbmVudCwgaXQgd2lsbCBkaWN0YXRlIHRoZSBzdHlsZSBvZiBjb25uZWN0aW9uIGxpbmUgcmVuZGVyZWQgd2hlbiBjcmVhdGluZ1xuICpuZXcgZWRnZXMuXG4gKlxuICogQHB1YmxpY1xuICpcbiAqIEByZW1hcmtzIElmIHlvdSBjaG9vc2UgdG8gcmVuZGVyIGEgY3VzdG9tIGNvbm5lY3Rpb24gbGluZSBjb21wb25lbnQsIHRoaXMgdmFsdWUgd2lsbCBiZVxuICpwYXNzZWQgdG8geW91ciBjb21wb25lbnQgYXMgcGFydCBvZiBpdHMgW2BDb25uZWN0aW9uTGluZUNvbXBvbmVudFByb3BzYF0oL2FwaS1yZWZlcmVuY2UvdHlwZXMvY29ubmVjdGlvbi1saW5lLWNvbXBvbmVudC1wcm9wcykuXG4gKi9cbnZhciBDb25uZWN0aW9uTGluZVR5cGU7XG4oZnVuY3Rpb24gKENvbm5lY3Rpb25MaW5lVHlwZSkge1xuICAgIENvbm5lY3Rpb25MaW5lVHlwZVtcIkJlemllclwiXSA9IFwiZGVmYXVsdFwiO1xuICAgIENvbm5lY3Rpb25MaW5lVHlwZVtcIlN0cmFpZ2h0XCJdID0gXCJzdHJhaWdodFwiO1xuICAgIENvbm5lY3Rpb25MaW5lVHlwZVtcIlN0ZXBcIl0gPSBcInN0ZXBcIjtcbiAgICBDb25uZWN0aW9uTGluZVR5cGVbXCJTbW9vdGhTdGVwXCJdID0gXCJzbW9vdGhzdGVwXCI7XG4gICAgQ29ubmVjdGlvbkxpbmVUeXBlW1wiU2ltcGxlQmV6aWVyXCJdID0gXCJzaW1wbGViZXppZXJcIjtcbn0pKENvbm5lY3Rpb25MaW5lVHlwZSB8fCAoQ29ubmVjdGlvbkxpbmVUeXBlID0ge30pKTtcbi8qKlxuICogRWRnZXMgbWF5IG9wdGlvbmFsbHkgaGF2ZSBhIG1hcmtlciBvbiBlaXRoZXIgZW5kLiBUaGUgTWFya2VyVHlwZSB0eXBlIGVudW1lcmF0ZXNcbiAqIHRoZSBvcHRpb25zIGF2YWlsYWJsZSB0byB5b3Ugd2hlbiBjb25maWd1cmluZyBhIGdpdmVuIG1hcmtlci5cbiAqXG4gKiBAcHVibGljXG4gKi9cbnZhciBNYXJrZXJUeXBlO1xuKGZ1bmN0aW9uIChNYXJrZXJUeXBlKSB7XG4gICAgTWFya2VyVHlwZVtcIkFycm93XCJdID0gXCJhcnJvd1wiO1xuICAgIE1hcmtlclR5cGVbXCJBcnJvd0Nsb3NlZFwiXSA9IFwiYXJyb3djbG9zZWRcIjtcbn0pKE1hcmtlclR5cGUgfHwgKE1hcmtlclR5cGUgPSB7fSkpO1xuXG4vKipcbiAqIFdoaWxlIFtgUGFuZWxQb3NpdGlvbmBdKC9hcGktcmVmZXJlbmNlL3R5cGVzL3BhbmVsLXBvc2l0aW9uKSBjYW4gYmUgdXNlZCB0byBwbGFjZSBhXG4gKiBjb21wb25lbnQgaW4gdGhlIGNvcm5lcnMgb2YgYSBjb250YWluZXIsIHRoZSBgUG9zaXRpb25gIGVudW0gaXMgbGVzcyBwcmVjaXNlIGFuZCB1c2VkXG4gKiBwcmltYXJpbHkgaW4gcmVsYXRpb24gdG8gZWRnZXMgYW5kIGhhbmRsZXMuXG4gKlxuICogQHB1YmxpY1xuICovXG52YXIgUG9zaXRpb247XG4oZnVuY3Rpb24gKFBvc2l0aW9uKSB7XG4gICAgUG9zaXRpb25bXCJMZWZ0XCJdID0gXCJsZWZ0XCI7XG4gICAgUG9zaXRpb25bXCJUb3BcIl0gPSBcInRvcFwiO1xuICAgIFBvc2l0aW9uW1wiUmlnaHRcIl0gPSBcInJpZ2h0XCI7XG4gICAgUG9zaXRpb25bXCJCb3R0b21cIl0gPSBcImJvdHRvbVwiO1xufSkoUG9zaXRpb24gfHwgKFBvc2l0aW9uID0ge30pKTtcbmNvbnN0IG9wcG9zaXRlUG9zaXRpb24gPSB7XG4gICAgW1Bvc2l0aW9uLkxlZnRdOiBQb3NpdGlvbi5SaWdodCxcbiAgICBbUG9zaXRpb24uUmlnaHRdOiBQb3NpdGlvbi5MZWZ0LFxuICAgIFtQb3NpdGlvbi5Ub3BdOiBQb3NpdGlvbi5Cb3R0b20sXG4gICAgW1Bvc2l0aW9uLkJvdHRvbV06IFBvc2l0aW9uLlRvcCxcbn07XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGFyZUNvbm5lY3Rpb25NYXBzRXF1YWwoYSwgYikge1xuICAgIGlmICghYSAmJiAhYikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKCFhIHx8ICFiIHx8IGEuc2l6ZSAhPT0gYi5zaXplKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFhLnNpemUgJiYgIWIuc2l6ZSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgb2YgYS5rZXlzKCkpIHtcbiAgICAgICAgaWYgKCFiLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbiAqIFdlIGNhbGwgdGhlIGNhbGxiYWNrIGZvciBhbGwgY29ubmVjdGlvbnMgaW4gYSB0aGF0IGFyZSBub3QgaW4gYlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBoYW5kbGVDb25uZWN0aW9uQ2hhbmdlKGEsIGIsIGNiKSB7XG4gICAgaWYgKCFjYikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGRpZmYgPSBbXTtcbiAgICBhLmZvckVhY2goKGNvbm5lY3Rpb24sIGtleSkgPT4ge1xuICAgICAgICBpZiAoIWI/LmhhcyhrZXkpKSB7XG4gICAgICAgICAgICBkaWZmLnB1c2goY29ubmVjdGlvbik7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAoZGlmZi5sZW5ndGgpIHtcbiAgICAgICAgY2IoZGlmZik7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0Q29ubmVjdGlvblN0YXR1cyhpc1ZhbGlkKSB7XG4gICAgcmV0dXJuIGlzVmFsaWQgPT09IG51bGwgPyBudWxsIDogaXNWYWxpZCA/ICd2YWxpZCcgOiAnaW52YWxpZCc7XG59XG5cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbi8qKlxuICogVGVzdCB3aGV0aGVyIGFuIG9iamVjdCBpcyB1c2VhYmxlIGFzIGFuIEVkZ2VcbiAqIEBwdWJsaWNcbiAqIEByZW1hcmtzIEluIFR5cGVTY3JpcHQgdGhpcyBpcyBhIHR5cGUgZ3VhcmQgdGhhdCB3aWxsIG5hcnJvdyB0aGUgdHlwZSBvZiB3aGF0ZXZlciB5b3UgcGFzcyBpbiB0byBFZGdlIGlmIGl0IHJldHVybnMgdHJ1ZVxuICogQHBhcmFtIGVsZW1lbnQgLSBUaGUgZWxlbWVudCB0byB0ZXN0XG4gKiBAcmV0dXJucyBBIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBlbGVtZW50IGlzIGFuIEVkZ2VcbiAqL1xuY29uc3QgaXNFZGdlQmFzZSA9IChlbGVtZW50KSA9PiAnaWQnIGluIGVsZW1lbnQgJiYgJ3NvdXJjZScgaW4gZWxlbWVudCAmJiAndGFyZ2V0JyBpbiBlbGVtZW50O1xuLyoqXG4gKiBUZXN0IHdoZXRoZXIgYW4gb2JqZWN0IGlzIHVzZWFibGUgYXMgYSBOb2RlXG4gKiBAcHVibGljXG4gKiBAcmVtYXJrcyBJbiBUeXBlU2NyaXB0IHRoaXMgaXMgYSB0eXBlIGd1YXJkIHRoYXQgd2lsbCBuYXJyb3cgdGhlIHR5cGUgb2Ygd2hhdGV2ZXIgeW91IHBhc3MgaW4gdG8gTm9kZSBpZiBpdCByZXR1cm5zIHRydWVcbiAqIEBwYXJhbSBlbGVtZW50IC0gVGhlIGVsZW1lbnQgdG8gdGVzdFxuICogQHJldHVybnMgQSBib29sZWFuIGluZGljYXRpbmcgd2hldGhlciB0aGUgZWxlbWVudCBpcyBhbiBOb2RlXG4gKi9cbmNvbnN0IGlzTm9kZUJhc2UgPSAoZWxlbWVudCkgPT4gJ2lkJyBpbiBlbGVtZW50ICYmICdwb3NpdGlvbicgaW4gZWxlbWVudCAmJiAhKCdzb3VyY2UnIGluIGVsZW1lbnQpICYmICEoJ3RhcmdldCcgaW4gZWxlbWVudCk7XG5jb25zdCBpc0ludGVybmFsTm9kZUJhc2UgPSAoZWxlbWVudCkgPT4gJ2lkJyBpbiBlbGVtZW50ICYmICdpbnRlcm5hbHMnIGluIGVsZW1lbnQgJiYgISgnc291cmNlJyBpbiBlbGVtZW50KSAmJiAhKCd0YXJnZXQnIGluIGVsZW1lbnQpO1xuLyoqXG4gKiBUaGlzIHV0aWwgaXMgdXNlZCB0byB0ZWxsIHlvdSB3aGF0IG5vZGVzLCBpZiBhbnksIGFyZSBjb25uZWN0ZWQgdG8gdGhlIGdpdmVuIG5vZGVcbiAqIGFzIHRoZSBfdGFyZ2V0XyBvZiBhbiBlZGdlLlxuICogQHB1YmxpY1xuICogQHBhcmFtIG5vZGUgLSBUaGUgbm9kZSB0byBnZXQgdGhlIGNvbm5lY3RlZCBub2RlcyBmcm9tXG4gKiBAcGFyYW0gbm9kZXMgLSBUaGUgYXJyYXkgb2YgYWxsIG5vZGVzXG4gKiBAcGFyYW0gZWRnZXMgLSBUaGUgYXJyYXkgb2YgYWxsIGVkZ2VzXG4gKiBAcmV0dXJucyBBbiBhcnJheSBvZiBub2RlcyB0aGF0IGFyZSBjb25uZWN0ZWQgb3ZlciBlZ2VzIHdoZXJlIHRoZSBzb3VyY2UgaXMgdGhlIGdpdmVuIG5vZGVcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqaW1wb3J0IHsgZ2V0T3V0Z29lcnMgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKmNvbnN0IG5vZGVzID0gW107XG4gKmNvbnN0IGVkZ2VzID0gW107XG4gKlxuICpjb25zdCBvdXRnb2VycyA9IGdldE91dGdvZXJzKFxuICogIHsgaWQ6ICcxJywgcG9zaXRpb246IHsgeDogMCwgeTogMCB9LCBkYXRhOiB7IGxhYmVsOiAnbm9kZScgfSB9LFxuICogIG5vZGVzLFxuICogIGVkZ2VzLFxuICopO1xuICpgYGBcbiAqL1xuY29uc3QgZ2V0T3V0Z29lcnMgPSAobm9kZSwgbm9kZXMsIGVkZ2VzKSA9PiB7XG4gICAgaWYgKCFub2RlLmlkKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3Qgb3V0Z29lcklkcyA9IG5ldyBTZXQoKTtcbiAgICBlZGdlcy5mb3JFYWNoKChlZGdlKSA9PiB7XG4gICAgICAgIGlmIChlZGdlLnNvdXJjZSA9PT0gbm9kZS5pZCkge1xuICAgICAgICAgICAgb3V0Z29lcklkcy5hZGQoZWRnZS50YXJnZXQpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG5vZGVzLmZpbHRlcigobikgPT4gb3V0Z29lcklkcy5oYXMobi5pZCkpO1xufTtcbi8qKlxuICogVGhpcyB1dGlsIGlzIHVzZWQgdG8gdGVsbCB5b3Ugd2hhdCBub2RlcywgaWYgYW55LCBhcmUgY29ubmVjdGVkIHRvIHRoZSBnaXZlbiBub2RlXG4gKiBhcyB0aGUgX3NvdXJjZV8gb2YgYW4gZWRnZS5cbiAqIEBwdWJsaWNcbiAqIEBwYXJhbSBub2RlIC0gVGhlIG5vZGUgdG8gZ2V0IHRoZSBjb25uZWN0ZWQgbm9kZXMgZnJvbVxuICogQHBhcmFtIG5vZGVzIC0gVGhlIGFycmF5IG9mIGFsbCBub2Rlc1xuICogQHBhcmFtIGVkZ2VzIC0gVGhlIGFycmF5IG9mIGFsbCBlZGdlc1xuICogQHJldHVybnMgQW4gYXJyYXkgb2Ygbm9kZXMgdGhhdCBhcmUgY29ubmVjdGVkIG92ZXIgZWdlcyB3aGVyZSB0aGUgdGFyZ2V0IGlzIHRoZSBnaXZlbiBub2RlXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKmltcG9ydCB7IGdldEluY29tZXJzIH0gZnJvbSAnQHh5Zmxvdy9yZWFjdCc7XG4gKlxuICpjb25zdCBub2RlcyA9IFtdO1xuICpjb25zdCBlZGdlcyA9IFtdO1xuICpcbiAqY29uc3QgaW5jb21lcnMgPSBnZXRJbmNvbWVycyhcbiAqICB7IGlkOiAnMScsIHBvc2l0aW9uOiB7IHg6IDAsIHk6IDAgfSwgZGF0YTogeyBsYWJlbDogJ25vZGUnIH0gfSxcbiAqICBub2RlcyxcbiAqICBlZGdlcyxcbiAqKTtcbiAqYGBgXG4gKi9cbmNvbnN0IGdldEluY29tZXJzID0gKG5vZGUsIG5vZGVzLCBlZGdlcykgPT4ge1xuICAgIGlmICghbm9kZS5pZCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGNvbnN0IGluY29tZXJzSWRzID0gbmV3IFNldCgpO1xuICAgIGVkZ2VzLmZvckVhY2goKGVkZ2UpID0+IHtcbiAgICAgICAgaWYgKGVkZ2UudGFyZ2V0ID09PSBub2RlLmlkKSB7XG4gICAgICAgICAgICBpbmNvbWVyc0lkcy5hZGQoZWRnZS5zb3VyY2UpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG5vZGVzLmZpbHRlcigobikgPT4gaW5jb21lcnNJZHMuaGFzKG4uaWQpKTtcbn07XG5jb25zdCBnZXROb2RlUG9zaXRpb25XaXRoT3JpZ2luID0gKG5vZGUsIG5vZGVPcmlnaW4gPSBbMCwgMF0pID0+IHtcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IGdldE5vZGVEaW1lbnNpb25zKG5vZGUpO1xuICAgIGNvbnN0IG9yaWdpbiA9IG5vZGUub3JpZ2luID8/IG5vZGVPcmlnaW47XG4gICAgY29uc3Qgb2Zmc2V0WCA9IHdpZHRoICogb3JpZ2luWzBdO1xuICAgIGNvbnN0IG9mZnNldFkgPSBoZWlnaHQgKiBvcmlnaW5bMV07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogbm9kZS5wb3NpdGlvbi54IC0gb2Zmc2V0WCxcbiAgICAgICAgeTogbm9kZS5wb3NpdGlvbi55IC0gb2Zmc2V0WSxcbiAgICB9O1xufTtcbi8qKlxuICogUmV0dXJucyB0aGUgYm91bmRpbmcgYm94IHRoYXQgY29udGFpbnMgYWxsIHRoZSBnaXZlbiBub2RlcyBpbiBhbiBhcnJheS4gVGhpcyBjYW5cbiAqIGJlIHVzZWZ1bCB3aGVuIGNvbWJpbmVkIHdpdGggW2BnZXRWaWV3cG9ydEZvckJvdW5kc2BdKC9hcGktcmVmZXJlbmNlL3V0aWxzL2dldC12aWV3cG9ydC1mb3ItYm91bmRzKVxuICogdG8gY2FsY3VsYXRlIHRoZSBjb3JyZWN0IHRyYW5zZm9ybSB0byBmaXQgdGhlIGdpdmVuIG5vZGVzIGluIGEgdmlld3BvcnQuXG4gKiBAcHVibGljXG4gKiBAcmVtYXJrcyBVc2VmdWwgd2hlbiBjb21iaW5lZCB3aXRoIHtAbGluayBnZXRWaWV3cG9ydEZvckJvdW5kc30gdG8gY2FsY3VsYXRlIHRoZSBjb3JyZWN0IHRyYW5zZm9ybSB0byBmaXQgdGhlIGdpdmVuIG5vZGVzIGluIGEgdmlld3BvcnQuXG4gKiBAcGFyYW0gbm9kZXMgLSBOb2RlcyB0byBjYWxjdWxhdGUgdGhlIGJvdW5kcyBmb3JcbiAqIEBwYXJhbSBwYXJhbXMubm9kZU9yaWdpbiAtIE9yaWdpbiBvZiB0aGUgbm9kZXM6IFswLCAwXSAtIHRvcCBsZWZ0LCBbMC41LCAwLjVdIC0gY2VudGVyXG4gKiBAcmV0dXJucyBCb3VuZGluZyBib3ggZW5jbG9zaW5nIGFsbCBub2Rlc1xuICpcbiAqIEByZW1hcmtzIFRoaXMgZnVuY3Rpb24gd2FzIHByZXZpb3VzbHkgY2FsbGVkIGBnZXRSZWN0T2ZOb2Rlc2BcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqaW1wb3J0IHsgZ2V0Tm9kZXNCb3VuZHMgfSBmcm9tICdAeHlmbG93L3JlYWN0JztcbiAqXG4gKmNvbnN0IG5vZGVzID0gW1xuICogIHtcbiAqICAgIGlkOiAnYScsXG4gKiAgICBwb3NpdGlvbjogeyB4OiAwLCB5OiAwIH0sXG4gKiAgICBkYXRhOiB7IGxhYmVsOiAnYScgfSxcbiAqICAgIHdpZHRoOiA1MCxcbiAqICAgIGhlaWdodDogMjUsXG4gKiAgfSxcbiAqICB7XG4gKiAgICBpZDogJ2InLFxuICogICAgcG9zaXRpb246IHsgeDogMTAwLCB5OiAxMDAgfSxcbiAqICAgIGRhdGE6IHsgbGFiZWw6ICdiJyB9LFxuICogICAgd2lkdGg6IDUwLFxuICogICAgaGVpZ2h0OiAyNSxcbiAqICB9LFxuICpdO1xuICpcbiAqY29uc3QgYm91bmRzID0gZ2V0Tm9kZXNCb3VuZHMobm9kZXMpO1xuICpgYGBcbiAqL1xuY29uc3QgZ2V0Tm9kZXNCb3VuZHMgPSAobm9kZXMsIHBhcmFtcyA9IHsgbm9kZU9yaWdpbjogWzAsIDBdLCBub2RlTG9va3VwOiB1bmRlZmluZWQgfSkgPT4ge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JyAmJiAhcGFyYW1zLm5vZGVMb29rdXApIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdQbGVhc2UgdXNlIGBnZXROb2Rlc0JvdW5kc2AgZnJvbSBgdXNlUmVhY3RGbG93YC9gdXNlU3ZlbHRlRmxvd2AgaG9vayB0byBlbnN1cmUgY29ycmVjdCB2YWx1ZXMgZm9yIHN1YiBmbG93cy4gSWYgbm90IHBvc3NpYmxlLCB5b3UgaGF2ZSB0byBwcm92aWRlIGEgbm9kZUxvb2t1cCB0byBzdXBwb3J0IHN1YiBmbG93cy4nKTtcbiAgICB9XG4gICAgaWYgKG5vZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4geyB4OiAwLCB5OiAwLCB3aWR0aDogMCwgaGVpZ2h0OiAwIH07XG4gICAgfVxuICAgIGNvbnN0IGJveCA9IG5vZGVzLnJlZHVjZSgoY3VyckJveCwgbm9kZU9ySWQpID0+IHtcbiAgICAgICAgY29uc3QgaXNJZCA9IHR5cGVvZiBub2RlT3JJZCA9PT0gJ3N0cmluZyc7XG4gICAgICAgIGxldCBjdXJyZW50Tm9kZSA9ICFwYXJhbXMubm9kZUxvb2t1cCAmJiAhaXNJZCA/IG5vZGVPcklkIDogdW5kZWZpbmVkO1xuICAgICAgICBpZiAocGFyYW1zLm5vZGVMb29rdXApIHtcbiAgICAgICAgICAgIGN1cnJlbnROb2RlID0gaXNJZFxuICAgICAgICAgICAgICAgID8gcGFyYW1zLm5vZGVMb29rdXAuZ2V0KG5vZGVPcklkKVxuICAgICAgICAgICAgICAgIDogIWlzSW50ZXJuYWxOb2RlQmFzZShub2RlT3JJZClcbiAgICAgICAgICAgICAgICAgICAgPyBwYXJhbXMubm9kZUxvb2t1cC5nZXQobm9kZU9ySWQuaWQpXG4gICAgICAgICAgICAgICAgICAgIDogbm9kZU9ySWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgbm9kZUJveCA9IGN1cnJlbnROb2RlID8gbm9kZVRvQm94KGN1cnJlbnROb2RlLCBwYXJhbXMubm9kZU9yaWdpbikgOiB7IHg6IDAsIHk6IDAsIHgyOiAwLCB5MjogMCB9O1xuICAgICAgICByZXR1cm4gZ2V0Qm91bmRzT2ZCb3hlcyhjdXJyQm94LCBub2RlQm94KTtcbiAgICB9LCB7IHg6IEluZmluaXR5LCB5OiBJbmZpbml0eSwgeDI6IC1JbmZpbml0eSwgeTI6IC1JbmZpbml0eSB9KTtcbiAgICByZXR1cm4gYm94VG9SZWN0KGJveCk7XG59O1xuLyoqXG4gKiBEZXRlcm1pbmVzIGEgYm91bmRpbmcgYm94IHRoYXQgY29udGFpbnMgYWxsIGdpdmVuIG5vZGVzIGluIGFuIGFycmF5XG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgZ2V0SW50ZXJuYWxOb2Rlc0JvdW5kcyA9IChub2RlTG9va3VwLCBwYXJhbXMgPSB7fSkgPT4ge1xuICAgIGlmIChub2RlTG9va3VwLnNpemUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHsgeDogMCwgeTogMCwgd2lkdGg6IDAsIGhlaWdodDogMCB9O1xuICAgIH1cbiAgICBsZXQgYm94ID0geyB4OiBJbmZpbml0eSwgeTogSW5maW5pdHksIHgyOiAtSW5maW5pdHksIHkyOiAtSW5maW5pdHkgfTtcbiAgICBub2RlTG9va3VwLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgICAgaWYgKHBhcmFtcy5maWx0ZXIgPT09IHVuZGVmaW5lZCB8fCBwYXJhbXMuZmlsdGVyKG5vZGUpKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlQm94ID0gbm9kZVRvQm94KG5vZGUpO1xuICAgICAgICAgICAgYm94ID0gZ2V0Qm91bmRzT2ZCb3hlcyhib3gsIG5vZGVCb3gpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGJveFRvUmVjdChib3gpO1xufTtcbmNvbnN0IGdldE5vZGVzSW5zaWRlID0gKG5vZGVzLCByZWN0LCBbdHgsIHR5LCB0U2NhbGVdID0gWzAsIDAsIDFdLCBwYXJ0aWFsbHkgPSBmYWxzZSwgXG4vLyBzZXQgZXhjbHVkZU5vblNlbGVjdGFibGVOb2RlcyBpZiB5b3Ugd2FudCB0byBwYXkgYXR0ZW50aW9uIHRvIHRoZSBub2RlcyBcInNlbGVjdGFibGVcIiBhdHRyaWJ1dGVcbmV4Y2x1ZGVOb25TZWxlY3RhYmxlTm9kZXMgPSBmYWxzZSkgPT4ge1xuICAgIGNvbnN0IHBhbmVSZWN0ID0ge1xuICAgICAgICAuLi5wb2ludFRvUmVuZGVyZXJQb2ludChyZWN0LCBbdHgsIHR5LCB0U2NhbGVdKSxcbiAgICAgICAgd2lkdGg6IHJlY3Qud2lkdGggLyB0U2NhbGUsXG4gICAgICAgIGhlaWdodDogcmVjdC5oZWlnaHQgLyB0U2NhbGUsXG4gICAgfTtcbiAgICBjb25zdCB2aXNpYmxlTm9kZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygbm9kZXMudmFsdWVzKCkpIHtcbiAgICAgICAgY29uc3QgeyBtZWFzdXJlZCwgc2VsZWN0YWJsZSA9IHRydWUsIGhpZGRlbiA9IGZhbHNlIH0gPSBub2RlO1xuICAgICAgICBpZiAoKGV4Y2x1ZGVOb25TZWxlY3RhYmxlTm9kZXMgJiYgIXNlbGVjdGFibGUpIHx8IGhpZGRlbikge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgd2lkdGggPSBtZWFzdXJlZC53aWR0aCA/PyBub2RlLndpZHRoID8/IG5vZGUuaW5pdGlhbFdpZHRoID8/IG51bGw7XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IG1lYXN1cmVkLmhlaWdodCA/PyBub2RlLmhlaWdodCA/PyBub2RlLmluaXRpYWxIZWlnaHQgPz8gbnVsbDtcbiAgICAgICAgY29uc3Qgb3ZlcmxhcHBpbmdBcmVhID0gZ2V0T3ZlcmxhcHBpbmdBcmVhKHBhbmVSZWN0LCBub2RlVG9SZWN0KG5vZGUpKTtcbiAgICAgICAgY29uc3QgYXJlYSA9ICh3aWR0aCA/PyAwKSAqIChoZWlnaHQgPz8gMCk7XG4gICAgICAgIGNvbnN0IHBhcnRpYWxseVZpc2libGUgPSBwYXJ0aWFsbHkgJiYgb3ZlcmxhcHBpbmdBcmVhID4gMDtcbiAgICAgICAgY29uc3QgZm9yY2VJbml0aWFsUmVuZGVyID0gIW5vZGUuaW50ZXJuYWxzLmhhbmRsZUJvdW5kcztcbiAgICAgICAgY29uc3QgaXNWaXNpYmxlID0gZm9yY2VJbml0aWFsUmVuZGVyIHx8IHBhcnRpYWxseVZpc2libGUgfHwgb3ZlcmxhcHBpbmdBcmVhID49IGFyZWE7XG4gICAgICAgIGlmIChpc1Zpc2libGUgfHwgbm9kZS5kcmFnZ2luZykge1xuICAgICAgICAgICAgdmlzaWJsZU5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZpc2libGVOb2Rlcztcbn07XG4vKipcbiAqIFRoaXMgdXRpbGl0eSBmaWx0ZXJzIGFuIGFycmF5IG9mIGVkZ2VzLCBrZWVwaW5nIG9ubHkgdGhvc2Ugd2hlcmUgZWl0aGVyIHRoZSBzb3VyY2Ugb3IgdGFyZ2V0XG4gKiBub2RlIGlzIHByZXNlbnQgaW4gdGhlIGdpdmVuIGFycmF5IG9mIG5vZGVzLlxuICogQHB1YmxpY1xuICogQHBhcmFtIG5vZGVzIC0gTm9kZXMgeW91IHdhbnQgdG8gZ2V0IHRoZSBjb25uZWN0ZWQgZWRnZXMgZm9yXG4gKiBAcGFyYW0gZWRnZXMgLSBBbGwgZWRnZXNcbiAqIEByZXR1cm5zIEFycmF5IG9mIGVkZ2VzIHRoYXQgY29ubmVjdCBhbnkgb2YgdGhlIGdpdmVuIG5vZGVzIHdpdGggZWFjaCBvdGhlclxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICppbXBvcnQgeyBnZXRDb25uZWN0ZWRFZGdlcyB9IGZyb20gJ0B4eWZsb3cvcmVhY3QnO1xuICpcbiAqY29uc3Qgbm9kZXMgPSBbXG4gKiAgeyBpZDogJ2EnLCBwb3NpdGlvbjogeyB4OiAwLCB5OiAwIH0gfSxcbiAqICB7IGlkOiAnYicsIHBvc2l0aW9uOiB7IHg6IDEwMCwgeTogMCB9IH0sXG4gKl07XG4gKlxuICpjb25zdCBlZGdlcyA9IFtcbiAqICB7IGlkOiAnYS0+YycsIHNvdXJjZTogJ2EnLCB0YXJnZXQ6ICdjJyB9LFxuICogIHsgaWQ6ICdjLT5kJywgc291cmNlOiAnYycsIHRhcmdldDogJ2QnIH0sXG4gKl07XG4gKlxuICpjb25zdCBjb25uZWN0ZWRFZGdlcyA9IGdldENvbm5lY3RlZEVkZ2VzKG5vZGVzLCBlZGdlcyk7XG4gKiAvLyA9PiBbeyBpZDogJ2EtPmMnLCBzb3VyY2U6ICdhJywgdGFyZ2V0OiAnYycgfV1cbiAqYGBgXG4gKi9cbmNvbnN0IGdldENvbm5lY3RlZEVkZ2VzID0gKG5vZGVzLCBlZGdlcykgPT4ge1xuICAgIGNvbnN0IG5vZGVJZHMgPSBuZXcgU2V0KCk7XG4gICAgbm9kZXMuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgICBub2RlSWRzLmFkZChub2RlLmlkKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZWRnZXMuZmlsdGVyKChlZGdlKSA9PiBub2RlSWRzLmhhcyhlZGdlLnNvdXJjZSkgfHwgbm9kZUlkcy5oYXMoZWRnZS50YXJnZXQpKTtcbn07XG5mdW5jdGlvbiBnZXRGaXRWaWV3Tm9kZXMobm9kZUxvb2t1cCwgb3B0aW9ucykge1xuICAgIGNvbnN0IGZpdFZpZXdOb2RlcyA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBvcHRpb25Ob2RlSWRzID0gb3B0aW9ucz8ubm9kZXMgPyBuZXcgU2V0KG9wdGlvbnMubm9kZXMubWFwKChub2RlKSA9PiBub2RlLmlkKSkgOiBudWxsO1xuICAgIG5vZGVMb29rdXAuZm9yRWFjaCgobikgPT4ge1xuICAgICAgICBjb25zdCBpc1Zpc2libGUgPSBuLm1lYXN1cmVkLndpZHRoICYmIG4ubWVhc3VyZWQuaGVpZ2h0ICYmIChvcHRpb25zPy5pbmNsdWRlSGlkZGVuTm9kZXMgfHwgIW4uaGlkZGVuKTtcbiAgICAgICAgaWYgKGlzVmlzaWJsZSAmJiAoIW9wdGlvbk5vZGVJZHMgfHwgb3B0aW9uTm9kZUlkcy5oYXMobi5pZCkpKSB7XG4gICAgICAgICAgICBmaXRWaWV3Tm9kZXMuc2V0KG4uaWQsIG4pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGZpdFZpZXdOb2Rlcztcbn1cbmFzeW5jIGZ1bmN0aW9uIGZpdFZpZXcoeyBub2Rlcywgd2lkdGgsIGhlaWdodCwgcGFuWm9vbSwgbWluWm9vbSwgbWF4Wm9vbSB9LCBvcHRpb25zKSB7XG4gICAgaWYgKG5vZGVzLnNpemUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShmYWxzZSk7XG4gICAgfVxuICAgIGNvbnN0IGJvdW5kcyA9IGdldEludGVybmFsTm9kZXNCb3VuZHMobm9kZXMpO1xuICAgIGNvbnN0IHZpZXdwb3J0ID0gZ2V0Vmlld3BvcnRGb3JCb3VuZHMoYm91bmRzLCB3aWR0aCwgaGVpZ2h0LCBvcHRpb25zPy5taW5ab29tID8/IG1pblpvb20sIG9wdGlvbnM/Lm1heFpvb20gPz8gbWF4Wm9vbSwgb3B0aW9ucz8ucGFkZGluZyA/PyAwLjEpO1xuICAgIGF3YWl0IHBhblpvb20uc2V0Vmlld3BvcnQodmlld3BvcnQsIHsgZHVyYXRpb246IG9wdGlvbnM/LmR1cmF0aW9uIH0pO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodHJ1ZSk7XG59XG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gY2FsY3VsYXRlcyB0aGUgbmV4dCBwb3NpdGlvbiBvZiBhIG5vZGUsIHRha2luZyBpbnRvIGFjY291bnQgdGhlIG5vZGUncyBleHRlbnQsIHBhcmVudCBub2RlLCBhbmQgb3JpZ2luLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHJldHVybnMgcG9zaXRpb24sIHBvc2l0aW9uQWJzb2x1dGVcbiAqL1xuZnVuY3Rpb24gY2FsY3VsYXRlTm9kZVBvc2l0aW9uKHsgbm9kZUlkLCBuZXh0UG9zaXRpb24sIG5vZGVMb29rdXAsIG5vZGVPcmlnaW4gPSBbMCwgMF0sIG5vZGVFeHRlbnQsIG9uRXJyb3IsIH0pIHtcbiAgICBjb25zdCBub2RlID0gbm9kZUxvb2t1cC5nZXQobm9kZUlkKTtcbiAgICBjb25zdCBwYXJlbnROb2RlID0gbm9kZS5wYXJlbnRJZCA/IG5vZGVMb29rdXAuZ2V0KG5vZGUucGFyZW50SWQpIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IHsgeDogcGFyZW50WCwgeTogcGFyZW50WSB9ID0gcGFyZW50Tm9kZSA/IHBhcmVudE5vZGUuaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUgOiB7IHg6IDAsIHk6IDAgfTtcbiAgICBjb25zdCBvcmlnaW4gPSBub2RlLm9yaWdpbiA/PyBub2RlT3JpZ2luO1xuICAgIGxldCBleHRlbnQgPSBub2RlRXh0ZW50O1xuICAgIGlmIChub2RlLmV4dGVudCA9PT0gJ3BhcmVudCcgJiYgIW5vZGUuZXhwYW5kUGFyZW50KSB7XG4gICAgICAgIGlmICghcGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgb25FcnJvcj8uKCcwMDUnLCBlcnJvck1lc3NhZ2VzWydlcnJvcjAwNSddKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcGFyZW50V2lkdGggPSBwYXJlbnROb2RlLm1lYXN1cmVkLndpZHRoO1xuICAgICAgICAgICAgY29uc3QgcGFyZW50SGVpZ2h0ID0gcGFyZW50Tm9kZS5tZWFzdXJlZC5oZWlnaHQ7XG4gICAgICAgICAgICBpZiAocGFyZW50V2lkdGggJiYgcGFyZW50SGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgZXh0ZW50ID0gW1xuICAgICAgICAgICAgICAgICAgICBbcGFyZW50WCwgcGFyZW50WV0sXG4gICAgICAgICAgICAgICAgICAgIFtwYXJlbnRYICsgcGFyZW50V2lkdGgsIHBhcmVudFkgKyBwYXJlbnRIZWlnaHRdLFxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAocGFyZW50Tm9kZSAmJiBpc0Nvb3JkaW5hdGVFeHRlbnQobm9kZS5leHRlbnQpKSB7XG4gICAgICAgIGV4dGVudCA9IFtcbiAgICAgICAgICAgIFtub2RlLmV4dGVudFswXVswXSArIHBhcmVudFgsIG5vZGUuZXh0ZW50WzBdWzFdICsgcGFyZW50WV0sXG4gICAgICAgICAgICBbbm9kZS5leHRlbnRbMV1bMF0gKyBwYXJlbnRYLCBub2RlLmV4dGVudFsxXVsxXSArIHBhcmVudFldLFxuICAgICAgICBdO1xuICAgIH1cbiAgICBjb25zdCBwb3NpdGlvbkFic29sdXRlID0gaXNDb29yZGluYXRlRXh0ZW50KGV4dGVudClcbiAgICAgICAgPyBjbGFtcFBvc2l0aW9uKG5leHRQb3NpdGlvbiwgZXh0ZW50LCBub2RlLm1lYXN1cmVkKVxuICAgICAgICA6IG5leHRQb3NpdGlvbjtcbiAgICBpZiAobm9kZS5tZWFzdXJlZC53aWR0aCA9PT0gdW5kZWZpbmVkIHx8IG5vZGUubWVhc3VyZWQuaGVpZ2h0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb25FcnJvcj8uKCcwMTUnLCBlcnJvck1lc3NhZ2VzWydlcnJvcjAxNSddKCkpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgeDogcG9zaXRpb25BYnNvbHV0ZS54IC0gcGFyZW50WCArIChub2RlLm1lYXN1cmVkLndpZHRoID8/IDApICogb3JpZ2luWzBdLFxuICAgICAgICAgICAgeTogcG9zaXRpb25BYnNvbHV0ZS55IC0gcGFyZW50WSArIChub2RlLm1lYXN1cmVkLmhlaWdodCA/PyAwKSAqIG9yaWdpblsxXSxcbiAgICAgICAgfSxcbiAgICAgICAgcG9zaXRpb25BYnNvbHV0ZSxcbiAgICB9O1xufVxuLyoqXG4gKiBQYXNzIGluIG5vZGVzICYgZWRnZXMgdG8gZGVsZXRlLCBnZXQgYXJyYXlzIG9mIG5vZGVzIGFuZCBlZGdlcyB0aGF0IGFjdHVhbGx5IGNhbiBiZSBkZWxldGVkXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSBwYXJhbS5ub2Rlc1RvUmVtb3ZlIC0gVGhlIG5vZGVzIHRvIHJlbW92ZVxuICogQHBhcmFtIHBhcmFtLmVkZ2VzVG9SZW1vdmUgLSBUaGUgZWRnZXMgdG8gcmVtb3ZlXG4gKiBAcGFyYW0gcGFyYW0ubm9kZXMgLSBBbGwgbm9kZXNcbiAqIEBwYXJhbSBwYXJhbS5lZGdlcyAtIEFsbCBlZGdlc1xuICogQHBhcmFtIHBhcmFtLm9uQmVmb3JlRGVsZXRlIC0gQ2FsbGJhY2sgdG8gY2hlY2sgd2hpY2ggbm9kZXMgYW5kIGVkZ2VzIGNhbiBiZSBkZWxldGVkXG4gKiBAcmV0dXJucyBub2Rlczogbm9kZXMgdGhhdCBjYW4gYmUgZGVsZXRlZCwgZWRnZXM6IGVkZ2VzIHRoYXQgY2FuIGJlIGRlbGV0ZWRcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0RWxlbWVudHNUb1JlbW92ZSh7IG5vZGVzVG9SZW1vdmUgPSBbXSwgZWRnZXNUb1JlbW92ZSA9IFtdLCBub2RlcywgZWRnZXMsIG9uQmVmb3JlRGVsZXRlLCB9KSB7XG4gICAgY29uc3Qgbm9kZUlkcyA9IG5ldyBTZXQobm9kZXNUb1JlbW92ZS5tYXAoKG5vZGUpID0+IG5vZGUuaWQpKTtcbiAgICBjb25zdCBtYXRjaGluZ05vZGVzID0gW107XG4gICAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVzKSB7XG4gICAgICAgIGlmIChub2RlLmRlbGV0YWJsZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzSW5jbHVkZWQgPSBub2RlSWRzLmhhcyhub2RlLmlkKTtcbiAgICAgICAgY29uc3QgcGFyZW50SGl0ID0gIWlzSW5jbHVkZWQgJiYgbm9kZS5wYXJlbnRJZCAmJiBtYXRjaGluZ05vZGVzLmZpbmQoKG4pID0+IG4uaWQgPT09IG5vZGUucGFyZW50SWQpO1xuICAgICAgICBpZiAoaXNJbmNsdWRlZCB8fCBwYXJlbnRIaXQpIHtcbiAgICAgICAgICAgIG1hdGNoaW5nTm9kZXMucHVzaChub2RlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBlZGdlSWRzID0gbmV3IFNldChlZGdlc1RvUmVtb3ZlLm1hcCgoZWRnZSkgPT4gZWRnZS5pZCkpO1xuICAgIGNvbnN0IGRlbGV0YWJsZUVkZ2VzID0gZWRnZXMuZmlsdGVyKChlZGdlKSA9PiBlZGdlLmRlbGV0YWJsZSAhPT0gZmFsc2UpO1xuICAgIGNvbnN0IGNvbm5lY3RlZEVkZ2VzID0gZ2V0Q29ubmVjdGVkRWRnZXMobWF0Y2hpbmdOb2RlcywgZGVsZXRhYmxlRWRnZXMpO1xuICAgIGNvbnN0IG1hdGNoaW5nRWRnZXMgPSBjb25uZWN0ZWRFZGdlcztcbiAgICBmb3IgKGNvbnN0IGVkZ2Ugb2YgZGVsZXRhYmxlRWRnZXMpIHtcbiAgICAgICAgY29uc3QgaXNJbmNsdWRlZCA9IGVkZ2VJZHMuaGFzKGVkZ2UuaWQpO1xuICAgICAgICBpZiAoaXNJbmNsdWRlZCAmJiAhbWF0Y2hpbmdFZGdlcy5maW5kKChlKSA9PiBlLmlkID09PSBlZGdlLmlkKSkge1xuICAgICAgICAgICAgbWF0Y2hpbmdFZGdlcy5wdXNoKGVkZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghb25CZWZvcmVEZWxldGUpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVkZ2VzOiBtYXRjaGluZ0VkZ2VzLFxuICAgICAgICAgICAgbm9kZXM6IG1hdGNoaW5nTm9kZXMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IG9uQmVmb3JlRGVsZXRlUmVzdWx0ID0gYXdhaXQgb25CZWZvcmVEZWxldGUoe1xuICAgICAgICBub2RlczogbWF0Y2hpbmdOb2RlcyxcbiAgICAgICAgZWRnZXM6IG1hdGNoaW5nRWRnZXMsXG4gICAgfSk7XG4gICAgaWYgKHR5cGVvZiBvbkJlZm9yZURlbGV0ZVJlc3VsdCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJldHVybiBvbkJlZm9yZURlbGV0ZVJlc3VsdCA/IHsgZWRnZXM6IG1hdGNoaW5nRWRnZXMsIG5vZGVzOiBtYXRjaGluZ05vZGVzIH0gOiB7IGVkZ2VzOiBbXSwgbm9kZXM6IFtdIH07XG4gICAgfVxuICAgIHJldHVybiBvbkJlZm9yZURlbGV0ZVJlc3VsdDtcbn1cblxuY29uc3QgY2xhbXAgPSAodmFsLCBtaW4gPSAwLCBtYXggPSAxKSA9PiBNYXRoLm1pbihNYXRoLm1heCh2YWwsIG1pbiksIG1heCk7XG5jb25zdCBjbGFtcFBvc2l0aW9uID0gKHBvc2l0aW9uID0geyB4OiAwLCB5OiAwIH0sIGV4dGVudCwgZGltZW5zaW9ucykgPT4gKHtcbiAgICB4OiBjbGFtcChwb3NpdGlvbi54LCBleHRlbnRbMF1bMF0sIGV4dGVudFsxXVswXSAtIChkaW1lbnNpb25zPy53aWR0aCA/PyAwKSksXG4gICAgeTogY2xhbXAocG9zaXRpb24ueSwgZXh0ZW50WzBdWzFdLCBleHRlbnRbMV1bMV0gLSAoZGltZW5zaW9ucz8uaGVpZ2h0ID8/IDApKSxcbn0pO1xuZnVuY3Rpb24gY2xhbXBQb3NpdGlvblRvUGFyZW50KGNoaWxkUG9zaXRpb24sIGNoaWxkRGltZW5zaW9ucywgcGFyZW50KSB7XG4gICAgY29uc3QgeyB3aWR0aDogcGFyZW50V2lkdGgsIGhlaWdodDogcGFyZW50SGVpZ2h0IH0gPSBnZXROb2RlRGltZW5zaW9ucyhwYXJlbnQpO1xuICAgIGNvbnN0IHsgeDogcGFyZW50WCwgeTogcGFyZW50WSB9ID0gcGFyZW50LmludGVybmFscy5wb3NpdGlvbkFic29sdXRlO1xuICAgIHJldHVybiBjbGFtcFBvc2l0aW9uKGNoaWxkUG9zaXRpb24sIFtcbiAgICAgICAgW3BhcmVudFgsIHBhcmVudFldLFxuICAgICAgICBbcGFyZW50WCArIHBhcmVudFdpZHRoLCBwYXJlbnRZICsgcGFyZW50SGVpZ2h0XSxcbiAgICBdLCBjaGlsZERpbWVuc2lvbnMpO1xufVxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSB2ZWxvY2l0eSBvZiBwYW5uaW5nIHdoZW4gdGhlIG1vdXNlIGlzIGNsb3NlIHRvIHRoZSBlZGdlIG9mIHRoZSBjYW52YXNcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHZhbHVlIC0gT25lIGRpbWVuc2lvbmFsIHBvaXRpb24gb2YgdGhlIG1vdXNlICh4IG9yIHkpXG4gKiBAcGFyYW0gbWluIC0gTWluaW1hbCBwb3NpdGlvbiBvbiBjYW52YXMgYmVmb3JlIHBhbm5pbmcgc3RhcnRzXG4gKiBAcGFyYW0gbWF4IC0gTWF4aW1hbCBwb3NpdGlvbiBvbiBjYW52YXMgYmVmb3JlIHBhbm5pbmcgc3RhcnRzXG4gKiBAcmV0dXJucyAtIEEgbnVtYmVyIGJldHdlZW4gMCBhbmQgMSB0aGF0IHJlcHJlc2VudHMgdGhlIHZlbG9jaXR5IG9mIHBhbm5pbmdcbiAqL1xuY29uc3QgY2FsY0F1dG9QYW5WZWxvY2l0eSA9ICh2YWx1ZSwgbWluLCBtYXgpID0+IHtcbiAgICBpZiAodmFsdWUgPCBtaW4pIHtcbiAgICAgICAgcmV0dXJuIGNsYW1wKE1hdGguYWJzKHZhbHVlIC0gbWluKSwgMSwgbWluKSAvIG1pbjtcbiAgICB9XG4gICAgZWxzZSBpZiAodmFsdWUgPiBtYXgpIHtcbiAgICAgICAgcmV0dXJuIC1jbGFtcChNYXRoLmFicyh2YWx1ZSAtIG1heCksIDEsIG1pbikgLyBtaW47XG4gICAgfVxuICAgIHJldHVybiAwO1xufTtcbmNvbnN0IGNhbGNBdXRvUGFuID0gKHBvcywgYm91bmRzLCBzcGVlZCA9IDE1LCBkaXN0YW5jZSA9IDQwKSA9PiB7XG4gICAgY29uc3QgeE1vdmVtZW50ID0gY2FsY0F1dG9QYW5WZWxvY2l0eShwb3MueCwgZGlzdGFuY2UsIGJvdW5kcy53aWR0aCAtIGRpc3RhbmNlKSAqIHNwZWVkO1xuICAgIGNvbnN0IHlNb3ZlbWVudCA9IGNhbGNBdXRvUGFuVmVsb2NpdHkocG9zLnksIGRpc3RhbmNlLCBib3VuZHMuaGVpZ2h0IC0gZGlzdGFuY2UpICogc3BlZWQ7XG4gICAgcmV0dXJuIFt4TW92ZW1lbnQsIHlNb3ZlbWVudF07XG59O1xuY29uc3QgZ2V0Qm91bmRzT2ZCb3hlcyA9IChib3gxLCBib3gyKSA9PiAoe1xuICAgIHg6IE1hdGgubWluKGJveDEueCwgYm94Mi54KSxcbiAgICB5OiBNYXRoLm1pbihib3gxLnksIGJveDIueSksXG4gICAgeDI6IE1hdGgubWF4KGJveDEueDIsIGJveDIueDIpLFxuICAgIHkyOiBNYXRoLm1heChib3gxLnkyLCBib3gyLnkyKSxcbn0pO1xuY29uc3QgcmVjdFRvQm94ID0gKHsgeCwgeSwgd2lkdGgsIGhlaWdodCB9KSA9PiAoe1xuICAgIHgsXG4gICAgeSxcbiAgICB4MjogeCArIHdpZHRoLFxuICAgIHkyOiB5ICsgaGVpZ2h0LFxufSk7XG5jb25zdCBib3hUb1JlY3QgPSAoeyB4LCB5LCB4MiwgeTIgfSkgPT4gKHtcbiAgICB4LFxuICAgIHksXG4gICAgd2lkdGg6IHgyIC0geCxcbiAgICBoZWlnaHQ6IHkyIC0geSxcbn0pO1xuY29uc3Qgbm9kZVRvUmVjdCA9IChub2RlLCBub2RlT3JpZ2luID0gWzAsIDBdKSA9PiB7XG4gICAgY29uc3QgeyB4LCB5IH0gPSBpc0ludGVybmFsTm9kZUJhc2Uobm9kZSlcbiAgICAgICAgPyBub2RlLmludGVybmFscy5wb3NpdGlvbkFic29sdXRlXG4gICAgICAgIDogZ2V0Tm9kZVBvc2l0aW9uV2l0aE9yaWdpbihub2RlLCBub2RlT3JpZ2luKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICB3aWR0aDogbm9kZS5tZWFzdXJlZD8ud2lkdGggPz8gbm9kZS53aWR0aCA/PyBub2RlLmluaXRpYWxXaWR0aCA/PyAwLFxuICAgICAgICBoZWlnaHQ6IG5vZGUubWVhc3VyZWQ/LmhlaWdodCA/PyBub2RlLmhlaWdodCA/PyBub2RlLmluaXRpYWxIZWlnaHQgPz8gMCxcbiAgICB9O1xufTtcbmNvbnN0IG5vZGVUb0JveCA9IChub2RlLCBub2RlT3JpZ2luID0gWzAsIDBdKSA9PiB7XG4gICAgY29uc3QgeyB4LCB5IH0gPSBpc0ludGVybmFsTm9kZUJhc2Uobm9kZSlcbiAgICAgICAgPyBub2RlLmludGVybmFscy5wb3NpdGlvbkFic29sdXRlXG4gICAgICAgIDogZ2V0Tm9kZVBvc2l0aW9uV2l0aE9yaWdpbihub2RlLCBub2RlT3JpZ2luKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB4LFxuICAgICAgICB5LFxuICAgICAgICB4MjogeCArIChub2RlLm1lYXN1cmVkPy53aWR0aCA/PyBub2RlLndpZHRoID8/IG5vZGUuaW5pdGlhbFdpZHRoID8/IDApLFxuICAgICAgICB5MjogeSArIChub2RlLm1lYXN1cmVkPy5oZWlnaHQgPz8gbm9kZS5oZWlnaHQgPz8gbm9kZS5pbml0aWFsSGVpZ2h0ID8/IDApLFxuICAgIH07XG59O1xuY29uc3QgZ2V0Qm91bmRzT2ZSZWN0cyA9IChyZWN0MSwgcmVjdDIpID0+IGJveFRvUmVjdChnZXRCb3VuZHNPZkJveGVzKHJlY3RUb0JveChyZWN0MSksIHJlY3RUb0JveChyZWN0MikpKTtcbmNvbnN0IGdldE92ZXJsYXBwaW5nQXJlYSA9IChyZWN0QSwgcmVjdEIpID0+IHtcbiAgICBjb25zdCB4T3ZlcmxhcCA9IE1hdGgubWF4KDAsIE1hdGgubWluKHJlY3RBLnggKyByZWN0QS53aWR0aCwgcmVjdEIueCArIHJlY3RCLndpZHRoKSAtIE1hdGgubWF4KHJlY3RBLngsIHJlY3RCLngpKTtcbiAgICBjb25zdCB5T3ZlcmxhcCA9IE1hdGgubWF4KDAsIE1hdGgubWluKHJlY3RBLnkgKyByZWN0QS5oZWlnaHQsIHJlY3RCLnkgKyByZWN0Qi5oZWlnaHQpIC0gTWF0aC5tYXgocmVjdEEueSwgcmVjdEIueSkpO1xuICAgIHJldHVybiBNYXRoLmNlaWwoeE92ZXJsYXAgKiB5T3ZlcmxhcCk7XG59O1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmNvbnN0IGlzUmVjdE9iamVjdCA9IChvYmopID0+IGlzTnVtZXJpYyhvYmoud2lkdGgpICYmIGlzTnVtZXJpYyhvYmouaGVpZ2h0KSAmJiBpc051bWVyaWMob2JqLngpICYmIGlzTnVtZXJpYyhvYmoueSk7XG4vKiBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuY29uc3QgaXNOdW1lcmljID0gKG4pID0+ICFpc05hTihuKSAmJiBpc0Zpbml0ZShuKTtcbi8vIHVzZWQgZm9yIGExMXkga2V5IGJvYXJkIGNvbnRyb2xzIGZvciBub2RlcyBhbmQgZWRnZXNcbmNvbnN0IGRldldhcm4gPSAoaWQsIG1lc3NhZ2UpID0+IHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGBbUmVhY3QgRmxvd106ICR7bWVzc2FnZX0gSGVscDogaHR0cHM6Ly9yZWFjdGZsb3cuZGV2L2Vycm9yIyR7aWR9YCk7XG4gICAgfVxufTtcbmNvbnN0IHNuYXBQb3NpdGlvbiA9IChwb3NpdGlvbiwgc25hcEdyaWQgPSBbMSwgMV0pID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgICB4OiBzbmFwR3JpZFswXSAqIE1hdGgucm91bmQocG9zaXRpb24ueCAvIHNuYXBHcmlkWzBdKSxcbiAgICAgICAgeTogc25hcEdyaWRbMV0gKiBNYXRoLnJvdW5kKHBvc2l0aW9uLnkgLyBzbmFwR3JpZFsxXSksXG4gICAgfTtcbn07XG5jb25zdCBwb2ludFRvUmVuZGVyZXJQb2ludCA9ICh7IHgsIHkgfSwgW3R4LCB0eSwgdFNjYWxlXSwgc25hcFRvR3JpZCA9IGZhbHNlLCBzbmFwR3JpZCA9IFsxLCAxXSkgPT4ge1xuICAgIGNvbnN0IHBvc2l0aW9uID0ge1xuICAgICAgICB4OiAoeCAtIHR4KSAvIHRTY2FsZSxcbiAgICAgICAgeTogKHkgLSB0eSkgLyB0U2NhbGUsXG4gICAgfTtcbiAgICByZXR1cm4gc25hcFRvR3JpZCA/IHNuYXBQb3NpdGlvbihwb3NpdGlvbiwgc25hcEdyaWQpIDogcG9zaXRpb247XG59O1xuY29uc3QgcmVuZGVyZXJQb2ludFRvUG9pbnQgPSAoeyB4LCB5IH0sIFt0eCwgdHksIHRTY2FsZV0pID0+IHtcbiAgICByZXR1cm4ge1xuICAgICAgICB4OiB4ICogdFNjYWxlICsgdHgsXG4gICAgICAgIHk6IHkgKiB0U2NhbGUgKyB0eSxcbiAgICB9O1xufTtcbi8qKlxuICogUmV0dXJucyBhIHZpZXdwb3J0IHRoYXQgZW5jbG9zZXMgdGhlIGdpdmVuIGJvdW5kcyB3aXRoIG9wdGlvbmFsIHBhZGRpbmcuXG4gKiBAcHVibGljXG4gKiBAcmVtYXJrcyBZb3UgY2FuIGRldGVybWluZSBib3VuZHMgb2Ygbm9kZXMgd2l0aCB7QGxpbmsgZ2V0Tm9kZXNCb3VuZHN9IGFuZCB7QGxpbmsgZ2V0Qm91bmRzT2ZSZWN0c31cbiAqIEBwYXJhbSBib3VuZHMgLSBCb3VuZHMgdG8gZml0IGluc2lkZSB2aWV3cG9ydFxuICogQHBhcmFtIHdpZHRoIC0gV2lkdGggb2YgdGhlIHZpZXdwb3J0XG4gKiBAcGFyYW0gaGVpZ2h0ICAtIEhlaWdodCBvZiB0aGUgdmlld3BvcnRcbiAqIEBwYXJhbSBtaW5ab29tIC0gTWluaW11bSB6b29tIGxldmVsIG9mIHRoZSByZXN1bHRpbmcgdmlld3BvcnRcbiAqIEBwYXJhbSBtYXhab29tIC0gTWF4aW11bSB6b29tIGxldmVsIG9mIHRoZSByZXN1bHRpbmcgdmlld3BvcnRcbiAqIEBwYXJhbSBwYWRkaW5nIC0gT3B0aW9uYWwgcGFkZGluZyBhcm91bmQgdGhlIGJvdW5kc1xuICogQHJldHVybnMgQSB0cmFuc2Zvcm5lZCB7QGxpbmsgVmlld3BvcnR9IHRoYXQgZW5jbG9zZXMgdGhlIGdpdmVuIGJvdW5kcyB3aGljaCB5b3UgY2FuIHBhc3MgdG8gZS5nLiB7QGxpbmsgc2V0Vmlld3BvcnR9XG4gKiBAZXhhbXBsZVxuICogY29uc3QgeyB4LCB5LCB6b29tIH0gPSBnZXRWaWV3cG9ydEZvckJvdW5kcyhcbiAqeyB4OiAwLCB5OiAwLCB3aWR0aDogMTAwLCBoZWlnaHQ6IDEwMH0sXG4gKjEyMDAsIDgwMCwgMC41LCAyKTtcbiAqL1xuY29uc3QgZ2V0Vmlld3BvcnRGb3JCb3VuZHMgPSAoYm91bmRzLCB3aWR0aCwgaGVpZ2h0LCBtaW5ab29tLCBtYXhab29tLCBwYWRkaW5nKSA9PiB7XG4gICAgY29uc3QgeFpvb20gPSB3aWR0aCAvIChib3VuZHMud2lkdGggKiAoMSArIHBhZGRpbmcpKTtcbiAgICBjb25zdCB5Wm9vbSA9IGhlaWdodCAvIChib3VuZHMuaGVpZ2h0ICogKDEgKyBwYWRkaW5nKSk7XG4gICAgY29uc3Qgem9vbSA9IE1hdGgubWluKHhab29tLCB5Wm9vbSk7XG4gICAgY29uc3QgY2xhbXBlZFpvb20gPSBjbGFtcCh6b29tLCBtaW5ab29tLCBtYXhab29tKTtcbiAgICBjb25zdCBib3VuZHNDZW50ZXJYID0gYm91bmRzLnggKyBib3VuZHMud2lkdGggLyAyO1xuICAgIGNvbnN0IGJvdW5kc0NlbnRlclkgPSBib3VuZHMueSArIGJvdW5kcy5oZWlnaHQgLyAyO1xuICAgIGNvbnN0IHggPSB3aWR0aCAvIDIgLSBib3VuZHNDZW50ZXJYICogY2xhbXBlZFpvb207XG4gICAgY29uc3QgeSA9IGhlaWdodCAvIDIgLSBib3VuZHNDZW50ZXJZICogY2xhbXBlZFpvb207XG4gICAgcmV0dXJuIHsgeCwgeSwgem9vbTogY2xhbXBlZFpvb20gfTtcbn07XG5jb25zdCBpc01hY09zID0gKCkgPT4gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yPy51c2VyQWdlbnQ/LmluZGV4T2YoJ01hYycpID49IDA7XG5mdW5jdGlvbiBpc0Nvb3JkaW5hdGVFeHRlbnQoZXh0ZW50KSB7XG4gICAgcmV0dXJuIGV4dGVudCAhPT0gdW5kZWZpbmVkICYmIGV4dGVudCAhPT0gJ3BhcmVudCc7XG59XG5mdW5jdGlvbiBnZXROb2RlRGltZW5zaW9ucyhub2RlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6IG5vZGUubWVhc3VyZWQ/LndpZHRoID8/IG5vZGUud2lkdGggPz8gbm9kZS5pbml0aWFsV2lkdGggPz8gMCxcbiAgICAgICAgaGVpZ2h0OiBub2RlLm1lYXN1cmVkPy5oZWlnaHQgPz8gbm9kZS5oZWlnaHQgPz8gbm9kZS5pbml0aWFsSGVpZ2h0ID8/IDAsXG4gICAgfTtcbn1cbmZ1bmN0aW9uIG5vZGVIYXNEaW1lbnNpb25zKG5vZGUpIHtcbiAgICByZXR1cm4gKChub2RlLm1lYXN1cmVkPy53aWR0aCA/PyBub2RlLndpZHRoID8/IG5vZGUuaW5pdGlhbFdpZHRoKSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgIChub2RlLm1lYXN1cmVkPy5oZWlnaHQgPz8gbm9kZS5oZWlnaHQgPz8gbm9kZS5pbml0aWFsSGVpZ2h0KSAhPT0gdW5kZWZpbmVkKTtcbn1cbi8qKlxuICogQ29udmVydCBjaGlsZCBwb3NpdGlvbiB0byBhYm9zbHV0ZSBwb3NpdGlvblxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHBvc2l0aW9uXG4gKiBAcGFyYW0gcGFyZW50SWRcbiAqIEBwYXJhbSBub2RlTG9va3VwXG4gKiBAcGFyYW0gbm9kZU9yaWdpblxuICogQHJldHVybnMgYW4gaW50ZXJuYWwgbm9kZSB3aXRoIGFuIGFic29sdXRlIHBvc2l0aW9uXG4gKi9cbmZ1bmN0aW9uIGV2YWx1YXRlQWJzb2x1dGVQb3NpdGlvbihwb3NpdGlvbiwgZGltZW5zaW9ucyA9IHsgd2lkdGg6IDAsIGhlaWdodDogMCB9LCBwYXJlbnRJZCwgbm9kZUxvb2t1cCwgbm9kZU9yaWdpbikge1xuICAgIGNvbnN0IHBvc2l0aW9uQWJzb2x1dGUgPSB7IC4uLnBvc2l0aW9uIH07XG4gICAgY29uc3QgcGFyZW50ID0gbm9kZUxvb2t1cC5nZXQocGFyZW50SWQpO1xuICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgY29uc3Qgb3JpZ2luID0gcGFyZW50Lm9yaWdpbiB8fCBub2RlT3JpZ2luO1xuICAgICAgICBwb3NpdGlvbkFic29sdXRlLnggKz0gcGFyZW50LmludGVybmFscy5wb3NpdGlvbkFic29sdXRlLnggLSAoZGltZW5zaW9ucy53aWR0aCA/PyAwKSAqIG9yaWdpblswXTtcbiAgICAgICAgcG9zaXRpb25BYnNvbHV0ZS55ICs9IHBhcmVudC5pbnRlcm5hbHMucG9zaXRpb25BYnNvbHV0ZS55IC0gKGRpbWVuc2lvbnMuaGVpZ2h0ID8/IDApICogb3JpZ2luWzFdO1xuICAgIH1cbiAgICByZXR1cm4gcG9zaXRpb25BYnNvbHV0ZTtcbn1cbmZ1bmN0aW9uIGFyZVNldHNFcXVhbChhLCBiKSB7XG4gICAgaWYgKGEuc2l6ZSAhPT0gYi5zaXplKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGEpIHtcbiAgICAgICAgaWYgKCFiLmhhcyhpdGVtKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBnZXRQb2ludGVyUG9zaXRpb24oZXZlbnQsIHsgc25hcEdyaWQgPSBbMCwgMF0sIHNuYXBUb0dyaWQgPSBmYWxzZSwgdHJhbnNmb3JtLCBjb250YWluZXJCb3VuZHMgfSkge1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gZ2V0RXZlbnRQb3NpdGlvbihldmVudCk7XG4gICAgY29uc3QgcG9pbnRlclBvcyA9IHBvaW50VG9SZW5kZXJlclBvaW50KHsgeDogeCAtIChjb250YWluZXJCb3VuZHM/LmxlZnQgPz8gMCksIHk6IHkgLSAoY29udGFpbmVyQm91bmRzPy50b3AgPz8gMCkgfSwgdHJhbnNmb3JtKTtcbiAgICBjb25zdCB7IHg6IHhTbmFwcGVkLCB5OiB5U25hcHBlZCB9ID0gc25hcFRvR3JpZCA/IHNuYXBQb3NpdGlvbihwb2ludGVyUG9zLCBzbmFwR3JpZCkgOiBwb2ludGVyUG9zO1xuICAgIC8vIHdlIG5lZWQgdGhlIHNuYXBwZWQgcG9zaXRpb24gaW4gb3JkZXIgdG8gYmUgYWJsZSB0byBza2lwIHVubmVjZXNzYXJ5IGRyYWcgZXZlbnRzXG4gICAgcmV0dXJuIHtcbiAgICAgICAgeFNuYXBwZWQsXG4gICAgICAgIHlTbmFwcGVkLFxuICAgICAgICAuLi5wb2ludGVyUG9zLFxuICAgIH07XG59XG5jb25zdCBnZXREaW1lbnNpb25zID0gKG5vZGUpID0+ICh7XG4gICAgd2lkdGg6IG5vZGUub2Zmc2V0V2lkdGgsXG4gICAgaGVpZ2h0OiBub2RlLm9mZnNldEhlaWdodCxcbn0pO1xuY29uc3QgZ2V0SG9zdEZvckVsZW1lbnQgPSAoZWxlbWVudCkgPT4gZWxlbWVudD8uZ2V0Um9vdE5vZGU/LigpIHx8IHdpbmRvdz8uZG9jdW1lbnQ7XG5jb25zdCBpbnB1dFRhZ3MgPSBbJ0lOUFVUJywgJ1NFTEVDVCcsICdURVhUQVJFQSddO1xuZnVuY3Rpb24gaXNJbnB1dERPTU5vZGUoZXZlbnQpIHtcbiAgICAvLyB1c2luZyBjb21wb3NlZCBwYXRoIGZvciBoYW5kbGluZyBzaGFkb3cgZG9tXG4gICAgY29uc3QgdGFyZ2V0ID0gKGV2ZW50LmNvbXBvc2VkUGF0aD8uKCk/LlswXSB8fCBldmVudC50YXJnZXQpO1xuICAgIGlmICh0YXJnZXQ/Lm5vZGVUeXBlICE9PSAxIC8qIE5vZGUuRUxFTUVOVF9OT0RFICovKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgaXNJbnB1dCA9IGlucHV0VGFncy5pbmNsdWRlcyh0YXJnZXQubm9kZU5hbWUpIHx8IHRhcmdldC5oYXNBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScpO1xuICAgIC8vIHdoZW4gYW4gaW5wdXQgZmllbGQgaXMgZm9jdXNlZCB3ZSBkb24ndCB3YW50IHRvIHRyaWdnZXIgZGVsZXRpb24gb3IgbW92ZW1lbnQgb2Ygbm9kZXNcbiAgICByZXR1cm4gaXNJbnB1dCB8fCAhIXRhcmdldC5jbG9zZXN0KCcubm9rZXknKTtcbn1cbmNvbnN0IGlzTW91c2VFdmVudCA9IChldmVudCkgPT4gJ2NsaWVudFgnIGluIGV2ZW50O1xuY29uc3QgZ2V0RXZlbnRQb3NpdGlvbiA9IChldmVudCwgYm91bmRzKSA9PiB7XG4gICAgY29uc3QgaXNNb3VzZSA9IGlzTW91c2VFdmVudChldmVudCk7XG4gICAgY29uc3QgZXZ0WCA9IGlzTW91c2UgPyBldmVudC5jbGllbnRYIDogZXZlbnQudG91Y2hlcz8uWzBdLmNsaWVudFg7XG4gICAgY29uc3QgZXZ0WSA9IGlzTW91c2UgPyBldmVudC5jbGllbnRZIDogZXZlbnQudG91Y2hlcz8uWzBdLmNsaWVudFk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogZXZ0WCAtIChib3VuZHM/LmxlZnQgPz8gMCksXG4gICAgICAgIHk6IGV2dFkgLSAoYm91bmRzPy50b3AgPz8gMCksXG4gICAgfTtcbn07XG4vKlxuICogVGhlIGhhbmRsZSBib3VuZHMgYXJlIGNhbGN1bGF0ZWQgcmVsYXRpdmUgdG8gdGhlIG5vZGUgZWxlbWVudC5cbiAqIFdlIHN0b3JlIHRoZW0gaW4gdGhlIGludGVybmFscyBvYmplY3Qgb2YgdGhlIG5vZGUgaW4gb3JkZXIgdG8gYXZvaWRcbiAqIHVubmVjZXNzYXJ5IHJlY2FsY3VsYXRpb25zLlxuICovXG5jb25zdCBnZXRIYW5kbGVCb3VuZHMgPSAodHlwZSwgbm9kZUVsZW1lbnQsIG5vZGVCb3VuZHMsIHpvb20sIG5vZGVJZCkgPT4ge1xuICAgIGNvbnN0IGhhbmRsZXMgPSBub2RlRWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKGAuJHt0eXBlfWApO1xuICAgIGlmICghaGFuZGxlcyB8fCAhaGFuZGxlcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBBcnJheS5mcm9tKGhhbmRsZXMpLm1hcCgoaGFuZGxlKSA9PiB7XG4gICAgICAgIGNvbnN0IGhhbmRsZUJvdW5kcyA9IGhhbmRsZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGlkOiBoYW5kbGUuZ2V0QXR0cmlidXRlKCdkYXRhLWhhbmRsZWlkJyksXG4gICAgICAgICAgICB0eXBlLFxuICAgICAgICAgICAgbm9kZUlkLFxuICAgICAgICAgICAgcG9zaXRpb246IGhhbmRsZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtaGFuZGxlcG9zJyksXG4gICAgICAgICAgICB4OiAoaGFuZGxlQm91bmRzLmxlZnQgLSBub2RlQm91bmRzLmxlZnQpIC8gem9vbSxcbiAgICAgICAgICAgIHk6IChoYW5kbGVCb3VuZHMudG9wIC0gbm9kZUJvdW5kcy50b3ApIC8gem9vbSxcbiAgICAgICAgICAgIC4uLmdldERpbWVuc2lvbnMoaGFuZGxlKSxcbiAgICAgICAgfTtcbiAgICB9KTtcbn07XG5cbmZ1bmN0aW9uIGdldEJlemllckVkZ2VDZW50ZXIoeyBzb3VyY2VYLCBzb3VyY2VZLCB0YXJnZXRYLCB0YXJnZXRZLCBzb3VyY2VDb250cm9sWCwgc291cmNlQ29udHJvbFksIHRhcmdldENvbnRyb2xYLCB0YXJnZXRDb250cm9sWSwgfSkge1xuICAgIC8qXG4gICAgICogY3ViaWMgYmV6aWVyIHQ9MC41IG1pZCBwb2ludCwgbm90IHRoZSBhY3R1YWwgbWlkIHBvaW50LCBidXQgZWFzeSB0byBjYWxjdWxhdGVcbiAgICAgKiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy82NzUxNjEwMS9ob3ctdG8tZmluZC1kaXN0YW5jZS1taWQtcG9pbnQtb2YtYmV6aWVyLWN1cnZlXG4gICAgICovXG4gICAgY29uc3QgY2VudGVyWCA9IHNvdXJjZVggKiAwLjEyNSArIHNvdXJjZUNvbnRyb2xYICogMC4zNzUgKyB0YXJnZXRDb250cm9sWCAqIDAuMzc1ICsgdGFyZ2V0WCAqIDAuMTI1O1xuICAgIGNvbnN0IGNlbnRlclkgPSBzb3VyY2VZICogMC4xMjUgKyBzb3VyY2VDb250cm9sWSAqIDAuMzc1ICsgdGFyZ2V0Q29udHJvbFkgKiAwLjM3NSArIHRhcmdldFkgKiAwLjEyNTtcbiAgICBjb25zdCBvZmZzZXRYID0gTWF0aC5hYnMoY2VudGVyWCAtIHNvdXJjZVgpO1xuICAgIGNvbnN0IG9mZnNldFkgPSBNYXRoLmFicyhjZW50ZXJZIC0gc291cmNlWSk7XG4gICAgcmV0dXJuIFtjZW50ZXJYLCBjZW50ZXJZLCBvZmZzZXRYLCBvZmZzZXRZXTtcbn1cbmZ1bmN0aW9uIGNhbGN1bGF0ZUNvbnRyb2xPZmZzZXQoZGlzdGFuY2UsIGN1cnZhdHVyZSkge1xuICAgIGlmIChkaXN0YW5jZSA+PSAwKSB7XG4gICAgICAgIHJldHVybiAwLjUgKiBkaXN0YW5jZTtcbiAgICB9XG4gICAgcmV0dXJuIGN1cnZhdHVyZSAqIDI1ICogTWF0aC5zcXJ0KC1kaXN0YW5jZSk7XG59XG5mdW5jdGlvbiBnZXRDb250cm9sV2l0aEN1cnZhdHVyZSh7IHBvcywgeDEsIHkxLCB4MiwgeTIsIGMgfSkge1xuICAgIHN3aXRjaCAocG9zKSB7XG4gICAgICAgIGNhc2UgUG9zaXRpb24uTGVmdDpcbiAgICAgICAgICAgIHJldHVybiBbeDEgLSBjYWxjdWxhdGVDb250cm9sT2Zmc2V0KHgxIC0geDIsIGMpLCB5MV07XG4gICAgICAgIGNhc2UgUG9zaXRpb24uUmlnaHQ6XG4gICAgICAgICAgICByZXR1cm4gW3gxICsgY2FsY3VsYXRlQ29udHJvbE9mZnNldCh4MiAtIHgxLCBjKSwgeTFdO1xuICAgICAgICBjYXNlIFBvc2l0aW9uLlRvcDpcbiAgICAgICAgICAgIHJldHVybiBbeDEsIHkxIC0gY2FsY3VsYXRlQ29udHJvbE9mZnNldCh5MSAtIHkyLCBjKV07XG4gICAgICAgIGNhc2UgUG9zaXRpb24uQm90dG9tOlxuICAgICAgICAgICAgcmV0dXJuIFt4MSwgeTEgKyBjYWxjdWxhdGVDb250cm9sT2Zmc2V0KHkyIC0geTEsIGMpXTtcbiAgICB9XG59XG4vKipcbiAqIFRoZSBgZ2V0QmV6aWVyUGF0aGAgdXRpbCByZXR1cm5zIGV2ZXJ5dGhpbmcgeW91IG5lZWQgdG8gcmVuZGVyIGEgYmV6aWVyIGVkZ2VcbiAqYmV0d2VlbiB0d28gbm9kZXMuXG4gKiBAcHVibGljXG4gKiBAcGFyYW0gcGFyYW1zLnNvdXJjZVggLSBUaGUgeCBwb3NpdGlvbiBvZiB0aGUgc291cmNlIGhhbmRsZVxuICogQHBhcmFtIHBhcmFtcy5zb3VyY2VZIC0gVGhlIHkgcG9zaXRpb24gb2YgdGhlIHNvdXJjZSBoYW5kbGVcbiAqIEBwYXJhbSBwYXJhbXMuc291cmNlUG9zaXRpb24gLSBUaGUgcG9zaXRpb24gb2YgdGhlIHNvdXJjZSBoYW5kbGUgKGRlZmF1bHQ6IFBvc2l0aW9uLkJvdHRvbSlcbiAqIEBwYXJhbSBwYXJhbXMudGFyZ2V0WCAtIFRoZSB4IHBvc2l0aW9uIG9mIHRoZSB0YXJnZXQgaGFuZGxlXG4gKiBAcGFyYW0gcGFyYW1zLnRhcmdldFkgLSBUaGUgeSBwb3NpdGlvbiBvZiB0aGUgdGFyZ2V0IGhhbmRsZVxuICogQHBhcmFtIHBhcmFtcy50YXJnZXRQb3NpdGlvbiAtIFRoZSBwb3NpdGlvbiBvZiB0aGUgdGFyZ2V0IGhhbmRsZSAoZGVmYXVsdDogUG9zaXRpb24uVG9wKVxuICogQHBhcmFtIHBhcmFtcy5jdXJ2YXR1cmUgLSBUaGUgY3VydmF0dXJlIG9mIHRoZSBiZXppZXIgZWRnZVxuICogQHJldHVybnMgQSBwYXRoIHN0cmluZyB5b3UgY2FuIHVzZSBpbiBhbiBTVkcsIHRoZSBsYWJlbFggYW5kIGxhYmVsWSBwb3NpdGlvbiAoY2VudGVyIG9mIHBhdGgpIGFuZCBvZmZzZXRYLCBvZmZzZXRZIGJldHdlZW4gc291cmNlIGhhbmRsZSBhbmQgbGFiZWxcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogIGNvbnN0IHNvdXJjZSA9IHsgeDogMCwgeTogMjAgfTtcbiAqICBjb25zdCB0YXJnZXQgPSB7IHg6IDE1MCwgeTogMTAwIH07XG4gKlxuICogIGNvbnN0IFtwYXRoLCBsYWJlbFgsIGxhYmVsWSwgb2Zmc2V0WCwgb2Zmc2V0WV0gPSBnZXRCZXppZXJQYXRoKHtcbiAqICAgIHNvdXJjZVg6IHNvdXJjZS54LFxuICogICAgc291cmNlWTogc291cmNlLnksXG4gKiAgICBzb3VyY2VQb3NpdGlvbjogUG9zaXRpb24uUmlnaHQsXG4gKiAgICB0YXJnZXRYOiB0YXJnZXQueCxcbiAqICAgIHRhcmdldFk6IHRhcmdldC55LFxuICogICAgdGFyZ2V0UG9zaXRpb246IFBvc2l0aW9uLkxlZnQsXG4gKn0pO1xuICpgYGBcbiAqXG4gKiBAcmVtYXJrcyBUaGlzIGZ1bmN0aW9uIHJldHVybnMgYSB0dXBsZSAoYWthIGEgZml4ZWQtc2l6ZSBhcnJheSkgdG8gbWFrZSBpdCBlYXNpZXIgdG9cbiAqd29yayB3aXRoIG11bHRpcGxlIGVkZ2UgcGF0aHMgYXQgb25jZS5cbiAqL1xuZnVuY3Rpb24gZ2V0QmV6aWVyUGF0aCh7IHNvdXJjZVgsIHNvdXJjZVksIHNvdXJjZVBvc2l0aW9uID0gUG9zaXRpb24uQm90dG9tLCB0YXJnZXRYLCB0YXJnZXRZLCB0YXJnZXRQb3NpdGlvbiA9IFBvc2l0aW9uLlRvcCwgY3VydmF0dXJlID0gMC4yNSwgfSkge1xuICAgIGNvbnN0IFtzb3VyY2VDb250cm9sWCwgc291cmNlQ29udHJvbFldID0gZ2V0Q29udHJvbFdpdGhDdXJ2YXR1cmUoe1xuICAgICAgICBwb3M6IHNvdXJjZVBvc2l0aW9uLFxuICAgICAgICB4MTogc291cmNlWCxcbiAgICAgICAgeTE6IHNvdXJjZVksXG4gICAgICAgIHgyOiB0YXJnZXRYLFxuICAgICAgICB5MjogdGFyZ2V0WSxcbiAgICAgICAgYzogY3VydmF0dXJlLFxuICAgIH0pO1xuICAgIGNvbnN0IFt0YXJnZXRDb250cm9sWCwgdGFyZ2V0Q29udHJvbFldID0gZ2V0Q29udHJvbFdpdGhDdXJ2YXR1cmUoe1xuICAgICAgICBwb3M6IHRhcmdldFBvc2l0aW9uLFxuICAgICAgICB4MTogdGFyZ2V0WCxcbiAgICAgICAgeTE6IHRhcmdldFksXG4gICAgICAgIHgyOiBzb3VyY2VYLFxuICAgICAgICB5Mjogc291cmNlWSxcbiAgICAgICAgYzogY3VydmF0dXJlLFxuICAgIH0pO1xuICAgIGNvbnN0IFtsYWJlbFgsIGxhYmVsWSwgb2Zmc2V0WCwgb2Zmc2V0WV0gPSBnZXRCZXppZXJFZGdlQ2VudGVyKHtcbiAgICAgICAgc291cmNlWCxcbiAgICAgICAgc291cmNlWSxcbiAgICAgICAgdGFyZ2V0WCxcbiAgICAgICAgdGFyZ2V0WSxcbiAgICAgICAgc291cmNlQ29udHJvbFgsXG4gICAgICAgIHNvdXJjZUNvbnRyb2xZLFxuICAgICAgICB0YXJnZXRDb250cm9sWCxcbiAgICAgICAgdGFyZ2V0Q29udHJvbFksXG4gICAgfSk7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgYE0ke3NvdXJjZVh9LCR7c291cmNlWX0gQyR7c291cmNlQ29udHJvbFh9LCR7c291cmNlQ29udHJvbFl9ICR7dGFyZ2V0Q29udHJvbFh9LCR7dGFyZ2V0Q29udHJvbFl9ICR7dGFyZ2V0WH0sJHt0YXJnZXRZfWAsXG4gICAgICAgIGxhYmVsWCxcbiAgICAgICAgbGFiZWxZLFxuICAgICAgICBvZmZzZXRYLFxuICAgICAgICBvZmZzZXRZLFxuICAgIF07XG59XG5cbi8vIHRoaXMgaXMgdXNlZCBmb3Igc3RyYWlnaHQgZWRnZXMgYW5kIHNpbXBsZSBzbW9vdGhzdGVwIGVkZ2VzIChMVFIsIFJUTCwgQlRULCBUVEIpXG5mdW5jdGlvbiBnZXRFZGdlQ2VudGVyKHsgc291cmNlWCwgc291cmNlWSwgdGFyZ2V0WCwgdGFyZ2V0WSwgfSkge1xuICAgIGNvbnN0IHhPZmZzZXQgPSBNYXRoLmFicyh0YXJnZXRYIC0gc291cmNlWCkgLyAyO1xuICAgIGNvbnN0IGNlbnRlclggPSB0YXJnZXRYIDwgc291cmNlWCA/IHRhcmdldFggKyB4T2Zmc2V0IDogdGFyZ2V0WCAtIHhPZmZzZXQ7XG4gICAgY29uc3QgeU9mZnNldCA9IE1hdGguYWJzKHRhcmdldFkgLSBzb3VyY2VZKSAvIDI7XG4gICAgY29uc3QgY2VudGVyWSA9IHRhcmdldFkgPCBzb3VyY2VZID8gdGFyZ2V0WSArIHlPZmZzZXQgOiB0YXJnZXRZIC0geU9mZnNldDtcbiAgICByZXR1cm4gW2NlbnRlclgsIGNlbnRlclksIHhPZmZzZXQsIHlPZmZzZXRdO1xufVxuZnVuY3Rpb24gZ2V0RWxldmF0ZWRFZGdlWkluZGV4KHsgc291cmNlTm9kZSwgdGFyZ2V0Tm9kZSwgc2VsZWN0ZWQgPSBmYWxzZSwgekluZGV4ID0gMCwgZWxldmF0ZU9uU2VsZWN0ID0gZmFsc2UsIH0pIHtcbiAgICBpZiAoIWVsZXZhdGVPblNlbGVjdCkge1xuICAgICAgICByZXR1cm4gekluZGV4O1xuICAgIH1cbiAgICBjb25zdCBlZGdlT3JDb25uZWN0ZWROb2RlU2VsZWN0ZWQgPSBzZWxlY3RlZCB8fCB0YXJnZXROb2RlLnNlbGVjdGVkIHx8IHNvdXJjZU5vZGUuc2VsZWN0ZWQ7XG4gICAgY29uc3Qgc2VsZWN0ZWRaSW5kZXggPSBNYXRoLm1heChzb3VyY2VOb2RlLmludGVybmFscy56IHx8IDAsIHRhcmdldE5vZGUuaW50ZXJuYWxzLnogfHwgMCwgMTAwMCk7XG4gICAgcmV0dXJuIHpJbmRleCArIChlZGdlT3JDb25uZWN0ZWROb2RlU2VsZWN0ZWQgPyBzZWxlY3RlZFpJbmRleCA6IDApO1xufVxuZnVuY3Rpb24gaXNFZGdlVmlzaWJsZSh7IHNvdXJjZU5vZGUsIHRhcmdldE5vZGUsIHdpZHRoLCBoZWlnaHQsIHRyYW5zZm9ybSB9KSB7XG4gICAgY29uc3QgZWRnZUJveCA9IGdldEJvdW5kc09mQm94ZXMobm9kZVRvQm94KHNvdXJjZU5vZGUpLCBub2RlVG9Cb3godGFyZ2V0Tm9kZSkpO1xuICAgIGlmIChlZGdlQm94LnggPT09IGVkZ2VCb3gueDIpIHtcbiAgICAgICAgZWRnZUJveC54MiArPSAxO1xuICAgIH1cbiAgICBpZiAoZWRnZUJveC55ID09PSBlZGdlQm94LnkyKSB7XG4gICAgICAgIGVkZ2VCb3gueTIgKz0gMTtcbiAgICB9XG4gICAgY29uc3Qgdmlld1JlY3QgPSB7XG4gICAgICAgIHg6IC10cmFuc2Zvcm1bMF0gLyB0cmFuc2Zvcm1bMl0sXG4gICAgICAgIHk6IC10cmFuc2Zvcm1bMV0gLyB0cmFuc2Zvcm1bMl0sXG4gICAgICAgIHdpZHRoOiB3aWR0aCAvIHRyYW5zZm9ybVsyXSxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHQgLyB0cmFuc2Zvcm1bMl0sXG4gICAgfTtcbiAgICByZXR1cm4gZ2V0T3ZlcmxhcHBpbmdBcmVhKHZpZXdSZWN0LCBib3hUb1JlY3QoZWRnZUJveCkpID4gMDtcbn1cbmNvbnN0IGdldEVkZ2VJZCA9ICh7IHNvdXJjZSwgc291cmNlSGFuZGxlLCB0YXJnZXQsIHRhcmdldEhhbmRsZSB9KSA9PiBgeHktZWRnZV9fJHtzb3VyY2V9JHtzb3VyY2VIYW5kbGUgfHwgJyd9LSR7dGFyZ2V0fSR7dGFyZ2V0SGFuZGxlIHx8ICcnfWA7XG5jb25zdCBjb25uZWN0aW9uRXhpc3RzID0gKGVkZ2UsIGVkZ2VzKSA9PiB7XG4gICAgcmV0dXJuIGVkZ2VzLnNvbWUoKGVsKSA9PiBlbC5zb3VyY2UgPT09IGVkZ2Uuc291cmNlICYmXG4gICAgICAgIGVsLnRhcmdldCA9PT0gZWRnZS50YXJnZXQgJiZcbiAgICAgICAgKGVsLnNvdXJjZUhhbmRsZSA9PT0gZWRnZS5zb3VyY2VIYW5kbGUgfHwgKCFlbC5zb3VyY2VIYW5kbGUgJiYgIWVkZ2Uuc291cmNlSGFuZGxlKSkgJiZcbiAgICAgICAgKGVsLnRhcmdldEhhbmRsZSA9PT0gZWRnZS50YXJnZXRIYW5kbGUgfHwgKCFlbC50YXJnZXRIYW5kbGUgJiYgIWVkZ2UudGFyZ2V0SGFuZGxlKSkpO1xufTtcbi8qKlxuICogVGhpcyB1dGlsIGlzIGEgY29udmVuaWVuY2UgZnVuY3Rpb24gdG8gYWRkIGEgbmV3IEVkZ2UgdG8gYW4gYXJyYXkgb2YgZWRnZXMuIEl0IGFsc28gcGVyZm9ybXMgc29tZSB2YWxpZGF0aW9uIHRvIG1ha2Ugc3VyZSB5b3UgZG9uJ3QgYWRkIGFuIGludmFsaWQgZWRnZSBvciBkdXBsaWNhdGUgYW4gZXhpc3Rpbmcgb25lLlxuICogQHB1YmxpY1xuICogQHBhcmFtIGVkZ2VQYXJhbXMgLSBFaXRoZXIgYW4gRWRnZSBvciBhIENvbm5lY3Rpb24geW91IHdhbnQgdG8gYWRkXG4gKiBAcGFyYW0gZWRnZXMgLSAgVGhlIGFycmF5IG9mIGFsbCBjdXJyZW50IGVkZ2VzXG4gKiBAcmV0dXJucyBBIG5ldyBhcnJheSBvZiBlZGdlcyB3aXRoIHRoZSBuZXcgZWRnZSBhZGRlZFxuICpcbiAqIEByZW1hcmtzIElmIGFuIGVkZ2Ugd2l0aCB0aGUgc2FtZSBgdGFyZ2V0YCBhbmQgYHNvdXJjZWAgYWxyZWFkeSBleGlzdHMgKGFuZCB0aGUgc2FtZVxuICpgdGFyZ2V0SGFuZGxlYCBhbmQgYHNvdXJjZUhhbmRsZWAgaWYgdGhvc2UgYXJlIHNldCksIHRoZW4gdGhpcyB1dGlsIHdvbid0IGFkZFxuICphIG5ldyBlZGdlIGV2ZW4gaWYgdGhlIGBpZGAgcHJvcGVydHkgaXMgZGlmZmVyZW50LlxuICpcbiAqL1xuY29uc3QgYWRkRWRnZSA9IChlZGdlUGFyYW1zLCBlZGdlcykgPT4ge1xuICAgIGlmICghZWRnZVBhcmFtcy5zb3VyY2UgfHwgIWVkZ2VQYXJhbXMudGFyZ2V0KSB7XG4gICAgICAgIGRldldhcm4oJzAwNicsIGVycm9yTWVzc2FnZXNbJ2Vycm9yMDA2J10oKSk7XG4gICAgICAgIHJldHVybiBlZGdlcztcbiAgICB9XG4gICAgbGV0IGVkZ2U7XG4gICAgaWYgKGlzRWRnZUJhc2UoZWRnZVBhcmFtcykpIHtcbiAgICAgICAgZWRnZSA9IHsgLi4uZWRnZVBhcmFtcyB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZWRnZSA9IHtcbiAgICAgICAgICAgIC4uLmVkZ2VQYXJhbXMsXG4gICAgICAgICAgICBpZDogZ2V0RWRnZUlkKGVkZ2VQYXJhbXMpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAoY29ubmVjdGlvbkV4aXN0cyhlZGdlLCBlZGdlcykpIHtcbiAgICAgICAgcmV0dXJuIGVkZ2VzO1xuICAgIH1cbiAgICBpZiAoZWRnZS5zb3VyY2VIYW5kbGUgPT09IG51bGwpIHtcbiAgICAgICAgZGVsZXRlIGVkZ2Uuc291cmNlSGFuZGxlO1xuICAgIH1cbiAgICBpZiAoZWRnZS50YXJnZXRIYW5kbGUgPT09IG51bGwpIHtcbiAgICAgICAgZGVsZXRlIGVkZ2UudGFyZ2V0SGFuZGxlO1xuICAgIH1cbiAgICByZXR1cm4gZWRnZXMuY29uY2F0KGVkZ2UpO1xufTtcbi8qKlxuICogQSBoYW5keSB1dGlsaXR5IHRvIHVwZGF0ZSBhbiBleGlzdGluZyBbYEVkZ2VgXSgvYXBpLXJlZmVyZW5jZS90eXBlcy9lZGdlKSB3aXRoIG5ldyBwcm9wZXJ0aWVzLlxuICpUaGlzIHNlYXJjaGVzIHlvdXIgZWRnZSBhcnJheSBmb3IgYW4gZWRnZSB3aXRoIGEgbWF0Y2hpbmcgYGlkYCBhbmQgdXBkYXRlcyBpdHNcbiAqcHJvcGVydGllcyB3aXRoIHRoZSBjb25uZWN0aW9uIHlvdSBwcm92aWRlLlxuICogQHB1YmxpY1xuICogQHBhcmFtIG9sZEVkZ2UgLSBUaGUgZWRnZSB5b3Ugd2FudCB0byB1cGRhdGVcbiAqIEBwYXJhbSBuZXdDb25uZWN0aW9uIC0gVGhlIG5ldyBjb25uZWN0aW9uIHlvdSB3YW50IHRvIHVwZGF0ZSB0aGUgZWRnZSB3aXRoXG4gKiBAcGFyYW0gZWRnZXMgLSBUaGUgYXJyYXkgb2YgYWxsIGN1cnJlbnQgZWRnZXNcbiAqIEBwYXJhbSBvcHRpb25zLnNob3VsZFJlcGxhY2VJZCAtIHNob3VsZCB0aGUgaWQgb2YgdGhlIG9sZCBlZGdlIGJlIHJlcGxhY2VkIHdpdGggdGhlIG5ldyBjb25uZWN0aW9uIGlkXG4gKiBAcmV0dXJucyB0aGUgdXBkYXRlZCBlZGdlcyBhcnJheVxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICpjb25zdCBvblJlY29ubmVjdCA9IHVzZUNhbGxiYWNrKFxuICogIChvbGRFZGdlOiBFZGdlLCBuZXdDb25uZWN0aW9uOiBDb25uZWN0aW9uKSA9PiBzZXRFZGdlcygoZWxzKSA9PiByZWNvbm5lY3RFZGdlKG9sZEVkZ2UsIG5ld0Nvbm5lY3Rpb24sIGVscykpLFtdKTtcbiAqYGBgXG4gKi9cbmNvbnN0IHJlY29ubmVjdEVkZ2UgPSAob2xkRWRnZSwgbmV3Q29ubmVjdGlvbiwgZWRnZXMsIG9wdGlvbnMgPSB7IHNob3VsZFJlcGxhY2VJZDogdHJ1ZSB9KSA9PiB7XG4gICAgY29uc3QgeyBpZDogb2xkRWRnZUlkLCAuLi5yZXN0IH0gPSBvbGRFZGdlO1xuICAgIGlmICghbmV3Q29ubmVjdGlvbi5zb3VyY2UgfHwgIW5ld0Nvbm5lY3Rpb24udGFyZ2V0KSB7XG4gICAgICAgIGRldldhcm4oJzAwNicsIGVycm9yTWVzc2FnZXNbJ2Vycm9yMDA2J10oKSk7XG4gICAgICAgIHJldHVybiBlZGdlcztcbiAgICB9XG4gICAgY29uc3QgZm91bmRFZGdlID0gZWRnZXMuZmluZCgoZSkgPT4gZS5pZCA9PT0gb2xkRWRnZS5pZCk7XG4gICAgaWYgKCFmb3VuZEVkZ2UpIHtcbiAgICAgICAgZGV2V2FybignMDA3JywgZXJyb3JNZXNzYWdlc1snZXJyb3IwMDcnXShvbGRFZGdlSWQpKTtcbiAgICAgICAgcmV0dXJuIGVkZ2VzO1xuICAgIH1cbiAgICAvLyBSZW1vdmUgb2xkIGVkZ2UgYW5kIGNyZWF0ZSB0aGUgbmV3IGVkZ2Ugd2l0aCBwYXJhbWV0ZXJzIG9mIG9sZCBlZGdlLlxuICAgIGNvbnN0IGVkZ2UgPSB7XG4gICAgICAgIC4uLnJlc3QsXG4gICAgICAgIGlkOiBvcHRpb25zLnNob3VsZFJlcGxhY2VJZCA/IGdldEVkZ2VJZChuZXdDb25uZWN0aW9uKSA6IG9sZEVkZ2VJZCxcbiAgICAgICAgc291cmNlOiBuZXdDb25uZWN0aW9uLnNvdXJjZSxcbiAgICAgICAgdGFyZ2V0OiBuZXdDb25uZWN0aW9uLnRhcmdldCxcbiAgICAgICAgc291cmNlSGFuZGxlOiBuZXdDb25uZWN0aW9uLnNvdXJjZUhhbmRsZSxcbiAgICAgICAgdGFyZ2V0SGFuZGxlOiBuZXdDb25uZWN0aW9uLnRhcmdldEhhbmRsZSxcbiAgICB9O1xuICAgIHJldHVybiBlZGdlcy5maWx0ZXIoKGUpID0+IGUuaWQgIT09IG9sZEVkZ2VJZCkuY29uY2F0KGVkZ2UpO1xufTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBzdHJhaWdodCBsaW5lIHBhdGggYmV0d2VlbiB0d28gcG9pbnRzLlxuICogQHB1YmxpY1xuICogQHBhcmFtIHBhcmFtcy5zb3VyY2VYIC0gVGhlIHggcG9zaXRpb24gb2YgdGhlIHNvdXJjZSBoYW5kbGVcbiAqIEBwYXJhbSBwYXJhbXMuc291cmNlWSAtIFRoZSB5IHBvc2l0aW9uIG9mIHRoZSBzb3VyY2UgaGFuZGxlXG4gKiBAcGFyYW0gcGFyYW1zLnRhcmdldFggLSBUaGUgeCBwb3NpdGlvbiBvZiB0aGUgdGFyZ2V0IGhhbmRsZVxuICogQHBhcmFtIHBhcmFtcy50YXJnZXRZIC0gVGhlIHkgcG9zaXRpb24gb2YgdGhlIHRhcmdldCBoYW5kbGVcbiAqIEByZXR1cm5zIEEgcGF0aCBzdHJpbmcgeW91IGNhbiB1c2UgaW4gYW4gU1ZHLCB0aGUgbGFiZWxYIGFuZCBsYWJlbFkgcG9zaXRpb24gKGNlbnRlciBvZiBwYXRoKSBhbmQgb2Zmc2V0WCwgb2Zmc2V0WSBiZXR3ZWVuIHNvdXJjZSBoYW5kbGUgYW5kIGxhYmVsXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqICBjb25zdCBzb3VyY2UgPSB7IHg6IDAsIHk6IDIwIH07XG4gKiAgY29uc3QgdGFyZ2V0ID0geyB4OiAxNTAsIHk6IDEwMCB9O1xuICpcbiAqICBjb25zdCBbcGF0aCwgbGFiZWxYLCBsYWJlbFksIG9mZnNldFgsIG9mZnNldFldID0gZ2V0U3RyYWlnaHRQYXRoKHtcbiAqICAgIHNvdXJjZVg6IHNvdXJjZS54LFxuICogICAgc291cmNlWTogc291cmNlLnksXG4gKiAgICBzb3VyY2VQb3NpdGlvbjogUG9zaXRpb24uUmlnaHQsXG4gKiAgICB0YXJnZXRYOiB0YXJnZXQueCxcbiAqICAgIHRhcmdldFk6IHRhcmdldC55LFxuICogICAgdGFyZ2V0UG9zaXRpb246IFBvc2l0aW9uLkxlZnQsXG4gKiAgfSk7XG4gKiBgYGBcbiAqIEByZW1hcmtzIFRoaXMgZnVuY3Rpb24gcmV0dXJucyBhIHR1cGxlIChha2EgYSBmaXhlZC1zaXplIGFycmF5KSB0byBtYWtlIGl0IGVhc2llciB0byB3b3JrIHdpdGggbXVsdGlwbGUgZWRnZSBwYXRocyBhdCBvbmNlLlxuICovXG5mdW5jdGlvbiBnZXRTdHJhaWdodFBhdGgoeyBzb3VyY2VYLCBzb3VyY2VZLCB0YXJnZXRYLCB0YXJnZXRZLCB9KSB7XG4gICAgY29uc3QgW2xhYmVsWCwgbGFiZWxZLCBvZmZzZXRYLCBvZmZzZXRZXSA9IGdldEVkZ2VDZW50ZXIoe1xuICAgICAgICBzb3VyY2VYLFxuICAgICAgICBzb3VyY2VZLFxuICAgICAgICB0YXJnZXRYLFxuICAgICAgICB0YXJnZXRZLFxuICAgIH0pO1xuICAgIHJldHVybiBbYE0gJHtzb3VyY2VYfSwke3NvdXJjZVl9TCAke3RhcmdldFh9LCR7dGFyZ2V0WX1gLCBsYWJlbFgsIGxhYmVsWSwgb2Zmc2V0WCwgb2Zmc2V0WV07XG59XG5cbmNvbnN0IGhhbmRsZURpcmVjdGlvbnMgPSB7XG4gICAgW1Bvc2l0aW9uLkxlZnRdOiB7IHg6IC0xLCB5OiAwIH0sXG4gICAgW1Bvc2l0aW9uLlJpZ2h0XTogeyB4OiAxLCB5OiAwIH0sXG4gICAgW1Bvc2l0aW9uLlRvcF06IHsgeDogMCwgeTogLTEgfSxcbiAgICBbUG9zaXRpb24uQm90dG9tXTogeyB4OiAwLCB5OiAxIH0sXG59O1xuY29uc3QgZ2V0RGlyZWN0aW9uID0gKHsgc291cmNlLCBzb3VyY2VQb3NpdGlvbiA9IFBvc2l0aW9uLkJvdHRvbSwgdGFyZ2V0LCB9KSA9PiB7XG4gICAgaWYgKHNvdXJjZVBvc2l0aW9uID09PSBQb3NpdGlvbi5MZWZ0IHx8IHNvdXJjZVBvc2l0aW9uID09PSBQb3NpdGlvbi5SaWdodCkge1xuICAgICAgICByZXR1cm4gc291cmNlLnggPCB0YXJnZXQueCA/IHsgeDogMSwgeTogMCB9IDogeyB4OiAtMSwgeTogMCB9O1xuICAgIH1cbiAgICByZXR1cm4gc291cmNlLnkgPCB0YXJnZXQueSA/IHsgeDogMCwgeTogMSB9IDogeyB4OiAwLCB5OiAtMSB9O1xufTtcbmNvbnN0IGRpc3RhbmNlID0gKGEsIGIpID0+IE1hdGguc3FydChNYXRoLnBvdyhiLnggLSBhLngsIDIpICsgTWF0aC5wb3coYi55IC0gYS55LCAyKSk7XG4vKlxuICogaXRoIHRoaXMgZnVuY3Rpb24gd2UgdHJ5IHRvIG1pbWljIGEgb3J0aG9nb25hbCBlZGdlIHJvdXRpbmcgYmVoYXZpb3VyXG4gKiBJdCdzIG5vdCBhcyBnb29kIGFzIGEgcmVhbCBvcnRob2dvbmFsIGVkZ2Ugcm91dGluZyBidXQgaXQncyBmYXN0ZXIgYW5kIGdvb2QgZW5vdWdoIGFzIGEgZGVmYXVsdCBmb3Igc3RlcCBhbmQgc21vb3RoIHN0ZXAgZWRnZXNcbiAqL1xuZnVuY3Rpb24gZ2V0UG9pbnRzKHsgc291cmNlLCBzb3VyY2VQb3NpdGlvbiA9IFBvc2l0aW9uLkJvdHRvbSwgdGFyZ2V0LCB0YXJnZXRQb3NpdGlvbiA9IFBvc2l0aW9uLlRvcCwgY2VudGVyLCBvZmZzZXQsIH0pIHtcbiAgICBjb25zdCBzb3VyY2VEaXIgPSBoYW5kbGVEaXJlY3Rpb25zW3NvdXJjZVBvc2l0aW9uXTtcbiAgICBjb25zdCB0YXJnZXREaXIgPSBoYW5kbGVEaXJlY3Rpb25zW3RhcmdldFBvc2l0aW9uXTtcbiAgICBjb25zdCBzb3VyY2VHYXBwZWQgPSB7IHg6IHNvdXJjZS54ICsgc291cmNlRGlyLnggKiBvZmZzZXQsIHk6IHNvdXJjZS55ICsgc291cmNlRGlyLnkgKiBvZmZzZXQgfTtcbiAgICBjb25zdCB0YXJnZXRHYXBwZWQgPSB7IHg6IHRhcmdldC54ICsgdGFyZ2V0RGlyLnggKiBvZmZzZXQsIHk6IHRhcmdldC55ICsgdGFyZ2V0RGlyLnkgKiBvZmZzZXQgfTtcbiAgICBjb25zdCBkaXIgPSBnZXREaXJlY3Rpb24oe1xuICAgICAgICBzb3VyY2U6IHNvdXJjZUdhcHBlZCxcbiAgICAgICAgc291cmNlUG9zaXRpb24sXG4gICAgICAgIHRhcmdldDogdGFyZ2V0R2FwcGVkLFxuICAgIH0pO1xuICAgIGNvbnN0IGRpckFjY2Vzc29yID0gZGlyLnggIT09IDAgPyAneCcgOiAneSc7XG4gICAgY29uc3QgY3VyckRpciA9IGRpcltkaXJBY2Nlc3Nvcl07XG4gICAgbGV0IHBvaW50cyA9IFtdO1xuICAgIGxldCBjZW50ZXJYLCBjZW50ZXJZO1xuICAgIGNvbnN0IHNvdXJjZUdhcE9mZnNldCA9IHsgeDogMCwgeTogMCB9O1xuICAgIGNvbnN0IHRhcmdldEdhcE9mZnNldCA9IHsgeDogMCwgeTogMCB9O1xuICAgIGNvbnN0IFtkZWZhdWx0Q2VudGVyWCwgZGVmYXVsdENlbnRlclksIGRlZmF1bHRPZmZzZXRYLCBkZWZhdWx0T2Zmc2V0WV0gPSBnZXRFZGdlQ2VudGVyKHtcbiAgICAgICAgc291cmNlWDogc291cmNlLngsXG4gICAgICAgIHNvdXJjZVk6IHNvdXJjZS55LFxuICAgICAgICB0YXJnZXRYOiB0YXJnZXQueCxcbiAgICAgICAgdGFyZ2V0WTogdGFyZ2V0LnksXG4gICAgfSk7XG4gICAgLy8gb3Bwb3NpdGUgaGFuZGxlIHBvc2l0aW9ucywgZGVmYXVsdCBjYXNlXG4gICAgaWYgKHNvdXJjZURpcltkaXJBY2Nlc3Nvcl0gKiB0YXJnZXREaXJbZGlyQWNjZXNzb3JdID09PSAtMSkge1xuICAgICAgICBjZW50ZXJYID0gY2VudGVyLnggPz8gZGVmYXVsdENlbnRlclg7XG4gICAgICAgIGNlbnRlclkgPSBjZW50ZXIueSA/PyBkZWZhdWx0Q2VudGVyWTtcbiAgICAgICAgLypcbiAgICAgICAgICogICAgLS0tPlxuICAgICAgICAgKiAgICB8XG4gICAgICAgICAqID4tLS1cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IHZlcnRpY2FsU3BsaXQgPSBbXG4gICAgICAgICAgICB7IHg6IGNlbnRlclgsIHk6IHNvdXJjZUdhcHBlZC55IH0sXG4gICAgICAgICAgICB7IHg6IGNlbnRlclgsIHk6IHRhcmdldEdhcHBlZC55IH0sXG4gICAgICAgIF07XG4gICAgICAgIC8qXG4gICAgICAgICAqICAgIHxcbiAgICAgICAgICogIC0tLVxuICAgICAgICAgKiAgfFxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgaG9yaXpvbnRhbFNwbGl0ID0gW1xuICAgICAgICAgICAgeyB4OiBzb3VyY2VHYXBwZWQueCwgeTogY2VudGVyWSB9LFxuICAgICAgICAgICAgeyB4OiB0YXJnZXRHYXBwZWQueCwgeTogY2VudGVyWSB9LFxuICAgICAgICBdO1xuICAgICAgICBpZiAoc291cmNlRGlyW2RpckFjY2Vzc29yXSA9PT0gY3VyckRpcikge1xuICAgICAgICAgICAgcG9pbnRzID0gZGlyQWNjZXNzb3IgPT09ICd4JyA/IHZlcnRpY2FsU3BsaXQgOiBob3Jpem9udGFsU3BsaXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwb2ludHMgPSBkaXJBY2Nlc3NvciA9PT0gJ3gnID8gaG9yaXpvbnRhbFNwbGl0IDogdmVydGljYWxTcGxpdDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gc291cmNlVGFyZ2V0IG1lYW5zIHdlIHRha2UgeCBmcm9tIHNvdXJjZSBhbmQgeSBmcm9tIHRhcmdldCwgdGFyZ2V0U291cmNlIGlzIHRoZSBvcHBvc2l0ZVxuICAgICAgICBjb25zdCBzb3VyY2VUYXJnZXQgPSBbeyB4OiBzb3VyY2VHYXBwZWQueCwgeTogdGFyZ2V0R2FwcGVkLnkgfV07XG4gICAgICAgIGNvbnN0IHRhcmdldFNvdXJjZSA9IFt7IHg6IHRhcmdldEdhcHBlZC54LCB5OiBzb3VyY2VHYXBwZWQueSB9XTtcbiAgICAgICAgLy8gdGhpcyBoYW5kbGVzIGVkZ2VzIHdpdGggc2FtZSBoYW5kbGUgcG9zaXRpb25zXG4gICAgICAgIGlmIChkaXJBY2Nlc3NvciA9PT0gJ3gnKSB7XG4gICAgICAgICAgICBwb2ludHMgPSBzb3VyY2VEaXIueCA9PT0gY3VyckRpciA/IHRhcmdldFNvdXJjZSA6IHNvdXJjZVRhcmdldDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBvaW50cyA9IHNvdXJjZURpci55ID09PSBjdXJyRGlyID8gc291cmNlVGFyZ2V0IDogdGFyZ2V0U291cmNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzb3VyY2VQb3NpdGlvbiA9PT0gdGFyZ2V0UG9zaXRpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IGRpZmYgPSBNYXRoLmFicyhzb3VyY2VbZGlyQWNjZXNzb3JdIC0gdGFyZ2V0W2RpckFjY2Vzc29yXSk7XG4gICAgICAgICAgICAvLyBpZiBhbiBlZGdlIGdvZXMgZnJvbSByaWdodCB0byByaWdodCBmb3IgZXhhbXBsZSAoc291cmNlUG9zaXRpb24gPT09IHRhcmdldFBvc2l0aW9uKSBhbmQgdGhlIGRpc3RhbmNlIGJldHdlZW4gc291cmNlLnggYW5kIHRhcmdldC54IGlzIGxlc3MgdGhhbiB0aGUgb2Zmc2V0LCB0aGUgYWRkZWQgcG9pbnQgYW5kIHRoZSBnYXBwZWQgc291cmNlL3RhcmdldCB3aWxsIG92ZXJsYXAuIFRoaXMgbGVhZHMgdG8gYSB3ZWlyZCBlZGdlIHBhdGguIFRvIGF2b2lkIHRoaXMgd2UgYWRkIGEgZ2FwT2Zmc2V0IHRvIHRoZSBzb3VyY2UvdGFyZ2V0XG4gICAgICAgICAgICBpZiAoZGlmZiA8PSBvZmZzZXQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBnYXBPZmZzZXQgPSBNYXRoLm1pbihvZmZzZXQgLSAxLCBvZmZzZXQgLSBkaWZmKTtcbiAgICAgICAgICAgICAgICBpZiAoc291cmNlRGlyW2RpckFjY2Vzc29yXSA9PT0gY3VyckRpcikge1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2VHYXBPZmZzZXRbZGlyQWNjZXNzb3JdID0gKHNvdXJjZUdhcHBlZFtkaXJBY2Nlc3Nvcl0gPiBzb3VyY2VbZGlyQWNjZXNzb3JdID8gLTEgOiAxKSAqIGdhcE9mZnNldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldEdhcE9mZnNldFtkaXJBY2Nlc3Nvcl0gPSAodGFyZ2V0R2FwcGVkW2RpckFjY2Vzc29yXSA+IHRhcmdldFtkaXJBY2Nlc3Nvcl0gPyAtMSA6IDEpICogZ2FwT2Zmc2V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyB0aGVzZSBhcmUgY29uZGl0aW9ucyBmb3IgaGFuZGxpbmcgbWl4ZWQgaGFuZGxlIHBvc2l0aW9ucyBsaWtlIFJpZ2h0IC0+IEJvdHRvbSBmb3IgZXhhbXBsZVxuICAgICAgICBpZiAoc291cmNlUG9zaXRpb24gIT09IHRhcmdldFBvc2l0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCBkaXJBY2Nlc3Nvck9wcG9zaXRlID0gZGlyQWNjZXNzb3IgPT09ICd4JyA/ICd5JyA6ICd4JztcbiAgICAgICAgICAgIGNvbnN0IGlzU2FtZURpciA9IHNvdXJjZURpcltkaXJBY2Nlc3Nvcl0gPT09IHRhcmdldERpcltkaXJBY2Nlc3Nvck9wcG9zaXRlXTtcbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZUd0VGFyZ2V0T3BwbyA9IHNvdXJjZUdhcHBlZFtkaXJBY2Nlc3Nvck9wcG9zaXRlXSA+IHRhcmdldEdhcHBlZFtkaXJBY2Nlc3Nvck9wcG9zaXRlXTtcbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZUx0VGFyZ2V0T3BwbyA9IHNvdXJjZUdhcHBlZFtkaXJBY2Nlc3Nvck9wcG9zaXRlXSA8IHRhcmdldEdhcHBlZFtkaXJBY2Nlc3Nvck9wcG9zaXRlXTtcbiAgICAgICAgICAgIGNvbnN0IGZsaXBTb3VyY2VUYXJnZXQgPSAoc291cmNlRGlyW2RpckFjY2Vzc29yXSA9PT0gMSAmJiAoKCFpc1NhbWVEaXIgJiYgc291cmNlR3RUYXJnZXRPcHBvKSB8fCAoaXNTYW1lRGlyICYmIHNvdXJjZUx0VGFyZ2V0T3BwbykpKSB8fFxuICAgICAgICAgICAgICAgIChzb3VyY2VEaXJbZGlyQWNjZXNzb3JdICE9PSAxICYmICgoIWlzU2FtZURpciAmJiBzb3VyY2VMdFRhcmdldE9wcG8pIHx8IChpc1NhbWVEaXIgJiYgc291cmNlR3RUYXJnZXRPcHBvKSkpO1xuICAgICAgICAgICAgaWYgKGZsaXBTb3VyY2VUYXJnZXQpIHtcbiAgICAgICAgICAgICAgICBwb2ludHMgPSBkaXJBY2Nlc3NvciA9PT0gJ3gnID8gc291cmNlVGFyZ2V0IDogdGFyZ2V0U291cmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNvdXJjZUdhcFBvaW50ID0geyB4OiBzb3VyY2VHYXBwZWQueCArIHNvdXJjZUdhcE9mZnNldC54LCB5OiBzb3VyY2VHYXBwZWQueSArIHNvdXJjZUdhcE9mZnNldC55IH07XG4gICAgICAgIGNvbnN0IHRhcmdldEdhcFBvaW50ID0geyB4OiB0YXJnZXRHYXBwZWQueCArIHRhcmdldEdhcE9mZnNldC54LCB5OiB0YXJnZXRHYXBwZWQueSArIHRhcmdldEdhcE9mZnNldC55IH07XG4gICAgICAgIGNvbnN0IG1heFhEaXN0YW5jZSA9IE1hdGgubWF4KE1hdGguYWJzKHNvdXJjZUdhcFBvaW50LnggLSBwb2ludHNbMF0ueCksIE1hdGguYWJzKHRhcmdldEdhcFBvaW50LnggLSBwb2ludHNbMF0ueCkpO1xuICAgICAgICBjb25zdCBtYXhZRGlzdGFuY2UgPSBNYXRoLm1heChNYXRoLmFicyhzb3VyY2VHYXBQb2ludC55IC0gcG9pbnRzWzBdLnkpLCBNYXRoLmFicyh0YXJnZXRHYXBQb2ludC55IC0gcG9pbnRzWzBdLnkpKTtcbiAgICAgICAgLy8gd2Ugd2FudCB0byBwbGFjZSB0aGUgbGFiZWwgb24gdGhlIGxvbmdlc3Qgc2VnbWVudCBvZiB0aGUgZWRnZVxuICAgICAgICBpZiAobWF4WERpc3RhbmNlID49IG1heFlEaXN0YW5jZSkge1xuICAgICAgICAgICAgY2VudGVyWCA9IChzb3VyY2VHYXBQb2ludC54ICsgdGFyZ2V0R2FwUG9pbnQueCkgLyAyO1xuICAgICAgICAgICAgY2VudGVyWSA9IHBvaW50c1swXS55O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2VudGVyWCA9IHBvaW50c1swXS54O1xuICAgICAgICAgICAgY2VudGVyWSA9IChzb3VyY2VHYXBQb2ludC55ICsgdGFyZ2V0R2FwUG9pbnQueSkgLyAyO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHBhdGhQb2ludHMgPSBbXG4gICAgICAgIHNvdXJjZSxcbiAgICAgICAgeyB4OiBzb3VyY2VHYXBwZWQueCArIHNvdXJjZUdhcE9mZnNldC54LCB5OiBzb3VyY2VHYXBwZWQueSArIHNvdXJjZUdhcE9mZnNldC55IH0sXG4gICAgICAgIC4uLnBvaW50cyxcbiAgICAgICAgeyB4OiB0YXJnZXRHYXBwZWQueCArIHRhcmdldEdhcE9mZnNldC54LCB5OiB0YXJnZXRHYXBwZWQueSArIHRhcmdldEdhcE9mZnNldC55IH0sXG4gICAgICAgIHRhcmdldCxcbiAgICBdO1xuICAgIHJldHVybiBbcGF0aFBvaW50cywgY2VudGVyWCwgY2VudGVyWSwgZGVmYXVsdE9mZnNldFgsIGRlZmF1bHRPZmZzZXRZXTtcbn1cbmZ1bmN0aW9uIGdldEJlbmQoYSwgYiwgYywgc2l6ZSkge1xuICAgIGNvbnN0IGJlbmRTaXplID0gTWF0aC5taW4oZGlzdGFuY2UoYSwgYikgLyAyLCBkaXN0YW5jZShiLCBjKSAvIDIsIHNpemUpO1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gYjtcbiAgICAvLyBubyBiZW5kXG4gICAgaWYgKChhLnggPT09IHggJiYgeCA9PT0gYy54KSB8fCAoYS55ID09PSB5ICYmIHkgPT09IGMueSkpIHtcbiAgICAgICAgcmV0dXJuIGBMJHt4fSAke3l9YDtcbiAgICB9XG4gICAgLy8gZmlyc3Qgc2VnbWVudCBpcyBob3Jpem9udGFsXG4gICAgaWYgKGEueSA9PT0geSkge1xuICAgICAgICBjb25zdCB4RGlyID0gYS54IDwgYy54ID8gLTEgOiAxO1xuICAgICAgICBjb25zdCB5RGlyID0gYS55IDwgYy55ID8gMSA6IC0xO1xuICAgICAgICByZXR1cm4gYEwgJHt4ICsgYmVuZFNpemUgKiB4RGlyfSwke3l9USAke3h9LCR7eX0gJHt4fSwke3kgKyBiZW5kU2l6ZSAqIHlEaXJ9YDtcbiAgICB9XG4gICAgY29uc3QgeERpciA9IGEueCA8IGMueCA/IDEgOiAtMTtcbiAgICBjb25zdCB5RGlyID0gYS55IDwgYy55ID8gLTEgOiAxO1xuICAgIHJldHVybiBgTCAke3h9LCR7eSArIGJlbmRTaXplICogeURpcn1RICR7eH0sJHt5fSAke3ggKyBiZW5kU2l6ZSAqIHhEaXJ9LCR7eX1gO1xufVxuLyoqXG4gKiBUaGUgYGdldFNtb290aFN0ZXBQYXRoYCB1dGlsIHJldHVybnMgZXZlcnl0aGluZyB5b3UgbmVlZCB0byByZW5kZXIgYSBzdGVwcGVkIHBhdGhcbiAqYmV0d2VlbiB0d28gbm9kZXMuIFRoZSBgYm9yZGVyUmFkaXVzYCBwcm9wZXJ0eSBjYW4gYmUgdXNlZCB0byBjaG9vc2UgaG93IHJvdW5kZWRcbiAqdGhlIGNvcm5lcnMgb2YgdGhvc2Ugc3RlcHMgYXJlLlxuICogQHB1YmxpY1xuICogQHBhcmFtIHBhcmFtcy5zb3VyY2VYIC0gVGhlIHggcG9zaXRpb24gb2YgdGhlIHNvdXJjZSBoYW5kbGVcbiAqIEBwYXJhbSBwYXJhbXMuc291cmNlWSAtIFRoZSB5IHBvc2l0aW9uIG9mIHRoZSBzb3VyY2UgaGFuZGxlXG4gKiBAcGFyYW0gcGFyYW1zLnNvdXJjZVBvc2l0aW9uIC0gVGhlIHBvc2l0aW9uIG9mIHRoZSBzb3VyY2UgaGFuZGxlIChkZWZhdWx0OiBQb3NpdGlvbi5Cb3R0b20pXG4gKiBAcGFyYW0gcGFyYW1zLnRhcmdldFggLSBUaGUgeCBwb3NpdGlvbiBvZiB0aGUgdGFyZ2V0IGhhbmRsZVxuICogQHBhcmFtIHBhcmFtcy50YXJnZXRZIC0gVGhlIHkgcG9zaXRpb24gb2YgdGhlIHRhcmdldCBoYW5kbGVcbiAqIEBwYXJhbSBwYXJhbXMudGFyZ2V0UG9zaXRpb24gLSBUaGUgcG9zaXRpb24gb2YgdGhlIHRhcmdldCBoYW5kbGUgKGRlZmF1bHQ6IFBvc2l0aW9uLlRvcClcbiAqIEByZXR1cm5zIEEgcGF0aCBzdHJpbmcgeW91IGNhbiB1c2UgaW4gYW4gU1ZHLCB0aGUgbGFiZWxYIGFuZCBsYWJlbFkgcG9zaXRpb24gKGNlbnRlciBvZiBwYXRoKSBhbmQgb2Zmc2V0WCwgb2Zmc2V0WSBiZXR3ZWVuIHNvdXJjZSBoYW5kbGUgYW5kIGxhYmVsXG4gKiBAZXhhbXBsZVxuICogYGBganNcbiAqICBjb25zdCBzb3VyY2UgPSB7IHg6IDAsIHk6IDIwIH07XG4gKiAgY29uc3QgdGFyZ2V0ID0geyB4OiAxNTAsIHk6IDEwMCB9O1xuICpcbiAqICBjb25zdCBbcGF0aCwgbGFiZWxYLCBsYWJlbFksIG9mZnNldFgsIG9mZnNldFldID0gZ2V0U21vb3RoU3RlcFBhdGgoe1xuICogICAgc291cmNlWDogc291cmNlLngsXG4gKiAgICBzb3VyY2VZOiBzb3VyY2UueSxcbiAqICAgIHNvdXJjZVBvc2l0aW9uOiBQb3NpdGlvbi5SaWdodCxcbiAqICAgIHRhcmdldFg6IHRhcmdldC54LFxuICogICAgdGFyZ2V0WTogdGFyZ2V0LnksXG4gKiAgICB0YXJnZXRQb3NpdGlvbjogUG9zaXRpb24uTGVmdCxcbiAqICB9KTtcbiAqIGBgYFxuICogQHJlbWFya3MgVGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgdHVwbGUgKGFrYSBhIGZpeGVkLXNpemUgYXJyYXkpIHRvIG1ha2UgaXQgZWFzaWVyIHRvIHdvcmsgd2l0aCBtdWx0aXBsZSBlZGdlIHBhdGhzIGF0IG9uY2UuXG4gKi9cbmZ1bmN0aW9uIGdldFNtb290aFN0ZXBQYXRoKHsgc291cmNlWCwgc291cmNlWSwgc291cmNlUG9zaXRpb24gPSBQb3NpdGlvbi5Cb3R0b20sIHRhcmdldFgsIHRhcmdldFksIHRhcmdldFBvc2l0aW9uID0gUG9zaXRpb24uVG9wLCBib3JkZXJSYWRpdXMgPSA1LCBjZW50ZXJYLCBjZW50ZXJZLCBvZmZzZXQgPSAyMCwgfSkge1xuICAgIGNvbnN0IFtwb2ludHMsIGxhYmVsWCwgbGFiZWxZLCBvZmZzZXRYLCBvZmZzZXRZXSA9IGdldFBvaW50cyh7XG4gICAgICAgIHNvdXJjZTogeyB4OiBzb3VyY2VYLCB5OiBzb3VyY2VZIH0sXG4gICAgICAgIHNvdXJjZVBvc2l0aW9uLFxuICAgICAgICB0YXJnZXQ6IHsgeDogdGFyZ2V0WCwgeTogdGFyZ2V0WSB9LFxuICAgICAgICB0YXJnZXRQb3NpdGlvbixcbiAgICAgICAgY2VudGVyOiB7IHg6IGNlbnRlclgsIHk6IGNlbnRlclkgfSxcbiAgICAgICAgb2Zmc2V0LFxuICAgIH0pO1xuICAgIGNvbnN0IHBhdGggPSBwb2ludHMucmVkdWNlKChyZXMsIHAsIGkpID0+IHtcbiAgICAgICAgbGV0IHNlZ21lbnQgPSAnJztcbiAgICAgICAgaWYgKGkgPiAwICYmIGkgPCBwb2ludHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgc2VnbWVudCA9IGdldEJlbmQocG9pbnRzW2kgLSAxXSwgcCwgcG9pbnRzW2kgKyAxXSwgYm9yZGVyUmFkaXVzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNlZ21lbnQgPSBgJHtpID09PSAwID8gJ00nIDogJ0wnfSR7cC54fSAke3AueX1gO1xuICAgICAgICB9XG4gICAgICAgIHJlcyArPSBzZWdtZW50O1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH0sICcnKTtcbiAgICByZXR1cm4gW3BhdGgsIGxhYmVsWCwgbGFiZWxZLCBvZmZzZXRYLCBvZmZzZXRZXTtcbn1cblxuZnVuY3Rpb24gaXNOb2RlSW5pdGlhbGl6ZWQobm9kZSkge1xuICAgIHJldHVybiAobm9kZSAmJlxuICAgICAgICAhIShub2RlLmludGVybmFscy5oYW5kbGVCb3VuZHMgfHwgbm9kZS5oYW5kbGVzPy5sZW5ndGgpICYmXG4gICAgICAgICEhKG5vZGUubWVhc3VyZWQud2lkdGggfHwgbm9kZS53aWR0aCB8fCBub2RlLmluaXRpYWxXaWR0aCkpO1xufVxuZnVuY3Rpb24gZ2V0RWRnZVBvc2l0aW9uKHBhcmFtcykge1xuICAgIGNvbnN0IHsgc291cmNlTm9kZSwgdGFyZ2V0Tm9kZSB9ID0gcGFyYW1zO1xuICAgIGlmICghaXNOb2RlSW5pdGlhbGl6ZWQoc291cmNlTm9kZSkgfHwgIWlzTm9kZUluaXRpYWxpemVkKHRhcmdldE5vZGUpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBzb3VyY2VIYW5kbGVCb3VuZHMgPSBzb3VyY2VOb2RlLmludGVybmFscy5oYW5kbGVCb3VuZHMgfHwgdG9IYW5kbGVCb3VuZHMoc291cmNlTm9kZS5oYW5kbGVzKTtcbiAgICBjb25zdCB0YXJnZXRIYW5kbGVCb3VuZHMgPSB0YXJnZXROb2RlLmludGVybmFscy5oYW5kbGVCb3VuZHMgfHwgdG9IYW5kbGVCb3VuZHModGFyZ2V0Tm9kZS5oYW5kbGVzKTtcbiAgICBjb25zdCBzb3VyY2VIYW5kbGUgPSBnZXRIYW5kbGUkMShzb3VyY2VIYW5kbGVCb3VuZHM/LnNvdXJjZSA/PyBbXSwgcGFyYW1zLnNvdXJjZUhhbmRsZSk7XG4gICAgY29uc3QgdGFyZ2V0SGFuZGxlID0gZ2V0SGFuZGxlJDEoXG4gICAgLy8gd2hlbiBjb25uZWN0aW9uIHR5cGUgaXMgbG9vc2Ugd2UgY2FuIGRlZmluZSBhbGwgaGFuZGxlcyBhcyBzb3VyY2VzIGFuZCBjb25uZWN0IHNvdXJjZSAtPiBzb3VyY2VcbiAgICBwYXJhbXMuY29ubmVjdGlvbk1vZGUgPT09IENvbm5lY3Rpb25Nb2RlLlN0cmljdFxuICAgICAgICA/IHRhcmdldEhhbmRsZUJvdW5kcz8udGFyZ2V0ID8/IFtdXG4gICAgICAgIDogKHRhcmdldEhhbmRsZUJvdW5kcz8udGFyZ2V0ID8/IFtdKS5jb25jYXQodGFyZ2V0SGFuZGxlQm91bmRzPy5zb3VyY2UgPz8gW10pLCBwYXJhbXMudGFyZ2V0SGFuZGxlKTtcbiAgICBpZiAoIXNvdXJjZUhhbmRsZSB8fCAhdGFyZ2V0SGFuZGxlKSB7XG4gICAgICAgIHBhcmFtcy5vbkVycm9yPy4oJzAwOCcsIGVycm9yTWVzc2FnZXNbJ2Vycm9yMDA4J10oIXNvdXJjZUhhbmRsZSA/ICdzb3VyY2UnIDogJ3RhcmdldCcsIHtcbiAgICAgICAgICAgIGlkOiBwYXJhbXMuaWQsXG4gICAgICAgICAgICBzb3VyY2VIYW5kbGU6IHBhcmFtcy5zb3VyY2VIYW5kbGUsXG4gICAgICAgICAgICB0YXJnZXRIYW5kbGU6IHBhcmFtcy50YXJnZXRIYW5kbGUsXG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHNvdXJjZVBvc2l0aW9uID0gc291cmNlSGFuZGxlPy5wb3NpdGlvbiB8fCBQb3NpdGlvbi5Cb3R0b207XG4gICAgY29uc3QgdGFyZ2V0UG9zaXRpb24gPSB0YXJnZXRIYW5kbGU/LnBvc2l0aW9uIHx8IFBvc2l0aW9uLlRvcDtcbiAgICBjb25zdCBzb3VyY2UgPSBnZXRIYW5kbGVQb3NpdGlvbihzb3VyY2VOb2RlLCBzb3VyY2VIYW5kbGUsIHNvdXJjZVBvc2l0aW9uKTtcbiAgICBjb25zdCB0YXJnZXQgPSBnZXRIYW5kbGVQb3NpdGlvbih0YXJnZXROb2RlLCB0YXJnZXRIYW5kbGUsIHRhcmdldFBvc2l0aW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzb3VyY2VYOiBzb3VyY2UueCxcbiAgICAgICAgc291cmNlWTogc291cmNlLnksXG4gICAgICAgIHRhcmdldFg6IHRhcmdldC54LFxuICAgICAgICB0YXJnZXRZOiB0YXJnZXQueSxcbiAgICAgICAgc291cmNlUG9zaXRpb24sXG4gICAgICAgIHRhcmdldFBvc2l0aW9uLFxuICAgIH07XG59XG5mdW5jdGlvbiB0b0hhbmRsZUJvdW5kcyhoYW5kbGVzKSB7XG4gICAgaWYgKCFoYW5kbGVzKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBzb3VyY2UgPSBbXTtcbiAgICBjb25zdCB0YXJnZXQgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGhhbmRsZSBvZiBoYW5kbGVzKSB7XG4gICAgICAgIGhhbmRsZS53aWR0aCA9IGhhbmRsZS53aWR0aCA/PyAxO1xuICAgICAgICBoYW5kbGUuaGVpZ2h0ID0gaGFuZGxlLmhlaWdodCA/PyAxO1xuICAgICAgICBpZiAoaGFuZGxlLnR5cGUgPT09ICdzb3VyY2UnKSB7XG4gICAgICAgICAgICBzb3VyY2UucHVzaChoYW5kbGUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGhhbmRsZS50eXBlID09PSAndGFyZ2V0Jykge1xuICAgICAgICAgICAgdGFyZ2V0LnB1c2goaGFuZGxlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBzb3VyY2UsXG4gICAgICAgIHRhcmdldCxcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2V0SGFuZGxlUG9zaXRpb24obm9kZSwgaGFuZGxlLCBmYWxsYmFja1Bvc2l0aW9uID0gUG9zaXRpb24uTGVmdCwgY2VudGVyID0gZmFsc2UpIHtcbiAgICBjb25zdCB4ID0gKGhhbmRsZT8ueCA/PyAwKSArIG5vZGUuaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUueDtcbiAgICBjb25zdCB5ID0gKGhhbmRsZT8ueSA/PyAwKSArIG5vZGUuaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGUueTtcbiAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IGhhbmRsZSA/PyBnZXROb2RlRGltZW5zaW9ucyhub2RlKTtcbiAgICBpZiAoY2VudGVyKSB7XG4gICAgICAgIHJldHVybiB7IHg6IHggKyB3aWR0aCAvIDIsIHk6IHkgKyBoZWlnaHQgLyAyIH07XG4gICAgfVxuICAgIGNvbnN0IHBvc2l0aW9uID0gaGFuZGxlPy5wb3NpdGlvbiA/PyBmYWxsYmFja1Bvc2l0aW9uO1xuICAgIHN3aXRjaCAocG9zaXRpb24pIHtcbiAgICAgICAgY2FzZSBQb3NpdGlvbi5Ub3A6XG4gICAgICAgICAgICByZXR1cm4geyB4OiB4ICsgd2lkdGggLyAyLCB5IH07XG4gICAgICAgIGNhc2UgUG9zaXRpb24uUmlnaHQ6XG4gICAgICAgICAgICByZXR1cm4geyB4OiB4ICsgd2lkdGgsIHk6IHkgKyBoZWlnaHQgLyAyIH07XG4gICAgICAgIGNhc2UgUG9zaXRpb24uQm90dG9tOlxuICAgICAgICAgICAgcmV0dXJuIHsgeDogeCArIHdpZHRoIC8gMiwgeTogeSArIGhlaWdodCB9O1xuICAgICAgICBjYXNlIFBvc2l0aW9uLkxlZnQ6XG4gICAgICAgICAgICByZXR1cm4geyB4LCB5OiB5ICsgaGVpZ2h0IC8gMiB9O1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldEhhbmRsZSQxKGJvdW5kcywgaGFuZGxlSWQpIHtcbiAgICBpZiAoIWJvdW5kcykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gaWYgbm8gaGFuZGxlSWQgaXMgZ2l2ZW4sIHdlIHVzZSB0aGUgZmlyc3QgaGFuZGxlLCBvdGhlcndpc2Ugd2UgY2hlY2sgZm9yIHRoZSBpZFxuICAgIHJldHVybiAoIWhhbmRsZUlkID8gYm91bmRzWzBdIDogYm91bmRzLmZpbmQoKGQpID0+IGQuaWQgPT09IGhhbmRsZUlkKSkgfHwgbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0TWFya2VySWQobWFya2VyLCBpZCkge1xuICAgIGlmICghbWFya2VyKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBtYXJrZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBtYXJrZXI7XG4gICAgfVxuICAgIGNvbnN0IGlkUHJlZml4ID0gaWQgPyBgJHtpZH1fX2AgOiAnJztcbiAgICByZXR1cm4gYCR7aWRQcmVmaXh9JHtPYmplY3Qua2V5cyhtYXJrZXIpXG4gICAgICAgIC5zb3J0KClcbiAgICAgICAgLm1hcCgoa2V5KSA9PiBgJHtrZXl9PSR7bWFya2VyW2tleV19YClcbiAgICAgICAgLmpvaW4oJyYnKX1gO1xufVxuZnVuY3Rpb24gY3JlYXRlTWFya2VySWRzKGVkZ2VzLCB7IGlkLCBkZWZhdWx0Q29sb3IsIGRlZmF1bHRNYXJrZXJTdGFydCwgZGVmYXVsdE1hcmtlckVuZCwgfSkge1xuICAgIGNvbnN0IGlkcyA9IG5ldyBTZXQoKTtcbiAgICByZXR1cm4gZWRnZXNcbiAgICAgICAgLnJlZHVjZSgobWFya2VycywgZWRnZSkgPT4ge1xuICAgICAgICBbZWRnZS5tYXJrZXJTdGFydCB8fCBkZWZhdWx0TWFya2VyU3RhcnQsIGVkZ2UubWFya2VyRW5kIHx8IGRlZmF1bHRNYXJrZXJFbmRdLmZvckVhY2goKG1hcmtlcikgPT4ge1xuICAgICAgICAgICAgaWYgKG1hcmtlciAmJiB0eXBlb2YgbWFya2VyID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1hcmtlcklkID0gZ2V0TWFya2VySWQobWFya2VyLCBpZCk7XG4gICAgICAgICAgICAgICAgaWYgKCFpZHMuaGFzKG1hcmtlcklkKSkge1xuICAgICAgICAgICAgICAgICAgICBtYXJrZXJzLnB1c2goeyBpZDogbWFya2VySWQsIGNvbG9yOiBtYXJrZXIuY29sb3IgfHwgZGVmYXVsdENvbG9yLCAuLi5tYXJrZXIgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlkcy5hZGQobWFya2VySWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBtYXJrZXJzO1xuICAgIH0sIFtdKVxuICAgICAgICAuc29ydCgoYSwgYikgPT4gYS5pZC5sb2NhbGVDb21wYXJlKGIuaWQpKTtcbn1cblxuZnVuY3Rpb24gZ2V0Tm9kZVRvb2xiYXJUcmFuc2Zvcm0obm9kZVJlY3QsIHZpZXdwb3J0LCBwb3NpdGlvbiwgb2Zmc2V0LCBhbGlnbikge1xuICAgIGxldCBhbGlnbm1lbnRPZmZzZXQgPSAwLjU7XG4gICAgaWYgKGFsaWduID09PSAnc3RhcnQnKSB7XG4gICAgICAgIGFsaWdubWVudE9mZnNldCA9IDA7XG4gICAgfVxuICAgIGVsc2UgaWYgKGFsaWduID09PSAnZW5kJykge1xuICAgICAgICBhbGlnbm1lbnRPZmZzZXQgPSAxO1xuICAgIH1cbiAgICAvKlxuICAgICAqIHBvc2l0aW9uID09PSBQb3NpdGlvbi5Ub3BcbiAgICAgKiB3ZSBzZXQgdGhlIHggYW55IHkgcG9zaXRpb24gb2YgdGhlIHRvb2xiYXIgYmFzZWQgb24gdGhlIG5vZGVzIHBvc2l0aW9uXG4gICAgICovXG4gICAgbGV0IHBvcyA9IFtcbiAgICAgICAgKG5vZGVSZWN0LnggKyBub2RlUmVjdC53aWR0aCAqIGFsaWdubWVudE9mZnNldCkgKiB2aWV3cG9ydC56b29tICsgdmlld3BvcnQueCxcbiAgICAgICAgbm9kZVJlY3QueSAqIHZpZXdwb3J0Lnpvb20gKyB2aWV3cG9ydC55IC0gb2Zmc2V0LFxuICAgIF07XG4gICAgLy8gYW5kIHRoYW4gc2hpZnQgaXQgYmFzZWQgb24gdGhlIGFsaWdubWVudC4gVGhlIHNoaWZ0IHZhbHVlcyBhcmUgaW4gJS5cbiAgICBsZXQgc2hpZnQgPSBbLTEwMCAqIGFsaWdubWVudE9mZnNldCwgLTEwMF07XG4gICAgc3dpdGNoIChwb3NpdGlvbikge1xuICAgICAgICBjYXNlIFBvc2l0aW9uLlJpZ2h0OlxuICAgICAgICAgICAgcG9zID0gW1xuICAgICAgICAgICAgICAgIChub2RlUmVjdC54ICsgbm9kZVJlY3Qud2lkdGgpICogdmlld3BvcnQuem9vbSArIHZpZXdwb3J0LnggKyBvZmZzZXQsXG4gICAgICAgICAgICAgICAgKG5vZGVSZWN0LnkgKyBub2RlUmVjdC5oZWlnaHQgKiBhbGlnbm1lbnRPZmZzZXQpICogdmlld3BvcnQuem9vbSArIHZpZXdwb3J0LnksXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgc2hpZnQgPSBbMCwgLTEwMCAqIGFsaWdubWVudE9mZnNldF07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBQb3NpdGlvbi5Cb3R0b206XG4gICAgICAgICAgICBwb3NbMV0gPSAobm9kZVJlY3QueSArIG5vZGVSZWN0LmhlaWdodCkgKiB2aWV3cG9ydC56b29tICsgdmlld3BvcnQueSArIG9mZnNldDtcbiAgICAgICAgICAgIHNoaWZ0WzFdID0gMDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFBvc2l0aW9uLkxlZnQ6XG4gICAgICAgICAgICBwb3MgPSBbXG4gICAgICAgICAgICAgICAgbm9kZVJlY3QueCAqIHZpZXdwb3J0Lnpvb20gKyB2aWV3cG9ydC54IC0gb2Zmc2V0LFxuICAgICAgICAgICAgICAgIChub2RlUmVjdC55ICsgbm9kZVJlY3QuaGVpZ2h0ICogYWxpZ25tZW50T2Zmc2V0KSAqIHZpZXdwb3J0Lnpvb20gKyB2aWV3cG9ydC55LFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIHNoaWZ0ID0gWy0xMDAsIC0xMDAgKiBhbGlnbm1lbnRPZmZzZXRdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBgdHJhbnNsYXRlKCR7cG9zWzBdfXB4LCAke3Bvc1sxXX1weCkgdHJhbnNsYXRlKCR7c2hpZnRbMF19JSwgJHtzaGlmdFsxXX0lKWA7XG59XG5cbmNvbnN0IGRlZmF1bHRPcHRpb25zID0ge1xuICAgIG5vZGVPcmlnaW46IFswLCAwXSxcbiAgICBub2RlRXh0ZW50OiBpbmZpbml0ZUV4dGVudCxcbiAgICBlbGV2YXRlTm9kZXNPblNlbGVjdDogdHJ1ZSxcbiAgICBkZWZhdWx0czoge30sXG59O1xuY29uc3QgYWRvcHRVc2VyTm9kZXNEZWZhdWx0T3B0aW9ucyA9IHtcbiAgICAuLi5kZWZhdWx0T3B0aW9ucyxcbiAgICBjaGVja0VxdWFsaXR5OiB0cnVlLFxufTtcbmZ1bmN0aW9uIG1lcmdlT2JqZWN0cyhiYXNlLCBpbmNvbWluZykge1xuICAgIGNvbnN0IHJlc3VsdCA9IHsgLi4uYmFzZSB9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIGluY29taW5nKSB7XG4gICAgICAgIGlmIChpbmNvbWluZ1trZXldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIHR5cGVjYXN0IGlzIHNhZmUgaGVyZSwgYmVjYXVzZSB3ZSBjaGVjayBmb3IgdW5kZWZpbmVkXG4gICAgICAgICAgICByZXN1bHRba2V5XSA9IGluY29taW5nW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUFic29sdXRlUG9zaXRpb25zKG5vZGVMb29rdXAsIHBhcmVudExvb2t1cCwgb3B0aW9ucykge1xuICAgIGNvbnN0IF9vcHRpb25zID0gbWVyZ2VPYmplY3RzKGRlZmF1bHRPcHRpb25zLCBvcHRpb25zKTtcbiAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygbm9kZUxvb2t1cC52YWx1ZXMoKSkge1xuICAgICAgICBpZiAobm9kZS5wYXJlbnRJZCkge1xuICAgICAgICAgICAgdXBkYXRlQ2hpbGROb2RlKG5vZGUsIG5vZGVMb29rdXAsIHBhcmVudExvb2t1cCwgX29wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgcG9zaXRpb25XaXRoT3JpZ2luID0gZ2V0Tm9kZVBvc2l0aW9uV2l0aE9yaWdpbihub2RlLCBfb3B0aW9ucy5ub2RlT3JpZ2luKTtcbiAgICAgICAgICAgIGNvbnN0IGV4dGVudCA9IGlzQ29vcmRpbmF0ZUV4dGVudChub2RlLmV4dGVudCkgPyBub2RlLmV4dGVudCA6IF9vcHRpb25zLm5vZGVFeHRlbnQ7XG4gICAgICAgICAgICBjb25zdCBjbGFtcGVkUG9zaXRpb24gPSBjbGFtcFBvc2l0aW9uKHBvc2l0aW9uV2l0aE9yaWdpbiwgZXh0ZW50LCBnZXROb2RlRGltZW5zaW9ucyhub2RlKSk7XG4gICAgICAgICAgICBub2RlLmludGVybmFscy5wb3NpdGlvbkFic29sdXRlID0gY2xhbXBlZFBvc2l0aW9uO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gYWRvcHRVc2VyTm9kZXMobm9kZXMsIG5vZGVMb29rdXAsIHBhcmVudExvb2t1cCwgb3B0aW9ucykge1xuICAgIGNvbnN0IF9vcHRpb25zID0gbWVyZ2VPYmplY3RzKGFkb3B0VXNlck5vZGVzRGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpO1xuICAgIGNvbnN0IHRtcExvb2t1cCA9IG5ldyBNYXAobm9kZUxvb2t1cCk7XG4gICAgY29uc3Qgc2VsZWN0ZWROb2RlWiA9IF9vcHRpb25zPy5lbGV2YXRlTm9kZXNPblNlbGVjdCA/IDEwMDAgOiAwO1xuICAgIG5vZGVMb29rdXAuY2xlYXIoKTtcbiAgICBwYXJlbnRMb29rdXAuY2xlYXIoKTtcbiAgICBmb3IgKGNvbnN0IHVzZXJOb2RlIG9mIG5vZGVzKSB7XG4gICAgICAgIGxldCBpbnRlcm5hbE5vZGUgPSB0bXBMb29rdXAuZ2V0KHVzZXJOb2RlLmlkKTtcbiAgICAgICAgaWYgKF9vcHRpb25zLmNoZWNrRXF1YWxpdHkgJiYgdXNlck5vZGUgPT09IGludGVybmFsTm9kZT8uaW50ZXJuYWxzLnVzZXJOb2RlKSB7XG4gICAgICAgICAgICBub2RlTG9va3VwLnNldCh1c2VyTm9kZS5pZCwgaW50ZXJuYWxOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uV2l0aE9yaWdpbiA9IGdldE5vZGVQb3NpdGlvbldpdGhPcmlnaW4odXNlck5vZGUsIF9vcHRpb25zLm5vZGVPcmlnaW4pO1xuICAgICAgICAgICAgY29uc3QgZXh0ZW50ID0gaXNDb29yZGluYXRlRXh0ZW50KHVzZXJOb2RlLmV4dGVudCkgPyB1c2VyTm9kZS5leHRlbnQgOiBfb3B0aW9ucy5ub2RlRXh0ZW50O1xuICAgICAgICAgICAgY29uc3QgY2xhbXBlZFBvc2l0aW9uID0gY2xhbXBQb3NpdGlvbihwb3NpdGlvbldpdGhPcmlnaW4sIGV4dGVudCwgZ2V0Tm9kZURpbWVuc2lvbnModXNlck5vZGUpKTtcbiAgICAgICAgICAgIGludGVybmFsTm9kZSA9IHtcbiAgICAgICAgICAgICAgICAuLi5fb3B0aW9ucy5kZWZhdWx0cyxcbiAgICAgICAgICAgICAgICAuLi51c2VyTm9kZSxcbiAgICAgICAgICAgICAgICBtZWFzdXJlZDoge1xuICAgICAgICAgICAgICAgICAgICB3aWR0aDogdXNlck5vZGUubWVhc3VyZWQ/LndpZHRoLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IHVzZXJOb2RlLm1lYXN1cmVkPy5oZWlnaHQsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpbnRlcm5hbHM6IHtcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25BYnNvbHV0ZTogY2xhbXBlZFBvc2l0aW9uLFxuICAgICAgICAgICAgICAgICAgICAvLyBpZiB1c2VyIHJlLWluaXRpYWxpemVzIHRoZSBub2RlIG9yIHJlbW92ZXMgYG1lYXN1cmVkYCBmb3Igd2hhdGV2ZXIgcmVhc29uLCB3ZSByZXNldCB0aGUgaGFuZGxlQm91bmRzIHNvIHRoYXQgdGhlIG5vZGUgZ2V0cyByZS1tZWFzdXJlZFxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVCb3VuZHM6ICF1c2VyTm9kZS5tZWFzdXJlZCA/IHVuZGVmaW5lZCA6IGludGVybmFsTm9kZT8uaW50ZXJuYWxzLmhhbmRsZUJvdW5kcyxcbiAgICAgICAgICAgICAgICAgICAgejogY2FsY3VsYXRlWih1c2VyTm9kZSwgc2VsZWN0ZWROb2RlWiksXG4gICAgICAgICAgICAgICAgICAgIHVzZXJOb2RlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbm9kZUxvb2t1cC5zZXQodXNlck5vZGUuaWQsIGludGVybmFsTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVzZXJOb2RlLnBhcmVudElkKSB7XG4gICAgICAgICAgICB1cGRhdGVDaGlsZE5vZGUoaW50ZXJuYWxOb2RlLCBub2RlTG9va3VwLCBwYXJlbnRMb29rdXAsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gdXBkYXRlUGFyZW50TG9va3VwKG5vZGUsIHBhcmVudExvb2t1cCkge1xuICAgIGlmICghbm9kZS5wYXJlbnRJZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNoaWxkTm9kZXMgPSBwYXJlbnRMb29rdXAuZ2V0KG5vZGUucGFyZW50SWQpO1xuICAgIGlmIChjaGlsZE5vZGVzKSB7XG4gICAgICAgIGNoaWxkTm9kZXMuc2V0KG5vZGUuaWQsIG5vZGUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcGFyZW50TG9va3VwLnNldChub2RlLnBhcmVudElkLCBuZXcgTWFwKFtbbm9kZS5pZCwgbm9kZV1dKSk7XG4gICAgfVxufVxuLyoqXG4gKiBVcGRhdGVzIHBvc2l0aW9uQWJzb2x1dGUgYW5kIHpJbmRleCBvZiBhIGNoaWxkIG5vZGUgYW5kIHRoZSBwYXJlbnRMb29rdXAuXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZUNoaWxkTm9kZShub2RlLCBub2RlTG9va3VwLCBwYXJlbnRMb29rdXAsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGVsZXZhdGVOb2Rlc09uU2VsZWN0LCBub2RlT3JpZ2luLCBub2RlRXh0ZW50IH0gPSBtZXJnZU9iamVjdHMoZGVmYXVsdE9wdGlvbnMsIG9wdGlvbnMpO1xuICAgIGNvbnN0IHBhcmVudElkID0gbm9kZS5wYXJlbnRJZDtcbiAgICBjb25zdCBwYXJlbnROb2RlID0gbm9kZUxvb2t1cC5nZXQocGFyZW50SWQpO1xuICAgIGlmICghcGFyZW50Tm9kZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oYFBhcmVudCBub2RlICR7cGFyZW50SWR9IG5vdCBmb3VuZC4gUGxlYXNlIG1ha2Ugc3VyZSB0aGF0IHBhcmVudCBub2RlcyBhcmUgaW4gZnJvbnQgb2YgdGhlaXIgY2hpbGQgbm9kZXMgaW4gdGhlIG5vZGVzIGFycmF5LmApO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHVwZGF0ZVBhcmVudExvb2t1cChub2RlLCBwYXJlbnRMb29rdXApO1xuICAgIGNvbnN0IHNlbGVjdGVkTm9kZVogPSBlbGV2YXRlTm9kZXNPblNlbGVjdCA/IDEwMDAgOiAwO1xuICAgIGNvbnN0IHsgeCwgeSwgeiB9ID0gY2FsY3VsYXRlQ2hpbGRYWVoobm9kZSwgcGFyZW50Tm9kZSwgbm9kZU9yaWdpbiwgbm9kZUV4dGVudCwgc2VsZWN0ZWROb2RlWik7XG4gICAgY29uc3QgeyBwb3NpdGlvbkFic29sdXRlIH0gPSBub2RlLmludGVybmFscztcbiAgICBjb25zdCBwb3NpdGlvbkNoYW5nZWQgPSB4ICE9PSBwb3NpdGlvbkFic29sdXRlLnggfHwgeSAhPT0gcG9zaXRpb25BYnNvbHV0ZS55O1xuICAgIGlmIChwb3NpdGlvbkNoYW5nZWQgfHwgeiAhPT0gbm9kZS5pbnRlcm5hbHMueikge1xuICAgICAgICAvLyB3ZSBjcmVhdGUgYSBuZXcgb2JqZWN0IHRvIG1hcmsgdGhlIG5vZGUgYXMgdXBkYXRlZFxuICAgICAgICBub2RlTG9va3VwLnNldChub2RlLmlkLCB7XG4gICAgICAgICAgICAuLi5ub2RlLFxuICAgICAgICAgICAgaW50ZXJuYWxzOiB7XG4gICAgICAgICAgICAgICAgLi4ubm9kZS5pbnRlcm5hbHMsXG4gICAgICAgICAgICAgICAgcG9zaXRpb25BYnNvbHV0ZTogcG9zaXRpb25DaGFuZ2VkID8geyB4LCB5IH0gOiBwb3NpdGlvbkFic29sdXRlLFxuICAgICAgICAgICAgICAgIHosXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVaKG5vZGUsIHNlbGVjdGVkTm9kZVopIHtcbiAgICByZXR1cm4gKGlzTnVtZXJpYyhub2RlLnpJbmRleCkgPyBub2RlLnpJbmRleCA6IDApICsgKG5vZGUuc2VsZWN0ZWQgPyBzZWxlY3RlZE5vZGVaIDogMCk7XG59XG5mdW5jdGlvbiBjYWxjdWxhdGVDaGlsZFhZWihjaGlsZE5vZGUsIHBhcmVudE5vZGUsIG5vZGVPcmlnaW4sIG5vZGVFeHRlbnQsIHNlbGVjdGVkTm9kZVopIHtcbiAgICBjb25zdCB7IHg6IHBhcmVudFgsIHk6IHBhcmVudFkgfSA9IHBhcmVudE5vZGUuaW50ZXJuYWxzLnBvc2l0aW9uQWJzb2x1dGU7XG4gICAgY29uc3QgY2hpbGREaW1lbnNpb25zID0gZ2V0Tm9kZURpbWVuc2lvbnMoY2hpbGROb2RlKTtcbiAgICBjb25zdCBwb3NpdGlvbldpdGhPcmlnaW4gPSBnZXROb2RlUG9zaXRpb25XaXRoT3JpZ2luKGNoaWxkTm9kZSwgbm9kZU9yaWdpbik7XG4gICAgY29uc3QgY2xhbXBlZFBvc2l0aW9uID0gaXNDb29yZGluYXRlRXh0ZW50KGNoaWxkTm9kZS5leHRlbnQpXG4gICAgICAgID8gY2xhbXBQb3NpdGlvbihwb3NpdGlvbldpdGhPcmlnaW4sIGNoaWxkTm9kZS5leHRlbnQsIGNoaWxkRGltZW5zaW9ucylcbiAgICAgICAgOiBwb3NpdGlvbldpdGhPcmlnaW47XG4gICAgbGV0IGFic29sdXRlUG9zaXRpb24gPSBjbGFtcFBvc2l0aW9uKHsgeDogcGFyZW50WCArIGNsYW1wZWRQb3NpdGlvbi54LCB5OiBwYXJlbnRZICsgY2xhbXBlZFBvc2l0aW9uLnkgfSwgbm9kZUV4dGVudCwgY2hpbGREaW1lbnNpb25zKTtcbiAgICBpZiAoY2hpbGROb2RlLmV4dGVudCA9PT0gJ3BhcmVudCcpIHtcbiAgICAgICAgYWJzb2x1dGVQb3NpdGlvbiA9IGNsYW1wUG9zaXRpb25Ub1BhcmVudChhYnNvbHV0ZVBvc2l0aW9uLCBjaGlsZERpbWVuc2lvbnMsIHBhcmVudE5vZGUpO1xuICAgIH1cbiAgICBjb25zdCBjaGlsZFogPSBjYWxjdWxhdGVaKGNoaWxkTm9kZSwgc2VsZWN0ZWROb2RlWik7XG4gICAgY29uc3QgcGFyZW50WiA9IHBhcmVudE5vZGUuaW50ZXJuYWxzLnogPz8gMDtcbiAgICByZXR1cm4ge1xuICAgICAgICB4OiBhYnNvbHV0ZVBvc2l0aW9uLngsXG4gICAgICAgIHk6IGFic29sdXRlUG9zaXRpb24ueSxcbiAgICAgICAgejogcGFyZW50WiA+IGNoaWxkWiA/IHBhcmVudFogOiBjaGlsZFosXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGhhbmRsZUV4cGFuZFBhcmVudChjaGlsZHJlbiwgbm9kZUxvb2t1cCwgcGFyZW50TG9va3VwLCBub2RlT3JpZ2luID0gWzAsIDBdKSB7XG4gICAgY29uc3QgY2hhbmdlcyA9IFtdO1xuICAgIGNvbnN0IHBhcmVudEV4cGFuc2lvbnMgPSBuZXcgTWFwKCk7XG4gICAgLy8gZGV0ZXJtaW5lIHRoZSBleHBhbmRlZCByZWN0YW5nbGUgdGhlIGNoaWxkIG5vZGVzIHdvdWxkIHRha2UgZm9yIGVhY2ggcGFyZW50XG4gICAgZm9yIChjb25zdCBjaGlsZCBvZiBjaGlsZHJlbikge1xuICAgICAgICBjb25zdCBwYXJlbnQgPSBub2RlTG9va3VwLmdldChjaGlsZC5wYXJlbnRJZCk7XG4gICAgICAgIGlmICghcGFyZW50KSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJlbnRSZWN0ID0gcGFyZW50RXhwYW5zaW9ucy5nZXQoY2hpbGQucGFyZW50SWQpPy5leHBhbmRlZFJlY3QgPz8gbm9kZVRvUmVjdChwYXJlbnQpO1xuICAgICAgICBjb25zdCBleHBhbmRlZFJlY3QgPSBnZXRCb3VuZHNPZlJlY3RzKHBhcmVudFJlY3QsIGNoaWxkLnJlY3QpO1xuICAgICAgICBwYXJlbnRFeHBhbnNpb25zLnNldChjaGlsZC5wYXJlbnRJZCwgeyBleHBhbmRlZFJlY3QsIHBhcmVudCB9KTtcbiAgICB9XG4gICAgaWYgKHBhcmVudEV4cGFuc2lvbnMuc2l6ZSA+IDApIHtcbiAgICAgICAgcGFyZW50RXhwYW5zaW9ucy5mb3JFYWNoKCh7IGV4cGFuZGVkUmVjdCwgcGFyZW50IH0sIHBhcmVudElkKSA9PiB7XG4gICAgICAgICAgICAvLyBkZXRlcm1pbmUgdGhlIHBvc2l0aW9uICYgZGltZW5zaW9ucyBvZiB0aGUgcGFyZW50XG4gICAgICAgICAgICBjb25zdCBwb3NpdGlvbkFic29sdXRlID0gcGFyZW50LmludGVybmFscy5wb3NpdGlvbkFic29sdXRlO1xuICAgICAgICAgICAgY29uc3QgZGltZW5zaW9ucyA9IGdldE5vZGVEaW1lbnNpb25zKHBhcmVudCk7XG4gICAgICAgICAgICBjb25zdCBvcmlnaW4gPSBwYXJlbnQub3JpZ2luID8/IG5vZGVPcmlnaW47XG4gICAgICAgICAgICAvLyBkZXRlcm1pbmUgaG93IG11Y2ggdGhlIHBhcmVudCBleHBhbmRzIGluIHdpZHRoIGFuZCBwb3NpdGlvblxuICAgICAgICAgICAgY29uc3QgeENoYW5nZSA9IGV4cGFuZGVkUmVjdC54IDwgcG9zaXRpb25BYnNvbHV0ZS54ID8gTWF0aC5yb3VuZChNYXRoLmFicyhwb3NpdGlvbkFic29sdXRlLnggLSBleHBhbmRlZFJlY3QueCkpIDogMDtcbiAgICAgICAgICAgIGNvbnN0IHlDaGFuZ2UgPSBleHBhbmRlZFJlY3QueSA8IHBvc2l0aW9uQWJzb2x1dGUueSA/IE1hdGgucm91bmQoTWF0aC5hYnMocG9zaXRpb25BYnNvbHV0ZS55IC0gZXhwYW5kZWRSZWN0LnkpKSA6IDA7XG4gICAgICAgICAgICBjb25zdCBuZXdXaWR0aCA9IE1hdGgubWF4KGRpbWVuc2lvbnMud2lkdGgsIE1hdGgucm91bmQoZXhwYW5kZWRSZWN0LndpZHRoKSk7XG4gICAgICAgICAgICBjb25zdCBuZXdIZWlnaHQgPSBNYXRoLm1heChkaW1lbnNpb25zLmhlaWdodCwgTWF0aC5yb3VuZChleHBhbmRlZFJlY3QuaGVpZ2h0KSk7XG4gICAgICAgICAgICBjb25zdCB3aWR0aENoYW5nZSA9IChuZXdXaWR0aCAtIGRpbWVuc2lvbnMud2lkdGgpICogb3JpZ2luWzBdO1xuICAgICAgICAgICAgY29uc3QgaGVpZ2h0Q2hhbmdlID0gKG5ld0hlaWdodCAtIGRpbWVuc2lvbnMuaGVpZ2h0KSAqIG9yaWdpblsxXTtcbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gY29ycmVjdCB0aGUgcG9zaXRpb24gb2YgdGhlIHBhcmVudCBub2RlIGlmIHRoZSBvcmlnaW4gaXMgbm90IFswLDBdXG4gICAgICAgICAgICBpZiAoeENoYW5nZSA+IDAgfHwgeUNoYW5nZSA+IDAgfHwgd2lkdGhDaGFuZ2UgfHwgaGVpZ2h0Q2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgY2hhbmdlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHBhcmVudElkLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAncG9zaXRpb24nLFxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgeDogcGFyZW50LnBvc2l0aW9uLnggLSB4Q2hhbmdlICsgd2lkdGhDaGFuZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBwYXJlbnQucG9zaXRpb24ueSAtIHlDaGFuZ2UgKyBoZWlnaHRDaGFuZ2UsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiBXZSBtb3ZlIGFsbCBjaGlsZCBub2RlcyBpbiB0aGUgb3Bwc2l0ZSBkaXJlY3Rpb25cbiAgICAgICAgICAgICAgICAgKiBzbyB0aGUgeCx5IGNoYW5nZXMgb2YgdGhlIHBhcmVudCBkbyBub3QgbW92ZSB0aGUgY2hpbGRyZW5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBwYXJlbnRMb29rdXAuZ2V0KHBhcmVudElkKT8uZm9yRWFjaCgoY2hpbGROb2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghY2hpbGRyZW4uc29tZSgoY2hpbGQpID0+IGNoaWxkLmlkID09PSBjaGlsZE5vZGUuaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2VzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBjaGlsZE5vZGUuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogJ3Bvc2l0aW9uJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4OiBjaGlsZE5vZGUucG9zaXRpb24ueCArIHhDaGFuZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHk6IGNoaWxkTm9kZS5wb3NpdGlvbi55ICsgeUNoYW5nZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gY29ycmVjdCB0aGUgZGltZW5zaW9ucyBvZiB0aGUgcGFyZW50IG5vZGUgaWYgdGhlIG9yaWdpbiBpcyBub3QgWzAsMF1cbiAgICAgICAgICAgIGlmIChkaW1lbnNpb25zLndpZHRoIDwgZXhwYW5kZWRSZWN0LndpZHRoIHx8IGRpbWVuc2lvbnMuaGVpZ2h0IDwgZXhwYW5kZWRSZWN0LmhlaWdodCB8fCB4Q2hhbmdlIHx8IHlDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBpZDogcGFyZW50SWQsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdkaW1lbnNpb25zJyxcbiAgICAgICAgICAgICAgICAgICAgc2V0QXR0cmlidXRlczogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZGltZW5zaW9uczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IG5ld1dpZHRoICsgKHhDaGFuZ2UgPyBvcmlnaW5bMF0gKiB4Q2hhbmdlIC0gd2lkdGhDaGFuZ2UgOiAwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogbmV3SGVpZ2h0ICsgKHlDaGFuZ2UgPyBvcmlnaW5bMV0gKiB5Q2hhbmdlIC0gaGVpZ2h0Q2hhbmdlIDogMCksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gY2hhbmdlcztcbn1cbmZ1bmN0aW9uIHVwZGF0ZU5vZGVJbnRlcm5hbHModXBkYXRlcywgbm9kZUxvb2t1cCwgcGFyZW50TG9va3VwLCBkb21Ob2RlLCBub2RlT3JpZ2luLCBub2RlRXh0ZW50KSB7XG4gICAgY29uc3Qgdmlld3BvcnROb2RlID0gZG9tTm9kZT8ucXVlcnlTZWxlY3RvcignLnh5Zmxvd19fdmlld3BvcnQnKTtcbiAgICBsZXQgdXBkYXRlZEludGVybmFscyA9IGZhbHNlO1xuICAgIGlmICghdmlld3BvcnROb2RlKSB7XG4gICAgICAgIHJldHVybiB7IGNoYW5nZXM6IFtdLCB1cGRhdGVkSW50ZXJuYWxzIH07XG4gICAgfVxuICAgIGNvbnN0IGNoYW5nZXMgPSBbXTtcbiAgICBjb25zdCBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHZpZXdwb3J0Tm9kZSk7XG4gICAgY29uc3QgeyBtMjI6IHpvb20gfSA9IG5ldyB3aW5kb3cuRE9NTWF0cml4UmVhZE9ubHkoc3R5bGUudHJhbnNmb3JtKTtcbiAgICAvLyBpbiB0aGlzIGFycmF5IHdlIGNvbGxlY3Qgbm9kZXMsIHRoYXQgbWlnaHQgdHJpZ2dlciBjaGFuZ2VzIChsaWtlIGV4cGFuZGluZyBwYXJlbnQpXG4gICAgY29uc3QgcGFyZW50RXhwYW5kQ2hpbGRyZW4gPSBbXTtcbiAgICBmb3IgKGNvbnN0IHVwZGF0ZSBvZiB1cGRhdGVzLnZhbHVlcygpKSB7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBub2RlTG9va3VwLmdldCh1cGRhdGUuaWQpO1xuICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLmhpZGRlbikge1xuICAgICAgICAgICAgbm9kZUxvb2t1cC5zZXQobm9kZS5pZCwge1xuICAgICAgICAgICAgICAgIC4uLm5vZGUsXG4gICAgICAgICAgICAgICAgaW50ZXJuYWxzOiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLm5vZGUuaW50ZXJuYWxzLFxuICAgICAgICAgICAgICAgICAgICBoYW5kbGVCb3VuZHM6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB1cGRhdGVkSW50ZXJuYWxzID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRpbWVuc2lvbnMgPSBnZXREaW1lbnNpb25zKHVwZGF0ZS5ub2RlRWxlbWVudCk7XG4gICAgICAgIGNvbnN0IGRpbWVuc2lvbkNoYW5nZWQgPSBub2RlLm1lYXN1cmVkLndpZHRoICE9PSBkaW1lbnNpb25zLndpZHRoIHx8IG5vZGUubWVhc3VyZWQuaGVpZ2h0ICE9PSBkaW1lbnNpb25zLmhlaWdodDtcbiAgICAgICAgY29uc3QgZG9VcGRhdGUgPSAhIShkaW1lbnNpb25zLndpZHRoICYmXG4gICAgICAgICAgICBkaW1lbnNpb25zLmhlaWdodCAmJlxuICAgICAgICAgICAgKGRpbWVuc2lvbkNoYW5nZWQgfHwgIW5vZGUuaW50ZXJuYWxzLmhhbmRsZUJvdW5kcyB8fCB1cGRhdGUuZm9yY2UpKTtcbiAgICAgICAgaWYgKGRvVXBkYXRlKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlQm91bmRzID0gdXBkYXRlLm5vZGVFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgY29uc3QgZXh0ZW50ID0gaXNDb29yZGluYXRlRXh0ZW50KG5vZGUuZXh0ZW50KSA/IG5vZGUuZXh0ZW50IDogbm9kZUV4dGVudDtcbiAgICAgICAgICAgIGxldCB7IHBvc2l0aW9uQWJzb2x1dGUgfSA9IG5vZGUuaW50ZXJuYWxzO1xuICAgICAgICAgICAgaWYgKG5vZGUucGFyZW50SWQgJiYgbm9kZS5leHRlbnQgPT09ICdwYXJlbnQnKSB7XG4gICAgICAgICAgICAgICAgcG9zaXRpb25BYnNvbHV0ZSA9IGNsYW1wUG9zaXRpb25Ub1BhcmVudChwb3NpdGlvbkFic29sdXRlLCBkaW1lbnNpb25zLCBub2RlTG9va3VwLmdldChub2RlLnBhcmVudElkKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChleHRlbnQpIHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbkFic29sdXRlID0gY2xhbXBQb3NpdGlvbihwb3NpdGlvbkFic29sdXRlLCBleHRlbnQsIGRpbWVuc2lvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbmV3Tm9kZSA9IHtcbiAgICAgICAgICAgICAgICAuLi5ub2RlLFxuICAgICAgICAgICAgICAgIG1lYXN1cmVkOiBkaW1lbnNpb25zLFxuICAgICAgICAgICAgICAgIGludGVybmFsczoge1xuICAgICAgICAgICAgICAgICAgICAuLi5ub2RlLmludGVybmFscyxcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25BYnNvbHV0ZSxcbiAgICAgICAgICAgICAgICAgICAgaGFuZGxlQm91bmRzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IGdldEhhbmRsZUJvdW5kcygnc291cmNlJywgdXBkYXRlLm5vZGVFbGVtZW50LCBub2RlQm91bmRzLCB6b29tLCBub2RlLmlkKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldDogZ2V0SGFuZGxlQm91bmRzKCd0YXJnZXQnLCB1cGRhdGUubm9kZUVsZW1lbnQsIG5vZGVCb3VuZHMsIHpvb20sIG5vZGUuaWQpLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbm9kZUxvb2t1cC5zZXQobm9kZS5pZCwgbmV3Tm9kZSk7XG4gICAgICAgICAgICBpZiAobm9kZS5wYXJlbnRJZCkge1xuICAgICAgICAgICAgICAgIHVwZGF0ZUNoaWxkTm9kZShuZXdOb2RlLCBub2RlTG9va3VwLCBwYXJlbnRMb29rdXAsIHsgbm9kZU9yaWdpbiB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHVwZGF0ZWRJbnRlcm5hbHMgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKGRpbWVuc2lvbkNoYW5nZWQpIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2VzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBpZDogbm9kZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2RpbWVuc2lvbnMnLFxuICAgICAgICAgICAgICAgICAgICBkaW1lbnNpb25zLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChub2RlLmV4cGFuZFBhcmVudCAmJiBub2RlLnBhcmVudElkKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmVudEV4cGFuZENoaWxkcmVuLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IG5vZGUuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRJZDogbm9kZS5wYXJlbnRJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlY3Q6IG5vZGVUb1JlY3QobmV3Tm9kZSwgbm9kZU9yaWdpbiksXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAocGFyZW50RXhwYW5kQ2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBwYXJlbnRFeHBhbmRDaGFuZ2VzID0gaGFuZGxlRXhwYW5kUGFyZW50KHBhcmVudEV4cGFuZENoaWxkcmVuLCBub2RlTG9va3VwLCBwYXJlbnRMb29rdXAsIG5vZGVPcmlnaW4pO1xuICAgICAgICBjaGFuZ2VzLnB1c2goLi4ucGFyZW50RXhwYW5kQ2hhbmdlcyk7XG4gICAgfVxuICAgIHJldHVybiB7IGNoYW5nZXMsIHVwZGF0ZWRJbnRlcm5hbHMgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHBhbkJ5KHsgZGVsdGEsIHBhblpvb20sIHRyYW5zZm9ybSwgdHJhbnNsYXRlRXh0ZW50LCB3aWR0aCwgaGVpZ2h0LCB9KSB7XG4gICAgaWYgKCFwYW5ab29tIHx8ICghZGVsdGEueCAmJiAhZGVsdGEueSkpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShmYWxzZSk7XG4gICAgfVxuICAgIGNvbnN0IG5leHRWaWV3cG9ydCA9IGF3YWl0IHBhblpvb20uc2V0Vmlld3BvcnRDb25zdHJhaW5lZCh7XG4gICAgICAgIHg6IHRyYW5zZm9ybVswXSArIGRlbHRhLngsXG4gICAgICAgIHk6IHRyYW5zZm9ybVsxXSArIGRlbHRhLnksXG4gICAgICAgIHpvb206IHRyYW5zZm9ybVsyXSxcbiAgICB9LCBbXG4gICAgICAgIFswLCAwXSxcbiAgICAgICAgW3dpZHRoLCBoZWlnaHRdLFxuICAgIF0sIHRyYW5zbGF0ZUV4dGVudCk7XG4gICAgY29uc3QgdHJhbnNmb3JtQ2hhbmdlZCA9ICEhbmV4dFZpZXdwb3J0ICYmXG4gICAgICAgIChuZXh0Vmlld3BvcnQueCAhPT0gdHJhbnNmb3JtWzBdIHx8IG5leHRWaWV3cG9ydC55ICE9PSB0cmFuc2Zvcm1bMV0gfHwgbmV4dFZpZXdwb3J0LmsgIT09IHRyYW5zZm9ybVsyXSk7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0cmFuc2Zvcm1DaGFuZ2VkKTtcbn1cbi8qKlxuICogdGhpcyBmdW5jdGlvbiBhZGRzIHRoZSBjb25uZWN0aW9uIHRvIHRoZSBjb25uZWN0aW9uTG9va3VwXG4gKiBhdCB0aGUgZm9sbG93aW5nIGtleXM6IG5vZGVJZC10eXBlLWhhbmRsZUlkLCBub2RlSWQtdHlwZSBhbmQgbm9kZUlkXG4gKiBAcGFyYW0gdHlwZSB0eXBlIG9mIHRoZSBjb25uZWN0aW9uXG4gKiBAcGFyYW0gY29ubmVjdGlvbiBjb25uZWN0aW9uIHRoYXQgc2hvdWxkIGJlIGFkZGVkIHRvIHRoZSBsb29rdXBcbiAqIEBwYXJhbSBjb25uZWN0aW9uS2V5IGF0IHdoaWNoIGtleSB0aGUgY29ubmVjdGlvbiBzaG91bGQgYmUgYWRkZWRcbiAqIEBwYXJhbSBjb25uZWN0aW9uTG9va3VwIHJlZmVyZW5jZSB0byB0aGUgY29ubmVjdGlvbiBsb29rdXBcbiAqIEBwYXJhbSBub2RlSWQgbm9kZUlkIG9mIHRoZSBjb25uZWN0aW9uXG4gKiBAcGFyYW0gaGFuZGxlSWQgaGFuZGxlSWQgb2YgdGhlIGNvbm5lY2l0b25cbiAqL1xuZnVuY3Rpb24gYWRkQ29ubmVjdGlvblRvTG9va3VwKHR5cGUsIGNvbm5lY3Rpb24sIGNvbm5lY3Rpb25LZXksIGNvbm5lY3Rpb25Mb29rdXAsIG5vZGVJZCwgaGFuZGxlSWQpIHtcbiAgICAvKlxuICAgICAqIFdlIGFkZCB0aGUgY29ubmVjdGlvbiB0byB0aGUgY29ubmVjdGlvbkxvb2t1cCBhdCB0aGUgZm9sbG93aW5nIGtleXNcbiAgICAgKiAxLiBub2RlSWQsIDIuIG5vZGVJZC10eXBlLCAzLiBub2RlSWQtdHlwZS1oYW5kbGVJZFxuICAgICAqIElmIHRoZSBrZXkgYWxyZWFkeSBleGlzdHMsIHdlIGFkZCB0aGUgY29ubmVjdGlvbiB0byB0aGUgZXhpc3RpbmcgbWFwXG4gICAgICovXG4gICAgbGV0IGtleSA9IG5vZGVJZDtcbiAgICBjb25zdCBub2RlTWFwID0gY29ubmVjdGlvbkxvb2t1cC5nZXQoa2V5KSB8fCBuZXcgTWFwKCk7XG4gICAgY29ubmVjdGlvbkxvb2t1cC5zZXQoa2V5LCBub2RlTWFwLnNldChjb25uZWN0aW9uS2V5LCBjb25uZWN0aW9uKSk7XG4gICAga2V5ID0gYCR7bm9kZUlkfS0ke3R5cGV9YDtcbiAgICBjb25zdCB0eXBlTWFwID0gY29ubmVjdGlvbkxvb2t1cC5nZXQoa2V5KSB8fCBuZXcgTWFwKCk7XG4gICAgY29ubmVjdGlvbkxvb2t1cC5zZXQoa2V5LCB0eXBlTWFwLnNldChjb25uZWN0aW9uS2V5LCBjb25uZWN0aW9uKSk7XG4gICAgaWYgKGhhbmRsZUlkKSB7XG4gICAgICAgIGtleSA9IGAke25vZGVJZH0tJHt0eXBlfS0ke2hhbmRsZUlkfWA7XG4gICAgICAgIGNvbnN0IGhhbmRsZU1hcCA9IGNvbm5lY3Rpb25Mb29rdXAuZ2V0KGtleSkgfHwgbmV3IE1hcCgpO1xuICAgICAgICBjb25uZWN0aW9uTG9va3VwLnNldChrZXksIGhhbmRsZU1hcC5zZXQoY29ubmVjdGlvbktleSwgY29ubmVjdGlvbikpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHVwZGF0ZUNvbm5lY3Rpb25Mb29rdXAoY29ubmVjdGlvbkxvb2t1cCwgZWRnZUxvb2t1cCwgZWRnZXMpIHtcbiAgICBjb25uZWN0aW9uTG9va3VwLmNsZWFyKCk7XG4gICAgZWRnZUxvb2t1cC5jbGVhcigpO1xuICAgIGZvciAoY29uc3QgZWRnZSBvZiBlZGdlcykge1xuICAgICAgICBjb25zdCB7IHNvdXJjZTogc291cmNlTm9kZSwgdGFyZ2V0OiB0YXJnZXROb2RlLCBzb3VyY2VIYW5kbGUgPSBudWxsLCB0YXJnZXRIYW5kbGUgPSBudWxsIH0gPSBlZGdlO1xuICAgICAgICBjb25zdCBjb25uZWN0aW9uID0geyBlZGdlSWQ6IGVkZ2UuaWQsIHNvdXJjZTogc291cmNlTm9kZSwgdGFyZ2V0OiB0YXJnZXROb2RlLCBzb3VyY2VIYW5kbGUsIHRhcmdldEhhbmRsZSB9O1xuICAgICAgICBjb25zdCBzb3VyY2VLZXkgPSBgJHtzb3VyY2VOb2RlfS0ke3NvdXJjZUhhbmRsZX0tLSR7dGFyZ2V0Tm9kZX0tJHt0YXJnZXRIYW5kbGV9YDtcbiAgICAgICAgY29uc3QgdGFyZ2V0S2V5ID0gYCR7dGFyZ2V0Tm9kZX0tJHt0YXJnZXRIYW5kbGV9LS0ke3NvdXJjZU5vZGV9LSR7c291cmNlSGFuZGxlfWA7XG4gICAgICAgIGFkZENvbm5lY3Rpb25Ub0xvb2t1cCgnc291cmNlJywgY29ubmVjdGlvbiwgdGFyZ2V0S2V5LCBjb25uZWN0aW9uTG9va3VwLCBzb3VyY2VOb2RlLCBzb3VyY2VIYW5kbGUpO1xuICAgICAgICBhZGRDb25uZWN0aW9uVG9Mb29rdXAoJ3RhcmdldCcsIGNvbm5lY3Rpb24sIHNvdXJjZUtleSwgY29ubmVjdGlvbkxvb2t1cCwgdGFyZ2V0Tm9kZSwgdGFyZ2V0SGFuZGxlKTtcbiAgICAgICAgZWRnZUxvb2t1cC5zZXQoZWRnZS5pZCwgZWRnZSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBzaGFsbG93Tm9kZURhdGEoYSwgYikge1xuICAgIGlmIChhID09PSBudWxsIHx8IGIgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBfYSA9IEFycmF5LmlzQXJyYXkoYSkgPyBhIDogW2FdO1xuICAgIGNvbnN0IF9iID0gQXJyYXkuaXNBcnJheShiKSA/IGIgOiBbYl07XG4gICAgaWYgKF9hLmxlbmd0aCAhPT0gX2IubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBfYS5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoX2FbaV0uaWQgIT09IF9iW2ldLmlkIHx8IF9hW2ldLnR5cGUgIT09IF9iW2ldLnR5cGUgfHwgIU9iamVjdC5pcyhfYVtpXS5kYXRhLCBfYltpXS5kYXRhKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBpc1BhcmVudFNlbGVjdGVkKG5vZGUsIG5vZGVMb29rdXApIHtcbiAgICBpZiAoIW5vZGUucGFyZW50SWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBwYXJlbnROb2RlID0gbm9kZUxvb2t1cC5nZXQobm9kZS5wYXJlbnRJZCk7XG4gICAgaWYgKCFwYXJlbnROb2RlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHBhcmVudE5vZGUuc2VsZWN0ZWQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBpc1BhcmVudFNlbGVjdGVkKHBhcmVudE5vZGUsIG5vZGVMb29rdXApO1xufVxuZnVuY3Rpb24gaGFzU2VsZWN0b3IodGFyZ2V0LCBzZWxlY3RvciwgZG9tTm9kZSkge1xuICAgIGxldCBjdXJyZW50ID0gdGFyZ2V0O1xuICAgIGRvIHtcbiAgICAgICAgaWYgKGN1cnJlbnQ/Lm1hdGNoZXM/LihzZWxlY3RvcikpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgaWYgKGN1cnJlbnQgPT09IGRvbU5vZGUpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGN1cnJlbnQgPSBjdXJyZW50Py5wYXJlbnRFbGVtZW50O1xuICAgIH0gd2hpbGUgKGN1cnJlbnQpO1xuICAgIHJldHVybiBmYWxzZTtcbn1cbi8vIGxvb2tzIGZvciBhbGwgc2VsZWN0ZWQgbm9kZXMgYW5kIGNyZWF0ZWQgYSBOb2RlRHJhZ0l0ZW0gZm9yIGVhY2ggb2YgdGhlbVxuZnVuY3Rpb24gZ2V0RHJhZ0l0ZW1zKG5vZGVMb29rdXAsIG5vZGVzRHJhZ2dhYmxlLCBtb3VzZVBvcywgbm9kZUlkKSB7XG4gICAgY29uc3QgZHJhZ0l0ZW1zID0gbmV3IE1hcCgpO1xuICAgIGZvciAoY29uc3QgW2lkLCBub2RlXSBvZiBub2RlTG9va3VwKSB7XG4gICAgICAgIGlmICgobm9kZS5zZWxlY3RlZCB8fCBub2RlLmlkID09PSBub2RlSWQpICYmXG4gICAgICAgICAgICAoIW5vZGUucGFyZW50SWQgfHwgIWlzUGFyZW50U2VsZWN0ZWQobm9kZSwgbm9kZUxvb2t1cCkpICYmXG4gICAgICAgICAgICAobm9kZS5kcmFnZ2FibGUgfHwgKG5vZGVzRHJhZ2dhYmxlICYmIHR5cGVvZiBub2RlLmRyYWdnYWJsZSA9PT0gJ3VuZGVmaW5lZCcpKSkge1xuICAgICAgICAgICAgY29uc3QgaW50ZXJuYWxOb2RlID0gbm9kZUxvb2t1cC5nZXQoaWQpO1xuICAgICAgICAgICAgaWYgKGludGVybmFsTm9kZSkge1xuICAgICAgICAgICAgICAgIGRyYWdJdGVtcy5zZXQoaWQsIHtcbiAgICAgICAgICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBpbnRlcm5hbE5vZGUucG9zaXRpb24gfHwgeyB4OiAwLCB5OiAwIH0sXG4gICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiBtb3VzZVBvcy54IC0gaW50ZXJuYWxOb2RlLmludGVybmFscy5wb3NpdGlvbkFic29sdXRlLngsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiBtb3VzZVBvcy55IC0gaW50ZXJuYWxOb2RlLmludGVybmFscy5wb3NpdGlvbkFic29sdXRlLnksXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGV4dGVudDogaW50ZXJuYWxOb2RlLmV4dGVudCxcbiAgICAgICAgICAgICAgICAgICAgcGFyZW50SWQ6IGludGVybmFsTm9kZS5wYXJlbnRJZCxcbiAgICAgICAgICAgICAgICAgICAgb3JpZ2luOiBpbnRlcm5hbE5vZGUub3JpZ2luLFxuICAgICAgICAgICAgICAgICAgICBleHBhbmRQYXJlbnQ6IGludGVybmFsTm9kZS5leHBhbmRQYXJlbnQsXG4gICAgICAgICAgICAgICAgICAgIGludGVybmFsczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25BYnNvbHV0ZTogaW50ZXJuYWxOb2RlLmludGVybmFscy5wb3NpdGlvbkFic29sdXRlIHx8IHsgeDogMCwgeTogMCB9LFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBtZWFzdXJlZDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IGludGVybmFsTm9kZS5tZWFzdXJlZC53aWR0aCA/PyAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0OiBpbnRlcm5hbE5vZGUubWVhc3VyZWQuaGVpZ2h0ID8/IDAsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRyYWdJdGVtcztcbn1cbi8qXG4gKiByZXR1cm5zIHR3byBwYXJhbXM6XG4gKiAxLiB0aGUgZHJhZ2dlZCBub2RlIChvciB0aGUgZmlyc3Qgb2YgdGhlIGxpc3QsIGlmIHdlIGFyZSBkcmFnZ2luZyBhIG5vZGUgc2VsZWN0aW9uKVxuICogMi4gYXJyYXkgb2Ygc2VsZWN0ZWQgbm9kZXMgKGZvciBtdWx0aSBzZWxlY3Rpb25zKVxuICovXG5mdW5jdGlvbiBnZXRFdmVudEhhbmRsZXJQYXJhbXMoeyBub2RlSWQsIGRyYWdJdGVtcywgbm9kZUxvb2t1cCwgZHJhZ2dpbmcgPSB0cnVlLCB9KSB7XG4gICAgY29uc3Qgbm9kZXNGcm9tRHJhZ0l0ZW1zID0gW107XG4gICAgZm9yIChjb25zdCBbaWQsIGRyYWdJdGVtXSBvZiBkcmFnSXRlbXMpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVMb29rdXAuZ2V0KGlkKT8uaW50ZXJuYWxzLnVzZXJOb2RlO1xuICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgbm9kZXNGcm9tRHJhZ0l0ZW1zLnB1c2goe1xuICAgICAgICAgICAgICAgIC4uLm5vZGUsXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IGRyYWdJdGVtLnBvc2l0aW9uLFxuICAgICAgICAgICAgICAgIGRyYWdnaW5nLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFub2RlSWQpIHtcbiAgICAgICAgcmV0dXJuIFtub2Rlc0Zyb21EcmFnSXRlbXNbMF0sIG5vZGVzRnJvbURyYWdJdGVtc107XG4gICAgfVxuICAgIGNvbnN0IG5vZGUgPSBub2RlTG9va3VwLmdldChub2RlSWQpPy5pbnRlcm5hbHMudXNlck5vZGU7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgIW5vZGVcbiAgICAgICAgICAgID8gbm9kZXNGcm9tRHJhZ0l0ZW1zWzBdXG4gICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICAuLi5ub2RlLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBkcmFnSXRlbXMuZ2V0KG5vZGVJZCk/LnBvc2l0aW9uIHx8IG5vZGUucG9zaXRpb24sXG4gICAgICAgICAgICAgICAgZHJhZ2dpbmcsXG4gICAgICAgICAgICB9LFxuICAgICAgICBub2Rlc0Zyb21EcmFnSXRlbXMsXG4gICAgXTtcbn1cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbmZ1bmN0aW9uIFhZRHJhZyh7IG9uTm9kZU1vdXNlRG93biwgZ2V0U3RvcmVJdGVtcywgb25EcmFnU3RhcnQsIG9uRHJhZywgb25EcmFnU3RvcCwgfSkge1xuICAgIGxldCBsYXN0UG9zID0geyB4OiBudWxsLCB5OiBudWxsIH07XG4gICAgbGV0IGF1dG9QYW5JZCA9IDA7XG4gICAgbGV0IGRyYWdJdGVtcyA9IG5ldyBNYXAoKTtcbiAgICBsZXQgYXV0b1BhblN0YXJ0ZWQgPSBmYWxzZTtcbiAgICBsZXQgbW91c2VQb3NpdGlvbiA9IHsgeDogMCwgeTogMCB9O1xuICAgIGxldCBjb250YWluZXJCb3VuZHMgPSBudWxsO1xuICAgIGxldCBkcmFnU3RhcnRlZCA9IGZhbHNlO1xuICAgIGxldCBkM1NlbGVjdGlvbiA9IG51bGw7XG4gICAgbGV0IGFib3J0RHJhZyA9IGZhbHNlOyAvLyBwcmV2ZW50cyB1bmludGVudGlvbmFsIGRyYWdnaW5nIG9uIG11bHRpdG91Y2hcbiAgICAvLyBwdWJsaWMgZnVuY3Rpb25zXG4gICAgZnVuY3Rpb24gdXBkYXRlKHsgbm9EcmFnQ2xhc3NOYW1lLCBoYW5kbGVTZWxlY3RvciwgZG9tTm9kZSwgaXNTZWxlY3RhYmxlLCBub2RlSWQsIG5vZGVDbGlja0Rpc3RhbmNlID0gMCwgfSkge1xuICAgICAgICBkM1NlbGVjdGlvbiA9IHNlbGVjdChkb21Ob2RlKTtcbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlTm9kZXMoeyB4LCB5IH0sIGRyYWdFdmVudCkge1xuICAgICAgICAgICAgY29uc3QgeyBub2RlTG9va3VwLCBub2RlRXh0ZW50LCBzbmFwR3JpZCwgc25hcFRvR3JpZCwgbm9kZU9yaWdpbiwgb25Ob2RlRHJhZywgb25TZWxlY3Rpb25EcmFnLCBvbkVycm9yLCB1cGRhdGVOb2RlUG9zaXRpb25zLCB9ID0gZ2V0U3RvcmVJdGVtcygpO1xuICAgICAgICAgICAgbGFzdFBvcyA9IHsgeCwgeSB9O1xuICAgICAgICAgICAgbGV0IGhhc0NoYW5nZSA9IGZhbHNlO1xuICAgICAgICAgICAgbGV0IG5vZGVzQm94ID0geyB4OiAwLCB5OiAwLCB4MjogMCwgeTI6IDAgfTtcbiAgICAgICAgICAgIGlmIChkcmFnSXRlbXMuc2l6ZSA+IDEgJiYgbm9kZUV4dGVudCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlY3QgPSBnZXRJbnRlcm5hbE5vZGVzQm91bmRzKGRyYWdJdGVtcyk7XG4gICAgICAgICAgICAgICAgbm9kZXNCb3ggPSByZWN0VG9Cb3gocmVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtpZCwgZHJhZ0l0ZW1dIG9mIGRyYWdJdGVtcykge1xuICAgICAgICAgICAgICAgIGlmICghbm9kZUxvb2t1cC5oYXMoaWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgICAqIGlmIHRoZSBub2RlIGlzIG5vdCBpbiB0aGUgbm9kZUxvb2t1cCBhbnltb3JlLCBpdCB3YXMgcHJvYmFibHkgZGVsZXRlZCB3aGlsZSBkcmFnZ2luZ1xuICAgICAgICAgICAgICAgICAgICAgKiBhbmQgd2UgZG9uJ3QgbmVlZCB0byB1cGRhdGUgaXQgYW55bW9yZVxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBuZXh0UG9zaXRpb24gPSB7IHg6IHggLSBkcmFnSXRlbS5kaXN0YW5jZS54LCB5OiB5IC0gZHJhZ0l0ZW0uZGlzdGFuY2UueSB9O1xuICAgICAgICAgICAgICAgIGlmIChzbmFwVG9HcmlkKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHRQb3NpdGlvbiA9IHNuYXBQb3NpdGlvbihuZXh0UG9zaXRpb24sIHNuYXBHcmlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiBpZiB0aGVyZSBpcyBzZWxlY3Rpb24gd2l0aCBtdWx0aXBsZSBub2RlcyBhbmQgYSBub2RlIGV4dGVudCBpcyBzZXQsIHdlIG5lZWQgdG8gYWRqdXN0IHRoZSBub2RlIGV4dGVudCBmb3IgZWFjaCBub2RlXG4gICAgICAgICAgICAgICAgICogYmFzZWQgb24gaXRzIHBvc2l0aW9uIHNvIHRoYXQgdGhlIG5vZGUgc3RheXMgYXQgaXQncyBwb3NpdGlvbiByZWxhdGl2ZSB0byB0aGUgc2VsZWN0aW9uLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGxldCBhZGp1c3RlZE5vZGVFeHRlbnQgPSBbXG4gICAgICAgICAgICAgICAgICAgIFtub2RlRXh0ZW50WzBdWzBdLCBub2RlRXh0ZW50WzBdWzFdXSxcbiAgICAgICAgICAgICAgICAgICAgW25vZGVFeHRlbnRbMV1bMF0sIG5vZGVFeHRlbnRbMV1bMV1dLFxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgaWYgKGRyYWdJdGVtcy5zaXplID4gMSAmJiBub2RlRXh0ZW50ICYmICFkcmFnSXRlbS5leHRlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBwb3NpdGlvbkFic29sdXRlIH0gPSBkcmFnSXRlbS5pbnRlcm5hbHM7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHgxID0gcG9zaXRpb25BYnNvbHV0ZS54IC0gbm9kZXNCb3gueCArIG5vZGVFeHRlbnRbMF1bMF07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHgyID0gcG9zaXRpb25BYnNvbHV0ZS54ICsgZHJhZ0l0ZW0ubWVhc3VyZWQud2lkdGggLSBub2Rlc0JveC54MiArIG5vZGVFeHRlbnRbMV1bMF07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHkxID0gcG9zaXRpb25BYnNvbHV0ZS55IC0gbm9kZXNCb3gueSArIG5vZGVFeHRlbnRbMF1bMV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHkyID0gcG9zaXRpb25BYnNvbHV0ZS55ICsgZHJhZ0l0ZW0ubWVhc3VyZWQuaGVpZ2h0IC0gbm9kZXNCb3gueTIgKyBub2RlRXh0ZW50WzFdWzFdO1xuICAgICAgICAgICAgICAgICAgICBhZGp1c3RlZE5vZGVFeHRlbnQgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICBbeDEsIHkxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFt4MiwgeTJdLFxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB7IHBvc2l0aW9uLCBwb3NpdGlvbkFic29sdXRlIH0gPSBjYWxjdWxhdGVOb2RlUG9zaXRpb24oe1xuICAgICAgICAgICAgICAgICAgICBub2RlSWQ6IGlkLFxuICAgICAgICAgICAgICAgICAgICBuZXh0UG9zaXRpb24sXG4gICAgICAgICAgICAgICAgICAgIG5vZGVMb29rdXAsXG4gICAgICAgICAgICAgICAgICAgIG5vZGVFeHRlbnQ6IGFkanVzdGVkTm9kZUV4dGVudCxcbiAgICAgICAgICAgICAgICAgICAgbm9kZU9yaWdpbixcbiAgICAgICAgICAgICAgICAgICAgb25FcnJvcixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyB3ZSB3YW50IHRvIG1ha2Ugc3VyZSB0aGF0IHdlIG9ubHkgZmlyZSBhIGNoYW5nZSBldmVudCB3aGVuIHRoZXJlIGlzIGEgY2hhbmdlXG4gICAgICAgICAgICAgICAgaGFzQ2hhbmdlID0gaGFzQ2hhbmdlIHx8IGRyYWdJdGVtLnBvc2l0aW9uLnggIT09IHBvc2l0aW9uLnggfHwgZHJhZ0l0ZW0ucG9zaXRpb24ueSAhPT0gcG9zaXRpb24ueTtcbiAgICAgICAgICAgICAgICBkcmFnSXRlbS5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgICAgICAgICAgICAgIGRyYWdJdGVtLmludGVybmFscy5wb3NpdGlvbkFic29sdXRlID0gcG9zaXRpb25BYnNvbHV0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaGFzQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdXBkYXRlTm9kZVBvc2l0aW9ucyhkcmFnSXRlbXMsIHRydWUpO1xuICAgICAgICAgICAgaWYgKGRyYWdFdmVudCAmJiAob25EcmFnIHx8IG9uTm9kZURyYWcgfHwgKCFub2RlSWQgJiYgb25TZWxlY3Rpb25EcmFnKSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBbY3VycmVudE5vZGUsIGN1cnJlbnROb2Rlc10gPSBnZXRFdmVudEhhbmRsZXJQYXJhbXMoe1xuICAgICAgICAgICAgICAgICAgICBub2RlSWQsXG4gICAgICAgICAgICAgICAgICAgIGRyYWdJdGVtcyxcbiAgICAgICAgICAgICAgICAgICAgbm9kZUxvb2t1cCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBvbkRyYWc/LihkcmFnRXZlbnQsIGRyYWdJdGVtcywgY3VycmVudE5vZGUsIGN1cnJlbnROb2Rlcyk7XG4gICAgICAgICAgICAgICAgb25Ob2RlRHJhZz8uKGRyYWdFdmVudCwgY3VycmVudE5vZGUsIGN1cnJlbnROb2Rlcyk7XG4gICAgICAgICAgICAgICAgaWYgKCFub2RlSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgb25TZWxlY3Rpb25EcmFnPy4oZHJhZ0V2ZW50LCBjdXJyZW50Tm9kZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhc3luYyBmdW5jdGlvbiBhdXRvUGFuKCkge1xuICAgICAgICAgICAgaWYgKCFjb250YWluZXJCb3VuZHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IHRyYW5zZm9ybSwgcGFuQnksIGF1dG9QYW5TcGVlZCwgYXV0b1Bhbk9uTm9kZURyYWcgfSA9IGdldFN0b3JlSXRlbXMoKTtcbiAgICAgICAgICAgIGlmICghYXV0b1Bhbk9uTm9kZURyYWcpIHtcbiAgICAgICAgICAgICAgICBhdXRvUGFuU3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGF1dG9QYW5JZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgW3hNb3ZlbWVudCwgeU1vdmVtZW50XSA9IGNhbGNBdXRvUGFuKG1vdXNlUG9zaXRpb24sIGNvbnRhaW5lckJvdW5kcywgYXV0b1BhblNwZWVkKTtcbiAgICAgICAgICAgIGlmICh4TW92ZW1lbnQgIT09IDAgfHwgeU1vdmVtZW50ICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgbGFzdFBvcy54ID0gKGxhc3RQb3MueCA/PyAwKSAtIHhNb3ZlbWVudCAvIHRyYW5zZm9ybVsyXTtcbiAgICAgICAgICAgICAgICBsYXN0UG9zLnkgPSAobGFzdFBvcy55ID8/IDApIC0geU1vdmVtZW50IC8gdHJhbnNmb3JtWzJdO1xuICAgICAgICAgICAgICAgIGlmIChhd2FpdCBwYW5CeSh7IHg6IHhNb3ZlbWVudCwgeTogeU1vdmVtZW50IH0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZU5vZGVzKGxhc3RQb3MsIG51bGwpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGF1dG9QYW5JZCA9IHJlcXVlc3RBbmltYXRpb25GcmFtZShhdXRvUGFuKTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBzdGFydERyYWcoZXZlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgbm9kZUxvb2t1cCwgbXVsdGlTZWxlY3Rpb25BY3RpdmUsIG5vZGVzRHJhZ2dhYmxlLCB0cmFuc2Zvcm0sIHNuYXBHcmlkLCBzbmFwVG9HcmlkLCBzZWxlY3ROb2Rlc09uRHJhZywgb25Ob2RlRHJhZ1N0YXJ0LCBvblNlbGVjdGlvbkRyYWdTdGFydCwgdW5zZWxlY3ROb2Rlc0FuZEVkZ2VzLCB9ID0gZ2V0U3RvcmVJdGVtcygpO1xuICAgICAgICAgICAgZHJhZ1N0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKCghc2VsZWN0Tm9kZXNPbkRyYWcgfHwgIWlzU2VsZWN0YWJsZSkgJiYgIW11bHRpU2VsZWN0aW9uQWN0aXZlICYmIG5vZGVJZCkge1xuICAgICAgICAgICAgICAgIGlmICghbm9kZUxvb2t1cC5nZXQobm9kZUlkKT8uc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gd2UgbmVlZCB0byByZXNldCBzZWxlY3RlZCBub2RlcyB3aGVuIHNlbGVjdE5vZGVzT25EcmFnPWZhbHNlXG4gICAgICAgICAgICAgICAgICAgIHVuc2VsZWN0Tm9kZXNBbmRFZGdlcygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1NlbGVjdGFibGUgJiYgc2VsZWN0Tm9kZXNPbkRyYWcgJiYgbm9kZUlkKSB7XG4gICAgICAgICAgICAgICAgb25Ob2RlTW91c2VEb3duPy4obm9kZUlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBvaW50ZXJQb3MgPSBnZXRQb2ludGVyUG9zaXRpb24oZXZlbnQuc291cmNlRXZlbnQsIHsgdHJhbnNmb3JtLCBzbmFwR3JpZCwgc25hcFRvR3JpZCwgY29udGFpbmVyQm91bmRzIH0pO1xuICAgICAgICAgICAgbGFzdFBvcyA9IHBvaW50ZXJQb3M7XG4gICAgICAgICAgICBkcmFnSXRlbXMgPSBnZXREcmFnSXRlbXMobm9kZUxvb2t1cCwgbm9kZXNEcmFnZ2FibGUsIHBvaW50ZXJQb3MsIG5vZGVJZCk7XG4gICAgICAgICAgICBpZiAoZHJhZ0l0ZW1zLnNpemUgPiAwICYmIChvbkRyYWdTdGFydCB8fCBvbk5vZGVEcmFnU3RhcnQgfHwgKCFub2RlSWQgJiYgb25TZWxlY3Rpb25EcmFnU3RhcnQpKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IFtjdXJyZW50Tm9kZSwgY3VycmVudE5vZGVzXSA9IGdldEV2ZW50SGFuZGxlclBhcmFtcyh7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVJZCxcbiAgICAgICAgICAgICAgICAgICAgZHJhZ0l0ZW1zLFxuICAgICAgICAgICAgICAgICAgICBub2RlTG9va3VwLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIG9uRHJhZ1N0YXJ0Py4oZXZlbnQuc291cmNlRXZlbnQsIGRyYWdJdGVtcywgY3VycmVudE5vZGUsIGN1cnJlbnROb2Rlcyk7XG4gICAgICAgICAgICAgICAgb25Ob2RlRHJhZ1N0YXJ0Py4oZXZlbnQuc291cmNlRXZlbnQsIGN1cnJlbnROb2RlLCBjdXJyZW50Tm9kZXMpO1xuICAgICAgICAgICAgICAgIGlmICghbm9kZUlkKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uU2VsZWN0aW9uRHJhZ1N0YXJ0Py4oZXZlbnQuc291cmNlRXZlbnQsIGN1cnJlbnROb2Rlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGQzRHJhZ0luc3RhbmNlID0gZHJhZygpXG4gICAgICAgICAgICAuY2xpY2tEaXN0YW5jZShub2RlQ2xpY2tEaXN0YW5jZSlcbiAgICAgICAgICAgIC5vbignc3RhcnQnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgZG9tTm9kZSwgbm9kZURyYWdUaHJlc2hvbGQsIHRyYW5zZm9ybSwgc25hcEdyaWQsIHNuYXBUb0dyaWQgfSA9IGdldFN0b3JlSXRlbXMoKTtcbiAgICAgICAgICAgIGNvbnRhaW5lckJvdW5kcyA9IGRvbU5vZGU/LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIHx8IG51bGw7XG4gICAgICAgICAgICBhYm9ydERyYWcgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChub2RlRHJhZ1RocmVzaG9sZCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0RHJhZyhldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwb2ludGVyUG9zID0gZ2V0UG9pbnRlclBvc2l0aW9uKGV2ZW50LnNvdXJjZUV2ZW50LCB7IHRyYW5zZm9ybSwgc25hcEdyaWQsIHNuYXBUb0dyaWQsIGNvbnRhaW5lckJvdW5kcyB9KTtcbiAgICAgICAgICAgIGxhc3RQb3MgPSBwb2ludGVyUG9zO1xuICAgICAgICAgICAgbW91c2VQb3NpdGlvbiA9IGdldEV2ZW50UG9zaXRpb24oZXZlbnQuc291cmNlRXZlbnQsIGNvbnRhaW5lckJvdW5kcyk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAub24oJ2RyYWcnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgYXV0b1Bhbk9uTm9kZURyYWcsIHRyYW5zZm9ybSwgc25hcEdyaWQsIHNuYXBUb0dyaWQsIG5vZGVEcmFnVGhyZXNob2xkLCBub2RlTG9va3VwIH0gPSBnZXRTdG9yZUl0ZW1zKCk7XG4gICAgICAgICAgICBjb25zdCBwb2ludGVyUG9zID0gZ2V0UG9pbnRlclBvc2l0aW9uKGV2ZW50LnNvdXJjZUV2ZW50LCB7IHRyYW5zZm9ybSwgc25hcEdyaWQsIHNuYXBUb0dyaWQsIGNvbnRhaW5lckJvdW5kcyB9KTtcbiAgICAgICAgICAgIGlmICgoZXZlbnQuc291cmNlRXZlbnQudHlwZSA9PT0gJ3RvdWNobW92ZScgJiYgZXZlbnQuc291cmNlRXZlbnQudG91Y2hlcy5sZW5ndGggPiAxKSB8fFxuICAgICAgICAgICAgICAgIC8vIGlmIHVzZXIgZGVsZXRlcyBhIG5vZGUgd2hpbGUgZHJhZ2dpbmcsIHdlIG5lZWQgdG8gYWJvcnQgdGhlIGRyYWcgdG8gcHJldmVudCBlcnJvcnNcbiAgICAgICAgICAgICAgICAobm9kZUlkICYmICFub2RlTG9va3VwLmhhcyhub2RlSWQpKSkge1xuICAgICAgICAgICAgICAgIGFib3J0RHJhZyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWJvcnREcmFnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFhdXRvUGFuU3RhcnRlZCAmJiBhdXRvUGFuT25Ob2RlRHJhZyAmJiBkcmFnU3RhcnRlZCkge1xuICAgICAgICAgICAgICAgIGF1dG9QYW5TdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBhdXRvUGFuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWRyYWdTdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IHBvaW50ZXJQb3MueFNuYXBwZWQgLSAobGFzdFBvcy54ID8/IDApO1xuICAgICAgICAgICAgICAgIGNvbnN0IHkgPSBwb2ludGVyUG9zLnlTbmFwcGVkIC0gKGxhc3RQb3MueSA/PyAwKTtcbiAgICAgICAgICAgICAgICBjb25zdCBkaXN0YW5jZSA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcbiAgICAgICAgICAgICAgICBpZiAoZGlzdGFuY2UgPiBub2RlRHJhZ1RocmVzaG9sZCkge1xuICAgICAgICAgICAgICAgICAgICBzdGFydERyYWcoZXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHNraXAgZXZlbnRzIHdpdGhvdXQgbW92ZW1lbnRcbiAgICAgICAgICAgIGlmICgobGFzdFBvcy54ICE9PSBwb2ludGVyUG9zLnhTbmFwcGVkIHx8IGxhc3RQb3MueSAhPT0gcG9pbnRlclBvcy55U25hcHBlZCkgJiYgZHJhZ0l0ZW1zICYmIGRyYWdTdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgLy8gZHJhZ0V2ZW50ID0gZXZlbnQuc291cmNlRXZlbnQgYXMgTW91c2VFdmVudDtcbiAgICAgICAgICAgICAgICBtb3VzZVBvc2l0aW9uID0gZ2V0RXZlbnRQb3NpdGlvbihldmVudC5zb3VyY2VFdmVudCwgY29udGFpbmVyQm91bmRzKTtcbiAgICAgICAgICAgICAgICB1cGRhdGVOb2Rlcyhwb2ludGVyUG9zLCBldmVudC5zb3VyY2VFdmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgICAgICAub24oJ2VuZCcsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFkcmFnU3RhcnRlZCB8fCBhYm9ydERyYWcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhdXRvUGFuU3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgZHJhZ1N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGF1dG9QYW5JZCk7XG4gICAgICAgICAgICBpZiAoZHJhZ0l0ZW1zLnNpemUgPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBub2RlTG9va3VwLCB1cGRhdGVOb2RlUG9zaXRpb25zLCBvbk5vZGVEcmFnU3RvcCwgb25TZWxlY3Rpb25EcmFnU3RvcCB9ID0gZ2V0U3RvcmVJdGVtcygpO1xuICAgICAgICAgICAgICAgIHVwZGF0ZU5vZGVQb3NpdGlvbnMoZHJhZ0l0ZW1zLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgaWYgKG9uRHJhZ1N0b3AgfHwgb25Ob2RlRHJhZ1N0b3AgfHwgKCFub2RlSWQgJiYgb25TZWxlY3Rpb25EcmFnU3RvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgW2N1cnJlbnROb2RlLCBjdXJyZW50Tm9kZXNdID0gZ2V0RXZlbnRIYW5kbGVyUGFyYW1zKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRyYWdJdGVtcyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVMb29rdXAsXG4gICAgICAgICAgICAgICAgICAgICAgICBkcmFnZ2luZzogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBvbkRyYWdTdG9wPy4oZXZlbnQuc291cmNlRXZlbnQsIGRyYWdJdGVtcywgY3VycmVudE5vZGUsIGN1cnJlbnROb2Rlcyk7XG4gICAgICAgICAgICAgICAgICAgIG9uTm9kZURyYWdTdG9wPy4oZXZlbnQuc291cmNlRXZlbnQsIGN1cnJlbnROb2RlLCBjdXJyZW50Tm9kZXMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5vZGVJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25TZWxlY3Rpb25EcmFnU3RvcD8uKGV2ZW50LnNvdXJjZUV2ZW50LCBjdXJyZW50Tm9kZXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAgICAgLmZpbHRlcigoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgICAgIGNvbnN0IGlzRHJhZ2dhYmxlID0gIWV2ZW50LmJ1dHRvbiAmJlxuICAgICAgICAgICAgICAgICghbm9EcmFnQ2xhc3NOYW1lIHx8ICFoYXNTZWxlY3Rvcih0YXJnZXQsIGAuJHtub0RyYWdDbGFzc05hbWV9YCwgZG9tTm9kZSkpICYmXG4gICAgICAgICAgICAgICAgKCFoYW5kbGVTZWxlY3RvciB8fCBoYXNTZWxlY3Rvcih0YXJnZXQsIGhhbmRsZVNlbGVjdG9yLCBkb21Ob2RlKSk7XG4gICAgICAgICAgICByZXR1cm4gaXNEcmFnZ2FibGU7XG4gICAgICAgIH0pO1xuICAgICAgICBkM1NlbGVjdGlvbi5jYWxsKGQzRHJhZ0luc3RhbmNlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgZDNTZWxlY3Rpb24/Lm9uKCcuZHJhZycsIG51bGwpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB1cGRhdGUsXG4gICAgICAgIGRlc3Ryb3ksXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0Tm9kZXNXaXRoaW5EaXN0YW5jZShwb3NpdGlvbiwgbm9kZUxvb2t1cCwgZGlzdGFuY2UpIHtcbiAgICBjb25zdCBub2RlcyA9IFtdO1xuICAgIGNvbnN0IHJlY3QgPSB7XG4gICAgICAgIHg6IHBvc2l0aW9uLnggLSBkaXN0YW5jZSxcbiAgICAgICAgeTogcG9zaXRpb24ueSAtIGRpc3RhbmNlLFxuICAgICAgICB3aWR0aDogZGlzdGFuY2UgKiAyLFxuICAgICAgICBoZWlnaHQ6IGRpc3RhbmNlICogMixcbiAgICB9O1xuICAgIGZvciAoY29uc3Qgbm9kZSBvZiBub2RlTG9va3VwLnZhbHVlcygpKSB7XG4gICAgICAgIGlmIChnZXRPdmVybGFwcGluZ0FyZWEocmVjdCwgbm9kZVRvUmVjdChub2RlKSkgPiAwKSB7XG4gICAgICAgICAgICBub2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub2Rlcztcbn1cbi8qXG4gKiB0aGlzIGRpc3RhbmNlIGlzIHVzZWQgZm9yIHRoZSBhcmVhIGFyb3VuZCB0aGUgdXNlciBwb2ludGVyXG4gKiB3aGlsZSBkb2luZyBhIGNvbm5lY3Rpb24gZm9yIGZpbmRpbmcgdGhlIGNsb3Nlc3Qgbm9kZXNcbiAqL1xuY29uc3QgQURESVRJT05BTF9ESVNUQU5DRSA9IDI1MDtcbmZ1bmN0aW9uIGdldENsb3Nlc3RIYW5kbGUocG9zaXRpb24sIGNvbm5lY3Rpb25SYWRpdXMsIG5vZGVMb29rdXAsIGZyb21IYW5kbGUpIHtcbiAgICBsZXQgY2xvc2VzdEhhbmRsZXMgPSBbXTtcbiAgICBsZXQgbWluRGlzdGFuY2UgPSBJbmZpbml0eTtcbiAgICBjb25zdCBjbG9zZU5vZGVzID0gZ2V0Tm9kZXNXaXRoaW5EaXN0YW5jZShwb3NpdGlvbiwgbm9kZUxvb2t1cCwgY29ubmVjdGlvblJhZGl1cyArIEFERElUSU9OQUxfRElTVEFOQ0UpO1xuICAgIGZvciAoY29uc3Qgbm9kZSBvZiBjbG9zZU5vZGVzKSB7XG4gICAgICAgIGNvbnN0IGFsbEhhbmRsZXMgPSBbLi4uKG5vZGUuaW50ZXJuYWxzLmhhbmRsZUJvdW5kcz8uc291cmNlID8/IFtdKSwgLi4uKG5vZGUuaW50ZXJuYWxzLmhhbmRsZUJvdW5kcz8udGFyZ2V0ID8/IFtdKV07XG4gICAgICAgIGZvciAoY29uc3QgaGFuZGxlIG9mIGFsbEhhbmRsZXMpIHtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBoYW5kbGUgaXMgdGhlIHNhbWUgYXMgdGhlIGZyb21IYW5kbGUgd2Ugc2tpcCBpdFxuICAgICAgICAgICAgaWYgKGZyb21IYW5kbGUubm9kZUlkID09PSBoYW5kbGUubm9kZUlkICYmIGZyb21IYW5kbGUudHlwZSA9PT0gaGFuZGxlLnR5cGUgJiYgZnJvbUhhbmRsZS5pZCA9PT0gaGFuZGxlLmlkKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBkZXRlcm1pbmUgYWJzb2x1dGUgcG9zaXRpb24gb2YgdGhlIGhhbmRsZVxuICAgICAgICAgICAgY29uc3QgeyB4LCB5IH0gPSBnZXRIYW5kbGVQb3NpdGlvbihub2RlLCBoYW5kbGUsIGhhbmRsZS5wb3NpdGlvbiwgdHJ1ZSk7XG4gICAgICAgICAgICBjb25zdCBkaXN0YW5jZSA9IE1hdGguc3FydChNYXRoLnBvdyh4IC0gcG9zaXRpb24ueCwgMikgKyBNYXRoLnBvdyh5IC0gcG9zaXRpb24ueSwgMikpO1xuICAgICAgICAgICAgaWYgKGRpc3RhbmNlID4gY29ubmVjdGlvblJhZGl1cykge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRpc3RhbmNlIDwgbWluRGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgICBjbG9zZXN0SGFuZGxlcyA9IFt7IC4uLmhhbmRsZSwgeCwgeSB9XTtcbiAgICAgICAgICAgICAgICBtaW5EaXN0YW5jZSA9IGRpc3RhbmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZGlzdGFuY2UgPT09IG1pbkRpc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgLy8gd2hlbiBtdWx0aXBsZSBoYW5kbGVzIGFyZSBvbiB0aGUgc2FtZSBkaXN0YW5jZSB3ZSBjb2xsZWN0IGFsbCBvZiB0aGVtXG4gICAgICAgICAgICAgICAgY2xvc2VzdEhhbmRsZXMucHVzaCh7IC4uLmhhbmRsZSwgeCwgeSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWNsb3Nlc3RIYW5kbGVzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gd2hlbiBtdWx0aXBsZSBoYW5kbGVzIG92ZXJsYXkgZWFjaCBvdGhlciB3ZSBwcmVmZXIgdGhlIG9wcG9zaXRlIGhhbmRsZVxuICAgIGlmIChjbG9zZXN0SGFuZGxlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGNvbnN0IG9wcG9zaXRlSGFuZGxlVHlwZSA9IGZyb21IYW5kbGUudHlwZSA9PT0gJ3NvdXJjZScgPyAndGFyZ2V0JyA6ICdzb3VyY2UnO1xuICAgICAgICByZXR1cm4gY2xvc2VzdEhhbmRsZXMuZmluZCgoaGFuZGxlKSA9PiBoYW5kbGUudHlwZSA9PT0gb3Bwb3NpdGVIYW5kbGVUeXBlKSA/PyBjbG9zZXN0SGFuZGxlc1swXTtcbiAgICB9XG4gICAgcmV0dXJuIGNsb3Nlc3RIYW5kbGVzWzBdO1xufVxuZnVuY3Rpb24gZ2V0SGFuZGxlKG5vZGVJZCwgaGFuZGxlVHlwZSwgaGFuZGxlSWQsIG5vZGVMb29rdXAsIGNvbm5lY3Rpb25Nb2RlLCB3aXRoQWJzb2x1dGVQb3NpdGlvbiA9IGZhbHNlKSB7XG4gICAgY29uc3Qgbm9kZSA9IG5vZGVMb29rdXAuZ2V0KG5vZGVJZCk7XG4gICAgaWYgKCFub2RlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBoYW5kbGVzID0gY29ubmVjdGlvbk1vZGUgPT09ICdzdHJpY3QnXG4gICAgICAgID8gbm9kZS5pbnRlcm5hbHMuaGFuZGxlQm91bmRzPy5baGFuZGxlVHlwZV1cbiAgICAgICAgOiBbLi4uKG5vZGUuaW50ZXJuYWxzLmhhbmRsZUJvdW5kcz8uc291cmNlID8/IFtdKSwgLi4uKG5vZGUuaW50ZXJuYWxzLmhhbmRsZUJvdW5kcz8udGFyZ2V0ID8/IFtdKV07XG4gICAgY29uc3QgaGFuZGxlID0gKGhhbmRsZUlkID8gaGFuZGxlcz8uZmluZCgoaCkgPT4gaC5pZCA9PT0gaGFuZGxlSWQpIDogaGFuZGxlcz8uWzBdKSA/PyBudWxsO1xuICAgIHJldHVybiBoYW5kbGUgJiYgd2l0aEFic29sdXRlUG9zaXRpb25cbiAgICAgICAgPyB7IC4uLmhhbmRsZSwgLi4uZ2V0SGFuZGxlUG9zaXRpb24obm9kZSwgaGFuZGxlLCBoYW5kbGUucG9zaXRpb24sIHRydWUpIH1cbiAgICAgICAgOiBoYW5kbGU7XG59XG5mdW5jdGlvbiBnZXRIYW5kbGVUeXBlKGVkZ2VVcGRhdGVyVHlwZSwgaGFuZGxlRG9tTm9kZSkge1xuICAgIGlmIChlZGdlVXBkYXRlclR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGVkZ2VVcGRhdGVyVHlwZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaGFuZGxlRG9tTm9kZT8uY2xhc3NMaXN0LmNvbnRhaW5zKCd0YXJnZXQnKSkge1xuICAgICAgICByZXR1cm4gJ3RhcmdldCc7XG4gICAgfVxuICAgIGVsc2UgaWYgKGhhbmRsZURvbU5vZGU/LmNsYXNzTGlzdC5jb250YWlucygnc291cmNlJykpIHtcbiAgICAgICAgcmV0dXJuICdzb3VyY2UnO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGlzQ29ubmVjdGlvblZhbGlkKGlzSW5zaWRlQ29ubmVjdGlvblJhZGl1cywgaXNIYW5kbGVWYWxpZCkge1xuICAgIGxldCBpc1ZhbGlkID0gbnVsbDtcbiAgICBpZiAoaXNIYW5kbGVWYWxpZCkge1xuICAgICAgICBpc1ZhbGlkID0gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNJbnNpZGVDb25uZWN0aW9uUmFkaXVzICYmICFpc0hhbmRsZVZhbGlkKSB7XG4gICAgICAgIGlzVmFsaWQgPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGlzVmFsaWQ7XG59XG5cbmNvbnN0IGFsd2F5c1ZhbGlkID0gKCkgPT4gdHJ1ZTtcbmZ1bmN0aW9uIG9uUG9pbnRlckRvd24oZXZlbnQsIHsgY29ubmVjdGlvbk1vZGUsIGNvbm5lY3Rpb25SYWRpdXMsIGhhbmRsZUlkLCBub2RlSWQsIGVkZ2VVcGRhdGVyVHlwZSwgaXNUYXJnZXQsIGRvbU5vZGUsIG5vZGVMb29rdXAsIGxpYiwgYXV0b1Bhbk9uQ29ubmVjdCwgZmxvd0lkLCBwYW5CeSwgY2FuY2VsQ29ubmVjdGlvbiwgb25Db25uZWN0U3RhcnQsIG9uQ29ubmVjdCwgb25Db25uZWN0RW5kLCBpc1ZhbGlkQ29ubmVjdGlvbiA9IGFsd2F5c1ZhbGlkLCBvblJlY29ubmVjdEVuZCwgdXBkYXRlQ29ubmVjdGlvbiwgZ2V0VHJhbnNmb3JtLCBnZXRGcm9tSGFuZGxlLCBhdXRvUGFuU3BlZWQsIH0pIHtcbiAgICAvLyB3aGVuIHh5ZmxvdyBpcyB1c2VkIGluc2lkZSBhIHNoYWRvdyByb290IHdlIGNhbid0IHVzZSBkb2N1bWVudFxuICAgIGNvbnN0IGRvYyA9IGdldEhvc3RGb3JFbGVtZW50KGV2ZW50LnRhcmdldCk7XG4gICAgbGV0IGF1dG9QYW5JZCA9IDA7XG4gICAgbGV0IGNsb3Nlc3RIYW5kbGU7XG4gICAgY29uc3QgeyB4LCB5IH0gPSBnZXRFdmVudFBvc2l0aW9uKGV2ZW50KTtcbiAgICBjb25zdCBjbGlja2VkSGFuZGxlID0gZG9jPy5lbGVtZW50RnJvbVBvaW50KHgsIHkpO1xuICAgIGNvbnN0IGhhbmRsZVR5cGUgPSBnZXRIYW5kbGVUeXBlKGVkZ2VVcGRhdGVyVHlwZSwgY2xpY2tlZEhhbmRsZSk7XG4gICAgY29uc3QgY29udGFpbmVyQm91bmRzID0gZG9tTm9kZT8uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgaWYgKCFjb250YWluZXJCb3VuZHMgfHwgIWhhbmRsZVR5cGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBmcm9tSGFuZGxlSW50ZXJuYWwgPSBnZXRIYW5kbGUobm9kZUlkLCBoYW5kbGVUeXBlLCBoYW5kbGVJZCwgbm9kZUxvb2t1cCwgY29ubmVjdGlvbk1vZGUpO1xuICAgIGlmICghZnJvbUhhbmRsZUludGVybmFsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHBvc2l0aW9uID0gZ2V0RXZlbnRQb3NpdGlvbihldmVudCwgY29udGFpbmVyQm91bmRzKTtcbiAgICBsZXQgYXV0b1BhblN0YXJ0ZWQgPSBmYWxzZTtcbiAgICBsZXQgY29ubmVjdGlvbiA9IG51bGw7XG4gICAgbGV0IGlzVmFsaWQgPSBmYWxzZTtcbiAgICBsZXQgaGFuZGxlRG9tTm9kZSA9IG51bGw7XG4gICAgLy8gd2hlbiB0aGUgdXNlciBpcyBtb3ZpbmcgdGhlIG1vdXNlIGNsb3NlIHRvIHRoZSBlZGdlIG9mIHRoZSBjYW52YXMgd2hpbGUgY29ubmVjdGluZyB3ZSBtb3ZlIHRoZSBjYW52YXNcbiAgICBmdW5jdGlvbiBhdXRvUGFuKCkge1xuICAgICAgICBpZiAoIWF1dG9QYW5PbkNvbm5lY3QgfHwgIWNvbnRhaW5lckJvdW5kcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFt4LCB5XSA9IGNhbGNBdXRvUGFuKHBvc2l0aW9uLCBjb250YWluZXJCb3VuZHMsIGF1dG9QYW5TcGVlZCk7XG4gICAgICAgIHBhbkJ5KHsgeCwgeSB9KTtcbiAgICAgICAgYXV0b1BhbklkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGF1dG9QYW4pO1xuICAgIH1cbiAgICAvLyBTdGF5cyB0aGUgc2FtZSBmb3IgYWxsIGNvbnNlY3V0aXZlIHBvaW50ZXJtb3ZlIGV2ZW50c1xuICAgIGNvbnN0IGZyb21IYW5kbGUgPSB7XG4gICAgICAgIC4uLmZyb21IYW5kbGVJbnRlcm5hbCxcbiAgICAgICAgbm9kZUlkLFxuICAgICAgICB0eXBlOiBoYW5kbGVUeXBlLFxuICAgICAgICBwb3NpdGlvbjogZnJvbUhhbmRsZUludGVybmFsLnBvc2l0aW9uLFxuICAgIH07XG4gICAgY29uc3QgZnJvbU5vZGVJbnRlcm5hbCA9IG5vZGVMb29rdXAuZ2V0KG5vZGVJZCk7XG4gICAgY29uc3QgZnJvbSA9IGdldEhhbmRsZVBvc2l0aW9uKGZyb21Ob2RlSW50ZXJuYWwsIGZyb21IYW5kbGUsIFBvc2l0aW9uLkxlZnQsIHRydWUpO1xuICAgIGNvbnN0IG5ld0Nvbm5lY3Rpb24gPSB7XG4gICAgICAgIGluUHJvZ3Jlc3M6IHRydWUsXG4gICAgICAgIGlzVmFsaWQ6IG51bGwsXG4gICAgICAgIGZyb20sXG4gICAgICAgIGZyb21IYW5kbGUsXG4gICAgICAgIGZyb21Qb3NpdGlvbjogZnJvbUhhbmRsZS5wb3NpdGlvbixcbiAgICAgICAgZnJvbU5vZGU6IGZyb21Ob2RlSW50ZXJuYWwsXG4gICAgICAgIHRvOiBwb3NpdGlvbixcbiAgICAgICAgdG9IYW5kbGU6IG51bGwsXG4gICAgICAgIHRvUG9zaXRpb246IG9wcG9zaXRlUG9zaXRpb25bZnJvbUhhbmRsZS5wb3NpdGlvbl0sXG4gICAgICAgIHRvTm9kZTogbnVsbCxcbiAgICB9O1xuICAgIHVwZGF0ZUNvbm5lY3Rpb24obmV3Q29ubmVjdGlvbik7XG4gICAgbGV0IHByZXZpb3VzQ29ubmVjdGlvbiA9IG5ld0Nvbm5lY3Rpb247XG4gICAgb25Db25uZWN0U3RhcnQ/LihldmVudCwgeyBub2RlSWQsIGhhbmRsZUlkLCBoYW5kbGVUeXBlIH0pO1xuICAgIGZ1bmN0aW9uIG9uUG9pbnRlck1vdmUoZXZlbnQpIHtcbiAgICAgICAgaWYgKCFnZXRGcm9tSGFuZGxlKCkgfHwgIWZyb21IYW5kbGUpIHtcbiAgICAgICAgICAgIG9uUG9pbnRlclVwKGV2ZW50KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0cmFuc2Zvcm0gPSBnZXRUcmFuc2Zvcm0oKTtcbiAgICAgICAgcG9zaXRpb24gPSBnZXRFdmVudFBvc2l0aW9uKGV2ZW50LCBjb250YWluZXJCb3VuZHMpO1xuICAgICAgICBjbG9zZXN0SGFuZGxlID0gZ2V0Q2xvc2VzdEhhbmRsZShwb2ludFRvUmVuZGVyZXJQb2ludChwb3NpdGlvbiwgdHJhbnNmb3JtLCBmYWxzZSwgWzEsIDFdKSwgY29ubmVjdGlvblJhZGl1cywgbm9kZUxvb2t1cCwgZnJvbUhhbmRsZSk7XG4gICAgICAgIGlmICghYXV0b1BhblN0YXJ0ZWQpIHtcbiAgICAgICAgICAgIGF1dG9QYW4oKTtcbiAgICAgICAgICAgIGF1dG9QYW5TdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBpc1ZhbGlkSGFuZGxlKGV2ZW50LCB7XG4gICAgICAgICAgICBoYW5kbGU6IGNsb3Nlc3RIYW5kbGUsXG4gICAgICAgICAgICBjb25uZWN0aW9uTW9kZSxcbiAgICAgICAgICAgIGZyb21Ob2RlSWQ6IG5vZGVJZCxcbiAgICAgICAgICAgIGZyb21IYW5kbGVJZDogaGFuZGxlSWQsXG4gICAgICAgICAgICBmcm9tVHlwZTogaXNUYXJnZXQgPyAndGFyZ2V0JyA6ICdzb3VyY2UnLFxuICAgICAgICAgICAgaXNWYWxpZENvbm5lY3Rpb24sXG4gICAgICAgICAgICBkb2MsXG4gICAgICAgICAgICBsaWIsXG4gICAgICAgICAgICBmbG93SWQsXG4gICAgICAgICAgICBub2RlTG9va3VwLFxuICAgICAgICB9KTtcbiAgICAgICAgaGFuZGxlRG9tTm9kZSA9IHJlc3VsdC5oYW5kbGVEb21Ob2RlO1xuICAgICAgICBjb25uZWN0aW9uID0gcmVzdWx0LmNvbm5lY3Rpb247XG4gICAgICAgIGlzVmFsaWQgPSBpc0Nvbm5lY3Rpb25WYWxpZCghIWNsb3Nlc3RIYW5kbGUsIHJlc3VsdC5pc1ZhbGlkKTtcbiAgICAgICAgY29uc3QgbmV3Q29ubmVjdGlvbiA9IHtcbiAgICAgICAgICAgIC8vIGZyb20gc3RheXMgdGhlIHNhbWVcbiAgICAgICAgICAgIC4uLnByZXZpb3VzQ29ubmVjdGlvbixcbiAgICAgICAgICAgIGlzVmFsaWQsXG4gICAgICAgICAgICB0bzogY2xvc2VzdEhhbmRsZSAmJiBpc1ZhbGlkXG4gICAgICAgICAgICAgICAgPyByZW5kZXJlclBvaW50VG9Qb2ludCh7IHg6IGNsb3Nlc3RIYW5kbGUueCwgeTogY2xvc2VzdEhhbmRsZS55IH0sIHRyYW5zZm9ybSlcbiAgICAgICAgICAgICAgICA6IHBvc2l0aW9uLFxuICAgICAgICAgICAgdG9IYW5kbGU6IHJlc3VsdC50b0hhbmRsZSxcbiAgICAgICAgICAgIHRvUG9zaXRpb246IGlzVmFsaWQgJiYgcmVzdWx0LnRvSGFuZGxlID8gcmVzdWx0LnRvSGFuZGxlLnBvc2l0aW9uIDogb3Bwb3NpdGVQb3NpdGlvbltmcm9tSGFuZGxlLnBvc2l0aW9uXSxcbiAgICAgICAgICAgIHRvTm9kZTogcmVzdWx0LnRvSGFuZGxlID8gbm9kZUxvb2t1cC5nZXQocmVzdWx0LnRvSGFuZGxlLm5vZGVJZCkgOiBudWxsLFxuICAgICAgICB9O1xuICAgICAgICAvKlxuICAgICAgICAgKiB3ZSBkb24ndCB3YW50IHRvIHRyaWdnZXIgYW4gdXBkYXRlIHdoZW4gdGhlIGNvbm5lY3Rpb25cbiAgICAgICAgICogaXMgc25hcHBlZCB0byB0aGUgc2FtZSBoYW5kbGUgYXMgYmVmb3JlXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoaXNWYWxpZCAmJlxuICAgICAgICAgICAgY2xvc2VzdEhhbmRsZSAmJlxuICAgICAgICAgICAgcHJldmlvdXNDb25uZWN0aW9uLnRvSGFuZGxlICYmXG4gICAgICAgICAgICBuZXdDb25uZWN0aW9uLnRvSGFuZGxlICYmXG4gICAgICAgICAgICBwcmV2aW91c0Nvbm5lY3Rpb24udG9IYW5kbGUudHlwZSA9PT0gbmV3Q29ubmVjdGlvbi50b0hhbmRsZS50eXBlICYmXG4gICAgICAgICAgICBwcmV2aW91c0Nvbm5lY3Rpb24udG9IYW5kbGUubm9kZUlkID09PSBuZXdDb25uZWN0aW9uLnRvSGFuZGxlLm5vZGVJZCAmJlxuICAgICAgICAgICAgcHJldmlvdXNDb25uZWN0aW9uLnRvSGFuZGxlLmlkID09PSBuZXdDb25uZWN0aW9uLnRvSGFuZGxlLmlkICYmXG4gICAgICAgICAgICBwcmV2aW91c0Nvbm5lY3Rpb24udG8ueCA9PT0gbmV3Q29ubmVjdGlvbi50by54ICYmXG4gICAgICAgICAgICBwcmV2aW91c0Nvbm5lY3Rpb24udG8ueSA9PT0gbmV3Q29ubmVjdGlvbi50by55KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlQ29ubmVjdGlvbihuZXdDb25uZWN0aW9uKTtcbiAgICAgICAgcHJldmlvdXNDb25uZWN0aW9uID0gbmV3Q29ubmVjdGlvbjtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25Qb2ludGVyVXAoZXZlbnQpIHtcbiAgICAgICAgaWYgKChjbG9zZXN0SGFuZGxlIHx8IGhhbmRsZURvbU5vZGUpICYmIGNvbm5lY3Rpb24gJiYgaXNWYWxpZCkge1xuICAgICAgICAgICAgb25Db25uZWN0Py4oY29ubmVjdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgLypcbiAgICAgICAgICogaXQncyBpbXBvcnRhbnQgdG8gZ2V0IGEgZnJlc2ggcmVmZXJlbmNlIGZyb20gdGhlIHN0b3JlIGhlcmVcbiAgICAgICAgICogaW4gb3JkZXIgdG8gZ2V0IHRoZSBsYXRlc3Qgc3RhdGUgb2Ygb25Db25uZWN0RW5kXG4gICAgICAgICAqL1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgICAgIGNvbnN0IHsgaW5Qcm9ncmVzcywgLi4uY29ubmVjdGlvblN0YXRlIH0gPSBwcmV2aW91c0Nvbm5lY3Rpb247XG4gICAgICAgIGNvbnN0IGZpbmFsQ29ubmVjdGlvblN0YXRlID0ge1xuICAgICAgICAgICAgLi4uY29ubmVjdGlvblN0YXRlLFxuICAgICAgICAgICAgdG9Qb3NpdGlvbjogcHJldmlvdXNDb25uZWN0aW9uLnRvSGFuZGxlID8gcHJldmlvdXNDb25uZWN0aW9uLnRvUG9zaXRpb24gOiBudWxsLFxuICAgICAgICB9O1xuICAgICAgICBvbkNvbm5lY3RFbmQ/LihldmVudCwgZmluYWxDb25uZWN0aW9uU3RhdGUpO1xuICAgICAgICBpZiAoZWRnZVVwZGF0ZXJUeXBlKSB7XG4gICAgICAgICAgICBvblJlY29ubmVjdEVuZD8uKGV2ZW50LCBmaW5hbENvbm5lY3Rpb25TdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2FuY2VsQ29ubmVjdGlvbigpO1xuICAgICAgICBjYW5jZWxBbmltYXRpb25GcmFtZShhdXRvUGFuSWQpO1xuICAgICAgICBhdXRvUGFuU3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICBpc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgIGNvbm5lY3Rpb24gPSBudWxsO1xuICAgICAgICBoYW5kbGVEb21Ob2RlID0gbnVsbDtcbiAgICAgICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG9uUG9pbnRlck1vdmUpO1xuICAgICAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG9uUG9pbnRlclVwKTtcbiAgICAgICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIG9uUG9pbnRlck1vdmUpO1xuICAgICAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBvblBvaW50ZXJVcCk7XG4gICAgfVxuICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBvblBvaW50ZXJNb3ZlKTtcbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIG9uUG9pbnRlclVwKTtcbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgb25Qb2ludGVyTW92ZSk7XG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgb25Qb2ludGVyVXApO1xufVxuLy8gY2hlY2tzIGlmICBhbmQgcmV0dXJucyBjb25uZWN0aW9uIGluIGZvbSBvZiBhbiBvYmplY3QgeyBzb3VyY2U6IDEyMywgdGFyZ2V0OiAzMTIgfVxuZnVuY3Rpb24gaXNWYWxpZEhhbmRsZShldmVudCwgeyBoYW5kbGUsIGNvbm5lY3Rpb25Nb2RlLCBmcm9tTm9kZUlkLCBmcm9tSGFuZGxlSWQsIGZyb21UeXBlLCBkb2MsIGxpYiwgZmxvd0lkLCBpc1ZhbGlkQ29ubmVjdGlvbiA9IGFsd2F5c1ZhbGlkLCBub2RlTG9va3VwLCB9KSB7XG4gICAgY29uc3QgaXNUYXJnZXQgPSBmcm9tVHlwZSA9PT0gJ3RhcmdldCc7XG4gICAgY29uc3QgaGFuZGxlRG9tTm9kZSA9IGhhbmRsZVxuICAgICAgICA/IGRvYy5xdWVyeVNlbGVjdG9yKGAuJHtsaWJ9LWZsb3dfX2hhbmRsZVtkYXRhLWlkPVwiJHtmbG93SWR9LSR7aGFuZGxlPy5ub2RlSWR9LSR7aGFuZGxlPy5pZH0tJHtoYW5kbGU/LnR5cGV9XCJdYClcbiAgICAgICAgOiBudWxsO1xuICAgIGNvbnN0IHsgeCwgeSB9ID0gZ2V0RXZlbnRQb3NpdGlvbihldmVudCk7XG4gICAgY29uc3QgaGFuZGxlQmVsb3cgPSBkb2MuZWxlbWVudEZyb21Qb2ludCh4LCB5KTtcbiAgICAvKlxuICAgICAqIHdlIGFsd2F5cyB3YW50IHRvIHByaW9yaXRpemUgdGhlIGhhbmRsZSBiZWxvdyB0aGUgbW91c2UgY3Vyc29yIG92ZXIgdGhlIGNsb3Nlc3QgZGlzdGFuY2UgaGFuZGxlLFxuICAgICAqIGJlY2F1c2UgaXQgY291bGQgYmUgdGhhdCB0aGUgY2VudGVyIG9mIGFub3RoZXIgaGFuZGxlIGlzIGNsb3NlciB0byB0aGUgbW91c2UgcG9pbnRlciB0aGFuIHRoZSBoYW5kbGUgYmVsb3cgdGhlIGN1cnNvclxuICAgICAqL1xuICAgIGNvbnN0IGhhbmRsZVRvQ2hlY2sgPSBoYW5kbGVCZWxvdz8uY2xhc3NMaXN0LmNvbnRhaW5zKGAke2xpYn0tZmxvd19faGFuZGxlYCkgPyBoYW5kbGVCZWxvdyA6IGhhbmRsZURvbU5vZGU7XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICBoYW5kbGVEb21Ob2RlOiBoYW5kbGVUb0NoZWNrLFxuICAgICAgICBpc1ZhbGlkOiBmYWxzZSxcbiAgICAgICAgY29ubmVjdGlvbjogbnVsbCxcbiAgICAgICAgdG9IYW5kbGU6IG51bGwsXG4gICAgfTtcbiAgICBpZiAoaGFuZGxlVG9DaGVjaykge1xuICAgICAgICBjb25zdCBoYW5kbGVUeXBlID0gZ2V0SGFuZGxlVHlwZSh1bmRlZmluZWQsIGhhbmRsZVRvQ2hlY2spO1xuICAgICAgICBjb25zdCBoYW5kbGVOb2RlSWQgPSBoYW5kbGVUb0NoZWNrLmdldEF0dHJpYnV0ZSgnZGF0YS1ub2RlaWQnKTtcbiAgICAgICAgY29uc3QgaGFuZGxlSWQgPSBoYW5kbGVUb0NoZWNrLmdldEF0dHJpYnV0ZSgnZGF0YS1oYW5kbGVpZCcpO1xuICAgICAgICBjb25zdCBjb25uZWN0YWJsZSA9IGhhbmRsZVRvQ2hlY2suY2xhc3NMaXN0LmNvbnRhaW5zKCdjb25uZWN0YWJsZScpO1xuICAgICAgICBjb25zdCBjb25uZWN0YWJsZUVuZCA9IGhhbmRsZVRvQ2hlY2suY2xhc3NMaXN0LmNvbnRhaW5zKCdjb25uZWN0YWJsZWVuZCcpO1xuICAgICAgICBpZiAoIWhhbmRsZU5vZGVJZCB8fCAhaGFuZGxlVHlwZSkge1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb25uZWN0aW9uID0ge1xuICAgICAgICAgICAgc291cmNlOiBpc1RhcmdldCA/IGhhbmRsZU5vZGVJZCA6IGZyb21Ob2RlSWQsXG4gICAgICAgICAgICBzb3VyY2VIYW5kbGU6IGlzVGFyZ2V0ID8gaGFuZGxlSWQgOiBmcm9tSGFuZGxlSWQsXG4gICAgICAgICAgICB0YXJnZXQ6IGlzVGFyZ2V0ID8gZnJvbU5vZGVJZCA6IGhhbmRsZU5vZGVJZCxcbiAgICAgICAgICAgIHRhcmdldEhhbmRsZTogaXNUYXJnZXQgPyBmcm9tSGFuZGxlSWQgOiBoYW5kbGVJZCxcbiAgICAgICAgfTtcbiAgICAgICAgcmVzdWx0LmNvbm5lY3Rpb24gPSBjb25uZWN0aW9uO1xuICAgICAgICBjb25zdCBpc0Nvbm5lY3RhYmxlID0gY29ubmVjdGFibGUgJiYgY29ubmVjdGFibGVFbmQ7XG4gICAgICAgIC8vIGluIHN0cmljdCBtb2RlIHdlIGRvbid0IGFsbG93IHRhcmdldCB0byB0YXJnZXQgb3Igc291cmNlIHRvIHNvdXJjZSBjb25uZWN0aW9uc1xuICAgICAgICBjb25zdCBpc1ZhbGlkID0gaXNDb25uZWN0YWJsZSAmJlxuICAgICAgICAgICAgKGNvbm5lY3Rpb25Nb2RlID09PSBDb25uZWN0aW9uTW9kZS5TdHJpY3RcbiAgICAgICAgICAgICAgICA/IChpc1RhcmdldCAmJiBoYW5kbGVUeXBlID09PSAnc291cmNlJykgfHwgKCFpc1RhcmdldCAmJiBoYW5kbGVUeXBlID09PSAndGFyZ2V0JylcbiAgICAgICAgICAgICAgICA6IGhhbmRsZU5vZGVJZCAhPT0gZnJvbU5vZGVJZCB8fCBoYW5kbGVJZCAhPT0gZnJvbUhhbmRsZUlkKTtcbiAgICAgICAgcmVzdWx0LmlzVmFsaWQgPSBpc1ZhbGlkICYmIGlzVmFsaWRDb25uZWN0aW9uKGNvbm5lY3Rpb24pO1xuICAgICAgICByZXN1bHQudG9IYW5kbGUgPSBnZXRIYW5kbGUoaGFuZGxlTm9kZUlkLCBoYW5kbGVUeXBlLCBoYW5kbGVJZCwgbm9kZUxvb2t1cCwgY29ubmVjdGlvbk1vZGUsIGZhbHNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0IFhZSGFuZGxlID0ge1xuICAgIG9uUG9pbnRlckRvd24sXG4gICAgaXNWYWxpZDogaXNWYWxpZEhhbmRsZSxcbn07XG5cbmZ1bmN0aW9uIFhZTWluaW1hcCh7IGRvbU5vZGUsIHBhblpvb20sIGdldFRyYW5zZm9ybSwgZ2V0Vmlld1NjYWxlIH0pIHtcbiAgICBjb25zdCBzZWxlY3Rpb24gPSBzZWxlY3QoZG9tTm9kZSk7XG4gICAgZnVuY3Rpb24gdXBkYXRlKHsgdHJhbnNsYXRlRXh0ZW50LCB3aWR0aCwgaGVpZ2h0LCB6b29tU3RlcCA9IDEwLCBwYW5uYWJsZSA9IHRydWUsIHpvb21hYmxlID0gdHJ1ZSwgaW52ZXJzZVBhbiA9IGZhbHNlLCB9KSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIGNvbnN0IHpvb21IYW5kbGVyID0gKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm0gPSBnZXRUcmFuc2Zvcm0oKTtcbiAgICAgICAgICAgIGlmIChldmVudC5zb3VyY2VFdmVudC50eXBlICE9PSAnd2hlZWwnIHx8ICFwYW5ab29tKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcGluY2hEZWx0YSA9IC1ldmVudC5zb3VyY2VFdmVudC5kZWx0YVkgKlxuICAgICAgICAgICAgICAgIChldmVudC5zb3VyY2VFdmVudC5kZWx0YU1vZGUgPT09IDEgPyAwLjA1IDogZXZlbnQuc291cmNlRXZlbnQuZGVsdGFNb2RlID8gMSA6IDAuMDAyKSAqXG4gICAgICAgICAgICAgICAgem9vbVN0ZXA7XG4gICAgICAgICAgICBjb25zdCBuZXh0Wm9vbSA9IHRyYW5zZm9ybVsyXSAqIE1hdGgucG93KDIsIHBpbmNoRGVsdGEpO1xuICAgICAgICAgICAgcGFuWm9vbS5zY2FsZVRvKG5leHRab29tKTtcbiAgICAgICAgfTtcbiAgICAgICAgbGV0IHBhblN0YXJ0ID0gWzAsIDBdO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBjb25zdCBwYW5TdGFydEhhbmRsZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudC5zb3VyY2VFdmVudC50eXBlID09PSAnbW91c2Vkb3duJyB8fCBldmVudC5zb3VyY2VFdmVudC50eXBlID09PSAndG91Y2hzdGFydCcpIHtcbiAgICAgICAgICAgICAgICBwYW5TdGFydCA9IFtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuc291cmNlRXZlbnQuY2xpZW50WCA/PyBldmVudC5zb3VyY2VFdmVudC50b3VjaGVzWzBdLmNsaWVudFgsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LnNvdXJjZUV2ZW50LmNsaWVudFkgPz8gZXZlbnQuc291cmNlRXZlbnQudG91Y2hlc1swXS5jbGllbnRZLFxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIGNvbnN0IHBhbkhhbmRsZXIgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IGdldFRyYW5zZm9ybSgpO1xuICAgICAgICAgICAgaWYgKChldmVudC5zb3VyY2VFdmVudC50eXBlICE9PSAnbW91c2Vtb3ZlJyAmJiBldmVudC5zb3VyY2VFdmVudC50eXBlICE9PSAndG91Y2htb3ZlJykgfHwgIXBhblpvb20pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwYW5DdXJyZW50ID0gW1xuICAgICAgICAgICAgICAgIGV2ZW50LnNvdXJjZUV2ZW50LmNsaWVudFggPz8gZXZlbnQuc291cmNlRXZlbnQudG91Y2hlc1swXS5jbGllbnRYLFxuICAgICAgICAgICAgICAgIGV2ZW50LnNvdXJjZUV2ZW50LmNsaWVudFkgPz8gZXZlbnQuc291cmNlRXZlbnQudG91Y2hlc1swXS5jbGllbnRZLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGNvbnN0IHBhbkRlbHRhID0gW3BhbkN1cnJlbnRbMF0gLSBwYW5TdGFydFswXSwgcGFuQ3VycmVudFsxXSAtIHBhblN0YXJ0WzFdXTtcbiAgICAgICAgICAgIHBhblN0YXJ0ID0gcGFuQ3VycmVudDtcbiAgICAgICAgICAgIGNvbnN0IG1vdmVTY2FsZSA9IGdldFZpZXdTY2FsZSgpICogTWF0aC5tYXgodHJhbnNmb3JtWzJdLCBNYXRoLmxvZyh0cmFuc2Zvcm1bMl0pKSAqIChpbnZlcnNlUGFuID8gLTEgOiAxKTtcbiAgICAgICAgICAgIGNvbnN0IHBvc2l0aW9uID0ge1xuICAgICAgICAgICAgICAgIHg6IHRyYW5zZm9ybVswXSAtIHBhbkRlbHRhWzBdICogbW92ZVNjYWxlLFxuICAgICAgICAgICAgICAgIHk6IHRyYW5zZm9ybVsxXSAtIHBhbkRlbHRhWzFdICogbW92ZVNjYWxlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGV4dGVudCA9IFtcbiAgICAgICAgICAgICAgICBbMCwgMF0sXG4gICAgICAgICAgICAgICAgW3dpZHRoLCBoZWlnaHRdLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIHBhblpvb20uc2V0Vmlld3BvcnRDb25zdHJhaW5lZCh7XG4gICAgICAgICAgICAgICAgeDogcG9zaXRpb24ueCxcbiAgICAgICAgICAgICAgICB5OiBwb3NpdGlvbi55LFxuICAgICAgICAgICAgICAgIHpvb206IHRyYW5zZm9ybVsyXSxcbiAgICAgICAgICAgIH0sIGV4dGVudCwgdHJhbnNsYXRlRXh0ZW50KTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgem9vbUFuZFBhbkhhbmRsZXIgPSB6b29tKClcbiAgICAgICAgICAgIC5vbignc3RhcnQnLCBwYW5TdGFydEhhbmRsZXIpXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAub24oJ3pvb20nLCBwYW5uYWJsZSA/IHBhbkhhbmRsZXIgOiBudWxsKVxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgLm9uKCd6b29tLndoZWVsJywgem9vbWFibGUgPyB6b29tSGFuZGxlciA6IG51bGwpO1xuICAgICAgICBzZWxlY3Rpb24uY2FsbCh6b29tQW5kUGFuSGFuZGxlciwge30pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICBzZWxlY3Rpb24ub24oJ3pvb20nLCBudWxsKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXBkYXRlLFxuICAgICAgICBkZXN0cm95LFxuICAgICAgICBwb2ludGVyLFxuICAgIH07XG59XG5cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnkgKi9cbmNvbnN0IHZpZXdDaGFuZ2VkID0gKHByZXZWaWV3cG9ydCwgZXZlbnRWaWV3cG9ydCkgPT4gcHJldlZpZXdwb3J0LnggIT09IGV2ZW50Vmlld3BvcnQueCB8fCBwcmV2Vmlld3BvcnQueSAhPT0gZXZlbnRWaWV3cG9ydC55IHx8IHByZXZWaWV3cG9ydC56b29tICE9PSBldmVudFZpZXdwb3J0Lms7XG5jb25zdCB0cmFuc2Zvcm1Ub1ZpZXdwb3J0ID0gKHRyYW5zZm9ybSkgPT4gKHtcbiAgICB4OiB0cmFuc2Zvcm0ueCxcbiAgICB5OiB0cmFuc2Zvcm0ueSxcbiAgICB6b29tOiB0cmFuc2Zvcm0uayxcbn0pO1xuY29uc3Qgdmlld3BvcnRUb1RyYW5zZm9ybSA9ICh7IHgsIHksIHpvb20gfSkgPT4gem9vbUlkZW50aXR5LnRyYW5zbGF0ZSh4LCB5KS5zY2FsZSh6b29tKTtcbmNvbnN0IGlzV3JhcHBlZFdpdGhDbGFzcyA9IChldmVudCwgY2xhc3NOYW1lKSA9PiBldmVudC50YXJnZXQuY2xvc2VzdChgLiR7Y2xhc3NOYW1lfWApO1xuY29uc3QgaXNSaWdodENsaWNrUGFuID0gKHBhbk9uRHJhZywgdXNlZEJ1dHRvbikgPT4gdXNlZEJ1dHRvbiA9PT0gMiAmJiBBcnJheS5pc0FycmF5KHBhbk9uRHJhZykgJiYgcGFuT25EcmFnLmluY2x1ZGVzKDIpO1xuY29uc3QgZ2V0RDNUcmFuc2l0aW9uID0gKHNlbGVjdGlvbiwgZHVyYXRpb24gPSAwLCBvbkVuZCA9ICgpID0+IHsgfSkgPT4ge1xuICAgIGNvbnN0IGhhc0R1cmF0aW9uID0gdHlwZW9mIGR1cmF0aW9uID09PSAnbnVtYmVyJyAmJiBkdXJhdGlvbiA+IDA7XG4gICAgaWYgKCFoYXNEdXJhdGlvbikge1xuICAgICAgICBvbkVuZCgpO1xuICAgIH1cbiAgICByZXR1cm4gaGFzRHVyYXRpb24gPyBzZWxlY3Rpb24udHJhbnNpdGlvbigpLmR1cmF0aW9uKGR1cmF0aW9uKS5vbignZW5kJywgb25FbmQpIDogc2VsZWN0aW9uO1xufTtcbmNvbnN0IHdoZWVsRGVsdGEgPSAoZXZlbnQpID0+IHtcbiAgICBjb25zdCBmYWN0b3IgPSBldmVudC5jdHJsS2V5ICYmIGlzTWFjT3MoKSA/IDEwIDogMTtcbiAgICByZXR1cm4gLWV2ZW50LmRlbHRhWSAqIChldmVudC5kZWx0YU1vZGUgPT09IDEgPyAwLjA1IDogZXZlbnQuZGVsdGFNb2RlID8gMSA6IDAuMDAyKSAqIGZhY3Rvcjtcbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZVBhbk9uU2Nyb2xsSGFuZGxlcih7IHpvb21QYW5WYWx1ZXMsIG5vV2hlZWxDbGFzc05hbWUsIGQzU2VsZWN0aW9uLCBkM1pvb20sIHBhbk9uU2Nyb2xsTW9kZSwgcGFuT25TY3JvbGxTcGVlZCwgem9vbU9uUGluY2gsIG9uUGFuWm9vbVN0YXJ0LCBvblBhblpvb20sIG9uUGFuWm9vbUVuZCwgfSkge1xuICAgIHJldHVybiAoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKGlzV3JhcHBlZFdpdGhDbGFzcyhldmVudCwgbm9XaGVlbENsYXNzTmFtZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgY29uc3QgY3VycmVudFpvb20gPSBkM1NlbGVjdGlvbi5wcm9wZXJ0eSgnX196b29tJykuayB8fCAxO1xuICAgICAgICAvLyBtYWNvcyBzZXRzIGN0cmxLZXk9dHJ1ZSBmb3IgcGluY2ggZ2VzdHVyZSBvbiBhIHRyYWNrcGFkXG4gICAgICAgIGlmIChldmVudC5jdHJsS2V5ICYmIHpvb21PblBpbmNoKSB7XG4gICAgICAgICAgICBjb25zdCBwb2ludCA9IHBvaW50ZXIoZXZlbnQpO1xuICAgICAgICAgICAgY29uc3QgcGluY2hEZWx0YSA9IHdoZWVsRGVsdGEoZXZlbnQpO1xuICAgICAgICAgICAgY29uc3Qgem9vbSA9IGN1cnJlbnRab29tICogTWF0aC5wb3coMiwgcGluY2hEZWx0YSk7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBkM1pvb20uc2NhbGVUbyhkM1NlbGVjdGlvbiwgem9vbSwgcG9pbnQsIGV2ZW50KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvKlxuICAgICAgICAgKiBpbmNyZWFzZSBzY3JvbGwgc3BlZWQgaW4gZmlyZWZveFxuICAgICAgICAgKiBmaXJlZm94OiBkZWx0YU1vZGUgPT09IDE7IGNocm9tZTogZGVsdGFNb2RlID09PSAwXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBkZWx0YU5vcm1hbGl6ZSA9IGV2ZW50LmRlbHRhTW9kZSA9PT0gMSA/IDIwIDogMTtcbiAgICAgICAgbGV0IGRlbHRhWCA9IHBhbk9uU2Nyb2xsTW9kZSA9PT0gUGFuT25TY3JvbGxNb2RlLlZlcnRpY2FsID8gMCA6IGV2ZW50LmRlbHRhWCAqIGRlbHRhTm9ybWFsaXplO1xuICAgICAgICBsZXQgZGVsdGFZID0gcGFuT25TY3JvbGxNb2RlID09PSBQYW5PblNjcm9sbE1vZGUuSG9yaXpvbnRhbCA/IDAgOiBldmVudC5kZWx0YVkgKiBkZWx0YU5vcm1hbGl6ZTtcbiAgICAgICAgLy8gdGhpcyBlbmFibGVzIHZlcnRpY2FsIHNjcm9sbGluZyB3aXRoIHNoaWZ0ICsgc2Nyb2xsIG9uIHdpbmRvd3NcbiAgICAgICAgaWYgKCFpc01hY09zKCkgJiYgZXZlbnQuc2hpZnRLZXkgJiYgcGFuT25TY3JvbGxNb2RlICE9PSBQYW5PblNjcm9sbE1vZGUuVmVydGljYWwpIHtcbiAgICAgICAgICAgIGRlbHRhWCA9IGV2ZW50LmRlbHRhWSAqIGRlbHRhTm9ybWFsaXplO1xuICAgICAgICAgICAgZGVsdGFZID0gMDtcbiAgICAgICAgfVxuICAgICAgICBkM1pvb20udHJhbnNsYXRlQnkoZDNTZWxlY3Rpb24sIC0oZGVsdGFYIC8gY3VycmVudFpvb20pICogcGFuT25TY3JvbGxTcGVlZCwgLShkZWx0YVkgLyBjdXJyZW50Wm9vbSkgKiBwYW5PblNjcm9sbFNwZWVkLCBcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICB7IGludGVybmFsOiB0cnVlIH0pO1xuICAgICAgICBjb25zdCBuZXh0Vmlld3BvcnQgPSB0cmFuc2Zvcm1Ub1ZpZXdwb3J0KGQzU2VsZWN0aW9uLnByb3BlcnR5KCdfX3pvb20nKSk7XG4gICAgICAgIGNsZWFyVGltZW91dCh6b29tUGFuVmFsdWVzLnBhblNjcm9sbFRpbWVvdXQpO1xuICAgICAgICAvKlxuICAgICAgICAgKiBmb3IgcGFuIG9uIHNjcm9sbCB3ZSBuZWVkIHRvIGhhbmRsZSB0aGUgZXZlbnQgY2FsbHMgb24gb3VyIG93blxuICAgICAgICAgKiB3ZSBjYW4ndCB1c2UgdGhlIHN0YXJ0LCB6b29tIGFuZCBlbmQgZXZlbnRzIGZyb20gZDMtem9vbVxuICAgICAgICAgKiBiZWNhdXNlIHN0YXJ0IGFuZCBtb3ZlIGdldHMgY2FsbGVkIG9uIGV2ZXJ5IHNjcm9sbCBldmVudCBhbmQgbm90IG9uY2UgYXQgdGhlIGJlZ2lubmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgaWYgKCF6b29tUGFuVmFsdWVzLmlzUGFuU2Nyb2xsaW5nKSB7XG4gICAgICAgICAgICB6b29tUGFuVmFsdWVzLmlzUGFuU2Nyb2xsaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIG9uUGFuWm9vbVN0YXJ0Py4oZXZlbnQsIG5leHRWaWV3cG9ydCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHpvb21QYW5WYWx1ZXMuaXNQYW5TY3JvbGxpbmcpIHtcbiAgICAgICAgICAgIG9uUGFuWm9vbT8uKGV2ZW50LCBuZXh0Vmlld3BvcnQpO1xuICAgICAgICAgICAgem9vbVBhblZhbHVlcy5wYW5TY3JvbGxUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgb25QYW5ab29tRW5kPy4oZXZlbnQsIG5leHRWaWV3cG9ydCk7XG4gICAgICAgICAgICAgICAgem9vbVBhblZhbHVlcy5pc1BhblNjcm9sbGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgfSwgMTUwKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiBjcmVhdGVab29tT25TY3JvbGxIYW5kbGVyKHsgbm9XaGVlbENsYXNzTmFtZSwgcHJldmVudFNjcm9sbGluZywgZDNab29tSGFuZGxlciB9KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChldmVudCwgZCkge1xuICAgICAgICAvLyB3ZSBzdGlsbCB3YW50IHRvIGVuYWJsZSBwaW5jaCB6b29taW5nIGV2ZW4gaWYgcHJldmVudFNjcm9sbGluZyBpcyBzZXQgdG8gZmFsc2VcbiAgICAgICAgY29uc3QgcHJldmVudFpvb20gPSAhcHJldmVudFNjcm9sbGluZyAmJiBldmVudC50eXBlID09PSAnd2hlZWwnICYmICFldmVudC5jdHJsS2V5O1xuICAgICAgICBpZiAocHJldmVudFpvb20gfHwgaXNXcmFwcGVkV2l0aENsYXNzKGV2ZW50LCBub1doZWVsQ2xhc3NOYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgZDNab29tSGFuZGxlci5jYWxsKHRoaXMsIGV2ZW50LCBkKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlUGFuWm9vbVN0YXJ0SGFuZGxlcih7IHpvb21QYW5WYWx1ZXMsIG9uRHJhZ2dpbmdDaGFuZ2UsIG9uUGFuWm9vbVN0YXJ0IH0pIHtcbiAgICByZXR1cm4gKGV2ZW50KSA9PiB7XG4gICAgICAgIGlmIChldmVudC5zb3VyY2VFdmVudD8uaW50ZXJuYWwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2aWV3cG9ydCA9IHRyYW5zZm9ybVRvVmlld3BvcnQoZXZlbnQudHJhbnNmb3JtKTtcbiAgICAgICAgLy8gd2UgbmVlZCB0byByZW1lbWJlciBpdCBoZXJlLCBiZWNhdXNlIGl0J3MgYWx3YXlzIDAgaW4gdGhlIFwiem9vbVwiIGV2ZW50XG4gICAgICAgIHpvb21QYW5WYWx1ZXMubW91c2VCdXR0b24gPSBldmVudC5zb3VyY2VFdmVudD8uYnV0dG9uIHx8IDA7XG4gICAgICAgIHpvb21QYW5WYWx1ZXMuaXNab29taW5nT3JQYW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgem9vbVBhblZhbHVlcy5wcmV2Vmlld3BvcnQgPSB2aWV3cG9ydDtcbiAgICAgICAgaWYgKGV2ZW50LnNvdXJjZUV2ZW50Py50eXBlID09PSAnbW91c2Vkb3duJykge1xuICAgICAgICAgICAgb25EcmFnZ2luZ0NoYW5nZSh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25QYW5ab29tU3RhcnQpIHtcbiAgICAgICAgICAgIG9uUGFuWm9vbVN0YXJ0Py4oZXZlbnQuc291cmNlRXZlbnQsIHZpZXdwb3J0KTtcbiAgICAgICAgfVxuICAgIH07XG59XG5mdW5jdGlvbiBjcmVhdGVQYW5ab29tSGFuZGxlcih7IHpvb21QYW5WYWx1ZXMsIHBhbk9uRHJhZywgb25QYW5lQ29udGV4dE1lbnUsIG9uVHJhbnNmb3JtQ2hhbmdlLCBvblBhblpvb20sIH0pIHtcbiAgICByZXR1cm4gKGV2ZW50KSA9PiB7XG4gICAgICAgIHpvb21QYW5WYWx1ZXMudXNlZFJpZ2h0TW91c2VCdXR0b24gPSAhIShvblBhbmVDb250ZXh0TWVudSAmJiBpc1JpZ2h0Q2xpY2tQYW4ocGFuT25EcmFnLCB6b29tUGFuVmFsdWVzLm1vdXNlQnV0dG9uID8/IDApKTtcbiAgICAgICAgaWYgKCFldmVudC5zb3VyY2VFdmVudD8uc3luYykge1xuICAgICAgICAgICAgb25UcmFuc2Zvcm1DaGFuZ2UoW2V2ZW50LnRyYW5zZm9ybS54LCBldmVudC50cmFuc2Zvcm0ueSwgZXZlbnQudHJhbnNmb3JtLmtdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob25QYW5ab29tICYmICFldmVudC5zb3VyY2VFdmVudD8uaW50ZXJuYWwpIHtcbiAgICAgICAgICAgIG9uUGFuWm9vbT8uKGV2ZW50LnNvdXJjZUV2ZW50LCB0cmFuc2Zvcm1Ub1ZpZXdwb3J0KGV2ZW50LnRyYW5zZm9ybSkpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVBhblpvb21FbmRIYW5kbGVyKHsgem9vbVBhblZhbHVlcywgcGFuT25EcmFnLCBwYW5PblNjcm9sbCwgb25EcmFnZ2luZ0NoYW5nZSwgb25QYW5ab29tRW5kLCBvblBhbmVDb250ZXh0TWVudSwgfSkge1xuICAgIHJldHVybiAoZXZlbnQpID0+IHtcbiAgICAgICAgaWYgKGV2ZW50LnNvdXJjZUV2ZW50Py5pbnRlcm5hbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHpvb21QYW5WYWx1ZXMuaXNab29taW5nT3JQYW5uaW5nID0gZmFsc2U7XG4gICAgICAgIGlmIChvblBhbmVDb250ZXh0TWVudSAmJlxuICAgICAgICAgICAgaXNSaWdodENsaWNrUGFuKHBhbk9uRHJhZywgem9vbVBhblZhbHVlcy5tb3VzZUJ1dHRvbiA/PyAwKSAmJlxuICAgICAgICAgICAgIXpvb21QYW5WYWx1ZXMudXNlZFJpZ2h0TW91c2VCdXR0b24gJiZcbiAgICAgICAgICAgIGV2ZW50LnNvdXJjZUV2ZW50KSB7XG4gICAgICAgICAgICBvblBhbmVDb250ZXh0TWVudShldmVudC5zb3VyY2VFdmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgem9vbVBhblZhbHVlcy51c2VkUmlnaHRNb3VzZUJ1dHRvbiA9IGZhbHNlO1xuICAgICAgICBvbkRyYWdnaW5nQ2hhbmdlKGZhbHNlKTtcbiAgICAgICAgaWYgKG9uUGFuWm9vbUVuZCAmJiB2aWV3Q2hhbmdlZCh6b29tUGFuVmFsdWVzLnByZXZWaWV3cG9ydCwgZXZlbnQudHJhbnNmb3JtKSkge1xuICAgICAgICAgICAgY29uc3Qgdmlld3BvcnQgPSB0cmFuc2Zvcm1Ub1ZpZXdwb3J0KGV2ZW50LnRyYW5zZm9ybSk7XG4gICAgICAgICAgICB6b29tUGFuVmFsdWVzLnByZXZWaWV3cG9ydCA9IHZpZXdwb3J0O1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHpvb21QYW5WYWx1ZXMudGltZXJJZCk7XG4gICAgICAgICAgICB6b29tUGFuVmFsdWVzLnRpbWVySWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBvblBhblpvb21FbmQ/LihldmVudC5zb3VyY2VFdmVudCwgdmlld3BvcnQpO1xuICAgICAgICAgICAgfSwgXG4gICAgICAgICAgICAvLyB3ZSBuZWVkIGEgc2V0VGltZW91dCBmb3IgcGFuT25TY3JvbGwgdG8gc3VwcmVzcyBtdWx0aXBsZSBlbmQgZXZlbnRzIGZpcmVkIGR1cmluZyBzY3JvbGxcbiAgICAgICAgICAgIHBhbk9uU2Nyb2xsID8gMTUwIDogMCk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXG5mdW5jdGlvbiBjcmVhdGVGaWx0ZXIoeyB6b29tQWN0aXZhdGlvbktleVByZXNzZWQsIHpvb21PblNjcm9sbCwgem9vbU9uUGluY2gsIHBhbk9uRHJhZywgcGFuT25TY3JvbGwsIHpvb21PbkRvdWJsZUNsaWNrLCB1c2VyU2VsZWN0aW9uQWN0aXZlLCBub1doZWVsQ2xhc3NOYW1lLCBub1BhbkNsYXNzTmFtZSwgbGliLCB9KSB7XG4gICAgcmV0dXJuIChldmVudCkgPT4ge1xuICAgICAgICBjb25zdCB6b29tU2Nyb2xsID0gem9vbUFjdGl2YXRpb25LZXlQcmVzc2VkIHx8IHpvb21PblNjcm9sbDtcbiAgICAgICAgY29uc3QgcGluY2hab29tID0gem9vbU9uUGluY2ggJiYgZXZlbnQuY3RybEtleTtcbiAgICAgICAgaWYgKGV2ZW50LmJ1dHRvbiA9PT0gMSAmJlxuICAgICAgICAgICAgZXZlbnQudHlwZSA9PT0gJ21vdXNlZG93bicgJiZcbiAgICAgICAgICAgIChpc1dyYXBwZWRXaXRoQ2xhc3MoZXZlbnQsIGAke2xpYn0tZmxvd19fbm9kZWApIHx8IGlzV3JhcHBlZFdpdGhDbGFzcyhldmVudCwgYCR7bGlifS1mbG93X19lZGdlYCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiBhbGwgaW50ZXJhY3Rpb25zIGFyZSBkaXNhYmxlZCwgd2UgcHJldmVudCBhbGwgem9vbSBldmVudHNcbiAgICAgICAgaWYgKCFwYW5PbkRyYWcgJiYgIXpvb21TY3JvbGwgJiYgIXBhbk9uU2Nyb2xsICYmICF6b29tT25Eb3VibGVDbGljayAmJiAhem9vbU9uUGluY2gpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBkdXJpbmcgYSBzZWxlY3Rpb24gd2UgcHJldmVudCBhbGwgb3RoZXIgaW50ZXJhY3Rpb25zXG4gICAgICAgIGlmICh1c2VyU2VsZWN0aW9uQWN0aXZlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgdGhlIHRhcmdldCBlbGVtZW50IGlzIGluc2lkZSBhbiBlbGVtZW50IHdpdGggdGhlIG5vd2hlZWwgY2xhc3MsIHdlIHByZXZlbnQgem9vbWluZ1xuICAgICAgICBpZiAoaXNXcmFwcGVkV2l0aENsYXNzKGV2ZW50LCBub1doZWVsQ2xhc3NOYW1lKSAmJiBldmVudC50eXBlID09PSAnd2hlZWwnKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgdGhlIHRhcmdldCBlbGVtZW50IGlzIGluc2lkZSBhbiBlbGVtZW50IHdpdGggdGhlIG5vcGFuIGNsYXNzLCB3ZSBwcmV2ZW50IHBhbm5pbmdcbiAgICAgICAgaWYgKGlzV3JhcHBlZFdpdGhDbGFzcyhldmVudCwgbm9QYW5DbGFzc05hbWUpICYmXG4gICAgICAgICAgICAoZXZlbnQudHlwZSAhPT0gJ3doZWVsJyB8fCAocGFuT25TY3JvbGwgJiYgZXZlbnQudHlwZSA9PT0gJ3doZWVsJyAmJiAhem9vbUFjdGl2YXRpb25LZXlQcmVzc2VkKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXpvb21PblBpbmNoICYmIGV2ZW50LmN0cmxLZXkgJiYgZXZlbnQudHlwZSA9PT0gJ3doZWVsJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghem9vbU9uUGluY2ggJiYgZXZlbnQudHlwZSA9PT0gJ3RvdWNoc3RhcnQnICYmIGV2ZW50LnRvdWNoZXM/Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7IC8vIGlmIHlvdSBtYW5hZ2UgdG8gc3RhcnQgd2l0aCAyIHRvdWNoZXMsIHdlIHByZXZlbnQgbmF0aXZlIHpvb21cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyB3aGVuIHRoZXJlIGlzIG5vIHNjcm9sbCBoYW5kbGluZyBlbmFibGVkLCB3ZSBwcmV2ZW50IGFsbCB3aGVlbCBldmVudHNcbiAgICAgICAgaWYgKCF6b29tU2Nyb2xsICYmICFwYW5PblNjcm9sbCAmJiAhcGluY2hab29tICYmIGV2ZW50LnR5cGUgPT09ICd3aGVlbCcpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB0aGUgcGFuZSBpcyBub3QgbW92YWJsZSwgd2UgcHJldmVudCBkcmFnZ2luZyBpdCB3aXRoIG1vdXNlc3RhcnQgb3IgdG91Y2hzdGFydFxuICAgICAgICBpZiAoIXBhbk9uRHJhZyAmJiAoZXZlbnQudHlwZSA9PT0gJ21vdXNlZG93bicgfHwgZXZlbnQudHlwZSA9PT0gJ3RvdWNoc3RhcnQnKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHRoZSBwYW5lIGlzIG9ubHkgbW92YWJsZSB1c2luZyBhbGxvd2VkIGNsaWNrc1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYW5PbkRyYWcpICYmICFwYW5PbkRyYWcuaW5jbHVkZXMoZXZlbnQuYnV0dG9uKSAmJiBldmVudC50eXBlID09PSAnbW91c2Vkb3duJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlIG9ubHkgYWxsb3cgcmlnaHQgY2xpY2tzIGlmIHBhbiBvbiBkcmFnIGlzIHNldCB0byByaWdodCBjbGlja1xuICAgICAgICBjb25zdCBidXR0b25BbGxvd2VkID0gKEFycmF5LmlzQXJyYXkocGFuT25EcmFnKSAmJiBwYW5PbkRyYWcuaW5jbHVkZXMoZXZlbnQuYnV0dG9uKSkgfHwgIWV2ZW50LmJ1dHRvbiB8fCBldmVudC5idXR0b24gPD0gMTtcbiAgICAgICAgLy8gZGVmYXVsdCBmaWx0ZXIgZm9yIGQzLXpvb21cbiAgICAgICAgcmV0dXJuICghZXZlbnQuY3RybEtleSB8fCBldmVudC50eXBlID09PSAnd2hlZWwnKSAmJiBidXR0b25BbGxvd2VkO1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIFhZUGFuWm9vbSh7IGRvbU5vZGUsIG1pblpvb20sIG1heFpvb20sIHBhbmVDbGlja0Rpc3RhbmNlLCB0cmFuc2xhdGVFeHRlbnQsIHZpZXdwb3J0LCBvblBhblpvb20sIG9uUGFuWm9vbVN0YXJ0LCBvblBhblpvb21FbmQsIG9uRHJhZ2dpbmdDaGFuZ2UsIH0pIHtcbiAgICBjb25zdCB6b29tUGFuVmFsdWVzID0ge1xuICAgICAgICBpc1pvb21pbmdPclBhbm5pbmc6IGZhbHNlLFxuICAgICAgICB1c2VkUmlnaHRNb3VzZUJ1dHRvbjogZmFsc2UsXG4gICAgICAgIHByZXZWaWV3cG9ydDogeyB4OiAwLCB5OiAwLCB6b29tOiAwIH0sXG4gICAgICAgIG1vdXNlQnV0dG9uOiAwLFxuICAgICAgICB0aW1lcklkOiB1bmRlZmluZWQsXG4gICAgICAgIHBhblNjcm9sbFRpbWVvdXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgaXNQYW5TY3JvbGxpbmc6IGZhbHNlLFxuICAgIH07XG4gICAgY29uc3QgYmJveCA9IGRvbU5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3QgZDNab29tSW5zdGFuY2UgPSB6b29tKClcbiAgICAgICAgLmNsaWNrRGlzdGFuY2UoIWlzTnVtZXJpYyhwYW5lQ2xpY2tEaXN0YW5jZSkgfHwgcGFuZUNsaWNrRGlzdGFuY2UgPCAwID8gMCA6IHBhbmVDbGlja0Rpc3RhbmNlKVxuICAgICAgICAuc2NhbGVFeHRlbnQoW21pblpvb20sIG1heFpvb21dKVxuICAgICAgICAudHJhbnNsYXRlRXh0ZW50KHRyYW5zbGF0ZUV4dGVudCk7XG4gICAgY29uc3QgZDNTZWxlY3Rpb24gPSBzZWxlY3QoZG9tTm9kZSkuY2FsbChkM1pvb21JbnN0YW5jZSk7XG4gICAgc2V0Vmlld3BvcnRDb25zdHJhaW5lZCh7XG4gICAgICAgIHg6IHZpZXdwb3J0LngsXG4gICAgICAgIHk6IHZpZXdwb3J0LnksXG4gICAgICAgIHpvb206IGNsYW1wKHZpZXdwb3J0Lnpvb20sIG1pblpvb20sIG1heFpvb20pLFxuICAgIH0sIFtcbiAgICAgICAgWzAsIDBdLFxuICAgICAgICBbYmJveC53aWR0aCwgYmJveC5oZWlnaHRdLFxuICAgIF0sIHRyYW5zbGF0ZUV4dGVudCk7XG4gICAgY29uc3QgZDNab29tSGFuZGxlciA9IGQzU2VsZWN0aW9uLm9uKCd3aGVlbC56b29tJyk7XG4gICAgY29uc3QgZDNEYmxDbGlja1pvb21IYW5kbGVyID0gZDNTZWxlY3Rpb24ub24oJ2RibGNsaWNrLnpvb20nKTtcbiAgICBkM1pvb21JbnN0YW5jZS53aGVlbERlbHRhKHdoZWVsRGVsdGEpO1xuICAgIGZ1bmN0aW9uIHNldFRyYW5zZm9ybSh0cmFuc2Zvcm0sIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGQzU2VsZWN0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgICBkM1pvb21JbnN0YW5jZT8udHJhbnNmb3JtKGdldEQzVHJhbnNpdGlvbihkM1NlbGVjdGlvbiwgb3B0aW9ucz8uZHVyYXRpb24sICgpID0+IHJlc29sdmUodHJ1ZSkpLCB0cmFuc2Zvcm0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShmYWxzZSk7XG4gICAgfVxuICAgIC8vIHB1YmxpYyBmdW5jdGlvbnNcbiAgICBmdW5jdGlvbiB1cGRhdGUoeyBub1doZWVsQ2xhc3NOYW1lLCBub1BhbkNsYXNzTmFtZSwgb25QYW5lQ29udGV4dE1lbnUsIHVzZXJTZWxlY3Rpb25BY3RpdmUsIHBhbk9uU2Nyb2xsLCBwYW5PbkRyYWcsIHBhbk9uU2Nyb2xsTW9kZSwgcGFuT25TY3JvbGxTcGVlZCwgcHJldmVudFNjcm9sbGluZywgem9vbU9uUGluY2gsIHpvb21PblNjcm9sbCwgem9vbU9uRG91YmxlQ2xpY2ssIHpvb21BY3RpdmF0aW9uS2V5UHJlc3NlZCwgbGliLCBvblRyYW5zZm9ybUNoYW5nZSwgfSkge1xuICAgICAgICBpZiAodXNlclNlbGVjdGlvbkFjdGl2ZSAmJiAhem9vbVBhblZhbHVlcy5pc1pvb21pbmdPclBhbm5pbmcpIHtcbiAgICAgICAgICAgIGRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc1Bhbk9uU2Nyb2xsID0gcGFuT25TY3JvbGwgJiYgIXpvb21BY3RpdmF0aW9uS2V5UHJlc3NlZCAmJiAhdXNlclNlbGVjdGlvbkFjdGl2ZTtcbiAgICAgICAgY29uc3Qgd2hlZWxIYW5kbGVyID0gaXNQYW5PblNjcm9sbFxuICAgICAgICAgICAgPyBjcmVhdGVQYW5PblNjcm9sbEhhbmRsZXIoe1xuICAgICAgICAgICAgICAgIHpvb21QYW5WYWx1ZXMsXG4gICAgICAgICAgICAgICAgbm9XaGVlbENsYXNzTmFtZSxcbiAgICAgICAgICAgICAgICBkM1NlbGVjdGlvbixcbiAgICAgICAgICAgICAgICBkM1pvb206IGQzWm9vbUluc3RhbmNlLFxuICAgICAgICAgICAgICAgIHBhbk9uU2Nyb2xsTW9kZSxcbiAgICAgICAgICAgICAgICBwYW5PblNjcm9sbFNwZWVkLFxuICAgICAgICAgICAgICAgIHpvb21PblBpbmNoLFxuICAgICAgICAgICAgICAgIG9uUGFuWm9vbVN0YXJ0LFxuICAgICAgICAgICAgICAgIG9uUGFuWm9vbSxcbiAgICAgICAgICAgICAgICBvblBhblpvb21FbmQsXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgOiBjcmVhdGVab29tT25TY3JvbGxIYW5kbGVyKHtcbiAgICAgICAgICAgICAgICBub1doZWVsQ2xhc3NOYW1lLFxuICAgICAgICAgICAgICAgIHByZXZlbnRTY3JvbGxpbmcsXG4gICAgICAgICAgICAgICAgZDNab29tSGFuZGxlcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBkM1NlbGVjdGlvbi5vbignd2hlZWwuem9vbScsIHdoZWVsSGFuZGxlciwgeyBwYXNzaXZlOiBmYWxzZSB9KTtcbiAgICAgICAgaWYgKCF1c2VyU2VsZWN0aW9uQWN0aXZlKSB7XG4gICAgICAgICAgICAvLyBwYW4gem9vbSBzdGFydFxuICAgICAgICAgICAgY29uc3Qgc3RhcnRIYW5kbGVyID0gY3JlYXRlUGFuWm9vbVN0YXJ0SGFuZGxlcih7XG4gICAgICAgICAgICAgICAgem9vbVBhblZhbHVlcyxcbiAgICAgICAgICAgICAgICBvbkRyYWdnaW5nQ2hhbmdlLFxuICAgICAgICAgICAgICAgIG9uUGFuWm9vbVN0YXJ0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkM1pvb21JbnN0YW5jZS5vbignc3RhcnQnLCBzdGFydEhhbmRsZXIpO1xuICAgICAgICAgICAgLy8gcGFuIHpvb21cbiAgICAgICAgICAgIGNvbnN0IHBhblpvb21IYW5kbGVyID0gY3JlYXRlUGFuWm9vbUhhbmRsZXIoe1xuICAgICAgICAgICAgICAgIHpvb21QYW5WYWx1ZXMsXG4gICAgICAgICAgICAgICAgcGFuT25EcmFnLFxuICAgICAgICAgICAgICAgIG9uUGFuZUNvbnRleHRNZW51OiAhIW9uUGFuZUNvbnRleHRNZW51LFxuICAgICAgICAgICAgICAgIG9uUGFuWm9vbSxcbiAgICAgICAgICAgICAgICBvblRyYW5zZm9ybUNoYW5nZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZDNab29tSW5zdGFuY2Uub24oJ3pvb20nLCBwYW5ab29tSGFuZGxlcik7XG4gICAgICAgICAgICAvLyBwYW4gem9vbSBlbmRcbiAgICAgICAgICAgIGNvbnN0IHBhblpvb21FbmRIYW5kbGVyID0gY3JlYXRlUGFuWm9vbUVuZEhhbmRsZXIoe1xuICAgICAgICAgICAgICAgIHpvb21QYW5WYWx1ZXMsXG4gICAgICAgICAgICAgICAgcGFuT25EcmFnLFxuICAgICAgICAgICAgICAgIHBhbk9uU2Nyb2xsLFxuICAgICAgICAgICAgICAgIG9uUGFuZUNvbnRleHRNZW51LFxuICAgICAgICAgICAgICAgIG9uUGFuWm9vbUVuZCxcbiAgICAgICAgICAgICAgICBvbkRyYWdnaW5nQ2hhbmdlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkM1pvb21JbnN0YW5jZS5vbignZW5kJywgcGFuWm9vbUVuZEhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZpbHRlciA9IGNyZWF0ZUZpbHRlcih7XG4gICAgICAgICAgICB6b29tQWN0aXZhdGlvbktleVByZXNzZWQsXG4gICAgICAgICAgICBwYW5PbkRyYWcsXG4gICAgICAgICAgICB6b29tT25TY3JvbGwsXG4gICAgICAgICAgICBwYW5PblNjcm9sbCxcbiAgICAgICAgICAgIHpvb21PbkRvdWJsZUNsaWNrLFxuICAgICAgICAgICAgem9vbU9uUGluY2gsXG4gICAgICAgICAgICB1c2VyU2VsZWN0aW9uQWN0aXZlLFxuICAgICAgICAgICAgbm9QYW5DbGFzc05hbWUsXG4gICAgICAgICAgICBub1doZWVsQ2xhc3NOYW1lLFxuICAgICAgICAgICAgbGliLFxuICAgICAgICB9KTtcbiAgICAgICAgZDNab29tSW5zdGFuY2UuZmlsdGVyKGZpbHRlcik7XG4gICAgICAgIC8qXG4gICAgICAgICAqIFdlIGNhbm5vdCBhZGQgem9vbU9uRG91YmxlQ2xpY2sgdG8gdGhlIGZpbHRlciBhYm92ZSBiZWNhdXNlXG4gICAgICAgICAqIGRvdWJsZSB0YXBwaW5nIG9uIHRvdWNoIHNjcmVlbnMgY2lyY3VtdmVudHMgdGhlIGZpbHRlciBhbmRcbiAgICAgICAgICogZGJsY2xpY2suem9vbSBpcyBmaXJlZCBvbiB0aGUgc2VsZWN0aW9uIGRpcmVjdGx5XG4gICAgICAgICAqL1xuICAgICAgICBpZiAoem9vbU9uRG91YmxlQ2xpY2spIHtcbiAgICAgICAgICAgIGQzU2VsZWN0aW9uLm9uKCdkYmxjbGljay56b29tJywgZDNEYmxDbGlja1pvb21IYW5kbGVyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGQzU2VsZWN0aW9uLm9uKCdkYmxjbGljay56b29tJywgbnVsbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgZDNab29tSW5zdGFuY2Uub24oJ3pvb20nLCBudWxsKTtcbiAgICB9XG4gICAgYXN5bmMgZnVuY3Rpb24gc2V0Vmlld3BvcnRDb25zdHJhaW5lZCh2aWV3cG9ydCwgZXh0ZW50LCB0cmFuc2xhdGVFeHRlbnQpIHtcbiAgICAgICAgY29uc3QgbmV4dFRyYW5zZm9ybSA9IHZpZXdwb3J0VG9UcmFuc2Zvcm0odmlld3BvcnQpO1xuICAgICAgICBjb25zdCBjb250cmFpbmVkVHJhbnNmb3JtID0gZDNab29tSW5zdGFuY2U/LmNvbnN0cmFpbigpKG5leHRUcmFuc2Zvcm0sIGV4dGVudCwgdHJhbnNsYXRlRXh0ZW50KTtcbiAgICAgICAgaWYgKGNvbnRyYWluZWRUcmFuc2Zvcm0pIHtcbiAgICAgICAgICAgIGF3YWl0IHNldFRyYW5zZm9ybShjb250cmFpbmVkVHJhbnNmb3JtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHJlc29sdmUoY29udHJhaW5lZFRyYW5zZm9ybSkpO1xuICAgIH1cbiAgICBhc3luYyBmdW5jdGlvbiBzZXRWaWV3cG9ydCh2aWV3cG9ydCwgb3B0aW9ucykge1xuICAgICAgICBjb25zdCBuZXh0VHJhbnNmb3JtID0gdmlld3BvcnRUb1RyYW5zZm9ybSh2aWV3cG9ydCk7XG4gICAgICAgIGF3YWl0IHNldFRyYW5zZm9ybShuZXh0VHJhbnNmb3JtLCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiByZXNvbHZlKG5leHRUcmFuc2Zvcm0pKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3luY1ZpZXdwb3J0KHZpZXdwb3J0KSB7XG4gICAgICAgIGlmIChkM1NlbGVjdGlvbikge1xuICAgICAgICAgICAgY29uc3QgbmV4dFRyYW5zZm9ybSA9IHZpZXdwb3J0VG9UcmFuc2Zvcm0odmlld3BvcnQpO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFRyYW5zZm9ybSA9IGQzU2VsZWN0aW9uLnByb3BlcnR5KCdfX3pvb20nKTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50VHJhbnNmb3JtLmsgIT09IHZpZXdwb3J0Lnpvb20gfHxcbiAgICAgICAgICAgICAgICBjdXJyZW50VHJhbnNmb3JtLnggIT09IHZpZXdwb3J0LnggfHxcbiAgICAgICAgICAgICAgICBjdXJyZW50VHJhbnNmb3JtLnkgIT09IHZpZXdwb3J0LnkpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIGQzWm9vbUluc3RhbmNlPy50cmFuc2Zvcm0oZDNTZWxlY3Rpb24sIG5leHRUcmFuc2Zvcm0sIG51bGwsIHsgc3luYzogdHJ1ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRWaWV3cG9ydCgpIHtcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtID0gZDNTZWxlY3Rpb24gPyB6b29tVHJhbnNmb3JtKGQzU2VsZWN0aW9uLm5vZGUoKSkgOiB7IHg6IDAsIHk6IDAsIGs6IDEgfTtcbiAgICAgICAgcmV0dXJuIHsgeDogdHJhbnNmb3JtLngsIHk6IHRyYW5zZm9ybS55LCB6b29tOiB0cmFuc2Zvcm0uayB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBzY2FsZVRvKHpvb20sIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGQzU2VsZWN0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgICBkM1pvb21JbnN0YW5jZT8uc2NhbGVUbyhnZXREM1RyYW5zaXRpb24oZDNTZWxlY3Rpb24sIG9wdGlvbnM/LmR1cmF0aW9uLCAoKSA9PiByZXNvbHZlKHRydWUpKSwgem9vbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZhbHNlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2NhbGVCeShmYWN0b3IsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGQzU2VsZWN0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgICBkM1pvb21JbnN0YW5jZT8uc2NhbGVCeShnZXREM1RyYW5zaXRpb24oZDNTZWxlY3Rpb24sIG9wdGlvbnM/LmR1cmF0aW9uLCAoKSA9PiByZXNvbHZlKHRydWUpKSwgZmFjdG9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZXRTY2FsZUV4dGVudChzY2FsZUV4dGVudCkge1xuICAgICAgICBkM1pvb21JbnN0YW5jZT8uc2NhbGVFeHRlbnQoc2NhbGVFeHRlbnQpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZXRUcmFuc2xhdGVFeHRlbnQodHJhbnNsYXRlRXh0ZW50KSB7XG4gICAgICAgIGQzWm9vbUluc3RhbmNlPy50cmFuc2xhdGVFeHRlbnQodHJhbnNsYXRlRXh0ZW50KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0Q2xpY2tEaXN0YW5jZShkaXN0YW5jZSkge1xuICAgICAgICBjb25zdCB2YWxpZERpc3RhbmNlID0gIWlzTnVtZXJpYyhkaXN0YW5jZSkgfHwgZGlzdGFuY2UgPCAwID8gMCA6IGRpc3RhbmNlO1xuICAgICAgICBkM1pvb21JbnN0YW5jZT8uY2xpY2tEaXN0YW5jZSh2YWxpZERpc3RhbmNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdXBkYXRlLFxuICAgICAgICBkZXN0cm95LFxuICAgICAgICBzZXRWaWV3cG9ydCxcbiAgICAgICAgc2V0Vmlld3BvcnRDb25zdHJhaW5lZCxcbiAgICAgICAgZ2V0Vmlld3BvcnQsXG4gICAgICAgIHNjYWxlVG8sXG4gICAgICAgIHNjYWxlQnksXG4gICAgICAgIHNldFNjYWxlRXh0ZW50LFxuICAgICAgICBzZXRUcmFuc2xhdGVFeHRlbnQsXG4gICAgICAgIHN5bmNWaWV3cG9ydCxcbiAgICAgICAgc2V0Q2xpY2tEaXN0YW5jZSxcbiAgICB9O1xufVxuXG4vKipcbiAqIFVzZWQgdG8gZGV0ZXJtaW5lIHRoZSB2YXJpYW50IG9mIHRoZSByZXNpemUgY29udHJvbFxuICpcbiAqIEBwdWJsaWNcbiAqL1xudmFyIFJlc2l6ZUNvbnRyb2xWYXJpYW50O1xuKGZ1bmN0aW9uIChSZXNpemVDb250cm9sVmFyaWFudCkge1xuICAgIFJlc2l6ZUNvbnRyb2xWYXJpYW50W1wiTGluZVwiXSA9IFwibGluZVwiO1xuICAgIFJlc2l6ZUNvbnRyb2xWYXJpYW50W1wiSGFuZGxlXCJdID0gXCJoYW5kbGVcIjtcbn0pKFJlc2l6ZUNvbnRyb2xWYXJpYW50IHx8IChSZXNpemVDb250cm9sVmFyaWFudCA9IHt9KSk7XG5jb25zdCBYWV9SRVNJWkVSX0hBTkRMRV9QT1NJVElPTlMgPSBbJ3RvcC1sZWZ0JywgJ3RvcC1yaWdodCcsICdib3R0b20tbGVmdCcsICdib3R0b20tcmlnaHQnXTtcbmNvbnN0IFhZX1JFU0laRVJfTElORV9QT1NJVElPTlMgPSBbJ3RvcCcsICdyaWdodCcsICdib3R0b20nLCAnbGVmdCddO1xuXG4vKipcbiAqIEdldCBhbGwgY29ubmVjdGluZyBlZGdlcyBmb3IgYSBnaXZlbiBzZXQgb2Ygbm9kZXNcbiAqIEBwYXJhbSB3aWR0aCAtIG5ldyB3aWR0aCBvZiB0aGUgbm9kZVxuICogQHBhcmFtIHByZXZXaWR0aCAtIHByZXZpb3VzIHdpZHRoIG9mIHRoZSBub2RlXG4gKiBAcGFyYW0gaGVpZ2h0IC0gbmV3IGhlaWdodCBvZiB0aGUgbm9kZVxuICogQHBhcmFtIHByZXZIZWlnaHQgLSBwcmV2aW91cyBoZWlnaHQgb2YgdGhlIG5vZGVcbiAqIEBwYXJhbSBhZmZlY3RzWCAtIHdoZXRoZXIgdG8gaW52ZXJ0IHRoZSByZXNpemUgZGlyZWN0aW9uIGZvciB0aGUgeCBheGlzXG4gKiBAcGFyYW0gYWZmZWN0c1kgLSB3aGV0aGVyIHRvIGludmVydCB0aGUgcmVzaXplIGRpcmVjdGlvbiBmb3IgdGhlIHkgYXhpc1xuICogQHJldHVybnMgYXJyYXkgb2YgdHdvIG51bWJlcnMgcmVwcmVzZW50aW5nIHRoZSBkaXJlY3Rpb24gb2YgdGhlIHJlc2l6ZSBmb3IgZWFjaCBheGlzLCAwID0gbm8gY2hhbmdlLCAxID0gaW5jcmVhc2UsIC0xID0gZGVjcmVhc2VcbiAqL1xuZnVuY3Rpb24gZ2V0UmVzaXplRGlyZWN0aW9uKHsgd2lkdGgsIHByZXZXaWR0aCwgaGVpZ2h0LCBwcmV2SGVpZ2h0LCBhZmZlY3RzWCwgYWZmZWN0c1ksIH0pIHtcbiAgICBjb25zdCBkZWx0YVdpZHRoID0gd2lkdGggLSBwcmV2V2lkdGg7XG4gICAgY29uc3QgZGVsdGFIZWlnaHQgPSBoZWlnaHQgLSBwcmV2SGVpZ2h0O1xuICAgIGNvbnN0IGRpcmVjdGlvbiA9IFtkZWx0YVdpZHRoID4gMCA/IDEgOiBkZWx0YVdpZHRoIDwgMCA/IC0xIDogMCwgZGVsdGFIZWlnaHQgPiAwID8gMSA6IGRlbHRhSGVpZ2h0IDwgMCA/IC0xIDogMF07XG4gICAgaWYgKGRlbHRhV2lkdGggJiYgYWZmZWN0c1gpIHtcbiAgICAgICAgZGlyZWN0aW9uWzBdID0gZGlyZWN0aW9uWzBdICogLTE7XG4gICAgfVxuICAgIGlmIChkZWx0YUhlaWdodCAmJiBhZmZlY3RzWSkge1xuICAgICAgICBkaXJlY3Rpb25bMV0gPSBkaXJlY3Rpb25bMV0gKiAtMTtcbiAgICB9XG4gICAgcmV0dXJuIGRpcmVjdGlvbjtcbn1cbi8qKlxuICogUGFyc2VzIHRoZSBjb250cm9sIHBvc2l0aW9uIHRoYXQgaXMgYmVpbmcgZHJhZ2dlZCB0byBkaW1lbnNpb25zIHRoYXQgYXJlIGJlaW5nIHJlc2l6ZWRcbiAqIEBwYXJhbSBjb250cm9sUG9zaXRpb24gLSBwb3NpdGlvbiBvZiB0aGUgY29udHJvbCB0aGF0IGlzIGJlaW5nIGRyYWdnZWRcbiAqIEByZXR1cm5zIGlzSG9yaXpvbnRhbCwgaXNWZXJ0aWNhbCwgYWZmZWN0c1gsIGFmZmVjdHNZLFxuICovXG5mdW5jdGlvbiBnZXRDb250cm9sRGlyZWN0aW9uKGNvbnRyb2xQb3NpdGlvbikge1xuICAgIGNvbnN0IGlzSG9yaXpvbnRhbCA9IGNvbnRyb2xQb3NpdGlvbi5pbmNsdWRlcygncmlnaHQnKSB8fCBjb250cm9sUG9zaXRpb24uaW5jbHVkZXMoJ2xlZnQnKTtcbiAgICBjb25zdCBpc1ZlcnRpY2FsID0gY29udHJvbFBvc2l0aW9uLmluY2x1ZGVzKCdib3R0b20nKSB8fCBjb250cm9sUG9zaXRpb24uaW5jbHVkZXMoJ3RvcCcpO1xuICAgIGNvbnN0IGFmZmVjdHNYID0gY29udHJvbFBvc2l0aW9uLmluY2x1ZGVzKCdsZWZ0Jyk7XG4gICAgY29uc3QgYWZmZWN0c1kgPSBjb250cm9sUG9zaXRpb24uaW5jbHVkZXMoJ3RvcCcpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGlzSG9yaXpvbnRhbCxcbiAgICAgICAgaXNWZXJ0aWNhbCxcbiAgICAgICAgYWZmZWN0c1gsXG4gICAgICAgIGFmZmVjdHNZLFxuICAgIH07XG59XG5mdW5jdGlvbiBnZXRMb3dlckV4dGVudENsYW1wKGxvd2VyRXh0ZW50LCBsb3dlckJvdW5kKSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KDAsIGxvd2VyQm91bmQgLSBsb3dlckV4dGVudCk7XG59XG5mdW5jdGlvbiBnZXRVcHBlckV4dGVudENsYW1wKHVwcGVyRXh0ZW50LCB1cHBlckJvdW5kKSB7XG4gICAgcmV0dXJuIE1hdGgubWF4KDAsIHVwcGVyRXh0ZW50IC0gdXBwZXJCb3VuZCk7XG59XG5mdW5jdGlvbiBnZXRTaXplQ2xhbXAoc2l6ZSwgbWluU2l6ZSwgbWF4U2l6ZSkge1xuICAgIHJldHVybiBNYXRoLm1heCgwLCBtaW5TaXplIC0gc2l6ZSwgc2l6ZSAtIG1heFNpemUpO1xufVxuZnVuY3Rpb24geG9yKGEsIGIpIHtcbiAgICByZXR1cm4gYSA/ICFiIDogYjtcbn1cbi8qKlxuICogQ2FsY3VsYXRlcyBuZXcgd2lkdGggJiBoZWlnaHQgYW5kIHggJiB5IG9mIG5vZGUgYWZ0ZXIgcmVzaXplIGJhc2VkIG9uIHBvaW50ZXIgcG9zaXRpb25cbiAqIEBkZXNjcmlwdGlvbiAtIEJ1Y2tsZSB1cCwgdGhpcyBpcyBhIGNodW5reSBvbmUuLi4gSWYgeW91IHdhbnQgdG8gZGV0ZXJtaW5lIHRoZSBuZXcgZGltZW5zaW9ucyBvZiBhIG5vZGUgYWZ0ZXIgYSByZXNpemUsXG4gKiB5b3UgaGF2ZSB0byBhY2NvdW50IGZvciBhbGwgcG9zc2libGUgcmVzdHJpY3Rpb25zOiBtaW4vbWF4IHdpZHRoL2hlaWdodCBvZiB0aGUgbm9kZSwgdGhlIG1heGltdW0gZXh0ZW50IHRoZSBub2RlIGlzIGFsbG93ZWRcbiAqIHRvIG1vdmUgaW4gKGluIHRoaXMgY2FzZTogcmVzaXplIGludG8pIGRldGVybWluZWQgYnkgdGhlIHBhcmVudCBub2RlLCB0aGUgbWluaW1hbCBleHRlbnQgZGV0ZXJtaW5lZCBieSBjaGlsZCBub2Rlc1xuICogd2l0aCBleHBhbmRQYXJlbnQgb3IgZXh0ZW50OiAncGFyZW50JyBzZXQgYW5kIG9oIHllYWgsIHRoZXNlIHRoaW5ncyBhbHNvIGhhdmUgdG8gd29yayB3aXRoIGtlZXBBc3BlY3RSYXRpbyFcbiAqIFRoZSB3YXkgdGhpcyBpcyBkb25lIGlzIGJ5IGRldGVybWluaW5nIGhvdyBtdWNoIGVhY2ggb2YgdGhlc2UgcmVzdHJpY3RpbmcgYWN0dWFsbHkgcmVzdHJpY3RzIHRoZSByZXNpemUgYW5kIHRoZW4gYXBwbHlpbmcgdGhlXG4gKiBzdHJvbmdlc3QgcmVzdHJpY3Rpb24uIEJlY2F1c2UgdGhlIHJlc2l6ZSBhZmZlY3RzIHgsIHkgYW5kIHdpZHRoLCBoZWlnaHQgYW5kIHdpZHRoLCBoZWlnaHQgb2YgYSBvcHBvc2luZyBzaWRlIHdpdGgga2VlcEFzcGVjdFJhdGlvLFxuICogdGhlIHJlc2l6ZSBhbW91bnQgaXMgYWx3YXlzIGtlcHQgaW4gZGlzdFggJiBkaXN0WSBhbW91bnQgKHRoZSBkaXN0YW5jZSBpbiBtb3VzZSBtb3ZlbWVudClcbiAqIEluc3RlYWQgb2YgY2xhbXBpbmcgZWFjaCB2YWx1ZSwgd2UgZmlyc3QgY2FsY3VsYXRlIHRoZSBiaWdnZXN0ICdjbGFtcCcgKGZvciB0aGUgbGFjayBvZiBhIGJldHRlciBuYW1lKSBhbmQgdGhlbiBhcHBseSBpdCB0byBhbGwgdmFsdWVzLlxuICogVG8gY29tcGxpY2F0ZSB0aGluZ3Mgbm9kZU9yaWdpbiBoYXMgdG8gYmUgdGFrZW4gaW50byBhY2NvdW50IGFzIHdlbGwuIFRoaXMgaXMgZG9uZSBieSBvZmZzZXR0aW5nIHRoZSBub2RlcyBhcyBpZiB0aGVpciBvcmlnaW4gaXMgWzAsIDBdLFxuICogdGhlbiBjYWxjdWxhdGluZyB0aGUgcmVzdHJpY3Rpb25zIGFzIHVzdWFsXG4gKiBAcGFyYW0gc3RhcnRWYWx1ZXMgLSBzdGFydGluZyB2YWx1ZXMgb2YgcmVzaXplXG4gKiBAcGFyYW0gY29udHJvbERpcmVjdGlvbiAtIGRpbWVuc2lvbnMgYWZmZWN0ZWQgYnkgdGhlIHJlc2l6ZVxuICogQHBhcmFtIHBvaW50ZXJQb3NpdGlvbiAtIHRoZSBjdXJyZW50IHBvaW50ZXIgcG9zaXRpb24gY29ycmVjdGVkIGZvciBzbmFwcGluZ1xuICogQHBhcmFtIGJvdW5kYXJpZXMgLSBtaW5pbXVtIGFuZCBtYXhpbXVtIGRpbWVuc2lvbnMgb2YgdGhlIG5vZGVcbiAqIEBwYXJhbSBrZWVwQXNwZWN0UmF0aW8gLSBwcmV2ZW50IGNoYW5nZXMgb2YgYXNwcmVjdCByYXRpb1xuICogQHJldHVybnMgeCwgeSwgd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgbm9kZSBhZnRlciByZXNpemVcbiAqL1xuZnVuY3Rpb24gZ2V0RGltZW5zaW9uc0FmdGVyUmVzaXplKHN0YXJ0VmFsdWVzLCBjb250cm9sRGlyZWN0aW9uLCBwb2ludGVyUG9zaXRpb24sIGJvdW5kYXJpZXMsIGtlZXBBc3BlY3RSYXRpbywgbm9kZU9yaWdpbiwgZXh0ZW50LCBjaGlsZEV4dGVudCkge1xuICAgIGxldCB7IGFmZmVjdHNYLCBhZmZlY3RzWSB9ID0gY29udHJvbERpcmVjdGlvbjtcbiAgICBjb25zdCB7IGlzSG9yaXpvbnRhbCwgaXNWZXJ0aWNhbCB9ID0gY29udHJvbERpcmVjdGlvbjtcbiAgICBjb25zdCBpc0RpYWdvbmFsID0gaXNIb3Jpem9udGFsICYmIGlzVmVydGljYWw7XG4gICAgY29uc3QgeyB4U25hcHBlZCwgeVNuYXBwZWQgfSA9IHBvaW50ZXJQb3NpdGlvbjtcbiAgICBjb25zdCB7IG1pbldpZHRoLCBtYXhXaWR0aCwgbWluSGVpZ2h0LCBtYXhIZWlnaHQgfSA9IGJvdW5kYXJpZXM7XG4gICAgY29uc3QgeyB4OiBzdGFydFgsIHk6IHN0YXJ0WSwgd2lkdGg6IHN0YXJ0V2lkdGgsIGhlaWdodDogc3RhcnRIZWlnaHQsIGFzcGVjdFJhdGlvIH0gPSBzdGFydFZhbHVlcztcbiAgICBsZXQgZGlzdFggPSBNYXRoLmZsb29yKGlzSG9yaXpvbnRhbCA/IHhTbmFwcGVkIC0gc3RhcnRWYWx1ZXMucG9pbnRlclggOiAwKTtcbiAgICBsZXQgZGlzdFkgPSBNYXRoLmZsb29yKGlzVmVydGljYWwgPyB5U25hcHBlZCAtIHN0YXJ0VmFsdWVzLnBvaW50ZXJZIDogMCk7XG4gICAgY29uc3QgbmV3V2lkdGggPSBzdGFydFdpZHRoICsgKGFmZmVjdHNYID8gLWRpc3RYIDogZGlzdFgpO1xuICAgIGNvbnN0IG5ld0hlaWdodCA9IHN0YXJ0SGVpZ2h0ICsgKGFmZmVjdHNZID8gLWRpc3RZIDogZGlzdFkpO1xuICAgIGNvbnN0IG9yaWdpbk9mZnNldFggPSAtbm9kZU9yaWdpblswXSAqIHN0YXJ0V2lkdGg7XG4gICAgY29uc3Qgb3JpZ2luT2Zmc2V0WSA9IC1ub2RlT3JpZ2luWzFdICogc3RhcnRIZWlnaHQ7XG4gICAgLy8gQ2hlY2sgaWYgbWF4V2lkdGgsIG1pbldXaWR0aCwgbWF4SGVpZ2h0LCBtaW5IZWlnaHQgYXJlIHJlc3RyaWN0aW5nIHRoZSByZXNpemVcbiAgICBsZXQgY2xhbXBYID0gZ2V0U2l6ZUNsYW1wKG5ld1dpZHRoLCBtaW5XaWR0aCwgbWF4V2lkdGgpO1xuICAgIGxldCBjbGFtcFkgPSBnZXRTaXplQ2xhbXAobmV3SGVpZ2h0LCBtaW5IZWlnaHQsIG1heEhlaWdodCk7XG4gICAgLy8gQ2hlY2sgaWYgZXh0ZW50IGlzIHJlc3RyaWN0aW5nIHRoZSByZXNpemVcbiAgICBpZiAoZXh0ZW50KSB7XG4gICAgICAgIGxldCB4RXh0ZW50Q2xhbXAgPSAwO1xuICAgICAgICBsZXQgeUV4dGVudENsYW1wID0gMDtcbiAgICAgICAgaWYgKGFmZmVjdHNYICYmIGRpc3RYIDwgMCkge1xuICAgICAgICAgICAgeEV4dGVudENsYW1wID0gZ2V0TG93ZXJFeHRlbnRDbGFtcChzdGFydFggKyBkaXN0WCArIG9yaWdpbk9mZnNldFgsIGV4dGVudFswXVswXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWFmZmVjdHNYICYmIGRpc3RYID4gMCkge1xuICAgICAgICAgICAgeEV4dGVudENsYW1wID0gZ2V0VXBwZXJFeHRlbnRDbGFtcChzdGFydFggKyBuZXdXaWR0aCArIG9yaWdpbk9mZnNldFgsIGV4dGVudFsxXVswXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFmZmVjdHNZICYmIGRpc3RZIDwgMCkge1xuICAgICAgICAgICAgeUV4dGVudENsYW1wID0gZ2V0TG93ZXJFeHRlbnRDbGFtcChzdGFydFkgKyBkaXN0WSArIG9yaWdpbk9mZnNldFksIGV4dGVudFswXVsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWFmZmVjdHNZICYmIGRpc3RZID4gMCkge1xuICAgICAgICAgICAgeUV4dGVudENsYW1wID0gZ2V0VXBwZXJFeHRlbnRDbGFtcChzdGFydFkgKyBuZXdIZWlnaHQgKyBvcmlnaW5PZmZzZXRZLCBleHRlbnRbMV1bMV0pO1xuICAgICAgICB9XG4gICAgICAgIGNsYW1wWCA9IE1hdGgubWF4KGNsYW1wWCwgeEV4dGVudENsYW1wKTtcbiAgICAgICAgY2xhbXBZID0gTWF0aC5tYXgoY2xhbXBZLCB5RXh0ZW50Q2xhbXApO1xuICAgIH1cbiAgICAvLyBDaGVjayBpZiB0aGUgY2hpbGQgZXh0ZW50IGlzIHJlc3RyaWN0aW5nIHRoZSByZXNpemVcbiAgICBpZiAoY2hpbGRFeHRlbnQpIHtcbiAgICAgICAgbGV0IHhFeHRlbnRDbGFtcCA9IDA7XG4gICAgICAgIGxldCB5RXh0ZW50Q2xhbXAgPSAwO1xuICAgICAgICBpZiAoYWZmZWN0c1ggJiYgZGlzdFggPiAwKSB7XG4gICAgICAgICAgICB4RXh0ZW50Q2xhbXAgPSBnZXRVcHBlckV4dGVudENsYW1wKHN0YXJ0WCArIGRpc3RYLCBjaGlsZEV4dGVudFswXVswXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWFmZmVjdHNYICYmIGRpc3RYIDwgMCkge1xuICAgICAgICAgICAgeEV4dGVudENsYW1wID0gZ2V0TG93ZXJFeHRlbnRDbGFtcChzdGFydFggKyBuZXdXaWR0aCwgY2hpbGRFeHRlbnRbMV1bMF0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhZmZlY3RzWSAmJiBkaXN0WSA+IDApIHtcbiAgICAgICAgICAgIHlFeHRlbnRDbGFtcCA9IGdldFVwcGVyRXh0ZW50Q2xhbXAoc3RhcnRZICsgZGlzdFksIGNoaWxkRXh0ZW50WzBdWzFdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghYWZmZWN0c1kgJiYgZGlzdFkgPCAwKSB7XG4gICAgICAgICAgICB5RXh0ZW50Q2xhbXAgPSBnZXRMb3dlckV4dGVudENsYW1wKHN0YXJ0WSArIG5ld0hlaWdodCwgY2hpbGRFeHRlbnRbMV1bMV0pO1xuICAgICAgICB9XG4gICAgICAgIGNsYW1wWCA9IE1hdGgubWF4KGNsYW1wWCwgeEV4dGVudENsYW1wKTtcbiAgICAgICAgY2xhbXBZID0gTWF0aC5tYXgoY2xhbXBZLCB5RXh0ZW50Q2xhbXApO1xuICAgIH1cbiAgICAvLyBDaGVjayBpZiB0aGUgYXNwZWN0IHJhdGlvIHJlc2l6aW5nIG9mIHRoZSBvdGhlciBzaWRlIGlzIHJlc3RyaWN0aW5nIHRoZSByZXNpemVcbiAgICBpZiAoa2VlcEFzcGVjdFJhdGlvKSB7XG4gICAgICAgIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBtYXggZGltZW5zaW9ucyBtaWdodCBiZSByZXN0cmljdGluZyB0aGUgcmVzaXplXG4gICAgICAgICAgICBjb25zdCBhc3BlY3RIZWlnaHRDbGFtcCA9IGdldFNpemVDbGFtcChuZXdXaWR0aCAvIGFzcGVjdFJhdGlvLCBtaW5IZWlnaHQsIG1heEhlaWdodCkgKiBhc3BlY3RSYXRpbztcbiAgICAgICAgICAgIGNsYW1wWCA9IE1hdGgubWF4KGNsYW1wWCwgYXNwZWN0SGVpZ2h0Q2xhbXApO1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGV4dGVudCBpcyByZXN0cmljdGluZyB0aGUgcmVzaXplXG4gICAgICAgICAgICBpZiAoZXh0ZW50KSB7XG4gICAgICAgICAgICAgICAgbGV0IGFzcGVjdEV4dGVudENsYW1wID0gMDtcbiAgICAgICAgICAgICAgICBpZiAoKCFhZmZlY3RzWCAmJiAhYWZmZWN0c1kpIHx8IChhZmZlY3RzWCAmJiAhYWZmZWN0c1kgJiYgaXNEaWFnb25hbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYXNwZWN0RXh0ZW50Q2xhbXAgPVxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0VXBwZXJFeHRlbnRDbGFtcChzdGFydFkgKyBvcmlnaW5PZmZzZXRZICsgbmV3V2lkdGggLyBhc3BlY3RSYXRpbywgZXh0ZW50WzFdWzFdKSAqIGFzcGVjdFJhdGlvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXNwZWN0RXh0ZW50Q2xhbXAgPVxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0TG93ZXJFeHRlbnRDbGFtcChzdGFydFkgKyBvcmlnaW5PZmZzZXRZICsgKGFmZmVjdHNYID8gZGlzdFggOiAtZGlzdFgpIC8gYXNwZWN0UmF0aW8sIGV4dGVudFswXVsxXSkgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzcGVjdFJhdGlvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjbGFtcFggPSBNYXRoLm1heChjbGFtcFgsIGFzcGVjdEV4dGVudENsYW1wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBjaGlsZCBleHRlbnQgaXMgcmVzdHJpY3RpbmcgdGhlIHJlc2l6ZVxuICAgICAgICAgICAgaWYgKGNoaWxkRXh0ZW50KSB7XG4gICAgICAgICAgICAgICAgbGV0IGFzcGVjdEV4dGVudENsYW1wID0gMDtcbiAgICAgICAgICAgICAgICBpZiAoKCFhZmZlY3RzWCAmJiAhYWZmZWN0c1kpIHx8IChhZmZlY3RzWCAmJiAhYWZmZWN0c1kgJiYgaXNEaWFnb25hbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYXNwZWN0RXh0ZW50Q2xhbXAgPSBnZXRMb3dlckV4dGVudENsYW1wKHN0YXJ0WSArIG5ld1dpZHRoIC8gYXNwZWN0UmF0aW8sIGNoaWxkRXh0ZW50WzFdWzFdKSAqIGFzcGVjdFJhdGlvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXNwZWN0RXh0ZW50Q2xhbXAgPVxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0VXBwZXJFeHRlbnRDbGFtcChzdGFydFkgKyAoYWZmZWN0c1ggPyBkaXN0WCA6IC1kaXN0WCkgLyBhc3BlY3RSYXRpbywgY2hpbGRFeHRlbnRbMF1bMV0pICogYXNwZWN0UmF0aW87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNsYW1wWCA9IE1hdGgubWF4KGNsYW1wWCwgYXNwZWN0RXh0ZW50Q2xhbXApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIERvIHRoZSBzYW1lIHRoaW5nIGZvciB2ZXJ0aWNhbCByZXNpemluZ1xuICAgICAgICBpZiAoaXNWZXJ0aWNhbCkge1xuICAgICAgICAgICAgY29uc3QgYXNwZWN0V2lkdGhDbGFtcCA9IGdldFNpemVDbGFtcChuZXdIZWlnaHQgKiBhc3BlY3RSYXRpbywgbWluV2lkdGgsIG1heFdpZHRoKSAvIGFzcGVjdFJhdGlvO1xuICAgICAgICAgICAgY2xhbXBZID0gTWF0aC5tYXgoY2xhbXBZLCBhc3BlY3RXaWR0aENsYW1wKTtcbiAgICAgICAgICAgIGlmIChleHRlbnQpIHtcbiAgICAgICAgICAgICAgICBsZXQgYXNwZWN0RXh0ZW50Q2xhbXAgPSAwO1xuICAgICAgICAgICAgICAgIGlmICgoIWFmZmVjdHNYICYmICFhZmZlY3RzWSkgfHwgKGFmZmVjdHNZICYmICFhZmZlY3RzWCAmJiBpc0RpYWdvbmFsKSkge1xuICAgICAgICAgICAgICAgICAgICBhc3BlY3RFeHRlbnRDbGFtcCA9XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRVcHBlckV4dGVudENsYW1wKHN0YXJ0WCArIG5ld0hlaWdodCAqIGFzcGVjdFJhdGlvICsgb3JpZ2luT2Zmc2V0WCwgZXh0ZW50WzFdWzBdKSAvIGFzcGVjdFJhdGlvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXNwZWN0RXh0ZW50Q2xhbXAgPVxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0TG93ZXJFeHRlbnRDbGFtcChzdGFydFggKyAoYWZmZWN0c1kgPyBkaXN0WSA6IC1kaXN0WSkgKiBhc3BlY3RSYXRpbyArIG9yaWdpbk9mZnNldFgsIGV4dGVudFswXVswXSkgL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzcGVjdFJhdGlvO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjbGFtcFkgPSBNYXRoLm1heChjbGFtcFksIGFzcGVjdEV4dGVudENsYW1wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaGlsZEV4dGVudCkge1xuICAgICAgICAgICAgICAgIGxldCBhc3BlY3RFeHRlbnRDbGFtcCA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKCghYWZmZWN0c1ggJiYgIWFmZmVjdHNZKSB8fCAoYWZmZWN0c1kgJiYgIWFmZmVjdHNYICYmIGlzRGlhZ29uYWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzcGVjdEV4dGVudENsYW1wID0gZ2V0TG93ZXJFeHRlbnRDbGFtcChzdGFydFggKyBuZXdIZWlnaHQgKiBhc3BlY3RSYXRpbywgY2hpbGRFeHRlbnRbMV1bMF0pIC8gYXNwZWN0UmF0aW87XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhc3BlY3RFeHRlbnRDbGFtcCA9XG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRVcHBlckV4dGVudENsYW1wKHN0YXJ0WCArIChhZmZlY3RzWSA/IGRpc3RZIDogLWRpc3RZKSAqIGFzcGVjdFJhdGlvLCBjaGlsZEV4dGVudFswXVswXSkgLyBhc3BlY3RSYXRpbztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2xhbXBZID0gTWF0aC5tYXgoY2xhbXBZLCBhc3BlY3RFeHRlbnRDbGFtcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGlzdFkgPSBkaXN0WSArIChkaXN0WSA8IDAgPyBjbGFtcFkgOiAtY2xhbXBZKTtcbiAgICBkaXN0WCA9IGRpc3RYICsgKGRpc3RYIDwgMCA/IGNsYW1wWCA6IC1jbGFtcFgpO1xuICAgIGlmIChrZWVwQXNwZWN0UmF0aW8pIHtcbiAgICAgICAgaWYgKGlzRGlhZ29uYWwpIHtcbiAgICAgICAgICAgIGlmIChuZXdXaWR0aCA+IG5ld0hlaWdodCAqIGFzcGVjdFJhdGlvKSB7XG4gICAgICAgICAgICAgICAgZGlzdFkgPSAoeG9yKGFmZmVjdHNYLCBhZmZlY3RzWSkgPyAtZGlzdFggOiBkaXN0WCkgLyBhc3BlY3RSYXRpbztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRpc3RYID0gKHhvcihhZmZlY3RzWCwgYWZmZWN0c1kpID8gLWRpc3RZIDogZGlzdFkpICogYXNwZWN0UmF0aW87XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoaXNIb3Jpem9udGFsKSB7XG4gICAgICAgICAgICAgICAgZGlzdFkgPSBkaXN0WCAvIGFzcGVjdFJhdGlvO1xuICAgICAgICAgICAgICAgIGFmZmVjdHNZID0gYWZmZWN0c1g7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkaXN0WCA9IGRpc3RZICogYXNwZWN0UmF0aW87XG4gICAgICAgICAgICAgICAgYWZmZWN0c1ggPSBhZmZlY3RzWTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB4ID0gYWZmZWN0c1ggPyBzdGFydFggKyBkaXN0WCA6IHN0YXJ0WDtcbiAgICBjb25zdCB5ID0gYWZmZWN0c1kgPyBzdGFydFkgKyBkaXN0WSA6IHN0YXJ0WTtcbiAgICByZXR1cm4ge1xuICAgICAgICB3aWR0aDogc3RhcnRXaWR0aCArIChhZmZlY3RzWCA/IC1kaXN0WCA6IGRpc3RYKSxcbiAgICAgICAgaGVpZ2h0OiBzdGFydEhlaWdodCArIChhZmZlY3RzWSA/IC1kaXN0WSA6IGRpc3RZKSxcbiAgICAgICAgeDogbm9kZU9yaWdpblswXSAqIGRpc3RYICogKCFhZmZlY3RzWCA/IDEgOiAtMSkgKyB4LFxuICAgICAgICB5OiBub2RlT3JpZ2luWzFdICogZGlzdFkgKiAoIWFmZmVjdHNZID8gMSA6IC0xKSArIHksXG4gICAgfTtcbn1cblxuY29uc3QgaW5pdFByZXZWYWx1ZXMgPSB7IHdpZHRoOiAwLCBoZWlnaHQ6IDAsIHg6IDAsIHk6IDAgfTtcbmNvbnN0IGluaXRTdGFydFZhbHVlcyA9IHtcbiAgICAuLi5pbml0UHJldlZhbHVlcyxcbiAgICBwb2ludGVyWDogMCxcbiAgICBwb2ludGVyWTogMCxcbiAgICBhc3BlY3RSYXRpbzogMSxcbn07XG5mdW5jdGlvbiBub2RlVG9QYXJlbnRFeHRlbnQobm9kZSkge1xuICAgIHJldHVybiBbXG4gICAgICAgIFswLCAwXSxcbiAgICAgICAgW25vZGUubWVhc3VyZWQud2lkdGgsIG5vZGUubWVhc3VyZWQuaGVpZ2h0XSxcbiAgICBdO1xufVxuZnVuY3Rpb24gbm9kZVRvQ2hpbGRFeHRlbnQoY2hpbGQsIHBhcmVudCwgbm9kZU9yaWdpbikge1xuICAgIGNvbnN0IHggPSBwYXJlbnQucG9zaXRpb24ueCArIGNoaWxkLnBvc2l0aW9uLng7XG4gICAgY29uc3QgeSA9IHBhcmVudC5wb3NpdGlvbi55ICsgY2hpbGQucG9zaXRpb24ueTtcbiAgICBjb25zdCB3aWR0aCA9IGNoaWxkLm1lYXN1cmVkLndpZHRoID8/IDA7XG4gICAgY29uc3QgaGVpZ2h0ID0gY2hpbGQubWVhc3VyZWQuaGVpZ2h0ID8/IDA7XG4gICAgY29uc3Qgb3JpZ2luT2Zmc2V0WCA9IG5vZGVPcmlnaW5bMF0gKiB3aWR0aDtcbiAgICBjb25zdCBvcmlnaW5PZmZzZXRZID0gbm9kZU9yaWdpblsxXSAqIGhlaWdodDtcbiAgICByZXR1cm4gW1xuICAgICAgICBbeCAtIG9yaWdpbk9mZnNldFgsIHkgLSBvcmlnaW5PZmZzZXRZXSxcbiAgICAgICAgW3ggKyB3aWR0aCAtIG9yaWdpbk9mZnNldFgsIHkgKyBoZWlnaHQgLSBvcmlnaW5PZmZzZXRZXSxcbiAgICBdO1xufVxuZnVuY3Rpb24gWFlSZXNpemVyKHsgZG9tTm9kZSwgbm9kZUlkLCBnZXRTdG9yZUl0ZW1zLCBvbkNoYW5nZSwgb25FbmQgfSkge1xuICAgIGNvbnN0IHNlbGVjdGlvbiA9IHNlbGVjdChkb21Ob2RlKTtcbiAgICBmdW5jdGlvbiB1cGRhdGUoeyBjb250cm9sUG9zaXRpb24sIGJvdW5kYXJpZXMsIGtlZXBBc3BlY3RSYXRpbywgb25SZXNpemVTdGFydCwgb25SZXNpemUsIG9uUmVzaXplRW5kLCBzaG91bGRSZXNpemUsIH0pIHtcbiAgICAgICAgbGV0IHByZXZWYWx1ZXMgPSB7IC4uLmluaXRQcmV2VmFsdWVzIH07XG4gICAgICAgIGxldCBzdGFydFZhbHVlcyA9IHsgLi4uaW5pdFN0YXJ0VmFsdWVzIH07XG4gICAgICAgIGNvbnN0IGNvbnRyb2xEaXJlY3Rpb24gPSBnZXRDb250cm9sRGlyZWN0aW9uKGNvbnRyb2xQb3NpdGlvbik7XG4gICAgICAgIGxldCBub2RlID0gdW5kZWZpbmVkO1xuICAgICAgICBsZXQgY29udGFpbmVyQm91bmRzID0gbnVsbDtcbiAgICAgICAgbGV0IGNoaWxkTm9kZXMgPSBbXTtcbiAgICAgICAgbGV0IHBhcmVudE5vZGUgPSB1bmRlZmluZWQ7IC8vIE5lZWRlZCB0byBmaXggZXhwYW5kUGFyZW50XG4gICAgICAgIGxldCBwYXJlbnRFeHRlbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBjaGlsZEV4dGVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgZHJhZ0hhbmRsZXIgPSBkcmFnKClcbiAgICAgICAgICAgIC5vbignc3RhcnQnLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgbm9kZUxvb2t1cCwgdHJhbnNmb3JtLCBzbmFwR3JpZCwgc25hcFRvR3JpZCwgbm9kZU9yaWdpbiwgcGFuZURvbU5vZGUgfSA9IGdldFN0b3JlSXRlbXMoKTtcbiAgICAgICAgICAgIG5vZGUgPSBub2RlTG9va3VwLmdldChub2RlSWQpO1xuICAgICAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udGFpbmVyQm91bmRzID0gcGFuZURvbU5vZGU/LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpID8/IG51bGw7XG4gICAgICAgICAgICBjb25zdCB7IHhTbmFwcGVkLCB5U25hcHBlZCB9ID0gZ2V0UG9pbnRlclBvc2l0aW9uKGV2ZW50LnNvdXJjZUV2ZW50LCB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtLFxuICAgICAgICAgICAgICAgIHNuYXBHcmlkLFxuICAgICAgICAgICAgICAgIHNuYXBUb0dyaWQsXG4gICAgICAgICAgICAgICAgY29udGFpbmVyQm91bmRzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwcmV2VmFsdWVzID0ge1xuICAgICAgICAgICAgICAgIHdpZHRoOiBub2RlLm1lYXN1cmVkLndpZHRoID8/IDAsXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBub2RlLm1lYXN1cmVkLmhlaWdodCA/PyAwLFxuICAgICAgICAgICAgICAgIHg6IG5vZGUucG9zaXRpb24ueCA/PyAwLFxuICAgICAgICAgICAgICAgIHk6IG5vZGUucG9zaXRpb24ueSA/PyAwLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHN0YXJ0VmFsdWVzID0ge1xuICAgICAgICAgICAgICAgIC4uLnByZXZWYWx1ZXMsXG4gICAgICAgICAgICAgICAgcG9pbnRlclg6IHhTbmFwcGVkLFxuICAgICAgICAgICAgICAgIHBvaW50ZXJZOiB5U25hcHBlZCxcbiAgICAgICAgICAgICAgICBhc3BlY3RSYXRpbzogcHJldlZhbHVlcy53aWR0aCAvIHByZXZWYWx1ZXMuaGVpZ2h0LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHBhcmVudE5vZGUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAobm9kZS5wYXJlbnRJZCAmJiAobm9kZS5leHRlbnQgPT09ICdwYXJlbnQnIHx8IG5vZGUuZXhwYW5kUGFyZW50KSkge1xuICAgICAgICAgICAgICAgIHBhcmVudE5vZGUgPSBub2RlTG9va3VwLmdldChub2RlLnBhcmVudElkKTtcbiAgICAgICAgICAgICAgICBwYXJlbnRFeHRlbnQgPSBwYXJlbnROb2RlICYmIG5vZGUuZXh0ZW50ID09PSAncGFyZW50JyA/IG5vZGVUb1BhcmVudEV4dGVudChwYXJlbnROb2RlKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBDb2xsZWN0IGFsbCBjaGlsZCBub2RlcyB0byBjb3JyZWN0IHRoZWlyIHJlbGF0aXZlIHBvc2l0aW9ucyB3aGVuIHRvcC9sZWZ0IGNoYW5nZXNcbiAgICAgICAgICAgICAqIERldGVybWluZSBsYXJnZXN0IG1pbmltYWwgZXh0ZW50IHRoZSBwYXJlbnQgbm9kZSBpcyBhbGxvd2VkIHRvIHJlc2l6ZSB0b1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjaGlsZE5vZGVzID0gW107XG4gICAgICAgICAgICBjaGlsZEV4dGVudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2NoaWxkSWQsIGNoaWxkXSBvZiBub2RlTG9va3VwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkLnBhcmVudElkID09PSBub2RlSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGROb2Rlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBjaGlsZElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHsgLi4uY2hpbGQucG9zaXRpb24gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4dGVudDogY2hpbGQuZXh0ZW50LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkLmV4dGVudCA9PT0gJ3BhcmVudCcgfHwgY2hpbGQuZXhwYW5kUGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBleHRlbnQgPSBub2RlVG9DaGlsZEV4dGVudChjaGlsZCwgbm9kZSwgY2hpbGQub3JpZ2luID8/IG5vZGVPcmlnaW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkRXh0ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRFeHRlbnQgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtNYXRoLm1pbihleHRlbnRbMF1bMF0sIGNoaWxkRXh0ZW50WzBdWzBdKSwgTWF0aC5taW4oZXh0ZW50WzBdWzFdLCBjaGlsZEV4dGVudFswXVsxXSldLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbTWF0aC5tYXgoZXh0ZW50WzFdWzBdLCBjaGlsZEV4dGVudFsxXVswXSksIE1hdGgubWF4KGV4dGVudFsxXVsxXSwgY2hpbGRFeHRlbnRbMV1bMV0pXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRFeHRlbnQgPSBleHRlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvblJlc2l6ZVN0YXJ0Py4oZXZlbnQsIHsgLi4ucHJldlZhbHVlcyB9KTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5vbignZHJhZycsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyB0cmFuc2Zvcm0sIHNuYXBHcmlkLCBzbmFwVG9HcmlkLCBub2RlT3JpZ2luOiBzdG9yZU5vZGVPcmlnaW4gfSA9IGdldFN0b3JlSXRlbXMoKTtcbiAgICAgICAgICAgIGNvbnN0IHBvaW50ZXJQb3NpdGlvbiA9IGdldFBvaW50ZXJQb3NpdGlvbihldmVudC5zb3VyY2VFdmVudCwge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybSxcbiAgICAgICAgICAgICAgICBzbmFwR3JpZCxcbiAgICAgICAgICAgICAgICBzbmFwVG9HcmlkLFxuICAgICAgICAgICAgICAgIGNvbnRhaW5lckJvdW5kcyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgY2hpbGRDaGFuZ2VzID0gW107XG4gICAgICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IHg6IHByZXZYLCB5OiBwcmV2WSwgd2lkdGg6IHByZXZXaWR0aCwgaGVpZ2h0OiBwcmV2SGVpZ2h0IH0gPSBwcmV2VmFsdWVzO1xuICAgICAgICAgICAgY29uc3QgY2hhbmdlID0ge307XG4gICAgICAgICAgICBjb25zdCBub2RlT3JpZ2luID0gbm9kZS5vcmlnaW4gPz8gc3RvcmVOb2RlT3JpZ2luO1xuICAgICAgICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0LCB4LCB5IH0gPSBnZXREaW1lbnNpb25zQWZ0ZXJSZXNpemUoc3RhcnRWYWx1ZXMsIGNvbnRyb2xEaXJlY3Rpb24sIHBvaW50ZXJQb3NpdGlvbiwgYm91bmRhcmllcywga2VlcEFzcGVjdFJhdGlvLCBub2RlT3JpZ2luLCBwYXJlbnRFeHRlbnQsIGNoaWxkRXh0ZW50KTtcbiAgICAgICAgICAgIGNvbnN0IGlzV2lkdGhDaGFuZ2UgPSB3aWR0aCAhPT0gcHJldldpZHRoO1xuICAgICAgICAgICAgY29uc3QgaXNIZWlnaHRDaGFuZ2UgPSBoZWlnaHQgIT09IHByZXZIZWlnaHQ7XG4gICAgICAgICAgICBjb25zdCBpc1hQb3NDaGFuZ2UgPSB4ICE9PSBwcmV2WCAmJiBpc1dpZHRoQ2hhbmdlO1xuICAgICAgICAgICAgY29uc3QgaXNZUG9zQ2hhbmdlID0geSAhPT0gcHJldlkgJiYgaXNIZWlnaHRDaGFuZ2U7XG4gICAgICAgICAgICBpZiAoIWlzWFBvc0NoYW5nZSAmJiAhaXNZUG9zQ2hhbmdlICYmICFpc1dpZHRoQ2hhbmdlICYmICFpc0hlaWdodENoYW5nZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1hQb3NDaGFuZ2UgfHwgaXNZUG9zQ2hhbmdlIHx8IG5vZGVPcmlnaW5bMF0gPT09IDEgfHwgbm9kZU9yaWdpblsxXSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGNoYW5nZS54ID0gaXNYUG9zQ2hhbmdlID8geCA6IHByZXZWYWx1ZXMueDtcbiAgICAgICAgICAgICAgICBjaGFuZ2UueSA9IGlzWVBvc0NoYW5nZSA/IHkgOiBwcmV2VmFsdWVzLnk7XG4gICAgICAgICAgICAgICAgcHJldlZhbHVlcy54ID0gY2hhbmdlLng7XG4gICAgICAgICAgICAgICAgcHJldlZhbHVlcy55ID0gY2hhbmdlLnk7XG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiB3aGVuIHRvcC9sZWZ0IGNoYW5nZXMsIGNvcnJlY3QgdGhlIHJlbGF0aXZlIHBvc2l0aW9ucyBvZiBjaGlsZCBub2Rlc1xuICAgICAgICAgICAgICAgICAqIHNvIHRoYXQgdGhleSBzdGF5IGluIHRoZSBzYW1lIHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkTm9kZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB4Q2hhbmdlID0geCAtIHByZXZYO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB5Q2hhbmdlID0geSAtIHByZXZZO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGNoaWxkTm9kZSBvZiBjaGlsZE5vZGVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZE5vZGUucG9zaXRpb24gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogY2hpbGROb2RlLnBvc2l0aW9uLnggLSB4Q2hhbmdlICsgbm9kZU9yaWdpblswXSAqICh3aWR0aCAtIHByZXZXaWR0aCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogY2hpbGROb2RlLnBvc2l0aW9uLnkgLSB5Q2hhbmdlICsgbm9kZU9yaWdpblsxXSAqIChoZWlnaHQgLSBwcmV2SGVpZ2h0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZENoYW5nZXMucHVzaChjaGlsZE5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzV2lkdGhDaGFuZ2UgfHwgaXNIZWlnaHRDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICBjaGFuZ2Uud2lkdGggPSBpc1dpZHRoQ2hhbmdlID8gd2lkdGggOiBwcmV2VmFsdWVzLndpZHRoO1xuICAgICAgICAgICAgICAgIGNoYW5nZS5oZWlnaHQgPSBpc0hlaWdodENoYW5nZSA/IGhlaWdodCA6IHByZXZWYWx1ZXMuaGVpZ2h0O1xuICAgICAgICAgICAgICAgIHByZXZWYWx1ZXMud2lkdGggPSBjaGFuZ2Uud2lkdGg7XG4gICAgICAgICAgICAgICAgcHJldlZhbHVlcy5oZWlnaHQgPSBjaGFuZ2UuaGVpZ2h0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRml4IGV4cGFuZFBhcmVudCB3aGVuIHJlc2l6aW5nIGZyb20gdG9wL2xlZnRcbiAgICAgICAgICAgIGlmIChwYXJlbnROb2RlICYmIG5vZGUuZXhwYW5kUGFyZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeExpbWl0ID0gbm9kZU9yaWdpblswXSAqIChjaGFuZ2Uud2lkdGggPz8gMCk7XG4gICAgICAgICAgICAgICAgaWYgKGNoYW5nZS54ICYmIGNoYW5nZS54IDwgeExpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXZWYWx1ZXMueCA9IHhMaW1pdDtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRWYWx1ZXMueCA9IHN0YXJ0VmFsdWVzLnggLSAoY2hhbmdlLnggLSB4TGltaXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB5TGltaXQgPSBub2RlT3JpZ2luWzFdICogKGNoYW5nZS5oZWlnaHQgPz8gMCk7XG4gICAgICAgICAgICAgICAgaWYgKGNoYW5nZS55ICYmIGNoYW5nZS55IDwgeUxpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXZWYWx1ZXMueSA9IHlMaW1pdDtcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRWYWx1ZXMueSA9IHN0YXJ0VmFsdWVzLnkgLSAoY2hhbmdlLnkgLSB5TGltaXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IGdldFJlc2l6ZURpcmVjdGlvbih7XG4gICAgICAgICAgICAgICAgd2lkdGg6IHByZXZWYWx1ZXMud2lkdGgsXG4gICAgICAgICAgICAgICAgcHJldldpZHRoLFxuICAgICAgICAgICAgICAgIGhlaWdodDogcHJldlZhbHVlcy5oZWlnaHQsXG4gICAgICAgICAgICAgICAgcHJldkhlaWdodCxcbiAgICAgICAgICAgICAgICBhZmZlY3RzWDogY29udHJvbERpcmVjdGlvbi5hZmZlY3RzWCxcbiAgICAgICAgICAgICAgICBhZmZlY3RzWTogY29udHJvbERpcmVjdGlvbi5hZmZlY3RzWSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgbmV4dFZhbHVlcyA9IHsgLi4ucHJldlZhbHVlcywgZGlyZWN0aW9uIH07XG4gICAgICAgICAgICBjb25zdCBjYWxsUmVzaXplID0gc2hvdWxkUmVzaXplPy4oZXZlbnQsIG5leHRWYWx1ZXMpO1xuICAgICAgICAgICAgaWYgKGNhbGxSZXNpemUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb25SZXNpemU/LihldmVudCwgbmV4dFZhbHVlcyk7XG4gICAgICAgICAgICBvbkNoYW5nZShjaGFuZ2UsIGNoaWxkQ2hhbmdlcyk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAub24oJ2VuZCcsIChldmVudCkgPT4ge1xuICAgICAgICAgICAgb25SZXNpemVFbmQ/LihldmVudCwgeyAuLi5wcmV2VmFsdWVzIH0pO1xuICAgICAgICAgICAgb25FbmQ/LigpO1xuICAgICAgICB9KTtcbiAgICAgICAgc2VsZWN0aW9uLmNhbGwoZHJhZ0hhbmRsZXIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZXN0cm95KCkge1xuICAgICAgICBzZWxlY3Rpb24ub24oJy5kcmFnJywgbnVsbCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHVwZGF0ZSxcbiAgICAgICAgZGVzdHJveSxcbiAgICB9O1xufVxuXG5leHBvcnQgeyBDb25uZWN0aW9uTGluZVR5cGUsIENvbm5lY3Rpb25Nb2RlLCBNYXJrZXJUeXBlLCBQYW5PblNjcm9sbE1vZGUsIFBvc2l0aW9uLCBSZXNpemVDb250cm9sVmFyaWFudCwgU2VsZWN0aW9uTW9kZSwgWFlEcmFnLCBYWUhhbmRsZSwgWFlNaW5pbWFwLCBYWVBhblpvb20sIFhZUmVzaXplciwgWFlfUkVTSVpFUl9IQU5ETEVfUE9TSVRJT05TLCBYWV9SRVNJWkVSX0xJTkVfUE9TSVRJT05TLCBhZGRFZGdlLCBhZG9wdFVzZXJOb2RlcywgYXJlQ29ubmVjdGlvbk1hcHNFcXVhbCwgYXJlU2V0c0VxdWFsLCBib3hUb1JlY3QsIGNhbGNBdXRvUGFuLCBjYWxjdWxhdGVOb2RlUG9zaXRpb24sIGNsYW1wLCBjbGFtcFBvc2l0aW9uLCBjbGFtcFBvc2l0aW9uVG9QYXJlbnQsIGNyZWF0ZU1hcmtlcklkcywgZGV2V2FybiwgZWxlbWVudFNlbGVjdGlvbktleXMsIGVycm9yTWVzc2FnZXMsIGV2YWx1YXRlQWJzb2x1dGVQb3NpdGlvbiwgZml0VmlldywgZ2V0QmV6aWVyRWRnZUNlbnRlciwgZ2V0QmV6aWVyUGF0aCwgZ2V0Qm91bmRzT2ZCb3hlcywgZ2V0Qm91bmRzT2ZSZWN0cywgZ2V0Q29ubmVjdGVkRWRnZXMsIGdldENvbm5lY3Rpb25TdGF0dXMsIGdldERpbWVuc2lvbnMsIGdldEVkZ2VDZW50ZXIsIGdldEVkZ2VQb3NpdGlvbiwgZ2V0RWxlbWVudHNUb1JlbW92ZSwgZ2V0RWxldmF0ZWRFZGdlWkluZGV4LCBnZXRFdmVudFBvc2l0aW9uLCBnZXRGaXRWaWV3Tm9kZXMsIGdldEhhbmRsZUJvdW5kcywgZ2V0SGFuZGxlUG9zaXRpb24sIGdldEhvc3RGb3JFbGVtZW50LCBnZXRJbmNvbWVycywgZ2V0SW50ZXJuYWxOb2Rlc0JvdW5kcywgZ2V0TWFya2VySWQsIGdldE5vZGVEaW1lbnNpb25zLCBnZXROb2RlUG9zaXRpb25XaXRoT3JpZ2luLCBnZXROb2RlVG9vbGJhclRyYW5zZm9ybSwgZ2V0Tm9kZXNCb3VuZHMsIGdldE5vZGVzSW5zaWRlLCBnZXRPdXRnb2VycywgZ2V0T3ZlcmxhcHBpbmdBcmVhLCBnZXRQb2ludGVyUG9zaXRpb24sIGdldFNtb290aFN0ZXBQYXRoLCBnZXRTdHJhaWdodFBhdGgsIGdldFZpZXdwb3J0Rm9yQm91bmRzLCBoYW5kbGVDb25uZWN0aW9uQ2hhbmdlLCBoYW5kbGVFeHBhbmRQYXJlbnQsIGluZmluaXRlRXh0ZW50LCBpbml0aWFsQ29ubmVjdGlvbiwgaXNDb29yZGluYXRlRXh0ZW50LCBpc0VkZ2VCYXNlLCBpc0VkZ2VWaXNpYmxlLCBpc0lucHV0RE9NTm9kZSwgaXNJbnRlcm5hbE5vZGVCYXNlLCBpc01hY09zLCBpc01vdXNlRXZlbnQsIGlzTm9kZUJhc2UsIGlzTnVtZXJpYywgaXNSZWN0T2JqZWN0LCBub2RlSGFzRGltZW5zaW9ucywgbm9kZVRvQm94LCBub2RlVG9SZWN0LCBvcHBvc2l0ZVBvc2l0aW9uLCBwYW5CeSwgcG9pbnRUb1JlbmRlcmVyUG9pbnQsIHJlY29ubmVjdEVkZ2UsIHJlY3RUb0JveCwgcmVuZGVyZXJQb2ludFRvUG9pbnQsIHNoYWxsb3dOb2RlRGF0YSwgc25hcFBvc2l0aW9uLCB1cGRhdGVBYnNvbHV0ZVBvc2l0aW9ucywgdXBkYXRlQ29ubmVjdGlvbkxvb2t1cCwgdXBkYXRlTm9kZUludGVybmFscyB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@xyflow/system/dist/esm/index.js\n");

/***/ })

};
;